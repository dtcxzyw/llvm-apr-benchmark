{
  "wall_time": 6.274488687515259,
  "knowledge": [
    [
      "base_model",
      "2023-12-31+0000"
    ],
    [
      "hint:bug_functions",
      "2025-01-01+0000"
    ],
    [
      "hint:components",
      "2025-01-01+0000"
    ],
    [
      "hint:issue",
      "2025-01-01+0000"
    ],
    [
      "hint:line_level_bug_locations",
      "2025-01-01+0000"
    ]
  ],
  "build_count": 2,
  "build_failure_count": 0,
  "fast_check_count": 1,
  "full_check_count": 1,
  "fast_check_pass": true,
  "full_check_pass": true,
  "patch": "diff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\nindex e7a8e947705f..3ddf906b622a 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n@@ -1217,7 +1217,7 @@ static Value *foldSelectCttzCtlz(ICmpInst *ICI, Value *TrueVal, Value *FalseVal,\n     II->setArgOperand(1, ConstantInt::getFalse(II->getContext()));\n     // A range annotation on the intrinsic may no longer be valid.\n     II->dropPoisonGeneratingAnnotations();\n-    IC.addToWorklist(II);\n+IC.addToWorklist(II);\n     return SelectArg;\n   }\n \n@@ -1225,8 +1225,12 @@ static Value *foldSelectCttzCtlz(ICmpInst *ICI, Value *TrueVal, Value *FalseVal,\n   // zext/trunc) have one use (ending at the select), the cttz/ctlz result will\n   // not be used if the input is zero. Relax to 'zero is poison' for that case.\n   if (II->hasOneUse() && SelectArg->hasOneUse() &&\n-      !match(II->getArgOperand(1), m_One()))\n+      !match(II->getArgOperand(1), m_One())) {\n     II->setArgOperand(1, ConstantInt::getTrue(II->getContext()));\n+    // Drop noundef attribute since the result may be poison now\n+    if (II->hasRetAttr(Attribute::NoUndef))\n+      II->removeRetAttr(Attribute::NoUndef);\n+  }\n \n   return nullptr;\n }\n",
  "log": [
    {
      "role": "system",
      "content": "You are an LLVM maintainer.\nYou are fixing a middle-end bug in the LLVM project.\nPlease answer with the code directly. Do not include any additional information.\n"
    },
    {
      "role": "user",
      "content": "This is a miscompilation bug in InstCombine.\nIssue title: [InstCombine] `noundef` attribute should be dropped\nIssue body: Alive2: https://alive2.llvm.org/ce/z/wKsUWK\n```\ndefine i32 @src(i32 noundef %x) {\n  %ct = call noundef i32 @llvm.cttz.i32(i32 %x, i1 false)\n  %cmp = icmp ne i32 %x, 0\n  %res = select i1 %cmp, i32 %ct, i32 123\n  ret i32 %res\n}\ndefine i32 @tgt(i32 noundef %x) {\n  %ct = call noundef range(i32 0, 33) i32 @llvm.cttz.i32(i32 %x, i1 true)\n  %cmp.not = icmp eq i32 %x, 0\n  %res = select i1 %cmp.not, i32 123, i32 %ct\n  ret i32 %res\n}\n```\n\nDetailed information:\n[{'file': 'llvm/test/Transforms/InstCombine/select-cmp-cttz-ctlz.ll', 'args': 'opt -passes=instcombine -S < %s', 'name': 'test_cttz_not_bw_multiuse', 'body': 'define i32 @test_cttz_not_bw_multiuse(i32 %x) {\\n  %ct = tail call i32 @llvm.cttz.i32(i32 %x, i1 false)\\n  %cmp = icmp ne i32 %x, 0\\n  %sel = select i1 %cmp, i32 %ct, i32 123\\n  %res = or i32 %sel, %ct\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'result': True, 'log': {'src': 'define i32 @test_cttz_not_bw_multiuse(i32 %x) {\\n  %ct = tail call i32 @llvm.cttz.i32(i32 %x, i1 false)\\n  %cmp = icmp ne i32 %x, 0\\n  %sel = select i1 %cmp, i32 %ct, i32 123\\n  %res = or i32 %sel, %ct\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine i32 @test_cttz_not_bw_multiuse(i32 %x) {\\n  %ct = tail call range(i32 0, 33) i32 @llvm.cttz.i32(i32 %x, i1 false)\\n  %cmp.not = icmp eq i32 %x, 0\\n  %sel = select i1 %cmp.not, i32 123, i32 %ct\\n  %res = or i32 %sel, %ct\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'log': '\\n----------------------------------------\\ndefine i32 @test_cttz_not_bw_multiuse(i32 %x) {\\n#0:\\n  %ct = cttz i32 %x, 0\\n  %cmp = icmp ne i32 %x, 0\\n  %sel = select i1 %cmp, i32 %ct, i32 123\\n  %res = or i32 %sel, %ct\\n  ret i32 %res\\n}\\n=>\\ndefine i32 @test_cttz_not_bw_multiuse(i32 %x) {\\n#0:\\n  %ct = cttz i32 %x, 0\\n  %#range_0_%ct = !range i32 %ct, i32 0, i32 33\\n  %cmp.not = icmp eq i32 %x, 0\\n  %sel = select i1 %cmp.not, i32 123, i32 %#range_0_%ct\\n  %res = or i32 %sel, %#range_0_%ct\\n  ret i32 %res\\n}\\nTransformation seems to be correct!\\n\\nSummary:\\n  1 correct transformations\\n  0 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n', 'opt_stderr': ''}}, {'file': 'llvm/test/Transforms/InstCombine/select-cmp-cttz-ctlz.ll', 'args': 'opt -passes=instcombine -S < %s', 'name': 'test_cttz_not_bw', 'body': 'define i32 @test_cttz_not_bw(i32 %x) {\\n  %ct = tail call i32 @llvm.cttz.i32(i32 %x, i1 false)\\n  %cmp = icmp ne i32 %x, 0\\n  %res = select i1 %cmp, i32 %ct, i32 123\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'result': True, 'log': {'src': 'define i32 @test_cttz_not_bw(i32 %x) {\\n  %ct = tail call i32 @llvm.cttz.i32(i32 %x, i1 false)\\n  %cmp = icmp ne i32 %x, 0\\n  %res = select i1 %cmp, i32 %ct, i32 123\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine i32 @test_cttz_not_bw(i32 %x) {\\n  %ct = tail call range(i32 0, 33) i32 @llvm.cttz.i32(i32 %x, i1 true)\\n  %cmp.not = icmp eq i32 %x, 0\\n  %res = select i1 %cmp.not, i32 123, i32 %ct\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'log': '\\n----------------------------------------\\ndefine i32 @test_cttz_not_bw(i32 %x) {\\n#0:\\n  %ct = cttz i32 %x, 0\\n  %cmp = icmp ne i32 %x, 0\\n  %res = select i1 %cmp, i32 %ct, i32 123\\n  ret i32 %res\\n}\\n=>\\ndefine i32 @test_cttz_not_bw(i32 %x) {\\n#0:\\n  %ct = cttz i32 %x, 1\\n  %#range_0_%ct = !range i32 %ct, i32 0, i32 33\\n  %cmp.not = icmp eq i32 %x, 0\\n  %res = select i1 %cmp.not, i32 123, i32 %#range_0_%ct\\n  ret i32 %res\\n}\\nTransformation seems to be correct!\\n\\nSummary:\\n  1 correct transformations\\n  0 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n', 'opt_stderr': ''}}, {'file': 'llvm/test/Transforms/InstCombine/select-cmp-cttz-ctlz.ll', 'args': 'opt -passes=instcombine -S < %s', 'name': 'test_cttz_not_bw_noundef', 'body': 'define i32 @test_cttz_not_bw_noundef(i32 %x) {\\n  %ct = tail call noundef i32 @llvm.cttz.i32(i32 %x, i1 false)\\n  %cmp = icmp ne i32 %x, 0\\n  %res = select i1 %cmp, i32 %ct, i32 123\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'result': False, 'log': {'src': 'define i32 @test_cttz_not_bw_noundef(i32 %x) {\\n  %ct = tail call noundef i32 @llvm.cttz.i32(i32 %x, i1 false)\\n  %cmp = icmp ne i32 %x, 0\\n  %res = select i1 %cmp, i32 %ct, i32 123\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine i32 @test_cttz_not_bw_noundef(i32 %x) {\\n  %ct = tail call noundef range(i32 0, 33) i32 @llvm.cttz.i32(i32 %x, i1 true)\\n  %cmp.not = icmp eq i32 %x, 0\\n  %res = select i1 %cmp.not, i32 123, i32 %ct\\n  ret i32 %res\\n}\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare i32 @llvm.cttz.i32(i32, i1 immarg) #0\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n', 'log': \"\\n----------------------------------------\\ndefine i32 @test_cttz_not_bw_noundef(i32 %x) {\\n#0:\\n  %ct = cttz i32 %x, 0\\n  assume_welldefined i32 %ct\\n  %cmp = icmp ne i32 %x, 0\\n  %res = select i1 %cmp, i32 %ct, i32 123\\n  ret i32 %res\\n}\\n=>\\ndefine i32 @test_cttz_not_bw_noundef(i32 %x) {\\n#0:\\n  %ct = cttz i32 %x, 1\\n  %#range_0_%ct = !range i32 %ct, i32 0, i32 33\\n  assume_welldefined i32 %#range_0_%ct\\n  %cmp.not = icmp eq i32 %x, 0\\n  %res = select i1 %cmp.not, i32 123, i32 %#range_0_%ct\\n  ret i32 %res\\n}\\nTransformation doesn't verify!\\n\\nERROR: Source is more defined than target\\n\\nExample:\\ni32 %x = #x00000000 (0)\\n\\nSource:\\ni32 %ct = #x00000020 (32)\\ni1 %cmp = #x0 (0)\\ni32 %res = #x0000007b (123)\\n\\nTarget:\\ni32 %ct = poison\\ni32 %#range_0_%ct = poison\\nvoid = UB triggered!\\n\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\", 'opt_stderr': ''}}]\nPlease modify the following code in llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:foldSelectCttzCtlz to fix the bug:\n```\n    IC.addToWorklist(II);\n    return SelectArg;\n  }\n\n  // The ValueOnZero is not the bitwidth. But if the cttz/ctlz (and optional\n  // zext/trunc) have one use (ending at the select), the cttz/ctlz result will\n  // not be used if the input is zero. Relax to 'zero is poison' for that case.\n  if (II->hasOneUse() && SelectArg->hasOneUse() &&\n      !match(II->getArgOperand(1), m_One()))\n    II->setArgOperand(1, ConstantInt::getTrue(II->getContext()));\n\n  return nullptr;\n}\n\nstatic Value *canonicalizeSPF(ICmpInst &Cmp, Value *TrueVal, Value *FalseVal,\n                              InstCombinerImpl &IC) {\n  Value *LHS, *RHS;\n  // TODO: What to do with pointer min/max patterns?\n```\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n    IC.addToWorklist(II);\n    return SelectArg;\n  }\n\n  // The ValueOnZero is not the bitwidth. But if the cttz/ctlz (and optional\n  // zext/trunc) have one use (ending at the select), the cttz/ctlz result will\n  // not be used if the input is zero. Relax to 'zero is poison' for that case.\n  if (II->hasOneUse() && SelectArg->hasOneUse() &&\n      !match(II->getArgOperand(1), m_One())) {\n    II->setArgOperand(1, ConstantInt::getTrue(II->getContext()));\n    // Drop noundef attribute since the result may be poison now\n    if (II->hasRetAttr(Attribute::NoUndef))\n      II->removeRetAttr(Attribute::NoUndef);\n  }\n\n  return nullptr;\n}\n\nstatic Value *canonicalizeSPF(ICmpInst &Cmp, Value *TrueVal, Value *FalseVal,\n                              InstCombinerImpl &IC) {\n  Value *LHS, *RHS;\n  // TODO: What to do with pointer min/max patterns?\n```"
    }
  ]
}