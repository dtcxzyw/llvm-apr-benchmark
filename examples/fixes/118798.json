{
  "wall_time": 454.34026074409485,
  "knowledge": [
    [
      "base_model",
      "2023-12-31+0000"
    ],
    [
      "hint:bug_functions",
      "2024-12-05+0000"
    ],
    [
      "hint:components",
      "2024-12-05+0000"
    ],
    [
      "hint:issue",
      "2024-12-05+0000"
    ],
    [
      "hint:line_level_bug_locations",
      "2024-12-05+0000"
    ]
  ],
  "build_count": 5,
  "build_failure_count": 1,
  "fast_check_count": 1,
  "full_check_count": 4,
  "fast_check_pass": false,
  "full_check_pass": false,
  "patch": "diff --git a/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp b/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp\nindex 10c3ccdb2243..a4d6b1268d50 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp\n@@ -409,8 +409,7 @@ Instruction *InstCombinerImpl::commonShiftTransforms(BinaryOperator &I) {\n   Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n   assert(Op0->getType() == Op1->getType());\n   Type *Ty = I.getType();\n-\n-  // If the shift amount is a one-use `sext`, we can demote it to `zext`.\n+// If the shift amount is a one-use `sext`, we can demote it to `zext`.\n   Value *Y;\n   if (match(Op1, m_OneUse(m_SExt(m_Value(Y))))) {\n     Value *NewExt = Builder.CreateZExt(Y, Ty, Op1->getName());\n@@ -431,9 +430,13 @@ Instruction *InstCombinerImpl::commonShiftTransforms(BinaryOperator &I) {\n     if (Instruction *Res = FoldShiftByConstant(Op0, CUI, I))\n       return Res;\n \n-  if (auto *NewShift = cast_or_null<Instruction>(\n-          reassociateShiftAmtsOfTwoSameDirectionShifts(&I, SQ)))\n-    return NewShift;\n+  // Don't reassociate shifts if the shift amount is a pointer type or if the\n+  // shift amount is not a constant.\n+  if (!Op1->getType()->isPointerTy() && isa<Constant>(Op1) && isa<Constant>(Op0)) {\n+    if (auto *NewShift = cast_or_null<Instruction>(\n+            reassociateShiftAmtsOfTwoSameDirectionShifts(&I, SQ)))\n+      return NewShift;\n+  }\n \n   // Pre-shift a constant shifted by a variable amount with constant offset:\n   // C shift (A add nuw C1) --> (C shift C1) shift A\n@@ -446,6 +449,11 @@ Instruction *InstCombinerImpl::commonShiftTransforms(BinaryOperator &I) {\n     if (I.getOpcode() == Instruction::Shl) {\n       NewShiftOp->setHasNoSignedWrap(I.hasNoSignedWrap());\n       NewShiftOp->setHasNoUnsignedWrap(I.hasNoUnsignedWrap());\n+    }\n+    return NewShiftOp;\n+  }\n+\n+  return nullptr;\n     } else {\n       NewShiftOp->setIsExact(I.isExact());\n     }\n",
  "log": [
    {
      "role": "system",
      "content": "You are an LLVM maintainer.\nYou are fixing a middle-end bug in the LLVM project.\nPlease answer with the code directly. Do not include any additional information.\n"
    },
    {
      "role": "user",
      "content": "This is a hang bug in InstCombine.\nIssue title: [InstCombine] Infinite loop when combining two `shl` instructions\nIssue body: The following sample triggers an infinite loop in instcombine:\n\n```\n@c = external constant i8\n@c2 = external constant i8\n\ndefine i16 @testfunc() {\nentry:\n  %0 = shl i64 1, ptrtoint (ptr @c2 to i64)\n  %1 = shl i64 %0, ptrtoint (ptr @c to i64)\n  %2 = inttoptr i64 %1 to ptr\n  %3 = load i16, ptr %2, align 1\n  ret i16 %3\n}\n```\n\nhttps://godbolt.org/z/WP6YvGjPq\n\nDetailed information:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/shl-twice-constant.ll\",\n  \"args\": \"opt < %s -passes=instcombine -S\",\n  \"name\": \"testfunc\",\n  \"body\": \"@c = external constant i8\\n@c2 = external constant i8\\n\\ndefine i64 @testfunc() {\\n  %shl1 = shl i64 1, ptrtoint (ptr @c2 to i64)\\n  %shl2 = shl i64 %shl1, ptrtoint (ptr @c to i64)\\n  ret i64 %shl2\\n}\\n\",\n  \"result\": false,\n  \"log\": \"Command '['/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt', '-', '-passes=instcombine', '-S']' timed out after 10.0 seconds\\n\\n\"\n}\nPlease modify the following code in llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:InstCombinerImpl::commonShiftTransforms to fix the bug:\n```\n\n  // If the shift amount is a one-use `sext`, we can demote it to `zext`.\n  Value *Y;\n  if (match(Op1, m_OneUse(m_SExt(m_Value(Y))))) {\n    Value *NewExt = Builder.CreateZExt(Y, Ty, Op1->getName());\n    return BinaryOperator::Create(I.getOpcode(), Op0, NewExt);\n  }\n\n  // See if we can fold away this shift.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  // Try to fold constant and into select arguments.\n  if (isa<Constant>(Op0))\n    if (SelectInst *SI = dyn_cast<SelectInst>(Op1))\n      if (Instruction *R = FoldOpIntoSelect(I, SI))\n        return R;\n\n  if (Constant *CUI = dyn_cast<Constant>(Op1))\n    if (Instruction *Res = FoldShiftByConstant(Op0, CUI, I))\n      return Res;\n\n  if (auto *NewShift = cast_or_null<Instruction>(\n          reassociateShiftAmtsOfTwoSameDirectionShifts(&I, SQ)))\n    return NewShift;\n\n  // Pre-shift a constant shifted by a variable amount with constant offset:\n  // C shift (A add nuw C1) --> (C shift C1) shift A\n  Value *A;\n  Constant *C, *C1;\n  if (match(Op0, m_Constant(C)) &&\n      match(Op1, m_NUWAddLike(m_Value(A), m_Constant(C1)))) {\n    Value *NewC = Builder.CreateBinOp(I.getOpcode(), C, C1);\n    BinaryOperator *NewShiftOp = BinaryOperator::Create(I.getOpcode(), NewC, A);\n    if (I.getOpcode() == Instruction::Shl) {\n      NewShiftOp->setHasNoSignedWrap(I.hasNoSignedWrap());\n      NewShiftOp->setHasNoUnsignedWrap(I.hasNoUnsignedWrap());\n```\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If the shift amount is a one-use `sext`, we can demote it to `zext`.\n  Value *Y;\n  if (match(Op1, m_OneUse(m_SExt(m_Value(Y))))) {\n    Value *NewExt = Builder.CreateZExt(Y, Ty, Op1->getName());\n    return BinaryOperator::Create(I.getOpcode(), Op0, NewExt);\n  }\n\n  // See if we can fold away this shift.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  // Try to fold constant and into select arguments.\n  if (isa<Constant>(Op0))\n    if (SelectInst *SI = dyn_cast<SelectInst>(Op1))\n      if (Instruction *R = FoldOpIntoSelect(I, SI))\n        return R;\n\n  if (Constant *CUI = dyn_cast<Constant>(Op1))\n    if (Instruction *Res = FoldShiftByConstant(Op0, CUI, I))\n      return Res;\n\n  // Don't reassociate shifts if the shift amount is a pointer type.\n  if (!Op1->getType()->isPointerTy()) {\n    if (auto *NewShift = cast_or_null<Instruction>(\n            reassociateShiftAmtsOfTwoSameDirectionShifts(&I, SQ)))\n      return NewShift;\n  }\n\n  // Pre-shift a constant shifted by a variable amount with constant offset:\n  // C shift (A add nuw C1) --> (C shift C1) shift A\n  Value *A;\n  Constant *C, *C1;\n  if (match(Op0, m_Constant(C)) &&\n      match(Op1, m_NUWAddLike(m_Value(A), m_Constant(C1)))) {\n    Value *NewC = Builder.CreateBinOp(I.getOpcode(), C, C1);\n    BinaryOperator *NewShiftOp = BinaryOperator::Create(I.getOpcode(), NewC, A);\n    if (I.getOpcode() == Instruction::Shl) {\n      NewShiftOp->setHasNoSignedWrap(I.hasNoSignedWrap());\n      NewShiftOp->setHasNoUnsignedWrap(I.hasNoUnsignedWrap());\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/shl-twice-constant.ll\",\n  \"args\": \"opt < %s -passes=instcombine -S\",\n  \"name\": \"testfunc\",\n  \"body\": \"@c = external constant i8\\n@c2 = external constant i8\\n\\ndefine i64 @testfunc() {\\n  %shl1 = shl i64 1, ptrtoint (ptr @c2 to i64)\\n  %shl2 = shl i64 %shl1, ptrtoint (ptr @c to i64)\\n  ret i64 %shl2\\n}\\n\",\n  \"result\": false,\n  \"log\": \"Command '['/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt', '-', '-passes=instcombine', '-S']' timed out after 10.0 seconds\\n\\n\"\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If the shift amount is a one-use `sext`, we can demote it to `zext`.\n  Value *Y;\n  if (match(Op1, m_OneUse(m_SExt(m_Value(Y))))) {\n    Value *NewExt = Builder.CreateZExt(Y, Ty, Op1->getName());\n    return BinaryOperator::Create(I.getOpcode(), Op0, NewExt);\n  }\n\n  // See if we can fold away this shift.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  // Try to fold constant and into select arguments.\n  if (isa<Constant>(Op0))\n    if (SelectInst *SI = dyn_cast<SelectInst>(Op1))\n      if (Instruction *R = FoldOpIntoSelect(I, SI))\n        return R;\n\n  if (Constant *CUI = dyn_cast<Constant>(Op1))\n    if (Instruction *Res = FoldShiftByConstant(Op0, CUI, I))\n      return Res;\n\n  // Don't reassociate shifts if the shift amount is a pointer type or if the\n  // shift amount is not a constant.\n  if (!Op1->getType()->isPointerTy() && isa<Constant>(Op1)) {\n    if (auto *NewShift = cast_or_null<Instruction>(\n            reassociateShiftAmtsOfTwoSameDirectionShifts(&I, SQ)))\n      return NewShift;\n  }\n\n  // Pre-shift a constant shifted by a variable amount with constant offset:\n  // C shift (A add nuw C1) --> (C shift C1) shift A\n  Value *A;\n  Constant *C, *C1;\n  if (match(Op0, m_Constant(C)) &&\n      match(Op1, m_NUWAddLike(m_Value(A), m_Constant(C1)))) {\n    Value *NewC = Builder.CreateBinOp(I.getOpcode(), C, C1);\n    BinaryOperator *NewShiftOp = BinaryOperator::Create(I.getOpcode(), NewC, A);\n    if (I.getOpcode() == Instruction::Shl) {\n      NewShiftOp->setHasNoSignedWrap(I.hasNoSignedWrap());\n      NewShiftOp->setHasNoUnsignedWrap(I.hasNoUnsignedWrap());\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/shl-twice-constant.ll\",\n  \"args\": \"opt < %s -passes=instcombine -S\",\n  \"name\": \"testfunc\",\n  \"body\": \"@c = external constant i8\\n@c2 = external constant i8\\n\\ndefine i64 @testfunc() {\\n  %shl1 = shl i64 1, ptrtoint (ptr @c2 to i64)\\n  %shl2 = shl i64 %shl1, ptrtoint (ptr @c to i64)\\n  ret i64 %shl2\\n}\\n\",\n  \"result\": false,\n  \"log\": \"Command '['/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt', '-', '-passes=instcombine', '-S']' timed out after 10.0 seconds\\n\\n\"\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If the shift amount is a one-use `sext`, we can demote it to `zext`.\n  Value *Y;\n  if (match(Op1, m_OneUse(m_SExt(m_Value(Y))))) {\n    Value *NewExt = Builder.CreateZExt(Y, Ty, Op1->getName());\n    return BinaryOperator::Create(I.getOpcode(), Op0, NewExt);\n  }\n\n  // See if we can fold away this shift.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  // Try to fold constant and into select arguments.\n  if (isa<Constant>(Op0))\n    if (SelectInst *SI = dyn_cast<SelectInst>(Op1))\n      if (Instruction *R = FoldOpIntoSelect(I, SI))\n        return R;\n\n  if (Constant *CUI = dyn_cast<Constant>(Op1))\n    if (Instruction *Res = FoldShiftByConstant(Op0, CUI, I))\n      return Res;\n\n  // Don't reassociate shifts if the shift amount is a pointer type or if the\n  // shift amount is not a constant.\n  if (!Op1->getType()->isPointerTy() && isa<Constant>(Op1) && isa<Constant>(Op0)) {\n    if (auto *NewShift = cast_or_null<Instruction>(\n            reassociateShiftAmtsOfTwoSameDirectionShifts(&I, SQ)))\n      return NewShift;\n  }\n\n  // Pre-shift a constant shifted by a variable amount with constant offset:\n  // C shift (A add nuw C1) --> (C shift C1) shift A\n  Value *A;\n  Constant *C, *C1;\n  if (match(Op0, m_Constant(C)) &&\n      match(Op1, m_NUWAddLike(m_Value(A), m_Constant(C1)))) {\n    Value *NewC = Builder.CreateBinOp(I.getOpcode(), C, C1);\n    BinaryOperator *NewShiftOp = BinaryOperator::Create(I.getOpcode(), NewC, A);\n    if (I.getOpcode() == Instruction::Shl) {\n      NewShiftOp->setHasNoSignedWrap(I.hasNoSignedWrap());\n      NewShiftOp->setHasNoUnsignedWrap(I.hasNoUnsignedWrap());\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/shl-twice-constant.ll\",\n  \"args\": \"opt < %s -passes=instcombine -S\",\n  \"name\": \"testfunc\",\n  \"body\": \"@c = external constant i8\\n@c2 = external constant i8\\n\\ndefine i64 @testfunc() {\\n  %shl1 = shl i64 1, ptrtoint (ptr @c2 to i64)\\n  %shl2 = shl i64 %shl1, ptrtoint (ptr @c to i64)\\n  ret i64 %shl2\\n}\\n\",\n  \"result\": false,\n  \"log\": \"Command '['/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt', '-', '-passes=instcombine', '-S']' timed out after 10.0 seconds\\n\\n\"\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If the shift amount is a one-use `sext`, we can demote it to `zext`.\n  Value *Y;\n  if (match(Op1, m_OneUse(m_SExt(m_Value(Y))))) {\n    Value *NewExt = Builder.CreateZExt(Y, Ty, Op1->getName());\n    return BinaryOperator::Create(I.getOpcode(), Op0, NewExt);\n  }\n\n  // See if we can fold away this shift.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  // Try to fold constant and into select arguments.\n  if (isa<Constant>(Op0))\n    if (SelectInst *SI = dyn_cast<SelectInst>(Op1))\n      if (Instruction *R = FoldOpIntoSelect(I, SI))\n        return R;\n\n  if (Constant *CUI = dyn_cast<Constant>(Op1))\n    if (Instruction *Res = FoldShiftByConstant(Op0, CUI, I))\n      return Res;\n\n  // Don't reassociate shifts if the shift amount is a pointer type or if the\n  // shift amount is not a constant.\n  if (!Op1->getType()->isPointerTy() && isa<Constant>(Op1) && isa<Constant>(Op0)) {\n    if (auto *NewShift = cast_or_null<Instruction>(\n            reassociateShiftAmtsOfTwoSameDirectionShifts(&I, SQ)))\n      return NewShift;\n  }\n\n  // Pre-shift a constant shifted by a variable amount with constant offset:\n  // C shift (A add nuw C1) --> (C shift C1) shift A\n  Value *A;\n  Constant *C, *C1;\n  if (match(Op0, m_Constant(C)) &&\n      match(Op1, m_NUWAddLike(m_Value(A), m_Constant(C1)))) {\n    Value *NewC = Builder.CreateBinOp(I.getOpcode(), C, C1);\n    BinaryOperator *NewShiftOp = BinaryOperator::Create(I.getOpcode(), NewC, A);\n    if (I.getOpcode() == Instruction::Shl) {\n      NewShiftOp->setHasNoSignedWrap(I.hasNoSignedWrap());\n      NewShiftOp->setHasNoUnsignedWrap(I.hasNoUnsignedWrap());\n    }\n    return NewShiftOp;\n  }\n\n  return nullptr;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCMake Deprecation Warning at /data/zyw/llvm-apr-benchmark/work/llvm-project/cmake/Modules/CMakePolicy.cmake:6 (cmake_policy):\n  The OLD behavior for policy CMP0116 will be removed from a future version\n  of CMake.\n\n  The cmake-policies(7) manual explains that the OLD behaviors of all\n  policies are deprecated and that a policy should be set to OLD only under\n  specific short-term circumstances.  Projects should be ported to the NEW\n  behavior and not rely on setting a policy to OLD.\nCall Stack (most recent call first):\n  CMakeLists.txt:8 (include)\n\n\n-- Could NOT find LibEdit (missing: LibEdit_INCLUDE_DIRS LibEdit_LIBRARIES) \n-- LLVM host triple: x86_64-unknown-linux-gnu\n-- Native target architecture is X86\n-- Threads enabled.\n-- Doxygen disabled.\n-- Ninja version: 1.10.0\n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- OCaml bindings disabled.\n-- LLVM default target triple: x86_64-unknown-linux-gnu\n-- Building with -fPIC\n-- Targeting X86\n-- Targeting RISCV\n-- Targeting AArch64\n-- Targeting SystemZ\n-- Targeting Hexagon\n-- Failed to find LLVM FileCheck\n-- Google Benchmark version: v0.0.0, normalized to 0.0.0\n-- Performing Test HAVE_GNU_POSIX_REGEX -- failed to compile\n-- Performing Test HAVE_POSIX_REGEX -- success\n-- Performing Test HAVE_STEADY_CLOCK -- success\n-- Performing Test HAVE_PTHREAD_AFFINITY -- failed to compile\n-- Configuring done (6.0s)\n-- Generating done (3.1s)\n-- Build files have been written to: /data/zyw/llvm-apr-benchmark/work/llvm-build\n\n[1/85] Building CXX object tools/llvm-config/CMakeFiles/llvm-config.dir/llvm-config.cpp.o\n[2/85] Linking CXX executable bin/llvm-config\n[3/85] Building CXX object lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineShifts.cpp.o\nFAILED: lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineShifts.cpp.o \nccache /usr/bin/c++ -DGTEST_HAS_RTTI=0 -DLLVM_EXPORTS -D_DEBUG -D_GLIBCXX_ASSERTIONS -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -I/data/zyw/llvm-apr-benchmark/work/llvm-build/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-build/include -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include -fPIC -fno-semantic-interposition -fvisibility-inlines-hidden -Werror=date-time -fno-lifetime-dse -w -fdiagnostics-color -ffunction-sections -fdata-sections -O2 -g -DNDEBUG -std=c++17 -fPIC  -fno-exceptions -funwind-tables -fno-rtti -UNDEBUG -MD -MT lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineShifts.cpp.o -MF lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineShifts.cpp.o.d -o lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineShifts.cpp.o -c /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:457:7: error: expected unqualified-id before \u2018else\u2019\n  457 |     } else {\n      |       ^~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:460:5: error: expected unqualified-id before \u2018return\u2019\n  460 |     return NewShiftOp;\n      |     ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:461:3: error: expected declaration before \u2018}\u2019 token\n  461 |   }\n      |   ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:463:23: error: \u2018Ty\u2019 was not declared in this scope\n  463 |   unsigned BitWidth = Ty->getScalarSizeInBits();\n      |                       ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:471:3: error: expected unqualified-id before \u2018if\u2019\n  471 |   if (match(Op0, m_APInt(AC)) && match(Op1, m_Add(m_Value(A), m_APInt(AddC))) &&\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:507:3: error: expected unqualified-id before \u2018if\u2019\n  507 |   if (Op1->hasOneUse() && match(Op1, m_SRem(m_Value(A), m_Constant(C))) &&\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:516:3: error: expected unqualified-id before \u2018if\u2019\n  516 |   if (Instruction *Logic = foldShiftOfShiftedBinOp(I, Builder))\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:519:3: error: expected unqualified-id before \u2018if\u2019\n  519 |   if (match(Op1, m_Or(m_Value(), m_SpecificInt(BitWidth - 1))))\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:523:3: error: expected unqualified-id before \u2018if\u2019\n  523 |   if ((I.getOpcode() == Instruction::LShr ||\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:537:3: error: expected unqualified-id before \u2018return\u2019\n  537 |   return nullptr;\n      |   ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:538:1: error: expected declaration before \u2018}\u2019 token\n  538 | }\n      | ^\nninja: build stopped: subcommand failed.\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    }
  ]
}