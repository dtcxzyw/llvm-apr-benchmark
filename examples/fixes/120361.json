{
  "wall_time": 66.45176982879639,
  "knowledge": [
    [
      "base_model",
      "2023-12-31+0000"
    ],
    [
      "hint:bug_functions",
      "2024-12-18+0000"
    ],
    [
      "hint:components",
      "2024-12-18+0000"
    ],
    [
      "hint:issue",
      "2024-12-18+0000"
    ],
    [
      "hint:line_level_bug_locations",
      "2024-12-18+0000"
    ]
  ],
  "build_count": 5,
  "build_failure_count": 3,
  "fast_check_count": 1,
  "full_check_count": 4,
  "fast_check_pass": false,
  "full_check_pass": false,
  "patch": "diff --git a/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp b/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\nindex dff9304be64d..6419b0ce86f9 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n@@ -437,7 +437,7 @@ static Value *foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed(\n \n   // At this point, either B is a superset of D, B is a subset of D or B == D.\n \n-  // If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n+// If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n   // and the whole expression becomes false (or true if negated), otherwise, no\n   // folding.\n   // For example,\n@@ -455,14 +455,28 @@ static Value *foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed(\n   // RHS. For example,\n   // (icmp ne (A & 255), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n   // (icmp ne (A & 15), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n-  if (IsSuperSetOrEqual(BCst, DCst))\n+  if (IsSuperSetOrEqual(BCst, DCst)) {\n+    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n+    // poison when LHS is false.\n+    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n+        isa<ConstantInt>(RHS->getOperand(1)) &&\n+        cast<ConstantInt>(RHS->getOperand(1))->isAllOnesValue())\n+      return nullptr;\n     return RHS;\n+  }\n   // Otherwise, B is a subset of D. If B and E have a common bit set,\n   // ie. (B & E) != 0, then LHS is subsumed by RHS. For example.\n   // (icmp ne (A & 12), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n   assert(IsSubSetOrEqual(BCst, DCst) && \"Precondition due to above code\");\n-  if ((*BCst & ECst) != 0)\n+  if ((*BCst & ECst) != 0) {\n+    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n+    // poison when LHS is false.\n+    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n+        isa<ConstantInt>(RHS->getOperand(1)) &&\n+        cast<ConstantInt>(RHS->getOperand(1))->isAllOnesValue())\n+      return nullptr;\n     return RHS;\n+  }\n   // Otherwise, LHS and RHS contradict and the whole expression becomes false\n   // (or true if negated.) For example,\n   // (icmp ne (A & 7), 0) & (icmp eq (A & 15), 8) -> false.\n",
  "log": [
    {
      "role": "system",
      "content": "You are an LLVM maintainer.\nYou are fixing a middle-end bug in the LLVM project.\nPlease answer with the code directly. Do not include any additional information.\n"
    },
    {
      "role": "user",
      "content": "This is a miscompilation bug in InstCombine.\nIssue title: [InstCombine] `samesign` should be dropped when folding logical and of icmps\nIssue body: Reproducer: https://alive2.llvm.org/ce/z/YSW_NC\n```\ndefine i1 @src(i8 %0, i8 %1) {\nstart:\n  %2 = icmp samesign eq i8 %0, -1\n  %3 = icmp ne i8 %0, 0\n  %4 = icmp ugt i8 %0, %0\n  %result = select i1 %3, i1 %2, i1 %4\n  ret i1 %result\n}\n\ndefine i1 @tgt(i8 %0, i8 %1) {\nstart:\n  %2 = icmp samesign eq i8 %0, -1\n  ret i1 %2\n}\n```\n```\n\n----------------------------------------\ndefine i1 @src(i8 %#0, i8 %#1) {\nstart:\n  %#2 = icmp samesign eq i8 %#0, 255\n  %#3 = icmp ne i8 %#0, 0\n  %#4 = icmp ugt i8 %#0, %#0\n  %result = select i1 %#3, i1 %#2, i1 %#4\n  ret i1 %result\n}\n=>\ndefine i1 @tgt(i8 %#0, i8 %#1) {\nstart:\n  %#2 = icmp samesign eq i8 %#0, 255\n  ret i1 %#2\n}\nTransformation doesn't verify!\n\nERROR: Target is more poisonous than source\n\nExample:\ni8 %#0 = #x00 (0)\ni8 %#1 = poison\n\nSource:\ni1 %#2 = poison\ni1 %#3 = #x0 (0)\ni1 %#4 = #x0 (0)\ni1 %result = #x0 (0)\n\nTarget:\ni1 %#2 = poison\nSource value: #x0 (0)\nTarget value: poison\n```\nReported by https://github.com/dtcxzyw/llvm-mutation-based-fuzz-service/issues/14 while reviewing https://github.com/llvm/llvm-project/pull/120177.\n\n\n\nDetailed information:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/icmp-logical.ll\",\n  \"args\": \"opt -passes=instcombine -S -o - %s\",\n  \"name\": \"pr120361\",\n  \"body\": \"define i1 @pr120361(i8 %x, i8 %y) {\\n  %cmp1 = icmp samesign eq i8 %x, -1\\n  %cmp2 = icmp ne i8 %x, 0\\n  %result = select i1 %cmp2, i1 %cmp1, i1 false\\n  ret i1 %result\\n}\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"define i1 @pr120361(i8 %x, i8 %y) {\\n  %cmp1 = icmp samesign eq i8 %x, -1\\n  %cmp2 = icmp ne i8 %x, 0\\n  %result = select i1 %cmp2, i1 %cmp1, i1 false\\n  ret i1 %result\\n}\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\n\\ndefine i1 @pr120361(i8 %x, i8 %y) {\\n  %cmp1 = icmp samesign eq i8 %x, -1\\n  ret i1 %cmp1\\n}\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine i1 @pr120361(i8 %x, i8 %y) {\\n#0:\\n  %cmp1 = icmp samesign eq i8 %x, 255\\n  %cmp2 = icmp ne i8 %x, 0\\n  %result = select i1 %cmp2, i1 %cmp1, i1 0\\n  ret i1 %result\\n}\\n=>\\ndefine i1 @pr120361(i8 %x, i8 %y) {\\n#0:\\n  %cmp1 = icmp samesign eq i8 %x, 255\\n  ret i1 %cmp1\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\ni8 %x = #x00 (0)\\ni8 %y = poison\\n\\nSource:\\ni1 %cmp1 = poison\\ni1 %cmp2 = #x0 (0)\\ni1 %result = #x0 (0)\\n\\nTarget:\\ni1 %cmp1 = poison\\nSource value: #x0 (0)\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease modify the following code in llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed to fix the bug:\n```\n  // If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n  // and the whole expression becomes false (or true if negated), otherwise, no\n  // folding.\n  // For example,\n  // (icmp ne (A & 3), 0) & (icmp eq (A & 7), 0) -> false.\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 3), 0) -> no folding.\n  if (ECst.isZero()) {\n    if (IsSubSetOrEqual(BCst, DCst))\n      return ConstantInt::get(LHS->getType(), !IsAnd);\n    return nullptr;\n  }\n\n  // At this point, B, D, E aren't zero and (B & D) == B, (B & D) == D or B ==\n  // D. If B is a superset of (or equal to) D, since E is not zero, LHS is\n  // subsumed by RHS (RHS implies LHS.) So the whole expression becomes\n  // RHS. For example,\n  // (icmp ne (A & 255), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  if (IsSuperSetOrEqual(BCst, DCst))\n    return RHS;\n  // Otherwise, B is a subset of D. If B and E have a common bit set,\n  // ie. (B & E) != 0, then LHS is subsumed by RHS. For example.\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  assert(IsSubSetOrEqual(BCst, DCst) && \"Precondition due to above code\");\n  if ((*BCst & ECst) != 0)\n    return RHS;\n  // Otherwise, LHS and RHS contradict and the whole expression becomes false\n  // (or true if negated.) For example,\n  // (icmp ne (A & 7), 0) & (icmp eq (A & 15), 8) -> false.\n  // (icmp ne (A & 6), 0) & (icmp eq (A & 15), 8) -> false.\n  return ConstantInt::get(LHS->getType(), !IsAnd);\n}\n\n/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single\n/// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side\n/// aren't of the common mask pattern type.\n/// Also used for logical and/or, must be poison safe.\nstatic Value *foldLogOpOfMaskedICmpsAsymmetric(\n    ICmpInst *LHS, ICmpInst *RHS, bool IsAnd, Value *A, Value *B, Value *C,\n    Value *D, Value *E, ICmpInst::Predicate PredL, ICmpInst::Predicate PredR,\n    unsigned LHSMask, unsigned RHSMask, InstCombiner::BuilderTy &Builder) {\n  assert(ICmpInst::isEquality(PredL) && ICmpInst::isEquality(PredR) &&\n         \"Expected equality predicates for masked type of icmps.\");\n  // Handle Mask_NotAllZeros-BMask_Mixed cases.\n```\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n  // and the whole expression becomes false (or true if negated), otherwise, no\n  // folding.\n  // For example,\n  // (icmp ne (A & 3), 0) & (icmp eq (A & 7), 0) -> false.\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 3), 0) -> no folding.\n  if (ECst.isZero()) {\n    if (IsSubSetOrEqual(BCst, DCst))\n      return ConstantInt::get(LHS->getType(), !IsAnd);\n    return nullptr;\n  }\n\n  // At this point, B, D, E aren't zero and (B & D) == B, (B & D) == D or B ==\n  // D. If B is a superset of (or equal to) D, since E is not zero, LHS is\n  // subsumed by RHS (RHS implies LHS.) So the whole expression becomes\n  // RHS. For example,\n  // (icmp ne (A & 255), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  if (IsSuperSetOrEqual(BCst, DCst)) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_SAMESIGN)\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, B is a subset of D. If B and E have a common bit set,\n  // ie. (B & E) != 0, then LHS is subsumed by RHS. For example.\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  assert(IsSubSetOrEqual(BCst, DCst) && \"Precondition due to above code\");\n  if ((*BCst & ECst) != 0) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_SAMESIGN)\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, LHS and RHS contradict and the whole expression becomes false\n  // (or true if negated.) For example,\n  // (icmp ne (A & 7), 0) & (icmp eq (A & 15), 8) -> false.\n  // (icmp ne (A & 6), 0) & (icmp eq (A & 15), 8) -> false.\n  return ConstantInt::get(LHS->getType(), !IsAnd);\n}\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCMake Deprecation Warning at /data/zyw/llvm-apr-benchmark/work/llvm-project/cmake/Modules/CMakePolicy.cmake:6 (cmake_policy):\n  The OLD behavior for policy CMP0116 will be removed from a future version\n  of CMake.\n\n  The cmake-policies(7) manual explains that the OLD behaviors of all\n  policies are deprecated and that a policy should be set to OLD only under\n  specific short-term circumstances.  Projects should be ported to the NEW\n  behavior and not rely on setting a policy to OLD.\nCall Stack (most recent call first):\n  CMakeLists.txt:8 (include)\n\n\n-- Could NOT find LibEdit (missing: LibEdit_INCLUDE_DIRS LibEdit_LIBRARIES) \n-- LLVM host triple: x86_64-unknown-linux-gnu\n-- Native target architecture is X86\n-- Threads enabled.\n-- Doxygen disabled.\n-- Ninja version: 1.10.0\n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- OCaml bindings disabled.\n-- LLVM default target triple: x86_64-unknown-linux-gnu\n-- Building with -fPIC\n-- Targeting X86\n-- Targeting RISCV\n-- Targeting AArch64\n-- Targeting SystemZ\n-- Targeting Hexagon\n-- Failed to find LLVM FileCheck\n-- Google Benchmark version: v0.0.0, normalized to 0.0.0\n-- Performing Test HAVE_GNU_POSIX_REGEX -- failed to compile\n-- Performing Test HAVE_POSIX_REGEX -- success\n-- Performing Test HAVE_STEADY_CLOCK -- success\n-- Performing Test HAVE_PTHREAD_AFFINITY -- failed to compile\n-- Configuring done (6.0s)\n-- Generating done (3.1s)\n-- Build files have been written to: /data/zyw/llvm-apr-benchmark/work/llvm-build\n\n[1/85] Building CXX object tools/llvm-config/CMakeFiles/llvm-config.dir/llvm-config.cpp.o\n[2/85] Linking CXX executable bin/llvm-config\n[3/85] Building CXX object lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o\nFAILED: lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o \nccache /usr/bin/c++ -DGTEST_HAS_RTTI=0 -DLLVM_EXPORTS -D_DEBUG -D_GLIBCXX_ASSERTIONS -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -I/data/zyw/llvm-apr-benchmark/work/llvm-build/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-build/include -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include -fPIC -fno-semantic-interposition -fvisibility-inlines-hidden -Werror=date-time -fno-lifetime-dse -w -fdiagnostics-color -ffunction-sections -fdata-sections -O2 -g -DNDEBUG -std=c++17 -fPIC  -fno-exceptions -funwind-tables -fno-rtti -UNDEBUG -MD -MT lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o -MF lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o.d -o lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o -c /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp: In function \u2018llvm::Value* foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed(llvm::ICmpInst*, llvm::ICmpInst*, bool, llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, llvm::CmpInst::Predicate, llvm::CmpInst::Predicate, llvm::InstCombiner::BuilderTy&)\u2019:\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:461:42: error: \u2018ICMP_SAMESIGN\u2019 is not a member of \u2018llvm::ICmpInst\u2019\n  461 |     if (RHS->getPredicate() == ICmpInst::ICMP_SAMESIGN)\n      |                                          ^~~~~~~~~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:472:42: error: \u2018ICMP_SAMESIGN\u2019 is not a member of \u2018llvm::ICmpInst\u2019\n  472 |     if (RHS->getPredicate() == ICmpInst::ICMP_SAMESIGN)\n      |                                          ^~~~~~~~~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp: At global scope:\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:486:3: error: expected unqualified-id before \u2018if\u2019\n  486 |   if (!IsAnd) {\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:490:3: error: expected unqualified-id before \u2018if\u2019\n  490 |   if ((LHSMask & Mask_NotAllZeros) && (RHSMask & BMask_Mixed)) {\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:495:5: error: expected unqualified-id before \u2018else\u2019\n  495 |   } else if ((LHSMask & BMask_Mixed) && (RHSMask & Mask_NotAllZeros)) {\n      |     ^~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:501:3: error: expected unqualified-id before \u2018return\u2019\n  501 |   return nullptr;\n      |   ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:502:1: error: expected declaration before \u2018}\u2019 token\n  502 | }\n      | ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp: In function \u2018llvm::Value* foldLogOpOfMaskedICmps(llvm::ICmpInst*, llvm::ICmpInst*, bool, bool, llvm::InstCombiner::BuilderTy&)\u2019:\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:523:20: error: \u2018foldLogOpOfMaskedICmpsAsymmetric\u2019 was not declared in this scope; did you mean \u2018foldLogOpOfMaskedICmps\u2019?\n  523 |     if (Value *V = foldLogOpOfMaskedICmpsAsymmetric(\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                    foldLogOpOfMaskedICmps\nninja: build stopped: subcommand failed.\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n  // and the whole expression becomes false (or true if negated), otherwise, no\n  // folding.\n  // For example,\n  // (icmp ne (A & 3), 0) & (icmp eq (A & 7), 0) -> false.\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 3), 0) -> no folding.\n  if (ECst.isZero()) {\n    if (IsSubSetOrEqual(BCst, DCst))\n      return ConstantInt::get(LHS->getType(), !IsAnd);\n    return nullptr;\n  }\n\n  // At this point, B, D, E aren't zero and (B & D) == B, (B & D) == D or B ==\n  // D. If B is a superset of (or equal to) D, since E is not zero, LHS is\n  // subsumed by RHS (RHS implies LHS.) So the whole expression becomes\n  // RHS. For example,\n  // (icmp ne (A & 255), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  if (IsSuperSetOrEqual(BCst, DCst)) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n        RHS->getOperand(1) == ConstantInt::get(RHS->getOperand(1)->getType(), -1))\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, B is a subset of D. If B and E have a common bit set,\n  // ie. (B & E) != 0, then LHS is subsumed by RHS. For example.\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  assert(IsSubSetOrEqual(BCst, DCst) && \"Precondition due to above code\");\n  if ((*BCst & ECst) != 0) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n        RHS->getOperand(1) == ConstantInt::get(RHS->getOperand(1)->getType(), -1))\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, LHS and RHS contradict and the whole expression becomes false\n  // (or true if negated.) For example,\n  // (icmp ne (A & 7), 0) & (icmp eq (A & 15), 8) -> false.\n  // (icmp ne (A & 6), 0) & (icmp eq (A & 15), 8) -> false.\n  return ConstantInt::get(LHS->getType(), !IsAnd);\n}\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCMake Deprecation Warning at /data/zyw/llvm-apr-benchmark/work/llvm-project/cmake/Modules/CMakePolicy.cmake:6 (cmake_policy):\n  The OLD behavior for policy CMP0116 will be removed from a future version\n  of CMake.\n\n  The cmake-policies(7) manual explains that the OLD behaviors of all\n  policies are deprecated and that a policy should be set to OLD only under\n  specific short-term circumstances.  Projects should be ported to the NEW\n  behavior and not rely on setting a policy to OLD.\nCall Stack (most recent call first):\n  CMakeLists.txt:8 (include)\n\n\n-- Could NOT find LibEdit (missing: LibEdit_INCLUDE_DIRS LibEdit_LIBRARIES) \n-- LLVM host triple: x86_64-unknown-linux-gnu\n-- Native target architecture is X86\n-- Threads enabled.\n-- Doxygen disabled.\n-- Ninja version: 1.10.0\n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- OCaml bindings disabled.\n-- LLVM default target triple: x86_64-unknown-linux-gnu\n-- Building with -fPIC\n-- Targeting X86\n-- Targeting RISCV\n-- Targeting AArch64\n-- Targeting SystemZ\n-- Targeting Hexagon\n-- Failed to find LLVM FileCheck\n-- Google Benchmark version: v0.0.0, normalized to 0.0.0\n-- Performing Test HAVE_GNU_POSIX_REGEX -- failed to compile\n-- Performing Test HAVE_POSIX_REGEX -- success\n-- Performing Test HAVE_STEADY_CLOCK -- success\n-- Performing Test HAVE_PTHREAD_AFFINITY -- failed to compile\n-- Configuring done (5.8s)\n-- Generating done (3.1s)\n-- Build files have been written to: /data/zyw/llvm-apr-benchmark/work/llvm-build\n\n[1/85] Building CXX object tools/llvm-config/CMakeFiles/llvm-config.dir/llvm-config.cpp.o\n[2/85] Linking CXX executable bin/llvm-config\n[3/85] Building CXX object lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o\nFAILED: lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o \nccache /usr/bin/c++ -DGTEST_HAS_RTTI=0 -DLLVM_EXPORTS -D_DEBUG -D_GLIBCXX_ASSERTIONS -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -I/data/zyw/llvm-apr-benchmark/work/llvm-build/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-build/include -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include -fPIC -fno-semantic-interposition -fvisibility-inlines-hidden -Werror=date-time -fno-lifetime-dse -w -fdiagnostics-color -ffunction-sections -fdata-sections -O2 -g -DNDEBUG -std=c++17 -fPIC  -fno-exceptions -funwind-tables -fno-rtti -UNDEBUG -MD -MT lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o -MF lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o.d -o lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o -c /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:488:3: error: expected unqualified-id before \u2018if\u2019\n  488 |   if (!IsAnd) {\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:492:3: error: expected unqualified-id before \u2018if\u2019\n  492 |   if ((LHSMask & Mask_NotAllZeros) && (RHSMask & BMask_Mixed)) {\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:497:5: error: expected unqualified-id before \u2018else\u2019\n  497 |   } else if ((LHSMask & BMask_Mixed) && (RHSMask & Mask_NotAllZeros)) {\n      |     ^~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:503:3: error: expected unqualified-id before \u2018return\u2019\n  503 |   return nullptr;\n      |   ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:504:1: error: expected declaration before \u2018}\u2019 token\n  504 | }\n      | ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp: In function \u2018llvm::Value* foldLogOpOfMaskedICmps(llvm::ICmpInst*, llvm::ICmpInst*, bool, bool, llvm::InstCombiner::BuilderTy&)\u2019:\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:525:20: error: \u2018foldLogOpOfMaskedICmpsAsymmetric\u2019 was not declared in this scope; did you mean \u2018foldLogOpOfMaskedICmps\u2019?\n  525 |     if (Value *V = foldLogOpOfMaskedICmpsAsymmetric(\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                    foldLogOpOfMaskedICmps\nninja: build stopped: subcommand failed.\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n  // and the whole expression becomes false (or true if negated), otherwise, no\n  // folding.\n  // For example,\n  // (icmp ne (A & 3), 0) & (icmp eq (A & 7), 0) -> false.\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 3), 0) -> no folding.\n  if (ECst.isZero()) {\n    if (IsSubSetOrEqual(BCst, DCst))\n      return ConstantInt::get(LHS->getType(), !IsAnd);\n    return nullptr;\n  }\n\n  // At this point, B, D, E aren't zero and (B & D) == B, (B & D) == D or B ==\n  // D. If B is a superset of (or equal to) D, since E is not zero, LHS is\n  // subsumed by RHS (RHS implies LHS.) So the whole expression becomes\n  // RHS. For example,\n  // (icmp ne (A & 255), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  if (IsSuperSetOrEqual(BCst, DCst)) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n        isa<ConstantInt>(RHS->getOperand(1)) &&\n        cast<ConstantInt>(RHS->getOperand(1))->isAllOnesValue())\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, B is a subset of D. If B and E have a common bit set,\n  // ie. (B & E) != 0, then LHS is subsumed by RHS. For example.\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  assert(IsSubSetOrEqual(BCst, DCst) && \"Precondition due to above code\");\n  if ((*BCst & ECst) != 0) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n        isa<ConstantInt>(RHS->getOperand(1)) &&\n        cast<ConstantInt>(RHS->getOperand(1))->isAllOnesValue())\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, LHS and RHS contradict and the whole expression becomes false\n  // (or true if negated.) For example,\n  // (icmp ne (A & 7), 0) & (icmp eq (A & 15), 8) -> false.\n  // (icmp ne (A & 6), 0) & (icmp eq (A & 15), 8) -> false.\n  return ConstantInt::get(LHS->getType(), !IsAnd);\n}\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCMake Deprecation Warning at /data/zyw/llvm-apr-benchmark/work/llvm-project/cmake/Modules/CMakePolicy.cmake:6 (cmake_policy):\n  The OLD behavior for policy CMP0116 will be removed from a future version\n  of CMake.\n\n  The cmake-policies(7) manual explains that the OLD behaviors of all\n  policies are deprecated and that a policy should be set to OLD only under\n  specific short-term circumstances.  Projects should be ported to the NEW\n  behavior and not rely on setting a policy to OLD.\nCall Stack (most recent call first):\n  CMakeLists.txt:8 (include)\n\n\n-- Could NOT find LibEdit (missing: LibEdit_INCLUDE_DIRS LibEdit_LIBRARIES) \n-- LLVM host triple: x86_64-unknown-linux-gnu\n-- Native target architecture is X86\n-- Threads enabled.\n-- Doxygen disabled.\n-- Ninja version: 1.10.0\n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- OCaml bindings disabled.\n-- LLVM default target triple: x86_64-unknown-linux-gnu\n-- Building with -fPIC\n-- Targeting X86\n-- Targeting RISCV\n-- Targeting AArch64\n-- Targeting SystemZ\n-- Targeting Hexagon\n-- Failed to find LLVM FileCheck\n-- Google Benchmark version: v0.0.0, normalized to 0.0.0\n-- Performing Test HAVE_GNU_POSIX_REGEX -- failed to compile\n-- Performing Test HAVE_POSIX_REGEX -- success\n-- Performing Test HAVE_STEADY_CLOCK -- success\n-- Performing Test HAVE_PTHREAD_AFFINITY -- failed to compile\n-- Configuring done (5.7s)\n-- Generating done (3.1s)\n-- Build files have been written to: /data/zyw/llvm-apr-benchmark/work/llvm-build\n\n[1/85] Building CXX object tools/llvm-config/CMakeFiles/llvm-config.dir/llvm-config.cpp.o\n[2/85] Linking CXX executable bin/llvm-config\n[3/85] Building CXX object lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o\nFAILED: lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o \nccache /usr/bin/c++ -DGTEST_HAS_RTTI=0 -DLLVM_EXPORTS -D_DEBUG -D_GLIBCXX_ASSERTIONS -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -I/data/zyw/llvm-apr-benchmark/work/llvm-build/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-build/include -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include -fPIC -fno-semantic-interposition -fvisibility-inlines-hidden -Werror=date-time -fno-lifetime-dse -w -fdiagnostics-color -ffunction-sections -fdata-sections -O2 -g -DNDEBUG -std=c++17 -fPIC  -fno-exceptions -funwind-tables -fno-rtti -UNDEBUG -MD -MT lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o -MF lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o.d -o lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstCombineAndOrXor.cpp.o -c /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:490:3: error: expected unqualified-id before \u2018if\u2019\n  490 |   if (!IsAnd) {\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:494:3: error: expected unqualified-id before \u2018if\u2019\n  494 |   if ((LHSMask & Mask_NotAllZeros) && (RHSMask & BMask_Mixed)) {\n      |   ^~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:499:5: error: expected unqualified-id before \u2018else\u2019\n  499 |   } else if ((LHSMask & BMask_Mixed) && (RHSMask & Mask_NotAllZeros)) {\n      |     ^~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:505:3: error: expected unqualified-id before \u2018return\u2019\n  505 |   return nullptr;\n      |   ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:506:1: error: expected declaration before \u2018}\u2019 token\n  506 | }\n      | ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp: In function \u2018llvm::Value* foldLogOpOfMaskedICmps(llvm::ICmpInst*, llvm::ICmpInst*, bool, bool, llvm::InstCombiner::BuilderTy&)\u2019:\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:527:20: error: \u2018foldLogOpOfMaskedICmpsAsymmetric\u2019 was not declared in this scope; did you mean \u2018foldLogOpOfMaskedICmps\u2019?\n  527 |     if (Value *V = foldLogOpOfMaskedICmpsAsymmetric(\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                    foldLogOpOfMaskedICmps\nninja: build stopped: subcommand failed.\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  // If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n  // and the whole expression becomes false (or true if negated), otherwise, no\n  // folding.\n  // For example,\n  // (icmp ne (A & 3), 0) & (icmp eq (A & 7), 0) -> false.\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 3), 0) -> no folding.\n  if (ECst.isZero()) {\n    if (IsSubSetOrEqual(BCst, DCst))\n      return ConstantInt::get(LHS->getType(), !IsAnd);\n    return nullptr;\n  }\n\n  // At this point, B, D, E aren't zero and (B & D) == B, (B & D) == D or B ==\n  // D. If B is a superset of (or equal to) D, since E is not zero, LHS is\n  // subsumed by RHS (RHS implies LHS.) So the whole expression becomes\n  // RHS. For example,\n  // (icmp ne (A & 255), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  if (IsSuperSetOrEqual(BCst, DCst)) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n        isa<ConstantInt>(RHS->getOperand(1)) &&\n        cast<ConstantInt>(RHS->getOperand(1))->isAllOnesValue())\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, B is a subset of D. If B and E have a common bit set,\n  // ie. (B & E) != 0, then LHS is subsumed by RHS. For example.\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  assert(IsSubSetOrEqual(BCst, DCst) && \"Precondition due to above code\");\n  if ((*BCst & ECst) != 0) {\n    // If RHS is a samesign icmp, we can't fold to RHS because it may introduce\n    // poison when LHS is false.\n    if (RHS->getPredicate() == ICmpInst::ICMP_EQ &&\n        isa<ConstantInt>(RHS->getOperand(1)) &&\n        cast<ConstantInt>(RHS->getOperand(1))->isAllOnesValue())\n      return nullptr;\n    return RHS;\n  }\n  // Otherwise, LHS and RHS contradict and the whole expression becomes false\n  // (or true if negated.) For example,\n  // (icmp ne (A & 7), 0) & (icmp eq (A & 15), 8) -> false.\n  // (icmp ne (A & 6), 0) & (icmp eq (A & 15), 8) -> false.\n  return ConstantInt::get(LHS->getType(), !IsAnd);\n}\n\n/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single\n/// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side\n/// aren't of the common mask pattern type.\n/// Also used for logical and/or, must be poison safe.\nstatic Value *foldLogOpOfMaskedICmpsAsymmetric(\n    ICmpInst *LHS, ICmpInst *RHS, bool IsAnd, Value *A, Value *B, Value *C,\n    Value *D, Value *E, ICmpInst::Predicate PredL, ICmpInst::Predicate PredR,\n    unsigned LHSMask, unsigned RHSMask, InstCombiner::BuilderTy &Builder) {\n  assert(ICmpInst::isEquality(PredL) && ICmpInst::isEquality(PredR) &&\n         \"Expected equality predicates for masked type of icmps.\");\n  // Handle Mask_NotAllZeros-BMask_Mixed cases.\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/icmp-logical.ll\",\n  \"args\": \"opt -passes=instcombine -S -o - %s\",\n  \"name\": \"pr120361_v2\",\n  \"body\": \"define i1 @pr120361_v2(i32 %x) {\\n  %and1 = and i32 %x, 15\\n  %cmp1 = icmp ne i32 %and1, 0\\n  %and2 = and i32 %x, -113\\n  %cmp2 = icmp samesign eq i32 %and2, 15\\n  %and = select i1 %cmp1, i1 %cmp2, i1 false\\n  ret i1 %and\\n}\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"define i1 @pr120361_v2(i32 %x) {\\n  %and1 = and i32 %x, 15\\n  %cmp1 = icmp ne i32 %and1, 0\\n  %and2 = and i32 %x, -113\\n  %cmp2 = icmp samesign eq i32 %and2, 15\\n  %and = select i1 %cmp1, i1 %cmp2, i1 false\\n  ret i1 %and\\n}\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\n\\ndefine i1 @pr120361_v2(i32 %x) {\\n  %and2 = and i32 %x, -113\\n  %cmp2 = icmp samesign eq i32 %and2, 15\\n  ret i1 %cmp2\\n}\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine i1 @pr120361_v2(i32 %x) {\\n#0:\\n  %and1 = and i32 %x, 15\\n  %cmp1 = icmp ne i32 %and1, 0\\n  %and2 = and i32 %x, 4294967183\\n  %cmp2 = icmp samesign eq i32 %and2, 15\\n  %and = select i1 %cmp1, i1 %cmp2, i1 0\\n  ret i1 %and\\n}\\n=>\\ndefine i1 @pr120361_v2(i32 %x) {\\n#0:\\n  %and2 = and i32 %x, 4294967183\\n  %cmp2 = icmp samesign eq i32 %and2, 15\\n  ret i1 %cmp2\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\ni32 %x = #x80000000 (2147483648, -2147483648)\\n\\nSource:\\ni32 %and1 = #x00000000 (0)\\ni1 %cmp1 = #x0 (0)\\ni32 %and2 = #x80000000 (2147483648, -2147483648)\\ni1 %cmp2 = poison\\ni1 %and = #x0 (0)\\n\\nTarget:\\ni32 %and2 = #x80000000 (2147483648, -2147483648)\\ni1 %cmp2 = poison\\nSource value: #x0 (0)\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    }
  ]
}