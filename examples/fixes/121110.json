{
  "wall_time": 712.4731123447418,
  "knowledge": [
    [
      "base_model",
      "2023-12-31+0000"
    ],
    [
      "hint:bug_functions",
      "2024-12-25+0000"
    ],
    [
      "hint:components",
      "2024-12-25+0000"
    ],
    [
      "hint:issue",
      "2024-12-25+0000"
    ],
    [
      "hint:line_level_bug_locations",
      "2024-12-25+0000"
    ]
  ],
  "build_count": 5,
  "build_failure_count": 0,
  "fast_check_count": 1,
  "full_check_count": 4,
  "fast_check_pass": true,
  "full_check_pass": false,
  "patch": "diff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\nindex ecbc13d489eb..156828dcabb9 100644\n--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n@@ -1651,7 +1651,7 @@ bool VectorCombine::foldPermuteOfBinops(Instruction &I) {\n   Worklist.pushValue(Shuf0);\n   Worklist.pushValue(Shuf1);\n   replaceValue(I, *NewBO);\n-  return true;\n+return true;\n }\n \n /// Try to convert \"shuffle (binop), (binop)\" into \"binop (shuffle), (shuffle)\".\n@@ -1716,6 +1716,13 @@ bool VectorCombine::foldShuffleOfBinops(Instruction &I) {\n     W = PoisonValue::get(BinOpTy);\n   }\n \n+  // Don't fold if the shuffle mask selects from both sources and the binop\n+  // operands are not the same.\n+  if (SK0 == TargetTransformInfo::SK_PermuteTwoSrc && X != Z)\n+    return false;\n+  if (SK1 == TargetTransformInfo::SK_PermuteTwoSrc && Y != W)\n+    return false;\n+\n   // Try to replace a binop with a shuffle if the shuffle is not costly.\n   InstructionCost OldCost =\n       TTI.getInstructionCost(LHS, CostKind) +\n",
  "log": [
    {
      "role": "system",
      "content": "You are an LLVM maintainer.\nYou are fixing a middle-end bug in the LLVM project.\nPlease answer with the code directly. Do not include any additional information.\n"
    },
    {
      "role": "user",
      "content": "This is a miscompilation bug in VectorCombine.\nIssue title: [clang] Miscompilation at -Os\nIssue body: This code prints 9 at `-Os` and 0 at `-O0/1/2/3`:\n\n```c\nint printf(const char *, ...);\nchar a = 9, c, d;\nint b, e;\nunsigned short f;\nchar *g = &a;\nvoid h(int i) {\n  for (; b; b++)\n    c &= 0 <= i;\n}\nstatic short j(unsigned long i) {\n  int k;\n  for (; e + d + 4 > 0;) {\n    k = i + 49;\n    h(k + i - 52 + i);\n    *g = 0;\n    return 0;\n  }\n  return 0;\n}\nint main() {\n  j(6 < (unsigned short)(f - 7) + f);\n  printf(\"%d\\n\", a);\n}\n```\n\nCompiler Explorer: https://godbolt.org/z/Mo5TEKh8r\n\nBisected to https://github.com/llvm/llvm-project/commit/5287299f8809ae927a0acafb179c4b37ce9ff21d, which was committed by @RKSimon \nDetailed information:\n{\n  \"file\": \"llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll\",\n  \"args\": \"opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2\",\n  \"name\": \"PR121110\",\n  \"body\": \"define <2 x i1> @PR121110() {\\n  %ugt = icmp samesign ugt <2 x i32> zeroinitializer, zeroinitializer\\n  %sgt = icmp sgt <2 x i32> zeroinitializer, <i32 6, i32 -4>\\n  %res = shufflevector <2 x i1> %ugt, <2 x i1> %sgt, <2 x i32> <i32 0, i32 3>\\n  ret <2 x i1> %res\\n}\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"target datalayout = \\\"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\\\"\\ntarget triple = \\\"x86_64-unknown-unknown\\\"\\ndefine <2 x i1> @PR121110() {\\n  %ugt = icmp samesign ugt <2 x i32> zeroinitializer, zeroinitializer\\n  %sgt = icmp sgt <2 x i32> zeroinitializer, <i32 6, i32 -4>\\n  %res = shufflevector <2 x i1> %ugt, <2 x i1> %sgt, <2 x i32> <i32 0, i32 3>\\n  ret <2 x i1> %res\\n}\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\ntarget datalayout = \\\"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\\\"\\ntarget triple = \\\"x86_64-unknown-unknown\\\"\\n\\ndefine <2 x i1> @PR121110() #0 {\\n  ret <2 x i1> zeroinitializer\\n}\\n\\nattributes #0 = { \\\"target-features\\\"=\\\"+sse2\\\" }\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine <2 x i1> @PR121110() {\\n#0:\\n  %ugt = icmp samesign ugt <2 x i32> { 0, 0 }, { 0, 0 }\\n  %sgt = icmp sgt <2 x i32> { 0, 0 }, { 6, 4294967292 }\\n  %res = shufflevector <2 x i1> %ugt, <2 x i1> %sgt, 0, 3\\n  ret <2 x i1> %res\\n}\\n=>\\ndefine <2 x i1> @PR121110() {\\n#0:\\n  ret <2 x i1> { 0, 0 }\\n}\\nTransformation doesn't verify!\\n\\nERROR: Value mismatch\\n\\nExample:\\n\\nSource:\\n<2 x i1> %ugt = < #x0 (0), #x0 (0) >\\n<2 x i1> %sgt = < #x0 (0), #x1 (1) >\\n<2 x i1> %res = < #x0 (0), #x1 (1) >\\n\\nTarget:\\nSource value: < #x0 (0), #x1 (1) >\\nTarget value: < #x0 (0), #x0 (0) >\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease modify the following code in llvm/lib/Transforms/Vectorize/VectorCombine.cpp:VectorCombine::foldShuffleOfBinops to fix the bug:\n```\n  return true;\n}\n\n/// Try to convert \"shuffle (binop), (binop)\" into \"binop (shuffle), (shuffle)\".\n/// Try to convert \"shuffle (cmpop), (cmpop)\" into \"cmpop (shuffle), (shuffle)\".\nbool VectorCombine::foldShuffleOfBinops(Instruction &I) {\n  ArrayRef<int> OldMask;\n  Instruction *LHS, *RHS;\n  if (!match(&I, m_Shuffle(m_OneUse(m_Instruction(LHS)),\n                           m_OneUse(m_Instruction(RHS)), m_Mask(OldMask))))\n    return false;\n\n  // TODO: Add support for addlike etc.\n  if (LHS->getOpcode() != RHS->getOpcode())\n    return false;\n\n  Value *X, *Y, *Z, *W;\n  bool IsCommutative = false;\n  CmpPredicate Pred = CmpInst::BAD_ICMP_PREDICATE;\n  if (match(LHS, m_BinOp(m_Value(X), m_Value(Y))) &&\n      match(RHS, m_BinOp(m_Value(Z), m_Value(W)))) {\n    auto *BO = cast<BinaryOperator>(LHS);\n    // Don't introduce poison into div/rem.\n    if (llvm::is_contained(OldMask, PoisonMaskElem) && BO->isIntDivRem())\n      return false;\n    IsCommutative = BinaryOperator::isCommutative(BO->getOpcode());\n  } else if (match(LHS, m_Cmp(Pred, m_Value(X), m_Value(Y))) &&\n             match(RHS, m_SpecificCmp(Pred, m_Value(Z), m_Value(W)))) {\n    IsCommutative = cast<CmpInst>(LHS)->isCommutative();\n  } else\n    return false;\n\n  auto *ShuffleDstTy = dyn_cast<FixedVectorType>(I.getType());\n  auto *BinResTy = dyn_cast<FixedVectorType>(LHS->getType());\n  auto *BinOpTy = dyn_cast<FixedVectorType>(X->getType());\n  if (!ShuffleDstTy || !BinResTy || !BinOpTy || X->getType() != Z->getType())\n    return false;\n\n  unsigned NumSrcElts = BinOpTy->getNumElements();\n\n  // If we have something like \"add X, Y\" and \"add Z, X\", swap ops to match.\n  if (IsCommutative && X != Z && Y != W && (X == W || Y == Z))\n    std::swap(X, Y);\n\n  auto ConvertToUnary = [NumSrcElts](int &M) {\n    if (M >= (int)NumSrcElts)\n      M -= NumSrcElts;\n  };\n\n  SmallVector<int> NewMask0(OldMask);\n  TargetTransformInfo::ShuffleKind SK0 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (X == Z) {\n    llvm::for_each(NewMask0, ConvertToUnary);\n    SK0 = TargetTransformInfo::SK_PermuteSingleSrc;\n    Z = PoisonValue::get(BinOpTy);\n  }\n\n  SmallVector<int> NewMask1(OldMask);\n  TargetTransformInfo::ShuffleKind SK1 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (Y == W) {\n    llvm::for_each(NewMask1, ConvertToUnary);\n    SK1 = TargetTransformInfo::SK_PermuteSingleSrc;\n    W = PoisonValue::get(BinOpTy);\n  }\n\n  // Try to replace a binop with a shuffle if the shuffle is not costly.\n  InstructionCost OldCost =\n      TTI.getInstructionCost(LHS, CostKind) +\n      TTI.getInstructionCost(RHS, CostKind) +\n      TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc, BinResTy,\n                         OldMask, CostKind, 0, nullptr, {LHS, RHS}, &I);\n\n  InstructionCost NewCost =\n      TTI.getShuffleCost(SK0, BinOpTy, NewMask0, CostKind, 0, nullptr, {X, Z}) +\n      TTI.getShuffleCost(SK1, BinOpTy, NewMask1, CostKind, 0, nullptr, {Y, W});\n\n  if (Pred == CmpInst::BAD_ICMP_PREDICATE) {\n    NewCost +=\n        TTI.getArithmeticInstrCost(LHS->getOpcode(), ShuffleDstTy, CostKind);\n  } else {\n    auto *ShuffleCmpTy =\n        FixedVectorType::get(BinOpTy->getElementType(), ShuffleDstTy);\n    NewCost += TTI.getCmpSelInstrCost(LHS->getOpcode(), ShuffleCmpTy,\n                                      ShuffleDstTy, Pred, CostKind);\n  }\n\n  LLVM_DEBUG(dbgs() << \"Found a shuffle feeding two binops: \" << I\n                    << \"\\n  OldCost: \" << OldCost << \" vs NewCost: \" << NewCost\n                    << \"\\n\");\n\n  // If either shuffle will constant fold away, then fold for the same cost as\n  // we will reduce the instruction count.\n  bool ReducedInstCount = (isa<Constant>(X) && isa<Constant>(Z)) ||\n                          (isa<Constant>(Y) && isa<Constant>(W));\n  if (ReducedInstCount ? (NewCost > OldCost) : (NewCost >= OldCost))\n    return false;\n\n  Value *Shuf0 = Builder.CreateShuffleVector(X, Z, NewMask0);\n  Value *Shuf1 = Builder.CreateShuffleVector(Y, W, NewMask1);\n  Value *NewBO = Pred == CmpInst::BAD_ICMP_PREDICATE\n                     ? Builder.CreateBinOp(\n                           cast<BinaryOperator>(LHS)->getOpcode(), Shuf0, Shuf1)\n                     : Builder.CreateCmp(Pred, Shuf0, Shuf1);\n\n  // Intersect flags from the old binops.\n  if (auto *NewInst = dyn_cast<Instruction>(NewBO)) {\n    NewInst->copyIRFlags(LHS);\n    NewInst->andIRFlags(RHS);\n  }\n\n  Worklist.pushValue(Shuf0);\n  Worklist.pushValue(Shuf1);\n  replaceValue(I, *NewBO);\n  return true;\n}\n\n/// Try to convert \"shuffle (castop), (castop)\" with a shared castop operand\n/// into \"castop (shuffle)\".\nbool VectorCombine::foldShuffleOfCastops(Instruction &I) {\n  Value *V0, *V1;\n  ArrayRef<int> OldMask;\n```\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  return true;\n}\n\n/// Try to convert \"shuffle (binop), (binop)\" into \"binop (shuffle), (shuffle)\".\n/// Try to convert \"shuffle (cmpop), (cmpop)\" into \"cmpop (shuffle), (shuffle)\".\nbool VectorCombine::foldShuffleOfBinops(Instruction &I) {\n  ArrayRef<int> OldMask;\n  Instruction *LHS, *RHS;\n  if (!match(&I, m_Shuffle(m_OneUse(m_Instruction(LHS)),\n                           m_OneUse(m_Instruction(RHS)), m_Mask(OldMask))))\n    return false;\n\n  // TODO: Add support for addlike etc.\n  if (LHS->getOpcode() != RHS->getOpcode())\n    return false;\n\n  Value *X, *Y, *Z, *W;\n  bool IsCommutative = false;\n  CmpPredicate Pred = CmpInst::BAD_ICMP_PREDICATE;\n  if (match(LHS, m_BinOp(m_Value(X), m_Value(Y))) &&\n      match(RHS, m_BinOp(m_Value(Z), m_Value(W)))) {\n    auto *BO = cast<BinaryOperator>(LHS);\n    // Don't introduce poison into div/rem.\n    if (llvm::is_contained(OldMask, PoisonMaskElem) && BO->isIntDivRem())\n      return false;\n    IsCommutative = BinaryOperator::isCommutative(BO->getOpcode());\n  } else if (match(LHS, m_Cmp(Pred, m_Value(X), m_Value(Y))) &&\n             match(RHS, m_SpecificCmp(Pred, m_Value(Z), m_Value(W)))) {\n    IsCommutative = cast<CmpInst>(LHS)->isCommutative();\n  } else\n    return false;\n\n  auto *ShuffleDstTy = dyn_cast<FixedVectorType>(I.getType());\n  auto *BinResTy = dyn_cast<FixedVectorType>(LHS->getType());\n  auto *BinOpTy = dyn_cast<FixedVectorType>(X->getType());\n  if (!ShuffleDstTy || !BinResTy || !BinOpTy || X->getType() != Z->getType())\n    return false;\n\n  unsigned NumSrcElts = BinOpTy->getNumElements();\n\n  // If we have something like \"add X, Y\" and \"add Z, X\", swap ops to match.\n  if (IsCommutative && X != Z && Y != W && (X == W || Y == Z))\n    std::swap(X, Y);\n\n  auto ConvertToUnary = [NumSrcElts](int &M) {\n    if (M >= (int)NumSrcElts)\n      M -= NumSrcElts;\n  };\n\n  SmallVector<int> NewMask0(OldMask);\n  TargetTransformInfo::ShuffleKind SK0 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (X == Z) {\n    llvm::for_each(NewMask0, ConvertToUnary);\n    SK0 = TargetTransformInfo::SK_PermuteSingleSrc;\n    Z = PoisonValue::get(BinOpTy);\n  }\n\n  SmallVector<int> NewMask1(OldMask);\n  TargetTransformInfo::ShuffleKind SK1 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (Y == W) {\n    llvm::for_each(NewMask1, ConvertToUnary);\n    SK1 = TargetTransformInfo::SK_PermuteSingleSrc;\n    W = PoisonValue::get(BinOpTy);\n  }\n\n  // Try to replace a binop with a shuffle if the shuffle is not costly.\n  InstructionCost OldCost =\n      TTI.getInstructionCost(LHS, CostKind) +\n      TTI.getInstructionCost(RHS, CostKind) +\n      TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc, BinResTy,\n                         OldMask, CostKind, 0, nullptr, {LHS, RHS}, &I);\n\n  InstructionCost NewCost =\n      TTI.getShuffleCost(SK0, BinOpTy, NewMask0, CostKind, 0, nullptr, {X, Z}) +\n      TTI.getShuffleCost(SK1, BinOpTy, NewMask1, CostKind, 0, nullptr, {Y, W});\n\n  if (Pred == CmpInst::BAD_ICMP_PREDICATE) {\n    NewCost +=\n        TTI.getArithmeticInstrCost(LHS->getOpcode(), ShuffleDstTy, CostKind);\n  } else {\n    auto *ShuffleCmpTy =\n        FixedVectorType::get(BinOpTy->getElementType(), ShuffleDstTy);\n    NewCost += TTI.getCmpSelInstrCost(LHS->getOpcode(), ShuffleCmpTy,\n                                      ShuffleDstTy, Pred, CostKind);\n  }\n\n  LLVM_DEBUG(dbgs() << \"Found a shuffle feeding two binops: \" << I\n                    << \"\\n  OldCost: \" << OldCost << \" vs NewCost: \" << NewCost\n                    << \"\\n\");\n\n  // If either shuffle will constant fold away, then fold for the same cost as\n  // we will reduce the instruction count.\n  bool ReducedInstCount = (isa<Constant>(X) && isa<Constant>(Z)) ||\n                          (isa<Constant>(Y) && isa<Constant>(W));\n  if (ReducedInstCount ? (NewCost > OldCost) : (NewCost >= OldCost))\n    return false;\n\n  // Don't fold if the shuffle mask selects from both sources and the binop\n  // operands are not the same.\n  if (SK0 == TargetTransformInfo::SK_PermuteTwoSrc && X != Z)\n    return false;\n  if (SK1 == TargetTransformInfo::SK_PermuteTwoSrc && Y != W)\n    return false;\n\n  Value *Shuf0 = Builder.CreateShuffleVector(X, Z, NewMask0);\n  Value *Shuf1 = Builder.CreateShuffleVector(Y, W, NewMask1);\n  Value *NewBO = Pred == CmpInst::BAD_ICMP_PREDICATE\n                     ? Builder.CreateBinOp(\n                           cast<BinaryOperator>(LHS)->getOpcode(), Shuf0, Shuf1)\n                     : Builder.CreateCmp(Pred, Shuf0, Shuf1);\n\n  // Intersect flags from the old binops.\n  if (auto *NewInst = dyn_cast<Instruction>(NewBO)) {\n    NewInst->copyIRFlags(LHS);\n    NewInst->andIRFlags(RHS);\n  }\n\n  Worklist.pushValue(Shuf0);\n  Worklist.pushValue(Shuf1);\n  replaceValue(I, *NewBO);\n  return true;\n}\n\n/// Try to convert \"shuffle (castop), (castop)\" with a shared castop operand\n/// into \"castop (shuffle)\".\nbool VectorCombine::foldShuffleOfCastops(Instruction &I) {\n  Value *V0, *V1;\n  ArrayRef<int> OldMask;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCommand '['/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/llvm-lit', '--no-progress-bar', '-j', '80', '--max-failures', '1', '--order', 'lexical', '-sv', '/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine']' returned non-zero exit status 1.\n-- Testing: 54 tests, 54 workers --\nFAIL: LLVM :: Transforms/VectorCombine/X86/shuffle-of-binops.ll (29 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/shuffle-of-binops.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2 | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll --check-prefixes=CHECK,SSE\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll --check-prefixes=CHECK,SSE\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:12:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP2:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:8:92: note: scanning from here\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:8:92: note: with \"X\" equal to \"%x\"\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:8:92: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:11:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:44:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[Z]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n            ^\n<stdin>:22:97: note: scanning from here\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:22:97: note: with \"Y\" equal to \"%y\"\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:22:97: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:25:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:83:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> poison, <4 x i32> <i32 3, i32 1, i32 1, i32 2>\n              ^\n<stdin>:36:83: note: scanning from here\ndefine <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                  ^\n<stdin>:36:83: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                  ^\n<stdin>:39:2: note: possible intended match here\n %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 1, i32 1, i32 6>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:99:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> [[Z]], <4 x i32> <i32 3, i32 2, i32 2, i32 5>\n            ^\n<stdin>:43:88: note: scanning from here\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:43:88: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:43:88: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:46:5: note: possible intended match here\n %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 2, i32 2, i32 5>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:190:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:80:118: note: scanning from here\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:80:118: note: with \"X\" equal to \"%x\"\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:80:118: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:83:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n    ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            1: ; ModuleID = '<stdin>' \n            2: source_filename = \"<stdin>\" \n            3: target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\" \n            4: target triple = \"x86_64-unknown-unknown\" \n            5:  \n            6: declare void @use(<4 x i32>) #0 \n            7:  \n            8: define <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:12'0                                                                                                 X error: no match found\nnext:12'1                                                                                                   with \"X\" equal to \"%x\"\nnext:12'2                                                                                                   with \"Z\" equal to \"%z\"\n            9:  %b0 = fdiv fast <4 x float> %x, %y \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           10:  %b1 = fdiv arcp <4 x float> %z, %y \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           11:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:12'3          ?                                                                                         possible intended match\n           12:  ret <4 x float> %r \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~\n           13: } \nnext:12'0      ~~\n           14:  \nnext:12'0      ~\n           15: define <4 x i32> @shuf_add_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           16:  %b0 = add <4 x i32> %x, %y \n           17:  %b1 = add <4 x i32> %x, %z \n           18:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0> \n           19:  ret <4 x i32> %r \n           20: } \n           21:  \n           22: define <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:44'0                                                                                                      X error: no match found\nnext:44'1                                                                                                        with \"Y\" equal to \"%y\"\nnext:44'2                                                                                                        with \"Z\" equal to \"%z\"\n           23:  %b0 = fmul <4 x float> %x, %y \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           24:  %b1 = fmul <4 x float> %z, %x \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           25:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7> \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:44'3          ?                                                                                         possible intended match\n           26:  ret <4 x float> %r \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~\n           27: } \nnext:44'0      ~~\n           28:  \nnext:44'0      ~\n           29: define <2 x i64> @shuf_and_v2i64_yy_swap(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) #0 { \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           30:  %b0 = and <2 x i64> %x, %y \n           31:  %b1 = and <2 x i64> %y, %z \n           32:  %r = shufflevector <2 x i64> %b0, <2 x i64> %b1, <2 x i32> <i32 3, i32 0> \n           33:  ret <2 x i64> %r \n           34: } \n           35:  \n           36: define <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:83'0                                                                                        X error: no match found\nnext:83'1                                                                                          with \"X\" equal to \"%x\"\n           37:  %b0 = shl <4 x i32> %x, %y \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           38:  %b1 = shl <4 x i32> %x, %z \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           39:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 1, i32 1, i32 6> \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:83'2       ?                                                                                        possible intended match\n           40:  ret <4 x i32> %r \nnext:83'0      ~~~~~~~~~~~~~~~~~~\n           41: } \nnext:83'0      ~~\n           42:  \nnext:83'0      ~\n           43: define <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:99'0                                                                                             X error: no match found\nnext:99'1                                                                                               with \"X\" equal to \"%x\"\nnext:99'2                                                                                               with \"Z\" equal to \"%z\"\n           44:  %b0 = shl <4 x i32> %x, %y \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           45:  %b1 = shl <4 x i32> %z, %x \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           46:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 2, i32 2, i32 5> \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:99'3          ?                                                                                     possible intended match\n           47:  ret <4 x i32> %r \nnext:99'0      ~~~~~~~~~~~~~~~~~~\n           48: } \nnext:99'0      ~~\n           49:  \nnext:99'0      ~\n           50: define <2 x i64> @shuf_sub_add_v2i64_yy(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) #0 { \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           51:  %b0 = sub <2 x i64> %x, %y \n            .\n            .\n            .\n           75:  call void @use(<4 x i32> %b1) \n           76:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \n           77:  ret <4 x i32> %r \n           78: } \n           79:  \n           80: define <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 { \nnext:190'0                                                                                                                          X error: no match found\nnext:190'1                                                                                                                            with \"X\" equal to \"%x\"\nnext:190'2                                                                                                                            with \"Z\" equal to \"%z\"\n           81:  %b0 = fdiv <4 x float> %x, %y \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           82:  %b1 = fdiv <4 x float> %z, %w \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           83:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:190'3         ?                                                                                         possible intended match\n           84:  ret <4 x float> %r \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~\n           85: } \nnext:190'0     ~~\n           86:  \nnext:190'0     ~\n           87: define <16 x i16> @shuf_and_v16i16_yy_expensive_shuf(<16 x i16> %x, <16 x i16> %y, <16 x i16> %z) #0 { \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           88:  %b0 = and <16 x i16> %x, %y \n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nFAIL: LLVM :: Transforms/VectorCombine/X86/shuffle-of-cmps.ll (38 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/shuffle-of-cmps.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2 | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll --check-prefixes=CHECK,SSE,SSE2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll --check-prefixes=CHECK,SSE,SSE2\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:48:14: error: SSE2-NEXT: expected string not found in input\n; SSE2-NEXT: [[TMP1:%.*]] = shufflevector <2 x i64> [[X]], <2 x i64> [[Z]], <2 x i32> <i32 1, i32 3>\n             ^\n<stdin>:16:98: note: scanning from here\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:16:98: note: with \"X\" equal to \"%x\"\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:16:98: note: with \"Z\" equal to \"%z\"\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:19:2: note: possible intended match here\n %s = shufflevector <2 x i1> %c0, <2 x i1> %c1, <2 x i32> <i32 1, i32 3>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:90:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:24:99: note: scanning from here\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:24:99: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:24:99: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:27:2: note: possible intended match here\n %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:108:14: error: SSE2-NEXT: expected string not found in input\n; SSE2-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[X]], <4 x float> poison, <4 x i32> <i32 poison, i32 poison, i32 2, i32 0>\n             ^\n<stdin>:32:91: note: scanning from here\ndefine <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                          ^\n<stdin>:32:91: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                          ^\n<stdin>:35:2: note: possible intended match here\n %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:142:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[Z]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n            ^\n<stdin>:40:96: note: scanning from here\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:40:96: note: with \"Y\" equal to \"%y\"\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:40:96: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:43:2: note: possible intended match here\n %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            .\n            .\n            .\n           11:  %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \n           12:  %r = sext <4 x i1> %s to <4 x i32> \n           13:  ret <4 x i32> %r \n           14: } \n           15:  \n           16: define <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 { \nnext:48'0                                                                                                       X error: no match found\nnext:48'1                                                                                                         with \"X\" equal to \"%x\"\nnext:48'2                                                                                                         with \"Z\" equal to \"%z\"\n           17:  %c0 = icmp eq <2 x i64> %x, %y \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           18:  %c1 = icmp eq <2 x i64> %z, %w \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           19:  %s = shufflevector <2 x i1> %c0, <2 x i1> %c1, <2 x i32> <i32 1, i32 3> \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:48'3       ?                                                                        possible intended match\n           20:  %r = sext <2 x i1> %s to <2 x i64> \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           21:  ret <2 x i64> %r \nnext:48'0      ~~~~~~~~~~~~~~~~~~\n           22: } \nnext:48'0      ~~\n           23:  \nnext:48'0      ~\n           24: define <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 { \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:90'0                                                                                                        X error: no match found\nnext:90'1                                                                                                          with \"X\" equal to \"%x\"\nnext:90'2                                                                                                          with \"Z\" equal to \"%z\"\n           25:  %c0 = icmp ugt <4 x i32> %x, %y \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           26:  %c1 = icmp ugt <4 x i32> %z, %w \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           27:  %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:90'3       ?                                                                                      possible intended match\n           28:  %r = sext <4 x i1> %s to <4 x i32> \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           29:  ret <4 x i32> %r \nnext:90'0      ~~~~~~~~~~~~~~~~~~\n           30: } \nnext:90'0      ~~\n           31:  \nnext:90'0      ~\n           32: define <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:108'0                                                                                               X error: no match found\nnext:108'1                                                                                                 with \"X\" equal to \"%x\"\n           33:  %b0 = fcmp oeq <4 x float> %x, %y \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           34:  %b1 = fcmp oeq <4 x float> %x, %z \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           35:  %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0> \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:108'2      ?                                                                                                possible intended match\n           36:  %r = sext <4 x i1> %s to <4 x i32> \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           37:  ret <4 x i32> %r \nnext:108'0     ~~~~~~~~~~~~~~~~~~\n           38: } \nnext:108'0     ~~\n           39:  \nnext:108'0     ~\n           40: define <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:142'0                                                                                                    X error: no match found\nnext:142'1                                                                                                      with \"Y\" equal to \"%y\"\nnext:142'2                                                                                                      with \"Z\" equal to \"%z\"\n           41:  %b0 = fcmp one <4 x float> %x, %y \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           42:  %b1 = fcmp one <4 x float> %z, %x \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           43:  %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7> \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:142'3      ?                                                                                      possible intended match\n           44:  %r = sext <4 x i1> %s to <4 x i32> \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           45:  ret <4 x i32> %r \nnext:142'0     ~~~~~~~~~~~~~~~~~~\n           46: } \nnext:142'0     ~~\n           47:  \nnext:142'0     ~\n           48: define <4 x i32> @shuf_icmp_sgt_v4i32_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nFAIL: LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll (53 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll -passes=vector-combine -S -mtriple=x86_64-- -mcpu=x86-64    | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll --check-prefixes=CHECK,SSE\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mcpu=x86-64\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll --check-prefixes=CHECK,SSE\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll:86:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP3:%.*]] = shufflevector <32 x i8> [[TMP2]], <32 x i8> [[TMP1]], <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63>\n              ^\n<stdin>:39:308: note: scanning from here\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:39:308: note: with \"TMP2\" equal to \"%2\"\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:39:308: note: with \"TMP1\" equal to \"%1\"\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:40:2: note: possible intended match here\n %3 = shufflevector <32 x i8> %1, <32 x i8> %2, <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll:116:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP3:%.*]] = shufflevector <8 x i32> [[TMP2]], <8 x i32> [[TMP1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n              ^\n<stdin>:48:117: note: scanning from here\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:48:117: note: with \"TMP2\" equal to \"%2\"\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:48:117: note: with \"TMP1\" equal to \"%1\"\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:49:2: note: possible intended match here\n %3 = shufflevector <8 x i32> %1, <8 x i32> %2, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            .\n            .\n            .\n           34:  ret i64 %or \n           35: } \n           36:  \n           37: define i64 @movmsk_i64_v64i8_v16i8(<16 x i8> %v0, <16 x i8> %v1, <16 x i8> %v2, <16 x i8> %v3) #0 { \n           38:  %1 = shufflevector <16 x i8> %v3, <16 x i8> %v2, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31> \n           39:  %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31> \nnext:86'0                                                                                                                                                                                                                                                                                                                         X error: no match found\nnext:86'1                                                                                                                                                                                                                                                                                                                           with \"TMP2\" equal to \"%2\"\nnext:86'2                                                                                                                                                                                                                                                                                                                           with \"TMP1\" equal to \"%1\"\n           40:  %3 = shufflevector <32 x i8> %1, <32 x i8> %2, <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63> \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:86'3       ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 possible intended match\n           41:  %4 = icmp slt <64 x i8> %3, zeroinitializer \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           42:  %or = bitcast <64 x i1> %4 to i64 \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           43:  ret i64 %or \nnext:86'0      ~~~~~~~~~~~~~\n           44: } \nnext:86'0      ~~\n           45:  \nnext:86'0      ~\n           46: define i64 @movmsk_i64_v32i32_v4i32(<4 x i32> %v0, <4 x i32> %v1, <4 x i32> %v2, <4 x i32> %v3) #0 { \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           47:  %1 = shufflevector <4 x i32> %v3, <4 x i32> %v2, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7> \n           48:  %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7> \nnext:116'0                                                                                                                         X error: no match found\nnext:116'1                                                                                                                           with \"TMP2\" equal to \"%2\"\nnext:116'2                                                                                                                           with \"TMP1\" equal to \"%1\"\n           49:  %3 = shufflevector <8 x i32> %1, <8 x i32> %2, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:116'3      ?                                                                                                                                                                                 possible intended match\n           50:  %4 = icmp slt <16 x i32> %3, zeroinitializer \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           51:  %5 = bitcast <16 x i1> %4 to i16 \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           52:  %or = zext i16 %5 to i64 \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           53:  ret i64 %or \nnext:116'0     ~~~~~~~~~~~~~\n           54: } \nnext:116'0     ~~\n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nwarning: reached maximum number of test failures, skipping remaining tests\n********************\nFailed Tests (1):\n  LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll\n\n\nTesting Time: 1.19s\n\nTotal Discovered Tests: 54\n  Skipped    : 33 (61.11%)\n  Unsupported:  2 (3.70%)\n  Passed     : 18 (33.33%)\n  Failed     :  1 (1.85%)\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  return true;\n}\n\n/// Try to convert \"shuffle (binop), (binop)\" into \"binop (shuffle), (shuffle)\".\n/// Try to convert \"shuffle (cmpop), (cmpop)\" into \"cmpop (shuffle), (shuffle)\".\nbool VectorCombine::foldShuffleOfBinops(Instruction &I) {\n  ArrayRef<int> OldMask;\n  Instruction *LHS, *RHS;\n  if (!match(&I, m_Shuffle(m_OneUse(m_Instruction(LHS)),\n                           m_OneUse(m_Instruction(RHS)), m_Mask(OldMask))))\n    return false;\n\n  // TODO: Add support for addlike etc.\n  if (LHS->getOpcode() != RHS->getOpcode())\n    return false;\n\n  Value *X, *Y, *Z, *W;\n  bool IsCommutative = false;\n  CmpPredicate Pred = CmpInst::BAD_ICMP_PREDICATE;\n  if (match(LHS, m_BinOp(m_Value(X), m_Value(Y))) &&\n      match(RHS, m_BinOp(m_Value(Z), m_Value(W)))) {\n    auto *BO = cast<BinaryOperator>(LHS);\n    // Don't introduce poison into div/rem.\n    if (llvm::is_contained(OldMask, PoisonMaskElem) && BO->isIntDivRem())\n      return false;\n    IsCommutative = BinaryOperator::isCommutative(BO->getOpcode());\n  } else if (match(LHS, m_Cmp(Pred, m_Value(X), m_Value(Y))) &&\n             match(RHS, m_SpecificCmp(Pred, m_Value(Z), m_Value(W)))) {\n    IsCommutative = cast<CmpInst>(LHS)->isCommutative();\n  } else\n    return false;\n\n  auto *ShuffleDstTy = dyn_cast<FixedVectorType>(I.getType());\n  auto *BinResTy = dyn_cast<FixedVectorType>(LHS->getType());\n  auto *BinOpTy = dyn_cast<FixedVectorType>(X->getType());\n  if (!ShuffleDstTy || !BinResTy || !BinOpTy || X->getType() != Z->getType())\n    return false;\n\n  unsigned NumSrcElts = BinOpTy->getNumElements();\n\n  // If we have something like \"add X, Y\" and \"add Z, X\", swap ops to match.\n  if (IsCommutative && X != Z && Y != W && (X == W || Y == Z))\n    std::swap(X, Y);\n\n  auto ConvertToUnary = [NumSrcElts](int &M) {\n    if (M >= (int)NumSrcElts)\n      M -= NumSrcElts;\n  };\n\n  SmallVector<int> NewMask0(OldMask);\n  TargetTransformInfo::ShuffleKind SK0 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (X == Z) {\n    llvm::for_each(NewMask0, ConvertToUnary);\n    SK0 = TargetTransformInfo::SK_PermuteSingleSrc;\n    Z = PoisonValue::get(BinOpTy);\n  }\n\n  SmallVector<int> NewMask1(OldMask);\n  TargetTransformInfo::ShuffleKind SK1 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (Y == W) {\n    llvm::for_each(NewMask1, ConvertToUnary);\n    SK1 = TargetTransformInfo::SK_PermuteSingleSrc;\n    W = PoisonValue::get(BinOpTy);\n  }\n\n  // Don't fold if the shuffle mask selects from both sources and the binop\n  // operands are not the same.\n  if (SK0 == TargetTransformInfo::SK_PermuteTwoSrc && X != Z)\n    return false;\n  if (SK1 == TargetTransformInfo::SK_PermuteTwoSrc && Y != W)\n    return false;\n\n  // Try to replace a binop with a shuffle if the shuffle is not costly.\n  InstructionCost OldCost =\n      TTI.getInstructionCost(LHS, CostKind) +\n      TTI.getInstructionCost(RHS, CostKind) +\n      TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc, BinResTy,\n                         OldMask, CostKind, 0, nullptr, {LHS, RHS}, &I);\n\n  InstructionCost NewCost =\n      TTI.getShuffleCost(SK0, BinOpTy, NewMask0, CostKind, 0, nullptr, {X, Z}) +\n      TTI.getShuffleCost(SK1, BinOpTy, NewMask1, CostKind, 0, nullptr, {Y, W});\n\n  if (Pred == CmpInst::BAD_ICMP_PREDICATE) {\n    NewCost +=\n        TTI.getArithmeticInstrCost(LHS->getOpcode(), ShuffleDstTy, CostKind);\n  } else {\n    auto *ShuffleCmpTy =\n        FixedVectorType::get(BinOpTy->getElementType(), ShuffleDstTy);\n    NewCost += TTI.getCmpSelInstrCost(LHS->getOpcode(), ShuffleCmpTy,\n                                      ShuffleDstTy, Pred, CostKind);\n  }\n\n  LLVM_DEBUG(dbgs() << \"Found a shuffle feeding two binops: \" << I\n                    << \"\\n  OldCost: \" << OldCost << \" vs NewCost: \" << NewCost\n                    << \"\\n\");\n\n  // If either shuffle will constant fold away, then fold for the same cost as\n  // we will reduce the instruction count.\n  bool ReducedInstCount = (isa<Constant>(X) && isa<Constant>(Z)) ||\n                          (isa<Constant>(Y) && isa<Constant>(W));\n  if (ReducedInstCount ? (NewCost > OldCost) : (NewCost >= OldCost))\n    return false;\n\n  Value *Shuf0 = Builder.CreateShuffleVector(X, Z, NewMask0);\n  Value *Shuf1 = Builder.CreateShuffleVector(Y, W, NewMask1);\n  Value *NewBO = Pred == CmpInst::BAD_ICMP_PREDICATE\n                     ? Builder.CreateBinOp(\n                           cast<BinaryOperator>(LHS)->getOpcode(), Shuf0, Shuf1)\n                     : Builder.CreateCmp(Pred, Shuf0, Shuf1);\n\n  // Intersect flags from the old binops.\n  if (auto *NewInst = dyn_cast<Instruction>(NewBO)) {\n    NewInst->copyIRFlags(LHS);\n    NewInst->andIRFlags(RHS);\n  }\n\n  Worklist.pushValue(Shuf0);\n  Worklist.pushValue(Shuf1);\n  replaceValue(I, *NewBO);\n  return true;\n}\n\n/// Try to convert \"shuffle (castop), (castop)\" with a shared castop operand\n/// into \"castop (shuffle)\".\nbool VectorCombine::foldShuffleOfCastops(Instruction &I) {\n  Value *V0, *V1;\n  ArrayRef<int> OldMask;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCommand '['/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/llvm-lit', '--no-progress-bar', '-j', '80', '--max-failures', '1', '--order', 'lexical', '-sv', '/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine']' returned non-zero exit status 1.\n-- Testing: 54 tests, 54 workers --\nFAIL: LLVM :: Transforms/VectorCombine/X86/shuffle-of-binops.ll (31 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/shuffle-of-binops.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2 | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll --check-prefixes=CHECK,SSE\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll --check-prefixes=CHECK,SSE\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:12:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP2:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:8:92: note: scanning from here\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:8:92: note: with \"X\" equal to \"%x\"\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:8:92: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:11:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:44:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[Z]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n            ^\n<stdin>:22:97: note: scanning from here\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:22:97: note: with \"Y\" equal to \"%y\"\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:22:97: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:25:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:83:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> poison, <4 x i32> <i32 3, i32 1, i32 1, i32 2>\n              ^\n<stdin>:36:83: note: scanning from here\ndefine <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                  ^\n<stdin>:36:83: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                  ^\n<stdin>:39:2: note: possible intended match here\n %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 1, i32 1, i32 6>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:99:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> [[Z]], <4 x i32> <i32 3, i32 2, i32 2, i32 5>\n            ^\n<stdin>:43:88: note: scanning from here\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:43:88: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:43:88: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:46:5: note: possible intended match here\n %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 2, i32 2, i32 5>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:190:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:80:118: note: scanning from here\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:80:118: note: with \"X\" equal to \"%x\"\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:80:118: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:83:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n    ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            1: ; ModuleID = '<stdin>' \n            2: source_filename = \"<stdin>\" \n            3: target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\" \n            4: target triple = \"x86_64-unknown-unknown\" \n            5:  \n            6: declare void @use(<4 x i32>) #0 \n            7:  \n            8: define <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:12'0                                                                                                 X error: no match found\nnext:12'1                                                                                                   with \"X\" equal to \"%x\"\nnext:12'2                                                                                                   with \"Z\" equal to \"%z\"\n            9:  %b0 = fdiv fast <4 x float> %x, %y \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           10:  %b1 = fdiv arcp <4 x float> %z, %y \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           11:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:12'3          ?                                                                                         possible intended match\n           12:  ret <4 x float> %r \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~\n           13: } \nnext:12'0      ~~\n           14:  \nnext:12'0      ~\n           15: define <4 x i32> @shuf_add_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           16:  %b0 = add <4 x i32> %x, %y \n           17:  %b1 = add <4 x i32> %x, %z \n           18:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0> \n           19:  ret <4 x i32> %r \n           20: } \n           21:  \n           22: define <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:44'0                                                                                                      X error: no match found\nnext:44'1                                                                                                        with \"Y\" equal to \"%y\"\nnext:44'2                                                                                                        with \"Z\" equal to \"%z\"\n           23:  %b0 = fmul <4 x float> %x, %y \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           24:  %b1 = fmul <4 x float> %z, %x \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           25:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7> \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:44'3          ?                                                                                         possible intended match\n           26:  ret <4 x float> %r \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~\n           27: } \nnext:44'0      ~~\n           28:  \nnext:44'0      ~\n           29: define <2 x i64> @shuf_and_v2i64_yy_swap(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) #0 { \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           30:  %b0 = and <2 x i64> %x, %y \n           31:  %b1 = and <2 x i64> %y, %z \n           32:  %r = shufflevector <2 x i64> %b0, <2 x i64> %b1, <2 x i32> <i32 3, i32 0> \n           33:  ret <2 x i64> %r \n           34: } \n           35:  \n           36: define <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:83'0                                                                                        X error: no match found\nnext:83'1                                                                                          with \"X\" equal to \"%x\"\n           37:  %b0 = shl <4 x i32> %x, %y \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           38:  %b1 = shl <4 x i32> %x, %z \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           39:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 1, i32 1, i32 6> \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:83'2       ?                                                                                        possible intended match\n           40:  ret <4 x i32> %r \nnext:83'0      ~~~~~~~~~~~~~~~~~~\n           41: } \nnext:83'0      ~~\n           42:  \nnext:83'0      ~\n           43: define <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:99'0                                                                                             X error: no match found\nnext:99'1                                                                                               with \"X\" equal to \"%x\"\nnext:99'2                                                                                               with \"Z\" equal to \"%z\"\n           44:  %b0 = shl <4 x i32> %x, %y \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           45:  %b1 = shl <4 x i32> %z, %x \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           46:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 2, i32 2, i32 5> \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:99'3          ?                                                                                     possible intended match\n           47:  ret <4 x i32> %r \nnext:99'0      ~~~~~~~~~~~~~~~~~~\n           48: } \nnext:99'0      ~~\n           49:  \nnext:99'0      ~\n           50: define <2 x i64> @shuf_sub_add_v2i64_yy(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) #0 { \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           51:  %b0 = sub <2 x i64> %x, %y \n            .\n            .\n            .\n           75:  call void @use(<4 x i32> %b1) \n           76:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \n           77:  ret <4 x i32> %r \n           78: } \n           79:  \n           80: define <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 { \nnext:190'0                                                                                                                          X error: no match found\nnext:190'1                                                                                                                            with \"X\" equal to \"%x\"\nnext:190'2                                                                                                                            with \"Z\" equal to \"%z\"\n           81:  %b0 = fdiv <4 x float> %x, %y \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           82:  %b1 = fdiv <4 x float> %z, %w \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           83:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:190'3         ?                                                                                         possible intended match\n           84:  ret <4 x float> %r \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~\n           85: } \nnext:190'0     ~~\n           86:  \nnext:190'0     ~\n           87: define <16 x i16> @shuf_and_v16i16_yy_expensive_shuf(<16 x i16> %x, <16 x i16> %y, <16 x i16> %z) #0 { \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           88:  %b0 = and <16 x i16> %x, %y \n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nFAIL: LLVM :: Transforms/VectorCombine/X86/shuffle-of-cmps.ll (34 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/shuffle-of-cmps.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2 | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll --check-prefixes=CHECK,SSE,SSE2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll --check-prefixes=CHECK,SSE,SSE2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:48:14: error: SSE2-NEXT: expected string not found in input\n; SSE2-NEXT: [[TMP1:%.*]] = shufflevector <2 x i64> [[X]], <2 x i64> [[Z]], <2 x i32> <i32 1, i32 3>\n             ^\n<stdin>:16:98: note: scanning from here\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:16:98: note: with \"X\" equal to \"%x\"\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:16:98: note: with \"Z\" equal to \"%z\"\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:19:2: note: possible intended match here\n %s = shufflevector <2 x i1> %c0, <2 x i1> %c1, <2 x i32> <i32 1, i32 3>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:90:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:24:99: note: scanning from here\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:24:99: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:24:99: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:27:2: note: possible intended match here\n %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:108:14: error: SSE2-NEXT: expected string not found in input\n; SSE2-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[X]], <4 x float> poison, <4 x i32> <i32 poison, i32 poison, i32 2, i32 0>\n             ^\n<stdin>:32:91: note: scanning from here\ndefine <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                          ^\n<stdin>:32:91: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                          ^\n<stdin>:35:2: note: possible intended match here\n %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:142:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[Z]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n            ^\n<stdin>:40:96: note: scanning from here\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:40:96: note: with \"Y\" equal to \"%y\"\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:40:96: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:43:2: note: possible intended match here\n %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            .\n            .\n            .\n           11:  %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \n           12:  %r = sext <4 x i1> %s to <4 x i32> \n           13:  ret <4 x i32> %r \n           14: } \n           15:  \n           16: define <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 { \nnext:48'0                                                                                                       X error: no match found\nnext:48'1                                                                                                         with \"X\" equal to \"%x\"\nnext:48'2                                                                                                         with \"Z\" equal to \"%z\"\n           17:  %c0 = icmp eq <2 x i64> %x, %y \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           18:  %c1 = icmp eq <2 x i64> %z, %w \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           19:  %s = shufflevector <2 x i1> %c0, <2 x i1> %c1, <2 x i32> <i32 1, i32 3> \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:48'3       ?                                                                        possible intended match\n           20:  %r = sext <2 x i1> %s to <2 x i64> \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           21:  ret <2 x i64> %r \nnext:48'0      ~~~~~~~~~~~~~~~~~~\n           22: } \nnext:48'0      ~~\n           23:  \nnext:48'0      ~\n           24: define <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 { \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:90'0                                                                                                        X error: no match found\nnext:90'1                                                                                                          with \"X\" equal to \"%x\"\nnext:90'2                                                                                                          with \"Z\" equal to \"%z\"\n           25:  %c0 = icmp ugt <4 x i32> %x, %y \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           26:  %c1 = icmp ugt <4 x i32> %z, %w \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           27:  %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:90'3       ?                                                                                      possible intended match\n           28:  %r = sext <4 x i1> %s to <4 x i32> \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           29:  ret <4 x i32> %r \nnext:90'0      ~~~~~~~~~~~~~~~~~~\n           30: } \nnext:90'0      ~~\n           31:  \nnext:90'0      ~\n           32: define <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:108'0                                                                                               X error: no match found\nnext:108'1                                                                                                 with \"X\" equal to \"%x\"\n           33:  %b0 = fcmp oeq <4 x float> %x, %y \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           34:  %b1 = fcmp oeq <4 x float> %x, %z \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           35:  %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0> \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:108'2      ?                                                                                                possible intended match\n           36:  %r = sext <4 x i1> %s to <4 x i32> \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           37:  ret <4 x i32> %r \nnext:108'0     ~~~~~~~~~~~~~~~~~~\n           38: } \nnext:108'0     ~~\n           39:  \nnext:108'0     ~\n           40: define <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:142'0                                                                                                    X error: no match found\nnext:142'1                                                                                                      with \"Y\" equal to \"%y\"\nnext:142'2                                                                                                      with \"Z\" equal to \"%z\"\n           41:  %b0 = fcmp one <4 x float> %x, %y \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           42:  %b1 = fcmp one <4 x float> %z, %x \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           43:  %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7> \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:142'3      ?                                                                                      possible intended match\n           44:  %r = sext <4 x i1> %s to <4 x i32> \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           45:  ret <4 x i32> %r \nnext:142'0     ~~~~~~~~~~~~~~~~~~\n           46: } \nnext:142'0     ~~\n           47:  \nnext:142'0     ~\n           48: define <4 x i32> @shuf_icmp_sgt_v4i32_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nFAIL: LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll (53 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll -passes=vector-combine -S -mtriple=x86_64-- -mcpu=x86-64    | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll --check-prefixes=CHECK,SSE\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mcpu=x86-64\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll --check-prefixes=CHECK,SSE\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll:86:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP3:%.*]] = shufflevector <32 x i8> [[TMP2]], <32 x i8> [[TMP1]], <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63>\n              ^\n<stdin>:39:308: note: scanning from here\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:39:308: note: with \"TMP2\" equal to \"%2\"\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:39:308: note: with \"TMP1\" equal to \"%1\"\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:40:2: note: possible intended match here\n %3 = shufflevector <32 x i8> %1, <32 x i8> %2, <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll:116:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP3:%.*]] = shufflevector <8 x i32> [[TMP2]], <8 x i32> [[TMP1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n              ^\n<stdin>:48:117: note: scanning from here\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:48:117: note: with \"TMP2\" equal to \"%2\"\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:48:117: note: with \"TMP1\" equal to \"%1\"\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:49:2: note: possible intended match here\n %3 = shufflevector <8 x i32> %1, <8 x i32> %2, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            .\n            .\n            .\n           34:  ret i64 %or \n           35: } \n           36:  \n           37: define i64 @movmsk_i64_v64i8_v16i8(<16 x i8> %v0, <16 x i8> %v1, <16 x i8> %v2, <16 x i8> %v3) #0 { \n           38:  %1 = shufflevector <16 x i8> %v3, <16 x i8> %v2, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31> \n           39:  %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31> \nnext:86'0                                                                                                                                                                                                                                                                                                                         X error: no match found\nnext:86'1                                                                                                                                                                                                                                                                                                                           with \"TMP2\" equal to \"%2\"\nnext:86'2                                                                                                                                                                                                                                                                                                                           with \"TMP1\" equal to \"%1\"\n           40:  %3 = shufflevector <32 x i8> %1, <32 x i8> %2, <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63> \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:86'3       ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 possible intended match\n           41:  %4 = icmp slt <64 x i8> %3, zeroinitializer \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           42:  %or = bitcast <64 x i1> %4 to i64 \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           43:  ret i64 %or \nnext:86'0      ~~~~~~~~~~~~~\n           44: } \nnext:86'0      ~~\n           45:  \nnext:86'0      ~\n           46: define i64 @movmsk_i64_v32i32_v4i32(<4 x i32> %v0, <4 x i32> %v1, <4 x i32> %v2, <4 x i32> %v3) #0 { \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           47:  %1 = shufflevector <4 x i32> %v3, <4 x i32> %v2, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7> \n           48:  %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7> \nnext:116'0                                                                                                                         X error: no match found\nnext:116'1                                                                                                                           with \"TMP2\" equal to \"%2\"\nnext:116'2                                                                                                                           with \"TMP1\" equal to \"%1\"\n           49:  %3 = shufflevector <8 x i32> %1, <8 x i32> %2, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:116'3      ?                                                                                                                                                                                 possible intended match\n           50:  %4 = icmp slt <16 x i32> %3, zeroinitializer \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           51:  %5 = bitcast <16 x i1> %4 to i16 \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           52:  %or = zext i16 %5 to i64 \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           53:  ret i64 %or \nnext:116'0     ~~~~~~~~~~~~~\n           54: } \nnext:116'0     ~~\n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nwarning: reached maximum number of test failures, skipping remaining tests\n********************\nFailed Tests (1):\n  LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll\n\n\nTesting Time: 1.19s\n\nTotal Discovered Tests: 54\n  Skipped    : 33 (61.11%)\n  Unsupported:  2 (3.70%)\n  Passed     : 18 (33.33%)\n  Failed     :  1 (1.85%)\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  return true;\n}\n\n/// Try to convert \"shuffle (binop), (binop)\" into \"binop (shuffle), (shuffle)\".\n/// Try to convert \"shuffle (cmpop), (cmpop)\" into \"cmpop (shuffle), (shuffle)\".\nbool VectorCombine::foldShuffleOfBinops(Instruction &I) {\n  ArrayRef<int> OldMask;\n  Instruction *LHS, *RHS;\n  if (!match(&I, m_Shuffle(m_OneUse(m_Instruction(LHS)),\n                           m_OneUse(m_Instruction(RHS)), m_Mask(OldMask))))\n    return false;\n\n  // TODO: Add support for addlike etc.\n  if (LHS->getOpcode() != RHS->getOpcode())\n    return false;\n\n  Value *X, *Y, *Z, *W;\n  bool IsCommutative = false;\n  CmpPredicate Pred = CmpInst::BAD_ICMP_PREDICATE;\n  if (match(LHS, m_BinOp(m_Value(X), m_Value(Y))) &&\n      match(RHS, m_BinOp(m_Value(Z), m_Value(W)))) {\n    auto *BO = cast<BinaryOperator>(LHS);\n    // Don't introduce poison into div/rem.\n    if (llvm::is_contained(OldMask, PoisonMaskElem) && BO->isIntDivRem())\n      return false;\n    IsCommutative = BinaryOperator::isCommutative(BO->getOpcode());\n  } else if (match(LHS, m_Cmp(Pred, m_Value(X), m_Value(Y))) &&\n             match(RHS, m_SpecificCmp(Pred, m_Value(Z), m_Value(W)))) {\n    IsCommutative = cast<CmpInst>(LHS)->isCommutative();\n  } else\n    return false;\n\n  auto *ShuffleDstTy = dyn_cast<FixedVectorType>(I.getType());\n  auto *BinResTy = dyn_cast<FixedVectorType>(LHS->getType());\n  auto *BinOpTy = dyn_cast<FixedVectorType>(X->getType());\n  if (!ShuffleDstTy || !BinResTy || !BinOpTy || X->getType() != Z->getType())\n    return false;\n\n  unsigned NumSrcElts = BinOpTy->getNumElements();\n\n  // If we have something like \"add X, Y\" and \"add Z, X\", swap ops to match.\n  if (IsCommutative && X != Z && Y != W && (X == W || Y == Z))\n    std::swap(X, Y);\n\n  auto ConvertToUnary = [NumSrcElts](int &M) {\n    if (M >= (int)NumSrcElts)\n      M -= NumSrcElts;\n  };\n\n  SmallVector<int> NewMask0(OldMask);\n  TargetTransformInfo::ShuffleKind SK0 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (X == Z) {\n    llvm::for_each(NewMask0, ConvertToUnary);\n    SK0 = TargetTransformInfo::SK_PermuteSingleSrc;\n    Z = PoisonValue::get(BinOpTy);\n  }\n\n  SmallVector<int> NewMask1(OldMask);\n  TargetTransformInfo::ShuffleKind SK1 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (Y == W) {\n    llvm::for_each(NewMask1, ConvertToUnary);\n    SK1 = TargetTransformInfo::SK_PermuteSingleSrc;\n    W = PoisonValue::get(BinOpTy);\n  }\n\n  // Try to replace a binop with a shuffle if the shuffle is not costly.\n  InstructionCost OldCost =\n      TTI.getInstructionCost(LHS, CostKind) +\n      TTI.getInstructionCost(RHS, CostKind) +\n      TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc, BinResTy,\n                         OldMask, CostKind, 0, nullptr, {LHS, RHS}, &I);\n\n  InstructionCost NewCost =\n      TTI.getShuffleCost(SK0, BinOpTy, NewMask0, CostKind, 0, nullptr, {X, Z}) +\n      TTI.getShuffleCost(SK1, BinOpTy, NewMask1, CostKind, 0, nullptr, {Y, W});\n\n  if (Pred == CmpInst::BAD_ICMP_PREDICATE) {\n    NewCost +=\n        TTI.getArithmeticInstrCost(LHS->getOpcode(), ShuffleDstTy, CostKind);\n  } else {\n    auto *ShuffleCmpTy =\n        FixedVectorType::get(BinOpTy->getElementType(), ShuffleDstTy);\n    NewCost += TTI.getCmpSelInstrCost(LHS->getOpcode(), ShuffleCmpTy,\n                                      ShuffleDstTy, Pred, CostKind);\n  }\n\n  LLVM_DEBUG(dbgs() << \"Found a shuffle feeding two binops: \" << I\n                    << \"\\n  OldCost: \" << OldCost << \" vs NewCost: \" << NewCost\n                    << \"\\n\");\n\n  // If either shuffle will constant fold away, then fold for the same cost as\n  // we will reduce the instruction count.\n  bool ReducedInstCount = (isa<Constant>(X) && isa<Constant>(Z)) ||\n                          (isa<Constant>(Y) && isa<Constant>(W));\n  if (ReducedInstCount ? (NewCost > OldCost) : (NewCost >= OldCost))\n    return false;\n\n  Value *Shuf0 = Builder.CreateShuffleVector(X, Z, NewMask0);\n  Value *Shuf1 = Builder.CreateShuffleVector(Y, W, NewMask1);\n  Value *NewBO = Pred == CmpInst::BAD_ICMP_PREDICATE\n                     ? Builder.CreateBinOp(\n                           cast<BinaryOperator>(LHS)->getOpcode(), Shuf0, Shuf1)\n                     : Builder.CreateCmp(Pred, Shuf0, Shuf1);\n\n  // Intersect flags from the old binops.\n  if (auto *NewInst = dyn_cast<Instruction>(NewBO)) {\n    NewInst->copyIRFlags(LHS);\n    NewInst->andIRFlags(RHS);\n  }\n\n  Worklist.pushValue(Shuf0);\n  Worklist.pushValue(Shuf1);\n  replaceValue(I, *NewBO);\n  return true;\n}\n\n/// Try to convert \"shuffle (castop), (castop)\" with a shared castop operand\n/// into \"castop (shuffle)\".\nbool VectorCombine::foldShuffleOfCastops(Instruction &I) {\n  Value *V0, *V1;\n  ArrayRef<int> OldMask;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll\",\n  \"args\": \"opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2\",\n  \"name\": \"PR121110\",\n  \"body\": \"define <2 x i1> @PR121110() {\\n  %ugt = icmp samesign ugt <2 x i32> zeroinitializer, zeroinitializer\\n  %sgt = icmp sgt <2 x i32> zeroinitializer, <i32 6, i32 -4>\\n  %res = shufflevector <2 x i1> %ugt, <2 x i1> %sgt, <2 x i32> <i32 0, i32 3>\\n  ret <2 x i1> %res\\n}\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"target datalayout = \\\"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\\\"\\ntarget triple = \\\"x86_64-unknown-unknown\\\"\\ndefine <2 x i1> @PR121110() {\\n  %ugt = icmp samesign ugt <2 x i32> zeroinitializer, zeroinitializer\\n  %sgt = icmp sgt <2 x i32> zeroinitializer, <i32 6, i32 -4>\\n  %res = shufflevector <2 x i1> %ugt, <2 x i1> %sgt, <2 x i32> <i32 0, i32 3>\\n  ret <2 x i1> %res\\n}\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\ntarget datalayout = \\\"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\\\"\\ntarget triple = \\\"x86_64-unknown-unknown\\\"\\n\\ndefine <2 x i1> @PR121110() #0 {\\n  ret <2 x i1> zeroinitializer\\n}\\n\\nattributes #0 = { \\\"target-features\\\"=\\\"+sse2\\\" }\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine <2 x i1> @PR121110() {\\n#0:\\n  %ugt = icmp samesign ugt <2 x i32> { 0, 0 }, { 0, 0 }\\n  %sgt = icmp sgt <2 x i32> { 0, 0 }, { 6, 4294967292 }\\n  %res = shufflevector <2 x i1> %ugt, <2 x i1> %sgt, 0, 3\\n  ret <2 x i1> %res\\n}\\n=>\\ndefine <2 x i1> @PR121110() {\\n#0:\\n  ret <2 x i1> { 0, 0 }\\n}\\nTransformation doesn't verify!\\n\\nERROR: Value mismatch\\n\\nExample:\\n\\nSource:\\n<2 x i1> %ugt = < #x0 (0), #x0 (0) >\\n<2 x i1> %sgt = < #x0 (0), #x1 (1) >\\n<2 x i1> %res = < #x0 (0), #x1 (1) >\\n\\nTarget:\\nSource value: < #x0 (0), #x1 (1) >\\nTarget value: < #x0 (0), #x0 (0) >\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n  return true;\n}\n\n/// Try to convert \"shuffle (binop), (binop)\" into \"binop (shuffle), (shuffle)\".\n/// Try to convert \"shuffle (cmpop), (cmpop)\" into \"cmpop (shuffle), (shuffle)\".\nbool VectorCombine::foldShuffleOfBinops(Instruction &I) {\n  ArrayRef<int> OldMask;\n  Instruction *LHS, *RHS;\n  if (!match(&I, m_Shuffle(m_OneUse(m_Instruction(LHS)),\n                           m_OneUse(m_Instruction(RHS)), m_Mask(OldMask))))\n    return false;\n\n  // TODO: Add support for addlike etc.\n  if (LHS->getOpcode() != RHS->getOpcode())\n    return false;\n\n  Value *X, *Y, *Z, *W;\n  bool IsCommutative = false;\n  CmpPredicate Pred = CmpInst::BAD_ICMP_PREDICATE;\n  if (match(LHS, m_BinOp(m_Value(X), m_Value(Y))) &&\n      match(RHS, m_BinOp(m_Value(Z), m_Value(W)))) {\n    auto *BO = cast<BinaryOperator>(LHS);\n    // Don't introduce poison into div/rem.\n    if (llvm::is_contained(OldMask, PoisonMaskElem) && BO->isIntDivRem())\n      return false;\n    IsCommutative = BinaryOperator::isCommutative(BO->getOpcode());\n  } else if (match(LHS, m_Cmp(Pred, m_Value(X), m_Value(Y))) &&\n             match(RHS, m_SpecificCmp(Pred, m_Value(Z), m_Value(W)))) {\n    IsCommutative = cast<CmpInst>(LHS)->isCommutative();\n  } else\n    return false;\n\n  auto *ShuffleDstTy = dyn_cast<FixedVectorType>(I.getType());\n  auto *BinResTy = dyn_cast<FixedVectorType>(LHS->getType());\n  auto *BinOpTy = dyn_cast<FixedVectorType>(X->getType());\n  if (!ShuffleDstTy || !BinResTy || !BinOpTy || X->getType() != Z->getType())\n    return false;\n\n  unsigned NumSrcElts = BinOpTy->getNumElements();\n\n  // If we have something like \"add X, Y\" and \"add Z, X\", swap ops to match.\n  if (IsCommutative && X != Z && Y != W && (X == W || Y == Z))\n    std::swap(X, Y);\n\n  auto ConvertToUnary = [NumSrcElts](int &M) {\n    if (M >= (int)NumSrcElts)\n      M -= NumSrcElts;\n  };\n\n  SmallVector<int> NewMask0(OldMask);\n  TargetTransformInfo::ShuffleKind SK0 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (X == Z) {\n    llvm::for_each(NewMask0, ConvertToUnary);\n    SK0 = TargetTransformInfo::SK_PermuteSingleSrc;\n    Z = PoisonValue::get(BinOpTy);\n  }\n\n  SmallVector<int> NewMask1(OldMask);\n  TargetTransformInfo::ShuffleKind SK1 = TargetTransformInfo::SK_PermuteTwoSrc;\n  if (Y == W) {\n    llvm::for_each(NewMask1, ConvertToUnary);\n    SK1 = TargetTransformInfo::SK_PermuteSingleSrc;\n    W = PoisonValue::get(BinOpTy);\n  }\n\n  // Don't fold if the shuffle mask selects from both sources and the binop\n  // operands are not the same.\n  if (SK0 == TargetTransformInfo::SK_PermuteTwoSrc && X != Z)\n    return false;\n  if (SK1 == TargetTransformInfo::SK_PermuteTwoSrc && Y != W)\n    return false;\n\n  // Try to replace a binop with a shuffle if the shuffle is not costly.\n  InstructionCost OldCost =\n      TTI.getInstructionCost(LHS, CostKind) +\n      TTI.getInstructionCost(RHS, CostKind) +\n      TTI.getShuffleCost(TargetTransformInfo::SK_PermuteTwoSrc, BinResTy,\n                         OldMask, CostKind, 0, nullptr, {LHS, RHS}, &I);\n\n  InstructionCost NewCost =\n      TTI.getShuffleCost(SK0, BinOpTy, NewMask0, CostKind, 0, nullptr, {X, Z}) +\n      TTI.getShuffleCost(SK1, BinOpTy, NewMask1, CostKind, 0, nullptr, {Y, W});\n\n  if (Pred == CmpInst::BAD_ICMP_PREDICATE) {\n    NewCost +=\n        TTI.getArithmeticInstrCost(LHS->getOpcode(), ShuffleDstTy, CostKind);\n  } else {\n    auto *ShuffleCmpTy =\n        FixedVectorType::get(BinOpTy->getElementType(), ShuffleDstTy);\n    NewCost += TTI.getCmpSelInstrCost(LHS->getOpcode(), ShuffleCmpTy,\n                                      ShuffleDstTy, Pred, CostKind);\n  }\n\n  LLVM_DEBUG(dbgs() << \"Found a shuffle feeding two binops: \" << I\n                    << \"\\n  OldCost: \" << OldCost << \" vs NewCost: \" << NewCost\n                    << \"\\n\");\n\n  // If either shuffle will constant fold away, then fold for the same cost as\n  // we will reduce the instruction count.\n  bool ReducedInstCount = (isa<Constant>(X) && isa<Constant>(Z)) ||\n                          (isa<Constant>(Y) && isa<Constant>(W));\n  if (ReducedInstCount ? (NewCost > OldCost) : (NewCost >= OldCost))\n    return false;\n\n  Value *Shuf0 = Builder.CreateShuffleVector(X, Z, NewMask0);\n  Value *Shuf1 = Builder.CreateShuffleVector(Y, W, NewMask1);\n  Value *NewBO = Pred == CmpInst::BAD_ICMP_PREDICATE\n                     ? Builder.CreateBinOp(\n                           cast<BinaryOperator>(LHS)->getOpcode(), Shuf0, Shuf1)\n                     : Builder.CreateCmp(Pred, Shuf0, Shuf1);\n\n  // Intersect flags from the old binops.\n  if (auto *NewInst = dyn_cast<Instruction>(NewBO)) {\n    NewInst->copyIRFlags(LHS);\n    NewInst->andIRFlags(RHS);\n  }\n\n  Worklist.pushValue(Shuf0);\n  Worklist.pushValue(Shuf1);\n  replaceValue(I, *NewBO);\n  return true;\n}\n\n/// Try to convert \"shuffle (castop), (castop)\" with a shared castop operand\n/// into \"castop (shuffle)\".\nbool VectorCombine::foldShuffleOfCastops(Instruction &I) {\n  Value *V0, *V1;\n  ArrayRef<int> OldMask;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCommand '['/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/llvm-lit', '--no-progress-bar', '-j', '80', '--max-failures', '1', '--order', 'lexical', '-sv', '/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine']' returned non-zero exit status 1.\n-- Testing: 54 tests, 54 workers --\nFAIL: LLVM :: Transforms/VectorCombine/X86/shuffle-of-cmps.ll (23 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/shuffle-of-cmps.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2 | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll --check-prefixes=CHECK,SSE,SSE2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll --check-prefixes=CHECK,SSE,SSE2\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:48:14: error: SSE2-NEXT: expected string not found in input\n; SSE2-NEXT: [[TMP1:%.*]] = shufflevector <2 x i64> [[X]], <2 x i64> [[Z]], <2 x i32> <i32 1, i32 3>\n             ^\n<stdin>:16:98: note: scanning from here\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:16:98: note: with \"X\" equal to \"%x\"\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:16:98: note: with \"Z\" equal to \"%z\"\ndefine <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 {\n                                                                                                 ^\n<stdin>:19:2: note: possible intended match here\n %s = shufflevector <2 x i1> %c0, <2 x i1> %c1, <2 x i32> <i32 1, i32 3>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:90:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:24:99: note: scanning from here\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:24:99: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:24:99: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 {\n                                                                                                  ^\n<stdin>:27:2: note: possible intended match here\n %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:108:14: error: SSE2-NEXT: expected string not found in input\n; SSE2-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[X]], <4 x float> poison, <4 x i32> <i32 poison, i32 poison, i32 2, i32 0>\n             ^\n<stdin>:32:91: note: scanning from here\ndefine <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                          ^\n<stdin>:32:91: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                          ^\n<stdin>:35:2: note: possible intended match here\n %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll:142:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[Z]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n            ^\n<stdin>:40:96: note: scanning from here\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:40:96: note: with \"Y\" equal to \"%y\"\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:40:96: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                               ^\n<stdin>:43:2: note: possible intended match here\n %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-cmps.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            .\n            .\n            .\n           11:  %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \n           12:  %r = sext <4 x i1> %s to <4 x i32> \n           13:  ret <4 x i32> %r \n           14: } \n           15:  \n           16: define <2 x i64> @shuf_icmp_eq_v2i64(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z, <2 x i64> %w) #0 { \nnext:48'0                                                                                                       X error: no match found\nnext:48'1                                                                                                         with \"X\" equal to \"%x\"\nnext:48'2                                                                                                         with \"Z\" equal to \"%z\"\n           17:  %c0 = icmp eq <2 x i64> %x, %y \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           18:  %c1 = icmp eq <2 x i64> %z, %w \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           19:  %s = shufflevector <2 x i1> %c0, <2 x i1> %c1, <2 x i32> <i32 1, i32 3> \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:48'3       ?                                                                        possible intended match\n           20:  %r = sext <2 x i1> %s to <2 x i64> \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           21:  ret <2 x i64> %r \nnext:48'0      ~~~~~~~~~~~~~~~~~~\n           22: } \nnext:48'0      ~~\n           23:  \nnext:48'0      ~\n           24: define <4 x i32> @shuf_icmp_ugt_v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %w) #0 { \nnext:48'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:90'0                                                                                                        X error: no match found\nnext:90'1                                                                                                          with \"X\" equal to \"%x\"\nnext:90'2                                                                                                          with \"Z\" equal to \"%z\"\n           25:  %c0 = icmp ugt <4 x i32> %x, %y \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           26:  %c1 = icmp ugt <4 x i32> %z, %w \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           27:  %s = shufflevector <4 x i1> %c0, <4 x i1> %c1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:90'3       ?                                                                                      possible intended match\n           28:  %r = sext <4 x i1> %s to <4 x i32> \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           29:  ret <4 x i32> %r \nnext:90'0      ~~~~~~~~~~~~~~~~~~\n           30: } \nnext:90'0      ~~\n           31:  \nnext:90'0      ~\n           32: define <4 x i32> @shuf_fcmp_oeq_v4i32(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:90'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:108'0                                                                                               X error: no match found\nnext:108'1                                                                                                 with \"X\" equal to \"%x\"\n           33:  %b0 = fcmp oeq <4 x float> %x, %y \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           34:  %b1 = fcmp oeq <4 x float> %x, %z \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           35:  %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0> \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:108'2      ?                                                                                                possible intended match\n           36:  %r = sext <4 x i1> %s to <4 x i32> \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           37:  ret <4 x i32> %r \nnext:108'0     ~~~~~~~~~~~~~~~~~~\n           38: } \nnext:108'0     ~~\n           39:  \nnext:108'0     ~\n           40: define <4 x i32> @shuf_fcmp_one_v4f32_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:108'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:142'0                                                                                                    X error: no match found\nnext:142'1                                                                                                      with \"Y\" equal to \"%y\"\nnext:142'2                                                                                                      with \"Z\" equal to \"%z\"\n           41:  %b0 = fcmp one <4 x float> %x, %y \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           42:  %b1 = fcmp one <4 x float> %z, %x \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           43:  %s = shufflevector <4 x i1> %b0, <4 x i1> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7> \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:142'3      ?                                                                                      possible intended match\n           44:  %r = sext <4 x i1> %s to <4 x i32> \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           45:  ret <4 x i32> %r \nnext:142'0     ~~~~~~~~~~~~~~~~~~\n           46: } \nnext:142'0     ~~\n           47:  \nnext:142'0     ~\n           48: define <4 x i32> @shuf_icmp_sgt_v4i32_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:142'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nFAIL: LLVM :: Transforms/VectorCombine/X86/shuffle-of-binops.ll (34 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/shuffle-of-binops.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2 | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll --check-prefixes=CHECK,SSE\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll --check-prefixes=CHECK,SSE\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:12:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP2:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:8:92: note: scanning from here\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:8:92: note: with \"X\" equal to \"%x\"\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:8:92: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                           ^\n<stdin>:11:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:44:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[Z]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n            ^\n<stdin>:22:97: note: scanning from here\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:22:97: note: with \"Y\" equal to \"%y\"\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:22:97: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 {\n                                                                                                ^\n<stdin>:25:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:83:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> poison, <4 x i32> <i32 3, i32 1, i32 1, i32 2>\n              ^\n<stdin>:36:83: note: scanning from here\ndefine <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                  ^\n<stdin>:36:83: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                  ^\n<stdin>:39:2: note: possible intended match here\n %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 1, i32 1, i32 6>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:99:13: error: SSE-NEXT: expected string not found in input\n; SSE-NEXT: [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> [[Z]], <4 x i32> <i32 3, i32 2, i32 2, i32 5>\n            ^\n<stdin>:43:88: note: scanning from here\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:43:88: note: with \"X\" equal to \"%x\"\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:43:88: note: with \"Z\" equal to \"%z\"\ndefine <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 {\n                                                                                       ^\n<stdin>:46:5: note: possible intended match here\n %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 2, i32 2, i32 5>\n    ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll:190:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP1:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n              ^\n<stdin>:80:118: note: scanning from here\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:80:118: note: with \"X\" equal to \"%x\"\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:80:118: note: with \"Z\" equal to \"%z\"\ndefine <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 {\n                                                                                                                     ^\n<stdin>:83:5: note: possible intended match here\n %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n    ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/shuffle-of-binops.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            1: ; ModuleID = '<stdin>' \n            2: source_filename = \"<stdin>\" \n            3: target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\" \n            4: target triple = \"x86_64-unknown-unknown\" \n            5:  \n            6: declare void @use(<4 x i32>) #0 \n            7:  \n            8: define <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:12'0                                                                                                 X error: no match found\nnext:12'1                                                                                                   with \"X\" equal to \"%x\"\nnext:12'2                                                                                                   with \"Z\" equal to \"%z\"\n            9:  %b0 = fdiv fast <4 x float> %x, %y \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           10:  %b1 = fdiv arcp <4 x float> %z, %y \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           11:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:12'3          ?                                                                                         possible intended match\n           12:  ret <4 x float> %r \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~\n           13: } \nnext:12'0      ~~\n           14:  \nnext:12'0      ~\n           15: define <4 x i32> @shuf_add_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:12'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           16:  %b0 = add <4 x i32> %x, %y \n           17:  %b1 = add <4 x i32> %x, %z \n           18:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0> \n           19:  ret <4 x i32> %r \n           20: } \n           21:  \n           22: define <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) #0 { \nnext:44'0                                                                                                      X error: no match found\nnext:44'1                                                                                                        with \"Y\" equal to \"%y\"\nnext:44'2                                                                                                        with \"Z\" equal to \"%z\"\n           23:  %b0 = fmul <4 x float> %x, %y \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           24:  %b1 = fmul <4 x float> %z, %x \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           25:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7> \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:44'3          ?                                                                                         possible intended match\n           26:  ret <4 x float> %r \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~\n           27: } \nnext:44'0      ~~\n           28:  \nnext:44'0      ~\n           29: define <2 x i64> @shuf_and_v2i64_yy_swap(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) #0 { \nnext:44'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           30:  %b0 = and <2 x i64> %x, %y \n           31:  %b1 = and <2 x i64> %y, %z \n           32:  %r = shufflevector <2 x i64> %b0, <2 x i64> %b1, <2 x i32> <i32 3, i32 0> \n           33:  ret <2 x i64> %r \n           34: } \n           35:  \n           36: define <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:83'0                                                                                        X error: no match found\nnext:83'1                                                                                          with \"X\" equal to \"%x\"\n           37:  %b0 = shl <4 x i32> %x, %y \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           38:  %b1 = shl <4 x i32> %x, %z \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           39:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 1, i32 1, i32 6> \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:83'2       ?                                                                                        possible intended match\n           40:  ret <4 x i32> %r \nnext:83'0      ~~~~~~~~~~~~~~~~~~\n           41: } \nnext:83'0      ~~\n           42:  \nnext:83'0      ~\n           43: define <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) #0 { \nnext:83'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:99'0                                                                                             X error: no match found\nnext:99'1                                                                                               with \"X\" equal to \"%x\"\nnext:99'2                                                                                               with \"Z\" equal to \"%z\"\n           44:  %b0 = shl <4 x i32> %x, %y \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           45:  %b1 = shl <4 x i32> %z, %x \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           46:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 2, i32 2, i32 5> \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:99'3          ?                                                                                     possible intended match\n           47:  ret <4 x i32> %r \nnext:99'0      ~~~~~~~~~~~~~~~~~~\n           48: } \nnext:99'0      ~~\n           49:  \nnext:99'0      ~\n           50: define <2 x i64> @shuf_sub_add_v2i64_yy(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) #0 { \nnext:99'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           51:  %b0 = sub <2 x i64> %x, %y \n            .\n            .\n            .\n           75:  call void @use(<4 x i32> %b1) \n           76:  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \n           77:  ret <4 x i32> %r \n           78: } \n           79:  \n           80: define <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) #0 { \nnext:190'0                                                                                                                          X error: no match found\nnext:190'1                                                                                                                            with \"X\" equal to \"%x\"\nnext:190'2                                                                                                                            with \"Z\" equal to \"%z\"\n           81:  %b0 = fdiv <4 x float> %x, %y \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           82:  %b1 = fdiv <4 x float> %z, %w \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           83:  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7> \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:190'3         ?                                                                                         possible intended match\n           84:  ret <4 x float> %r \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~\n           85: } \nnext:190'0     ~~\n           86:  \nnext:190'0     ~\n           87: define <16 x i16> @shuf_and_v16i16_yy_expensive_shuf(<16 x i16> %x, <16 x i16> %y, <16 x i16> %z) #0 { \nnext:190'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           88:  %b0 = and <16 x i16> %x, %y \n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nFAIL: LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll (53 of 54)\n******************** TEST 'LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll' FAILED ********************\nExit Code: 1\n\nCommand Output (stderr):\n--\nRUN: at line 2: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt < /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll -passes=vector-combine -S -mtriple=x86_64-- -mcpu=x86-64    | /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll --check-prefixes=CHECK,SSE\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -passes=vector-combine -S -mtriple=x86_64-- -mcpu=x86-64\n+ /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/FileCheck /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll --check-prefixes=CHECK,SSE\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll:86:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP3:%.*]] = shufflevector <32 x i8> [[TMP2]], <32 x i8> [[TMP1]], <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63>\n              ^\n<stdin>:39:308: note: scanning from here\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:39:308: note: with \"TMP2\" equal to \"%2\"\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:39:308: note: with \"TMP1\" equal to \"%1\"\n %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n                                                                                                                                                                                                                                                                                                                   ^\n<stdin>:40:2: note: possible intended match here\n %3 = shufflevector <32 x i8> %1, <32 x i8> %2, <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63>\n ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll:116:15: error: CHECK-NEXT: expected string not found in input\n; CHECK-NEXT: [[TMP3:%.*]] = shufflevector <8 x i32> [[TMP2]], <8 x i32> [[TMP1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n              ^\n<stdin>:48:117: note: scanning from here\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:48:117: note: with \"TMP2\" equal to \"%2\"\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:48:117: note: with \"TMP1\" equal to \"%1\"\n %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n                                                                                                                    ^\n<stdin>:49:2: note: possible intended match here\n %3 = shufflevector <8 x i32> %1, <8 x i32> %2, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n ^\n\nInput file: <stdin>\nCheck file: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/test/Transforms/VectorCombine/X86/concat-boolmasks.ll\n\n-dump-input=help explains the following input dump.\n\nInput was:\n<<<<<<\n            .\n            .\n            .\n           34:  ret i64 %or \n           35: } \n           36:  \n           37: define i64 @movmsk_i64_v64i8_v16i8(<16 x i8> %v0, <16 x i8> %v1, <16 x i8> %v2, <16 x i8> %v3) #0 { \n           38:  %1 = shufflevector <16 x i8> %v3, <16 x i8> %v2, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31> \n           39:  %2 = shufflevector <16 x i8> %v1, <16 x i8> %v0, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31> \nnext:86'0                                                                                                                                                                                                                                                                                                                         X error: no match found\nnext:86'1                                                                                                                                                                                                                                                                                                                           with \"TMP2\" equal to \"%2\"\nnext:86'2                                                                                                                                                                                                                                                                                                                           with \"TMP1\" equal to \"%1\"\n           40:  %3 = shufflevector <32 x i8> %1, <32 x i8> %2, <64 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 58, i32 59, i32 60, i32 61, i32 62, i32 63> \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:86'3       ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 possible intended match\n           41:  %4 = icmp slt <64 x i8> %3, zeroinitializer \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           42:  %or = bitcast <64 x i1> %4 to i64 \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           43:  ret i64 %or \nnext:86'0      ~~~~~~~~~~~~~\n           44: } \nnext:86'0      ~~\n           45:  \nnext:86'0      ~\n           46: define i64 @movmsk_i64_v32i32_v4i32(<4 x i32> %v0, <4 x i32> %v1, <4 x i32> %v2, <4 x i32> %v3) #0 { \nnext:86'0      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           47:  %1 = shufflevector <4 x i32> %v3, <4 x i32> %v2, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7> \n           48:  %2 = shufflevector <4 x i32> %v1, <4 x i32> %v0, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7> \nnext:116'0                                                                                                                         X error: no match found\nnext:116'1                                                                                                                           with \"TMP2\" equal to \"%2\"\nnext:116'2                                                                                                                           with \"TMP1\" equal to \"%1\"\n           49:  %3 = shufflevector <8 x i32> %1, <8 x i32> %2, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnext:116'3      ?                                                                                                                                                                                 possible intended match\n           50:  %4 = icmp slt <16 x i32> %3, zeroinitializer \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           51:  %5 = bitcast <16 x i1> %4 to i16 \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           52:  %or = zext i16 %5 to i64 \nnext:116'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           53:  ret i64 %or \nnext:116'0     ~~~~~~~~~~~~~\n           54: } \nnext:116'0     ~~\n            .\n            .\n            .\n>>>>>>\n\n--\n\n********************\nwarning: reached maximum number of test failures, skipping remaining tests\n********************\nFailed Tests (1):\n  LLVM :: Transforms/VectorCombine/X86/concat-boolmasks.ll\n\n\nTesting Time: 1.15s\n\nTotal Discovered Tests: 54\n  Skipped    : 33 (61.11%)\n  Unsupported:  2 (3.70%)\n  Passed     : 18 (33.33%)\n  Failed     :  1 (1.85%)\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    }
  ]
}