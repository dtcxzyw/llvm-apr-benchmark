{
  "wall_time": 46.38868260383606,
  "knowledge": [
    [
      "base_model",
      "2023-12-31+0000"
    ],
    [
      "hint:bug_functions",
      "2025-01-01+0000"
    ],
    [
      "hint:components",
      "2025-01-01+0000"
    ],
    [
      "hint:issue",
      "2025-01-01+0000"
    ],
    [
      "hint:line_level_bug_locations",
      "2025-01-01+0000"
    ]
  ],
  "build_count": 5,
  "build_failure_count": 0,
  "fast_check_count": 1,
  "full_check_count": 4,
  "fast_check_pass": true,
  "full_check_pass": true,
  "patch": "diff --git a/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp b/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp\nindex cdb2c11ef046..cf82e1c59bb2 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp\n@@ -2655,7 +2655,7 @@ Instruction *InstCombinerImpl::visitCallInst(CallInst &CI) {\n   }\n   case Intrinsic::copysign: {\n     Value *Mag = II->getArgOperand(0), *Sign = II->getArgOperand(1);\n-    if (std::optional<bool> KnownSignBit = computeKnownFPSignBit(\n+if (std::optional<bool> KnownSignBit = computeKnownFPSignBit(\n             Sign, /*Depth=*/0, getSimplifyQuery().getWithInstruction(II))) {\n       if (*KnownSignBit) {\n         // If we know that the sign argument is negative, reduce to FNABS:\n@@ -2673,8 +2673,12 @@ Instruction *InstCombinerImpl::visitCallInst(CallInst &CI) {\n     // Propagate sign argument through nested calls:\n     // copysign Mag, (copysign ?, X) --> copysign Mag, X\n     Value *X;\n-    if (match(Sign, m_Intrinsic<Intrinsic::copysign>(m_Value(), m_Value(X))))\n-      return replaceOperand(*II, 1, X);\n+    if (match(Sign, m_Intrinsic<Intrinsic::copysign>(m_Value(), m_Value(X)))) {\n+      CallInst *NewCI = cast<CallInst>(replaceOperand(*II, 1, X));\n+      NewCI->copyIRFlags(II, /*IncludeWrapFlags=*/false);\n+      NewCI->andIRFlags(Sign);\n+      return NewCI;\n+    }\n \n     // Clear sign-bit of constant magnitude:\n     // copysign -MagC, X --> copysign MagC, X\n",
  "log": [
    {
      "role": "system",
      "content": "You are an LLVM maintainer.\nYou are fixing a middle-end bug in the LLVM project.\nPlease answer with the code directly. Do not include any additional information.\n"
    },
    {
      "role": "user",
      "content": "This is a miscompilation bug in InstCombine.\nIssue title: [InstCombine] FMF flags should not be propagated\nIssue body: Alive2: https://alive2.llvm.org/ce/z/ajCxTh\n```\ndefine float @src1(float noundef %x, float noundef %y, float noundef %z) {\n  %s = call float @llvm.copysign.f32(float %y, float %z)\n  %r = call nnan float @llvm.copysign.f32(float %x, float %s)\n  ret float %r\n}\n\ndefine float @tgt1(float noundef %x, float noundef %y, float noundef %z) {\n  %r = call nnan float @llvm.copysign.f32(float %x, float %z)\n  ret float %r\n}\n\ndefine float @src2(float noundef %x, float noundef %y, float noundef %z) {\n  %s = call float @llvm.copysign.f32(float %y, float %z)\n  %r = call ninf float @llvm.copysign.f32(float %x, float %s)\n  ret float %r\n}\n\ndefine float @tgt2(float noundef %x, float noundef %y, float noundef %z) {\n  %r = call ninf float @llvm.copysign.f32(float %x, float %z)\n  ret float %r\n}\n\ndefine float @src3(float noundef %x, float noundef %y, float noundef %z) {\n  %s = call float @llvm.copysign.f32(float %y, float %z)\n  %r = call nsz float @llvm.copysign.f32(float %x, float %s)\n  ret float %r\n}\n\ndefine float @tgt3(float noundef %x, float noundef %y, float noundef %z) {\n  %r = call nsz float @llvm.copysign.f32(float %x, float %z)\n  ret float %r\n}\n```\n\nDetailed information:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/copysign.ll\",\n  \"args\": \"opt -S -passes=instcombine < %s\",\n  \"name\": \"copysign_sign_arg_mixed\",\n  \"body\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %z)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %s = copysign ninf nsz float %y, %z\\n  %r = copysign nnan nsz float %x, %s\\n  ret float %r\\n}\\n=>\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %r = copysign nnan nsz float %x, %z\\n  ret float %r\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\nfloat %x = #x00000000 (+0.0)\\nfloat %y = #x00000000 (+0.0)\\nfloat %z = #x7f800004 (SNaN)\\n\\nSource:\\nfloat %s = #x00000000 (+0.0)\\nfloat %r = #x00000000 (+0.0)\\n\\nTarget:\\nfloat %r = poison\\nSource value: #x00000000 (+0.0)\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease modify the following code in llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:InstCombinerImpl::visitCallInst to fix the bug:\n```\n    if (std::optional<bool> KnownSignBit = computeKnownFPSignBit(\n            Sign, /*Depth=*/0, getSimplifyQuery().getWithInstruction(II))) {\n      if (*KnownSignBit) {\n        // If we know that the sign argument is negative, reduce to FNABS:\n        // copysign Mag, -Sign --> fneg (fabs Mag)\n        Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n        return replaceInstUsesWith(*II, Builder.CreateFNegFMF(Fabs, II));\n      }\n\n      // If we know that the sign argument is positive, reduce to FABS:\n      // copysign Mag, +Sign --> fabs Mag\n      Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n      return replaceInstUsesWith(*II, Fabs);\n    }\n\n    // Propagate sign argument through nested calls:\n    // copysign Mag, (copysign ?, X) --> copysign Mag, X\n    Value *X;\n    if (match(Sign, m_Intrinsic<Intrinsic::copysign>(m_Value(), m_Value(X))))\n      return replaceOperand(*II, 1, X);\n\n    // Clear sign-bit of constant magnitude:\n    // copysign -MagC, X --> copysign MagC, X\n    // TODO: Support constant folding for fabs\n    const APFloat *MagC;\n    if (match(Mag, m_APFloat(MagC)) && MagC->isNegative()) {\n      APFloat PosMagC = *MagC;\n      PosMagC.clearSign();\n      return replaceOperand(*II, 0, ConstantFP::get(Mag->getType(), PosMagC));\n    }\n\n    // Peek through changes of magnitude's sign-bit. This call rewrites those:\n    // copysign (fabs X), Sign --> copysign X, Sign\n    // copysign (fneg X), Sign --> copysign X, Sign\n    if (match(Mag, m_FAbs(m_Value(X))) || match(Mag, m_FNeg(m_Value(X))))\n      return replaceOperand(*II, 0, X);\n\n    break;\n```\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n    if (std::optional<bool> KnownSignBit = computeKnownFPSignBit(\n            Sign, /*Depth=*/0, getSimplifyQuery().getWithInstruction(II))) {\n      if (*KnownSignBit) {\n        // If we know that the sign argument is negative, reduce to FNABS:\n        // copysign Mag, -Sign --> fneg (fabs Mag)\n        Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n        return replaceInstUsesWith(*II, Builder.CreateFNegFMF(Fabs, II));\n      }\n\n      // If we know that the sign argument is positive, reduce to FABS:\n      // copysign Mag, +Sign --> fabs Mag\n      Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n      return replaceInstUsesWith(*II, Fabs);\n    }\n\n    // Propagate sign argument through nested calls:\n    // copysign Mag, (copysign ?, X) --> copysign Mag, X\n    Value *X;\n    if (match(Sign, m_Intrinsic<Intrinsic::copysign>(m_Value(), m_Value(X)))) {\n      CallInst *NewCI = cast<CallInst>(replaceOperand(*II, 1, X));\n      NewCI->copyFastMathFlags(II);\n      return NewCI;\n    }\n\n    // Clear sign-bit of constant magnitude:\n    // copysign -MagC, X --> copysign MagC, X\n    // TODO: Support constant folding for fabs\n    const APFloat *MagC;\n    if (match(Mag, m_APFloat(MagC)) && MagC->isNegative()) {\n      APFloat PosMagC = *MagC;\n      PosMagC.clearSign();\n      return replaceOperand(*II, 0, ConstantFP::get(Mag->getType(), PosMagC));\n    }\n\n    // Peek through changes of magnitude's sign-bit. This call rewrites those:\n    // copysign (fabs X), Sign --> copysign X, Sign\n    // copysign (fneg X), Sign --> copysign X, Sign\n    if (match(Mag, m_FAbs(m_Value(X))) || match(Mag, m_FNeg(m_Value(X))))\n      return replaceOperand(*II, 0, X);\n\n    break;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/copysign.ll\",\n  \"args\": \"opt -S -passes=instcombine < %s\",\n  \"name\": \"copysign_sign_arg_mixed\",\n  \"body\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %z)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %s = copysign ninf nsz float %y, %z\\n  %r = copysign nnan nsz float %x, %s\\n  ret float %r\\n}\\n=>\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %r = copysign nnan nsz float %x, %z\\n  ret float %r\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\nfloat %x = #x00000000 (+0.0)\\nfloat %y = #x00000000 (+0.0)\\nfloat %z = #x7f800004 (SNaN)\\n\\nSource:\\nfloat %s = #x00000000 (+0.0)\\nfloat %r = #x00000000 (+0.0)\\n\\nTarget:\\nfloat %r = poison\\nSource value: #x00000000 (+0.0)\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n    if (std::optional<bool> KnownSignBit = computeKnownFPSignBit(\n            Sign, /*Depth=*/0, getSimplifyQuery().getWithInstruction(II))) {\n      if (*KnownSignBit) {\n        // If we know that the sign argument is negative, reduce to FNABS:\n        // copysign Mag, -Sign --> fneg (fabs Mag)\n        Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n        return replaceInstUsesWith(*II, Builder.CreateFNegFMF(Fabs, II));\n      }\n\n      // If we know that the sign argument is positive, reduce to FABS:\n      // copysign Mag, +Sign --> fabs Mag\n      Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n      return replaceInstUsesWith(*II, Fabs);\n    }\n\n    // Propagate sign argument through nested calls:\n    // copysign Mag, (copysign ?, X) --> copysign Mag, X\n    Value *X;\n    if (match(Sign, m_Intrinsic<Intrinsic::copysign>(m_Value(), m_Value(X)))) {\n      CallInst *NewCI = cast<CallInst>(replaceOperand(*II, 1, X));\n      NewCI->copyIRFlags(II);\n      return NewCI;\n    }\n\n    // Clear sign-bit of constant magnitude:\n    // copysign -MagC, X --> copysign MagC, X\n    // TODO: Support constant folding for fabs\n    const APFloat *MagC;\n    if (match(Mag, m_APFloat(MagC)) && MagC->isNegative()) {\n      APFloat PosMagC = *MagC;\n      PosMagC.clearSign();\n      return replaceOperand(*II, 0, ConstantFP::get(Mag->getType(), PosMagC));\n    }\n\n    // Peek through changes of magnitude's sign-bit. This call rewrites those:\n    // copysign (fabs X), Sign --> copysign X, Sign\n    // copysign (fneg X), Sign --> copysign X, Sign\n    if (match(Mag, m_FAbs(m_Value(X))) || match(Mag, m_FNeg(m_Value(X))))\n      return replaceOperand(*II, 0, X);\n\n    break;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/copysign.ll\",\n  \"args\": \"opt -S -passes=instcombine < %s\",\n  \"name\": \"copysign_sign_arg_mixed\",\n  \"body\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %z)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %s = copysign ninf nsz float %y, %z\\n  %r = copysign nnan nsz float %x, %s\\n  ret float %r\\n}\\n=>\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %r = copysign nnan nsz float %x, %z\\n  ret float %r\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\nfloat %x = #x00000000 (+0.0)\\nfloat %y = #x00000000 (+0.0)\\nfloat %z = #x7f800004 (SNaN)\\n\\nSource:\\nfloat %s = #x00000000 (+0.0)\\nfloat %r = #x00000000 (+0.0)\\n\\nTarget:\\nfloat %r = poison\\nSource value: #x00000000 (+0.0)\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n    if (std::optional<bool> KnownSignBit = computeKnownFPSignBit(\n            Sign, /*Depth=*/0, getSimplifyQuery().getWithInstruction(II))) {\n      if (*KnownSignBit) {\n        // If we know that the sign argument is negative, reduce to FNABS:\n        // copysign Mag, -Sign --> fneg (fabs Mag)\n        Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n        return replaceInstUsesWith(*II, Builder.CreateFNegFMF(Fabs, II));\n      }\n\n      // If we know that the sign argument is positive, reduce to FABS:\n      // copysign Mag, +Sign --> fabs Mag\n      Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n      return replaceInstUsesWith(*II, Fabs);\n    }\n\n    // Propagate sign argument through nested calls:\n    // copysign Mag, (copysign ?, X) --> copysign Mag, X\n    Value *X;\n    if (match(Sign, m_Intrinsic<Intrinsic::copysign>(m_Value(), m_Value(X)))) {\n      CallInst *NewCI = cast<CallInst>(replaceOperand(*II, 1, X));\n      NewCI->copyIRFlags(II, /*IncludeWrapFlags=*/false);\n      return NewCI;\n    }\n\n    // Clear sign-bit of constant magnitude:\n    // copysign -MagC, X --> copysign MagC, X\n    // TODO: Support constant folding for fabs\n    const APFloat *MagC;\n    if (match(Mag, m_APFloat(MagC)) && MagC->isNegative()) {\n      APFloat PosMagC = *MagC;\n      PosMagC.clearSign();\n      return replaceOperand(*II, 0, ConstantFP::get(Mag->getType(), PosMagC));\n    }\n\n    // Peek through changes of magnitude's sign-bit. This call rewrites those:\n    // copysign (fabs X), Sign --> copysign X, Sign\n    // copysign (fneg X), Sign --> copysign X, Sign\n    if (match(Mag, m_FAbs(m_Value(X))) || match(Mag, m_FNeg(m_Value(X))))\n      return replaceOperand(*II, 0, X);\n\n    break;\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n{\n  \"file\": \"llvm/test/Transforms/InstCombine/copysign.ll\",\n  \"args\": \"opt -S -passes=instcombine < %s\",\n  \"name\": \"copysign_sign_arg_mixed\",\n  \"body\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n  \"result\": false,\n  \"log\": {\n    \"src\": \"; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %s = call ninf nsz float @llvm.copysign.f32(float %y, float %z)\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %s)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"tgt\": \"; ModuleID = '<stdin>'\\nsource_filename = \\\"<stdin>\\\"\\n\\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\\ndeclare float @llvm.copysign.f32(float, float) #0\\n\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n  %r = call nnan nsz float @llvm.copysign.f32(float %x, float %z)\\n  ret float %r\\n}\\n\\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\\n\",\n    \"log\": \"\\n----------------------------------------\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %s = copysign ninf nsz float %y, %z\\n  %r = copysign nnan nsz float %x, %s\\n  ret float %r\\n}\\n=>\\ndefine float @copysign_sign_arg_mixed(float %x, float %y, float %z) {\\n#0:\\n  %r = copysign nnan nsz float %x, %z\\n  ret float %r\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\nfloat %x = #x00000000 (+0.0)\\nfloat %y = #x00000000 (+0.0)\\nfloat %z = #x7f800004 (SNaN)\\n\\nSource:\\nfloat %s = #x00000000 (+0.0)\\nfloat %r = #x00000000 (+0.0)\\n\\nTarget:\\nfloat %r = poison\\nSource value: #x00000000 (+0.0)\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\",\n    \"opt_stderr\": \"\"\n  }\n}\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n    if (std::optional<bool> KnownSignBit = computeKnownFPSignBit(\n            Sign, /*Depth=*/0, getSimplifyQuery().getWithInstruction(II))) {\n      if (*KnownSignBit) {\n        // If we know that the sign argument is negative, reduce to FNABS:\n        // copysign Mag, -Sign --> fneg (fabs Mag)\n        Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n        return replaceInstUsesWith(*II, Builder.CreateFNegFMF(Fabs, II));\n      }\n\n      // If we know that the sign argument is positive, reduce to FABS:\n      // copysign Mag, +Sign --> fabs Mag\n      Value *Fabs = Builder.CreateUnaryIntrinsic(Intrinsic::fabs, Mag, II);\n      return replaceInstUsesWith(*II, Fabs);\n    }\n\n    // Propagate sign argument through nested calls:\n    // copysign Mag, (copysign ?, X) --> copysign Mag, X\n    Value *X;\n    if (match(Sign, m_Intrinsic<Intrinsic::copysign>(m_Value(), m_Value(X)))) {\n      CallInst *NewCI = cast<CallInst>(replaceOperand(*II, 1, X));\n      NewCI->copyIRFlags(II, /*IncludeWrapFlags=*/false);\n      NewCI->andIRFlags(Sign);\n      return NewCI;\n    }\n\n    // Clear sign-bit of constant magnitude:\n    // copysign -MagC, X --> copysign MagC, X\n    // TODO: Support constant folding for fabs\n    const APFloat *MagC;\n    if (match(Mag, m_APFloat(MagC)) && MagC->isNegative()) {\n      APFloat PosMagC = *MagC;\n      PosMagC.clearSign();\n      return replaceOperand(*II, 0, ConstantFP::get(Mag->getType(), PosMagC));\n    }\n\n    // Peek through changes of magnitude's sign-bit. This call rewrites those:\n    // copysign (fabs X), Sign --> copysign X, Sign\n    // copysign (fneg X), Sign --> copysign X, Sign\n    if (match(Mag, m_FAbs(m_Value(X))) || match(Mag, m_FNeg(m_Value(X))))\n      return replaceOperand(*II, 0, X);\n\n    break;\n```"
    }
  ]
}