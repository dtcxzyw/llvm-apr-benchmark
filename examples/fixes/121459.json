{
  "wall_time": 85.64710140228271,
  "knowledge": [
    [
      "base_model",
      "2023-12-31+0000"
    ],
    [
      "hint:bug_functions",
      "2025-01-02+0000"
    ],
    [
      "hint:components",
      "2025-01-02+0000"
    ],
    [
      "hint:issue",
      "2025-01-02+0000"
    ],
    [
      "hint:line_level_bug_locations",
      "2025-01-02+0000"
    ]
  ],
  "build_count": 5,
  "build_failure_count": 2,
  "fast_check_count": 1,
  "full_check_count": 4,
  "fast_check_pass": false,
  "full_check_pass": false,
  "patch": "diff --git a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp\nindex 934156f04f7f..57ad53009408 100644\n--- a/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp\n@@ -2764,7 +2764,7 @@ static bool shouldCanonicalizeGEPToPtrAdd(GetElementPtrInst &GEP) {\n   return PtrOpGep && PtrOpGep->hasAllConstantIndices() &&\n          any_of(GEP.indices(), [](Value *V) {\n            const APInt *C;\n-           return match(V, m_APInt(C)) && !C->isZero();\n+return match(V, m_APInt(C)) && !C->isZero();\n          });\n }\n \n@@ -2862,9 +2862,22 @@ static Instruction *foldGEPOfPhi(GetElementPtrInst &GEP, PHINode *PN,\n                                 PN->getNumOperands());\n     }\n \n-    for (auto &I : PN->operands())\n-      NewPN->addIncoming(cast<GEPOperator>(I)->getOperand(DI),\n-                         PN->getIncomingBlock(I));\n+    for (auto &I : PN->operands()) {\n+      auto *GEPOp = cast<GEPOperator>(I);\n+      // Only propagate inbounds if all incoming GEPs are inbounds\n+      if (!GEPOp->isInBounds())\n+        NewGEP->setIsInBounds(false);\n+      // Only propagate nuw if all incoming GEPs are nuw\n+      if (!GEPOp->hasNoUnsignedWrap())\n+        NewGEP->setHasNoUnsignedWrap(false);\n+      NewPN->addIncoming(GEPOp->getOperand(DI), PN->getIncomingBlock(I));\n+    }\n+\n+    NewGEP->setOperand(DI, NewPN);\n+  }\n+\n+  return NewGEP;\n+}\n \n     NewGEP->setOperand(DI, NewPN);\n   }\n",
  "log": [
    {
      "role": "system",
      "content": "You are an LLVM maintainer.\nYou are fixing a middle-end bug in the LLVM project.\nPlease answer with the code directly. Do not include any additional information.\n"
    },
    {
      "role": "user",
      "content": "This is a miscompilation bug in InstCombine.\nIssue title: [InstCombine] GEPNoWrapFlags is propagated incorrectly\nIssue body: Alive2: https://alive2.llvm.org/ce/z/3ME7S7\n```\ndefine ptr @src(i1 %c, ptr %p) {\n  br i1 %c, label %if, label %else\n\nif:\n  %gep1 = getelementptr inbounds i32, ptr %p, i64 1\n  br label %join\n\nelse:\n  %gep2 = getelementptr i64, ptr %p, i64 2\n  br label %join\n\njoin:\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\n  %gep = getelementptr i32, ptr %phi, i64 1\n  ret ptr %gep\n}\n```\n```\n\n----------------------------------------\ndefine ptr @src(i1 %c, ptr %p) {\n#0:\n  br i1 %c, label %if, label %else\n\nelse:\n  %gep2 = gep ptr %p, 8 x i64 2\n  br label %join\n\nif:\n  %gep1 = gep inbounds ptr %p, 4 x i64 1\n  br label %join\n\njoin:\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\n  %gep = gep ptr %phi, 4 x i64 1\n  ret ptr %gep\n}\n=>\ndefine ptr @src(i1 %c, ptr %p) {\n#0:\n  br i1 %c, label %if, label %else\n\nelse:\n  br label %join\n\nif:\n  br label %join\n\njoin:\n  %#1 = phi i64 [ 4, %if ], [ 16, %else ]\n  %#2 = gep inbounds nuw ptr %p, 1 x i64 %#1\n  %gep = gep ptr %#2, 1 x i64 4\n  ret ptr %gep\n}\nTransformation doesn't verify!\n\nERROR: Target is more poisonous than source\n\nExample:\ni1 %c = #x0 (0)\nptr %p = null\n\nSource:\n  >> Jump to %else\nptr %gep2 = pointer(non-local, block_id=0, offset=16) / Address=#x0000000000000010\n  >> Jump to %join\nptr %phi = pointer(non-local, block_id=0, offset=16) / Address=#x0000000000000010\nptr %gep = pointer(non-local, block_id=0, offset=20) / Address=#x0000000000000014\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\tsize: 0\talign: 1\talloc type: 0\talive: false\taddress: 0\nBlock 1 >\tsize: 0\talign: 1\talloc type: 0\talive: true\taddress: 1\n\nTarget:\n  >> Jump to %else\n  >> Jump to %join\ni64 %#1 = #x0000000000000010 (16)\nptr %#2 = poison\nptr %gep = poison\nSource value: pointer(non-local, block_id=0, offset=20) / Address=#x0000000000000014\nTarget value: poison\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors\n```\n\nDetailed information:\n[{'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_different_type', 'body': 'define ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i64, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': True, 'log': {'src': 'define ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i64, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %1 = phi i64 [ 4, %if ], [ 16, %else ]\\n  %2 = getelementptr i8, ptr %p, i64 %1\\n  %gep = getelementptr i8, ptr %2, i64 4\\n  ret ptr %gep\\n}\\n', 'log': '\\n----------------------------------------\\ndefine ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  %gep2 = gep ptr %p, 8 x i64 2\\n  br label %join\\n\\nif:\\n  %gep1 = gep ptr %p, 4 x i64 1\\n  br label %join\\n\\njoin:\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = gep ptr %phi, 4 x i64 1\\n  ret ptr %gep\\n}\\n=>\\ndefine ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  br label %join\\n\\nif:\\n  br label %join\\n\\njoin:\\n  %#1 = phi i64 [ 4, %if ], [ 16, %else ]\\n  %#2 = gep ptr %p, 1 x i64 %#1\\n  %gep = gep ptr %#2, 1 x i64 4\\n  ret ptr %gep\\n}\\nTransformation seems to be correct!\\n\\nSummary:\\n  1 correct transformations\\n  0 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n', 'opt_stderr': ''}}, {'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_flags2', 'body': 'define ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr nuw i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr nuw i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': True, 'log': {'src': 'define ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr nuw i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr nuw i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %2 = getelementptr nuw i8, ptr %p, i64 %1\\n  %gep = getelementptr i8, ptr %2, i64 4\\n  ret ptr %gep\\n}\\n', 'log': '\\n----------------------------------------\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  %gep2 = gep nuw ptr %p, 4 x i64 2\\n  br label %join\\n\\nif:\\n  %gep1 = gep nuw ptr %p, 4 x i64 1\\n  br label %join\\n\\njoin:\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = gep ptr %phi, 4 x i64 1\\n  ret ptr %gep\\n}\\n=>\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  br label %join\\n\\nif:\\n  br label %join\\n\\njoin:\\n  %#1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %#2 = gep nuw ptr %p, 1 x i64 %#1\\n  %gep = gep ptr %#2, 1 x i64 4\\n  ret ptr %gep\\n}\\nTransformation seems to be correct!\\n\\nSummary:\\n  1 correct transformations\\n  0 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n', 'opt_stderr': ''}}, {'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_flags1', 'body': 'define ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr inbounds i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': False, 'log': {'src': 'define ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr inbounds i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %2 = getelementptr inbounds nuw i8, ptr %p, i64 %1\\n  %gep = getelementptr i8, ptr %2, i64 4\\n  ret ptr %gep\\n}\\n', 'log': \"\\n----------------------------------------\\ndefine ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  %gep2 = gep ptr %p, 4 x i64 2\\n  br label %join\\n\\nif:\\n  %gep1 = gep inbounds ptr %p, 4 x i64 1\\n  br label %join\\n\\njoin:\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = gep ptr %phi, 4 x i64 1\\n  ret ptr %gep\\n}\\n=>\\ndefine ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  br label %join\\n\\nif:\\n  br label %join\\n\\njoin:\\n  %#1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %#2 = gep inbounds nuw ptr %p, 1 x i64 %#1\\n  %gep = gep ptr %#2, 1 x i64 4\\n  ret ptr %gep\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\ni1 %c = #x0 (0)\\nptr %p = null\\n\\nSource:\\n  >> Jump to %else\\nptr %gep2 = pointer(non-local, block_id=0, offset=8) / Address=#x0000000000000008\\n  >> Jump to %join\\nptr %phi = pointer(non-local, block_id=0, offset=8) / Address=#x0000000000000008\\nptr %gep = pointer(non-local, block_id=0, offset=12) / Address=#x000000000000000c\\n\\nSOURCE MEMORY STATE\\n===================\\nNON-LOCAL BLOCKS:\\nBlock 0 >\\tsize: 0\\talign: 1\\talloc type: 0\\talive: false\\taddress: 0\\nBlock 1 >\\tsize: 0\\talign: 1\\talloc type: 0\\talive: true\\taddress: 1\\n\\nTarget:\\n  >> Jump to %else\\n  >> Jump to %join\\ni64 %#1 = #x0000000000000008 (8)\\nptr %#2 = poison\\nptr %gep = poison\\nSource value: pointer(non-local, block_id=0, offset=12) / Address=#x000000000000000c\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\", 'opt_stderr': ''}}]\nPlease modify the following code in llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:foldGEPOfPhi to fix the bug:\n```\n           return match(V, m_APInt(C)) && !C->isZero();\n         });\n}\n\nstatic Instruction *foldGEPOfPhi(GetElementPtrInst &GEP, PHINode *PN,\n                                 IRBuilderBase &Builder) {\n  auto *Op1 = dyn_cast<GetElementPtrInst>(PN->getOperand(0));\n  if (!Op1)\n    return nullptr;\n\n  // Don't fold a GEP into itself through a PHI node. This can only happen\n  // through the back-edge of a loop. Folding a GEP into itself means that\n  // the value of the previous iteration needs to be stored in the meantime,\n  // thus requiring an additional register variable to be live, but not\n  // actually achieving anything (the GEP still needs to be executed once per\n  // loop iteration).\n  if (Op1 == &GEP)\n    return nullptr;\n\n  int DI = -1;\n\n  for (auto I = PN->op_begin()+1, E = PN->op_end(); I !=E; ++I) {\n    auto *Op2 = dyn_cast<GetElementPtrInst>(*I);\n    if (!Op2 || Op1->getNumOperands() != Op2->getNumOperands() ||\n        Op1->getSourceElementType() != Op2->getSourceElementType())\n      return nullptr;\n\n    // As for Op1 above, don't try to fold a GEP into itself.\n    if (Op2 == &GEP)\n      return nullptr;\n\n    // Keep track of the type as we walk the GEP.\n    Type *CurTy = nullptr;\n\n    for (unsigned J = 0, F = Op1->getNumOperands(); J != F; ++J) {\n      if (Op1->getOperand(J)->getType() != Op2->getOperand(J)->getType())\n        return nullptr;\n\n      if (Op1->getOperand(J) != Op2->getOperand(J)) {\n        if (DI == -1) {\n          // We have not seen any differences yet in the GEPs feeding the\n          // PHI yet, so we record this one if it is allowed to be a\n          // variable.\n\n          // The first two arguments can vary for any GEP, the rest have to be\n          // static for struct slots\n          if (J > 1) {\n            assert(CurTy && \"No current type?\");\n            if (CurTy->isStructTy())\n              return nullptr;\n          }\n\n          DI = J;\n        } else {\n          // The GEP is different by more than one input. While this could be\n          // extended to support GEPs that vary by more than one variable it\n          // doesn't make sense since it greatly increases the complexity and\n          // would result in an R+R+R addressing mode which no backend\n          // directly supports and would need to be broken into several\n          // simpler instructions anyway.\n          return nullptr;\n        }\n      }\n\n      // Sink down a layer of the type for the next iteration.\n      if (J > 0) {\n        if (J == 1) {\n          CurTy = Op1->getSourceElementType();\n        } else {\n          CurTy =\n              GetElementPtrInst::getTypeAtIndex(CurTy, Op1->getOperand(J));\n        }\n      }\n    }\n  }\n\n  // If not all GEPs are identical we'll have to create a new PHI node.\n  // Check that the old PHI node has only one use so that it will get\n  // removed.\n  if (DI != -1 && !PN->hasOneUse())\n    return nullptr;\n\n  auto *NewGEP = cast<GetElementPtrInst>(Op1->clone());\n  if (DI == -1) {\n    // All the GEPs feeding the PHI are identical. Clone one down into our\n    // BB so that it can be merged with the current GEP.\n  } else {\n    // All the GEPs feeding the PHI differ at a single offset. Clone a GEP\n    // into the current block so it can be merged, and create a new PHI to\n    // set that index.\n    PHINode *NewPN;\n    {\n      IRBuilderBase::InsertPointGuard Guard(Builder);\n      Builder.SetInsertPoint(PN);\n      NewPN = Builder.CreatePHI(Op1->getOperand(DI)->getType(),\n                                PN->getNumOperands());\n    }\n\n    for (auto &I : PN->operands())\n      NewPN->addIncoming(cast<GEPOperator>(I)->getOperand(DI),\n                         PN->getIncomingBlock(I));\n```\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n           return match(V, m_APInt(C)) && !C->isZero();\n         });\n}\n\nstatic Instruction *foldGEPOfPhi(GetElementPtrInst &GEP, PHINode *PN,\n                                 IRBuilderBase &Builder) {\n  auto *Op1 = dyn_cast<GetElementPtrInst>(PN->getOperand(0));\n  if (!Op1)\n    return nullptr;\n\n  // Don't fold a GEP into itself through a PHI node. This can only happen\n  // through the back-edge of a loop. Folding a GEP into itself means that\n  // the value of the previous iteration needs to be stored in the meantime,\n  // thus requiring an additional register variable to be live, but not\n  // actually achieving anything (the GEP still needs to be executed once per\n  // loop iteration).\n  if (Op1 == &GEP)\n    return nullptr;\n\n  int DI = -1;\n\n  for (auto I = PN->op_begin()+1, E = PN->op_end(); I !=E; ++I) {\n    auto *Op2 = dyn_cast<GetElementPtrInst>(*I);\n    if (!Op2 || Op1->getNumOperands() != Op2->getNumOperands() ||\n        Op1->getSourceElementType() != Op2->getSourceElementType())\n      return nullptr;\n\n    // As for Op1 above, don't try to fold a GEP into itself.\n    if (Op2 == &GEP)\n      return nullptr;\n\n    // Keep track of the type as we walk the GEP.\n    Type *CurTy = nullptr;\n\n    for (unsigned J = 0, F = Op1->getNumOperands(); J != F; ++J) {\n      if (Op1->getOperand(J)->getType() != Op2->getOperand(J)->getType())\n        return nullptr;\n\n      if (Op1->getOperand(J) != Op2->getOperand(J)) {\n        if (DI == -1) {\n          // We have not seen any differences yet in the GEPs feeding the\n          // PHI yet, so we record this one if it is allowed to be a\n          // variable.\n\n          // The first two arguments can vary for any GEP, the rest have to be\n          // static for struct slots\n          if (J > 1) {\n            assert(CurTy && \"No current type?\");\n            if (CurTy->isStructTy())\n              return nullptr;\n          }\n\n          DI = J;\n        } else {\n          // The GEP is different by more than one input. While this could be\n          // extended to support GEPs that vary by more than one variable it\n          // doesn't make sense since it greatly increases the complexity and\n          // would result in an R+R+R addressing mode which no backend\n          // directly supports and would need to be broken into several\n          // simpler instructions anyway.\n          return nullptr;\n        }\n      }\n\n      // Sink down a layer of the type for the next iteration.\n      if (J > 0) {\n        if (J == 1) {\n          CurTy = Op1->getSourceElementType();\n        } else {\n          CurTy =\n              GetElementPtrInst::getTypeAtIndex(CurTy, Op1->getOperand(J));\n        }\n      }\n    }\n  }\n\n  // If not all GEPs are identical we'll have to create a new PHI node.\n  // Check that the old PHI node has only one use so that it will get\n  // removed.\n  if (DI != -1 && !PN->hasOneUse())\n    return nullptr;\n\n  auto *NewGEP = cast<GetElementPtrInst>(Op1->clone());\n  if (DI == -1) {\n    // All the GEPs feeding the PHI are identical. Clone one down into our\n    // BB so that it can be merged with the current GEP.\n  } else {\n    // All the GEPs feeding the PHI differ at a single offset. Clone a GEP\n    // into the current block so it can be merged, and create a new PHI to\n    // set that index.\n    PHINode *NewPN;\n    {\n      IRBuilderBase::InsertPointGuard Guard(Builder);\n      Builder.SetInsertPoint(PN);\n      NewPN = Builder.CreatePHI(Op1->getOperand(DI)->getType(),\n                                PN->getNumOperands());\n    }\n\n    for (auto &I : PN->operands()) {\n      auto *GEPOp = cast<GEPOperator>(I);\n      // Only propagate inbounds if all incoming GEPs are inbounds\n      if (!GEPOp->isInBounds())\n        NewGEP->setIsInBounds(false);\n      NewPN->addIncoming(GEPOp->getOperand(DI), PN->getIncomingBlock(I));\n    }\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n[{'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_different_type', 'body': 'define ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i64, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': True, 'log': {'src': 'define ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i64, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %1 = phi i64 [ 4, %if ], [ 16, %else ]\\n  %2 = getelementptr i8, ptr %p, i64 %1\\n  %gep = getelementptr i8, ptr %2, i64 4\\n  ret ptr %gep\\n}\\n', 'log': '\\n----------------------------------------\\ndefine ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  %gep2 = gep ptr %p, 8 x i64 2\\n  br label %join\\n\\nif:\\n  %gep1 = gep ptr %p, 4 x i64 1\\n  br label %join\\n\\njoin:\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = gep ptr %phi, 4 x i64 1\\n  ret ptr %gep\\n}\\n=>\\ndefine ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  br label %join\\n\\nif:\\n  br label %join\\n\\njoin:\\n  %#1 = phi i64 [ 4, %if ], [ 16, %else ]\\n  %#2 = gep ptr %p, 1 x i64 %#1\\n  %gep = gep ptr %#2, 1 x i64 4\\n  ret ptr %gep\\n}\\nTransformation seems to be correct!\\n\\nSummary:\\n  1 correct transformations\\n  0 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n', 'opt_stderr': ''}}, {'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_flags2', 'body': 'define ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr nuw i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr nuw i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': True, 'log': {'src': 'define ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr nuw i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr nuw i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %2 = getelementptr nuw i8, ptr %p, i64 %1\\n  %gep = getelementptr i8, ptr %2, i64 4\\n  ret ptr %gep\\n}\\n', 'log': '\\n----------------------------------------\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  %gep2 = gep nuw ptr %p, 4 x i64 2\\n  br label %join\\n\\nif:\\n  %gep1 = gep nuw ptr %p, 4 x i64 1\\n  br label %join\\n\\njoin:\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = gep ptr %phi, 4 x i64 1\\n  ret ptr %gep\\n}\\n=>\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  br label %join\\n\\nif:\\n  br label %join\\n\\njoin:\\n  %#1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %#2 = gep nuw ptr %p, 1 x i64 %#1\\n  %gep = gep ptr %#2, 1 x i64 4\\n  ret ptr %gep\\n}\\nTransformation seems to be correct!\\n\\nSummary:\\n  1 correct transformations\\n  0 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n', 'opt_stderr': ''}}, {'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_flags1', 'body': 'define ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr inbounds i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': False, 'log': {'src': 'define ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr inbounds i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %2 = getelementptr nusw nuw i8, ptr %p, i64 %1\\n  %gep = getelementptr i8, ptr %2, i64 4\\n  ret ptr %gep\\n}\\n', 'log': \"\\n----------------------------------------\\ndefine ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  %gep2 = gep ptr %p, 4 x i64 2\\n  br label %join\\n\\nif:\\n  %gep1 = gep inbounds ptr %p, 4 x i64 1\\n  br label %join\\n\\njoin:\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = gep ptr %phi, 4 x i64 1\\n  ret ptr %gep\\n}\\n=>\\ndefine ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  br label %join\\n\\nif:\\n  br label %join\\n\\njoin:\\n  %#1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %#2 = gep nusw nuw ptr %p, 1 x i64 %#1\\n  %gep = gep ptr %#2, 1 x i64 4\\n  ret ptr %gep\\n}\\nTransformation doesn't verify!\\n\\nERROR: Target is more poisonous than source\\n\\nExample:\\ni1 %c = #x0 (0)\\nptr %p = pointer(non-local, block_id=1, offset=0) / Address=#xfffffffffffffff8\\n\\nSource:\\n  >> Jump to %else\\nptr %gep2 = pointer(non-local, block_id=1, offset=8) / Address=#x0000000000000000\\n  >> Jump to %join\\nptr %phi = pointer(non-local, block_id=1, offset=8) / Address=#x0000000000000000\\nptr %gep = pointer(non-local, block_id=1, offset=12) / Address=#x0000000000000004\\n\\nSOURCE MEMORY STATE\\n===================\\nNON-LOCAL BLOCKS:\\nBlock 0 >\\tsize: 0\\talign: 1\\talloc type: 0\\talive: false\\taddress: 0\\nBlock 1 >\\tsize: 0\\talign: 1\\talloc type: 0\\talive: true\\taddress: 18446744073709551608\\n\\nTarget:\\n  >> Jump to %else\\n  >> Jump to %join\\ni64 %#1 = #x0000000000000008 (8)\\nptr %#2 = poison\\nptr %gep = poison\\nSource value: pointer(non-local, block_id=1, offset=12) / Address=#x0000000000000004\\nTarget value: poison\\n\\nSummary:\\n  0 correct transformations\\n  1 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n\", 'opt_stderr': ''}}]\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n           return match(V, m_APInt(C)) && !C->isZero();\n         });\n}\n\nstatic Instruction *foldGEPOfPhi(GetElementPtrInst &GEP, PHINode *PN,\n                                 IRBuilderBase &Builder) {\n  auto *Op1 = dyn_cast<GetElementPtrInst>(PN->getOperand(0));\n  if (!Op1)\n    return nullptr;\n\n  // Don't fold a GEP into itself through a PHI node. This can only happen\n  // through the back-edge of a loop. Folding a GEP into itself means that\n  // the value of the previous iteration needs to be stored in the meantime,\n  // thus requiring an additional register variable to be live, but not\n  // actually achieving anything (the GEP still needs to be executed once per\n  // loop iteration).\n  if (Op1 == &GEP)\n    return nullptr;\n\n  int DI = -1;\n\n  for (auto I = PN->op_begin()+1, E = PN->op_end(); I !=E; ++I) {\n    auto *Op2 = dyn_cast<GetElementPtrInst>(*I);\n    if (!Op2 || Op1->getNumOperands() != Op2->getNumOperands() ||\n        Op1->getSourceElementType() != Op2->getSourceElementType())\n      return nullptr;\n\n    // As for Op1 above, don't try to fold a GEP into itself.\n    if (Op2 == &GEP)\n      return nullptr;\n\n    // Keep track of the type as we walk the GEP.\n    Type *CurTy = nullptr;\n\n    for (unsigned J = 0, F = Op1->getNumOperands(); J != F; ++J) {\n      if (Op1->getOperand(J)->getType() != Op2->getOperand(J)->getType())\n        return nullptr;\n\n      if (Op1->getOperand(J) != Op2->getOperand(J)) {\n        if (DI == -1) {\n          // We have not seen any differences yet in the GEPs feeding the\n          // PHI yet, so we record this one if it is allowed to be a\n          // variable.\n\n          // The first two arguments can vary for any GEP, the rest have to be\n          // static for struct slots\n          if (J > 1) {\n            assert(CurTy && \"No current type?\");\n            if (CurTy->isStructTy())\n              return nullptr;\n          }\n\n          DI = J;\n        } else {\n          // The GEP is different by more than one input. While this could be\n          // extended to support GEPs that vary by more than one variable it\n          // doesn't make sense since it greatly increases the complexity and\n          // would result in an R+R+R addressing mode which no backend\n          // directly supports and would need to be broken into several\n          // simpler instructions anyway.\n          return nullptr;\n        }\n      }\n\n      // Sink down a layer of the type for the next iteration.\n      if (J > 0) {\n        if (J == 1) {\n          CurTy = Op1->getSourceElementType();\n        } else {\n          CurTy =\n              GetElementPtrInst::getTypeAtIndex(CurTy, Op1->getOperand(J));\n        }\n      }\n    }\n  }\n\n  // If not all GEPs are identical we'll have to create a new PHI node.\n  // Check that the old PHI node has only one use so that it will get\n  // removed.\n  if (DI != -1 && !PN->hasOneUse())\n    return nullptr;\n\n  auto *NewGEP = cast<GetElementPtrInst>(Op1->clone());\n  if (DI == -1) {\n    // All the GEPs feeding the PHI are identical. Clone one down into our\n    // BB so that it can be merged with the current GEP.\n  } else {\n    // All the GEPs feeding the PHI differ at a single offset. Clone a GEP\n    // into the current block so it can be merged, and create a new PHI to\n    // set that index.\n    PHINode *NewPN;\n    {\n      IRBuilderBase::InsertPointGuard Guard(Builder);\n      Builder.SetInsertPoint(PN);\n      NewPN = Builder.CreatePHI(Op1->getOperand(DI)->getType(),\n                                PN->getNumOperands());\n    }\n\n    for (auto &I : PN->operands()) {\n      auto *GEPOp = cast<GEPOperator>(I);\n      // Only propagate inbounds if all incoming GEPs are inbounds\n      if (!GEPOp->isInBounds())\n        NewGEP->setIsInBounds(false);\n      // Only propagate nuw if all incoming GEPs are nuw\n      if (!GEPOp->hasNoUnsignedWrap())\n        NewGEP->setHasNoUnsignedWrap(false);\n      // Only propagate nsw if all incoming GEPs are nsw\n      if (!GEPOp->hasNoSignedWrap())\n        NewGEP->setHasNoSignedWrap(false);\n      NewPN->addIncoming(GEPOp->getOperand(DI), PN->getIncomingBlock(I));\n    }\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCMake Deprecation Warning at /data/zyw/llvm-apr-benchmark/work/llvm-project/cmake/Modules/CMakePolicy.cmake:6 (cmake_policy):\n  The OLD behavior for policy CMP0116 will be removed from a future version\n  of CMake.\n\n  The cmake-policies(7) manual explains that the OLD behaviors of all\n  policies are deprecated and that a policy should be set to OLD only under\n  specific short-term circumstances.  Projects should be ported to the NEW\n  behavior and not rely on setting a policy to OLD.\nCall Stack (most recent call first):\n  CMakeLists.txt:8 (include)\n\n\n-- Could NOT find LibEdit (missing: LibEdit_INCLUDE_DIRS LibEdit_LIBRARIES) \n-- LLVM host triple: x86_64-unknown-linux-gnu\n-- Native target architecture is X86\n-- Threads enabled.\n-- Doxygen disabled.\n-- Ninja version: 1.10.0\n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- OCaml bindings disabled.\n-- LLVM default target triple: x86_64-unknown-linux-gnu\n-- Building with -fPIC\n-- Targeting X86\n-- Targeting RISCV\n-- Targeting AArch64\n-- Targeting SystemZ\n-- Targeting Hexagon\n-- Failed to find LLVM FileCheck\n-- Google Benchmark version: v0.0.0, normalized to 0.0.0\n-- Performing Test HAVE_GNU_POSIX_REGEX -- failed to compile\n-- Performing Test HAVE_POSIX_REGEX -- success\n-- Performing Test HAVE_STEADY_CLOCK -- success\n-- Performing Test HAVE_PTHREAD_AFFINITY -- failed to compile\n-- Configuring done (5.8s)\n-- Generating done (3.2s)\n-- Build files have been written to: /data/zyw/llvm-apr-benchmark/work/llvm-build\n\n[1/87] Building CXX object tools/llvm-config/CMakeFiles/llvm-config.dir/llvm-config.cpp.o\n[2/87] Linking CXX executable bin/llvm-config\n[3/87] Building CXX object lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o\nFAILED: lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o \nccache /usr/bin/c++ -DGTEST_HAS_RTTI=0 -DLLVM_EXPORTS -D_DEBUG -D_GLIBCXX_ASSERTIONS -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -I/data/zyw/llvm-apr-benchmark/work/llvm-build/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-build/include -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include -fPIC -fno-semantic-interposition -fvisibility-inlines-hidden -Werror=date-time -fno-lifetime-dse -w -fdiagnostics-color -ffunction-sections -fdata-sections -O2 -g -DNDEBUG -std=c++17 -fPIC  -fno-exceptions -funwind-tables -fno-rtti -UNDEBUG -MD -MT lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o -MF lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o.d -o lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o -c /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp: In function \u2018llvm::Instruction* foldGEPOfPhi(llvm::GetElementPtrInst&, llvm::PHINode*, llvm::IRBuilderBase&)\u2019:\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2874:19: error: \u2018class llvm::GEPOperator\u2019 has no member named \u2018hasNoSignedWrap\u2019; did you mean \u2018hasNoUnsignedWrap\u2019?\n 2874 |       if (!GEPOp->hasNoSignedWrap())\n      |                   ^~~~~~~~~~~~~~~\n      |                   hasNoUnsignedWrap\nninja: build stopped: subcommand failed.\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n           return match(V, m_APInt(C)) && !C->isZero();\n         });\n}\n\nstatic Instruction *foldGEPOfPhi(GetElementPtrInst &GEP, PHINode *PN,\n                                 IRBuilderBase &Builder) {\n  auto *Op1 = dyn_cast<GetElementPtrInst>(PN->getOperand(0));\n  if (!Op1)\n    return nullptr;\n\n  // Don't fold a GEP into itself through a PHI node. This can only happen\n  // through the back-edge of a loop. Folding a GEP into itself means that\n  // the value of the previous iteration needs to be stored in the meantime,\n  // thus requiring an additional register variable to be live, but not\n  // actually achieving anything (the GEP still needs to be executed once per\n  // loop iteration).\n  if (Op1 == &GEP)\n    return nullptr;\n\n  int DI = -1;\n\n  for (auto I = PN->op_begin()+1, E = PN->op_end(); I !=E; ++I) {\n    auto *Op2 = dyn_cast<GetElementPtrInst>(*I);\n    if (!Op2 || Op1->getNumOperands() != Op2->getNumOperands() ||\n        Op1->getSourceElementType() != Op2->getSourceElementType())\n      return nullptr;\n\n    // As for Op1 above, don't try to fold a GEP into itself.\n    if (Op2 == &GEP)\n      return nullptr;\n\n    // Keep track of the type as we walk the GEP.\n    Type *CurTy = nullptr;\n\n    for (unsigned J = 0, F = Op1->getNumOperands(); J != F; ++J) {\n      if (Op1->getOperand(J)->getType() != Op2->getOperand(J)->getType())\n        return nullptr;\n\n      if (Op1->getOperand(J) != Op2->getOperand(J)) {\n        if (DI == -1) {\n          // We have not seen any differences yet in the GEPs feeding the\n          // PHI yet, so we record this one if it is allowed to be a\n          // variable.\n\n          // The first two arguments can vary for any GEP, the rest have to be\n          // static for struct slots\n          if (J > 1) {\n            assert(CurTy && \"No current type?\");\n            if (CurTy->isStructTy())\n              return nullptr;\n          }\n\n          DI = J;\n        } else {\n          // The GEP is different by more than one input. While this could be\n          // extended to support GEPs that vary by more than one variable it\n          // doesn't make sense since it greatly increases the complexity and\n          // would result in an R+R+R addressing mode which no backend\n          // directly supports and would need to be broken into several\n          // simpler instructions anyway.\n          return nullptr;\n        }\n      }\n\n      // Sink down a layer of the type for the next iteration.\n      if (J > 0) {\n        if (J == 1) {\n          CurTy = Op1->getSourceElementType();\n        } else {\n          CurTy =\n              GetElementPtrInst::getTypeAtIndex(CurTy, Op1->getOperand(J));\n        }\n      }\n    }\n  }\n\n  // If not all GEPs are identical we'll have to create a new PHI node.\n  // Check that the old PHI node has only one use so that it will get\n  // removed.\n  if (DI != -1 && !PN->hasOneUse())\n    return nullptr;\n\n  auto *NewGEP = cast<GetElementPtrInst>(Op1->clone());\n  if (DI == -1) {\n    // All the GEPs feeding the PHI are identical. Clone one down into our\n    // BB so that it can be merged with the current GEP.\n  } else {\n    // All the GEPs feeding the PHI differ at a single offset. Clone a GEP\n    // into the current block so it can be merged, and create a new PHI to\n    // set that index.\n    PHINode *NewPN;\n    {\n      IRBuilderBase::InsertPointGuard Guard(Builder);\n      Builder.SetInsertPoint(PN);\n      NewPN = Builder.CreatePHI(Op1->getOperand(DI)->getType(),\n                                PN->getNumOperands());\n    }\n\n    for (auto &I : PN->operands()) {\n      auto *GEPOp = cast<GEPOperator>(I);\n      // Only propagate inbounds if all incoming GEPs are inbounds\n      if (!GEPOp->isInBounds())\n        NewGEP->setIsInBounds(false);\n      // Only propagate nuw if all incoming GEPs are nuw\n      if (!GEPOp->hasNoUnsignedWrap())\n        NewGEP->setHasNoUnsignedWrap(false);\n      NewPN->addIncoming(GEPOp->getOperand(DI), PN->getIncomingBlock(I));\n    }\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\n[{'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_different_type', 'body': 'define ptr @gep_of_phi_of_gep_different_type(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i64, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': False, 'log': 'Command \\'[\\'/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt\\', \\'-S\\', \\'-passes=instcombine<no-verify-fixpoint>\\', \\'-\\']\\' died with <Signals.SIGABRT: 6>.\\n\\nopt: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/Support/Casting.h:578: decltype(auto) llvm::cast(From*) [with To = llvm::TruncInst; From = llvm::Instruction]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"\\' failed.\\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\\nStack dump:\\n0.\\tProgram arguments: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -S -passes=instcombine<no-verify-fixpoint> -\\n1.\\tRunning pass \"function(instcombine<max-iterations=1;no-verify-fixpoint>)\" on module \"<stdin>\"\\n2.\\tRunning pass \"instcombine<max-iterations=1;no-verify-fixpoint>\" on function \"gep_of_phi_of_gep_different_type\"\\n #0 0x00007ffff7eb679c llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Support/Unix/Signals.inc:727:3\\n #1 0x00007ffff7eb4234 llvm::sys::RunSignalHandlers() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Support/Signals.cpp:105:20\\n #2 0x00007ffff7eb458e SignalHandler(int) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Support/Unix/Signals.inc:413:1\\n #3 0x00007ffff7b3c090 (/lib/x86_64-linux-gnu/libc.so.6+0x43090)\\n #4 0x00007ffff7b3c00b raise /build/glibc-LcI20x/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise.c:51:1\\n #5 0x00007ffff7b1b859 abort /build/glibc-LcI20x/glibc-2.31/stdlib/abort.c:81:7\\n #6 0x00007ffff7b1b729 get_sysdep_segment_value /build/glibc-LcI20x/glibc-2.31/intl/loadmsgcat.c:509:8\\n #7 0x00007ffff7b1b729 _nl_load_domain /build/glibc-LcI20x/glibc-2.31/intl/loadmsgcat.c:970:34\\n #8 0x00007ffff7b2cfd6 (/lib/x86_64-linux-gnu/libc.so.6+0x33fd6)\\n #9 0x00007ffff20fed05 (/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x213d05)\\n#10 0x00007ffff21001b6 (/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x2151b6)\\n#11 0x00007ffff3344cb2 foldGEPOfPhi /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2872:37\\n#12 0x00007ffff3344cb2 llvm::InstCombinerImpl::visitGetElementPtrInst(llvm::GetElementPtrInst&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2973:39\\n#13 0x00007ffff33503f1 llvm::InstCombinerImpl::run() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:5220:36\\n#14 0x00007ffff33513b3 combineInstructionsOverFunction(llvm::Function&, llvm::InstructionWorklist&, llvm::AAResults*, llvm::AssumptionCache&, llvm::TargetLibraryInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::OptimizationRemarkEmitter&, llvm::BlockFrequencyInfo*, llvm::BranchProbabilityInfo*, llvm::ProfileSummaryInfo*, llvm::InstCombineOptions const&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:5538:5\\n#15 0x00007ffff3351d5b llvm::InstCombinePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:5600:3\\n#16 0x00007ffff4bc30d6 llvm::detail::PassModel<llvm::Function, llvm::InstCombinePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:91:3\\n#17 0x00007ffff2196bcc llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerImpl.h:85:18\\n#18 0x00007ffff724e256 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:91:3\\n#19 0x00007ffff21970f9 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/IR/PassManager.cpp:129:41\\n#20 0x00007ffff724ec16 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:91:3\\n#21 0x00007ffff2195015 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerImpl.h:85:18\\n#22 0x00007ffff7fa61a2 llvm::SmallPtrSetImplBase::~SmallPtrSetImplBase() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:84:5\\n#23 0x00007ffff7fa61a2 llvm::SmallPtrSetImpl<llvm::AnalysisKey*>::~SmallPtrSetImpl() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:363:7\\n#24 0x00007ffff7fa61a2 llvm::SmallPtrSet<llvm::AnalysisKey*, 2u>::~SmallPtrSet() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:519:7\\n#25 0x00007ffff7fa61a2 llvm::PreservedAnalyses::~PreservedAnalyses() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/Analysis.h:111:7\\n#26 0x00007ffff7fa61a2 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/tools/opt/NewPMDriver.cpp:541:10\\n#27 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_data() const /usr/include/c++/10/bits/basic_string.h:195:28\\n#28 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_is_local() const /usr/include/c++/10/bits/basic_string.h:230:23\\n#29 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_dispose() /usr/include/c++/10/bits/basic_string.h:239:18\\n#30 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string() /usr/include/c++/10/bits/basic_string.h:671:19\\n#31 0x00007ffff7fb06af optMain /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/tools/opt/optdriver.cpp:710:28\\n#32 0x00007ffff7b1d083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3\\n#33 0x000055555555509e _start (/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt+0x109e)\\n'}, {'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_flags2', 'body': 'define ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr nuw i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr nuw i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': True, 'log': {'src': 'define ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr nuw i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr nuw i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'tgt': '; ModuleID = \\'<stdin>\\'\\nsource_filename = \"<stdin>\"\\n\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %2 = getelementptr nuw i8, ptr %p, i64 %1\\n  %gep = getelementptr i8, ptr %2, i64 4\\n  ret ptr %gep\\n}\\n', 'log': '\\n----------------------------------------\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  %gep2 = gep nuw ptr %p, 4 x i64 2\\n  br label %join\\n\\nif:\\n  %gep1 = gep nuw ptr %p, 4 x i64 1\\n  br label %join\\n\\njoin:\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = gep ptr %phi, 4 x i64 1\\n  ret ptr %gep\\n}\\n=>\\ndefine ptr @gep_of_phi_of_gep_flags2(i1 %c, ptr %p) {\\n#0:\\n  br i1 %c, label %if, label %else\\n\\nelse:\\n  br label %join\\n\\nif:\\n  br label %join\\n\\njoin:\\n  %#1 = phi i64 [ 4, %if ], [ 8, %else ]\\n  %#2 = gep nuw ptr %p, 1 x i64 %#1\\n  %gep = gep ptr %#2, 1 x i64 4\\n  ret ptr %gep\\n}\\nTransformation seems to be correct!\\n\\nSummary:\\n  1 correct transformations\\n  0 incorrect transformations\\n  0 failed-to-prove transformations\\n  0 Alive2 errors\\n', 'opt_stderr': ''}}, {'file': 'llvm/test/Transforms/InstCombine/opaque-ptr.ll', 'args': \"opt -S -passes='instcombine<no-verify-fixpoint>' < %s\", 'name': 'gep_of_phi_of_gep_flags1', 'body': 'define ptr @gep_of_phi_of_gep_flags1(i1 %c, ptr %p) {\\n  br i1 %c, label %if, label %else\\n\\nif:                                               ; preds = %0\\n  %gep1 = getelementptr inbounds i32, ptr %p, i64 1\\n  br label %join\\n\\nelse:                                             ; preds = %0\\n  %gep2 = getelementptr i32, ptr %p, i64 2\\n  br label %join\\n\\njoin:                                             ; preds = %else, %if\\n  %phi = phi ptr [ %gep1, %if ], [ %gep2, %else ]\\n  %gep = getelementptr i32, ptr %phi, i64 1\\n  ret ptr %gep\\n}\\n', 'result': False, 'log': 'Command \\'[\\'/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt\\', \\'-S\\', \\'-passes=instcombine<no-verify-fixpoint>\\', \\'-\\']\\' died with <Signals.SIGABRT: 6>.\\n\\nopt: /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/Support/Casting.h:578: decltype(auto) llvm::cast(From*) [with To = llvm::TruncInst; From = llvm::Instruction]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"\\' failed.\\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\\nStack dump:\\n0.\\tProgram arguments: /data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt -S -passes=instcombine<no-verify-fixpoint> -\\n1.\\tRunning pass \"function(instcombine<max-iterations=1;no-verify-fixpoint>)\" on module \"<stdin>\"\\n2.\\tRunning pass \"instcombine<max-iterations=1;no-verify-fixpoint>\" on function \"gep_of_phi_of_gep_flags1\"\\n #0 0x00007ffff7eb679c llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Support/Unix/Signals.inc:727:3\\n #1 0x00007ffff7eb4234 llvm::sys::RunSignalHandlers() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Support/Signals.cpp:105:20\\n #2 0x00007ffff7eb458e SignalHandler(int) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Support/Unix/Signals.inc:413:1\\n #3 0x00007ffff7b3c090 (/lib/x86_64-linux-gnu/libc.so.6+0x43090)\\n #4 0x00007ffff7b3c00b raise /build/glibc-LcI20x/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise.c:51:1\\n #5 0x00007ffff7b1b859 abort /build/glibc-LcI20x/glibc-2.31/stdlib/abort.c:81:7\\n #6 0x00007ffff7b1b729 get_sysdep_segment_value /build/glibc-LcI20x/glibc-2.31/intl/loadmsgcat.c:509:8\\n #7 0x00007ffff7b1b729 _nl_load_domain /build/glibc-LcI20x/glibc-2.31/intl/loadmsgcat.c:970:34\\n #8 0x00007ffff7b2cfd6 (/lib/x86_64-linux-gnu/libc.so.6+0x33fd6)\\n #9 0x00007ffff20fed05 (/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x213d05)\\n#10 0x00007ffff21001b6 (/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x2151b6)\\n#11 0x00007ffff3344cb2 foldGEPOfPhi /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2872:37\\n#12 0x00007ffff3344cb2 llvm::InstCombinerImpl::visitGetElementPtrInst(llvm::GetElementPtrInst&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2973:39\\n#13 0x00007ffff33503f1 llvm::InstCombinerImpl::run() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:5220:36\\n#14 0x00007ffff33513b3 combineInstructionsOverFunction(llvm::Function&, llvm::InstructionWorklist&, llvm::AAResults*, llvm::AssumptionCache&, llvm::TargetLibraryInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::OptimizationRemarkEmitter&, llvm::BlockFrequencyInfo*, llvm::BranchProbabilityInfo*, llvm::ProfileSummaryInfo*, llvm::InstCombineOptions const&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:5538:5\\n#15 0x00007ffff3351d5b llvm::InstCombinePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:5600:3\\n#16 0x00007ffff4bc30d6 llvm::detail::PassModel<llvm::Function, llvm::InstCombinePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:91:3\\n#17 0x00007ffff2196bcc llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerImpl.h:85:18\\n#18 0x00007ffff724e256 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:91:3\\n#19 0x00007ffff21970f9 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/IR/PassManager.cpp:129:41\\n#20 0x00007ffff724ec16 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:91:3\\n#21 0x00007ffff2195015 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/PassManagerImpl.h:85:18\\n#22 0x00007ffff7fa61a2 llvm::SmallPtrSetImplBase::~SmallPtrSetImplBase() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:84:5\\n#23 0x00007ffff7fa61a2 llvm::SmallPtrSetImpl<llvm::AnalysisKey*>::~SmallPtrSetImpl() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:363:7\\n#24 0x00007ffff7fa61a2 llvm::SmallPtrSet<llvm::AnalysisKey*, 2u>::~SmallPtrSet() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:519:7\\n#25 0x00007ffff7fa61a2 llvm::PreservedAnalyses::~PreservedAnalyses() /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include/llvm/IR/Analysis.h:111:7\\n#26 0x00007ffff7fa61a2 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/tools/opt/NewPMDriver.cpp:541:10\\n#27 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_data() const /usr/include/c++/10/bits/basic_string.h:195:28\\n#28 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_is_local() const /usr/include/c++/10/bits/basic_string.h:230:23\\n#29 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_M_dispose() /usr/include/c++/10/bits/basic_string.h:239:18\\n#30 0x00007ffff7fb06af std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string() /usr/include/c++/10/bits/basic_string.h:671:19\\n#31 0x00007ffff7fb06af optMain /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/tools/opt/optdriver.cpp:710:28\\n#32 0x00007ffff7b1d083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3\\n#33 0x000055555555509e _start (/data/zyw/llvm-apr-benchmark/work/llvm-build/bin/opt+0x109e)\\n'}]\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    },
    {
      "role": "assistant",
      "content": "```cpp\n           return match(V, m_APInt(C)) && !C->isZero();\n         });\n}\n\nstatic Instruction *foldGEPOfPhi(GetElementPtrInst &GEP, PHINode *PN,\n                                 IRBuilderBase &Builder) {\n  auto *Op1 = dyn_cast<GetElementPtrInst>(PN->getOperand(0));\n  if (!Op1)\n    return nullptr;\n\n  // Don't fold a GEP into itself through a PHI node. This can only happen\n  // through the back-edge of a loop. Folding a GEP into itself means that\n  // the value of the previous iteration needs to be stored in the meantime,\n  // thus requiring an additional register variable to be live, but not\n  // actually achieving anything (the GEP still needs to be executed once per\n  // loop iteration).\n  if (Op1 == &GEP)\n    return nullptr;\n\n  int DI = -1;\n\n  for (auto I = PN->op_begin()+1, E = PN->op_end(); I !=E; ++I) {\n    auto *Op2 = dyn_cast<GetElementPtrInst>(*I);\n    if (!Op2 || Op1->getNumOperands() != Op2->getNumOperands() ||\n        Op1->getSourceElementType() != Op2->getSourceElementType())\n      return nullptr;\n\n    // As for Op1 above, don't try to fold a GEP into itself.\n    if (Op2 == &GEP)\n      return nullptr;\n\n    // Keep track of the type as we walk the GEP.\n    Type *CurTy = nullptr;\n\n    for (unsigned J = 0, F = Op1->getNumOperands(); J != F; ++J) {\n      if (Op1->getOperand(J)->getType() != Op2->getOperand(J)->getType())\n        return nullptr;\n\n      if (Op1->getOperand(J) != Op2->getOperand(J)) {\n        if (DI == -1) {\n          // We have not seen any differences yet in the GEPs feeding the\n          // PHI yet, so we record this one if it is allowed to be a\n          // variable.\n\n          // The first two arguments can vary for any GEP, the rest have to be\n          // static for struct slots\n          if (J > 1) {\n            assert(CurTy && \"No current type?\");\n            if (CurTy->isStructTy())\n              return nullptr;\n          }\n\n          DI = J;\n        } else {\n          // The GEP is different by more than one input. While this could be\n          // extended to support GEPs that vary by more than one variable it\n          // doesn't make sense since it greatly increases the complexity and\n          // would result in an R+R+R addressing mode which no backend\n          // directly supports and would need to be broken into several\n          // simpler instructions anyway.\n          return nullptr;\n        }\n      }\n\n      // Sink down a layer of the type for the next iteration.\n      if (J > 0) {\n        if (J == 1) {\n          CurTy = Op1->getSourceElementType();\n        } else {\n          CurTy =\n              GetElementPtrInst::getTypeAtIndex(CurTy, Op1->getOperand(J));\n        }\n      }\n    }\n  }\n\n  // If not all GEPs are identical we'll have to create a new PHI node.\n  // Check that the old PHI node has only one use so that it will get\n  // removed.\n  if (DI != -1 && !PN->hasOneUse())\n    return nullptr;\n\n  auto *NewGEP = cast<GetElementPtrInst>(Op1->clone());\n  if (DI == -1) {\n    // All the GEPs feeding the PHI are identical. Clone one down into our\n    // BB so that it can be merged with the current GEP.\n  } else {\n    // All the GEPs feeding the PHI differ at a single offset. Clone a GEP\n    // into the current block so it can be merged, and create a new PHI to\n    // set that index.\n    PHINode *NewPN;\n    {\n      IRBuilderBase::InsertPointGuard Guard(Builder);\n      Builder.SetInsertPoint(PN);\n      NewPN = Builder.CreatePHI(Op1->getOperand(DI)->getType(),\n                                PN->getNumOperands());\n    }\n\n    for (auto &I : PN->operands()) {\n      auto *GEPOp = cast<GEPOperator>(I);\n      // Only propagate inbounds if all incoming GEPs are inbounds\n      if (!GEPOp->isInBounds())\n        NewGEP->setIsInBounds(false);\n      // Only propagate nuw if all incoming GEPs are nuw\n      if (!GEPOp->hasNoUnsignedWrap())\n        NewGEP->setHasNoUnsignedWrap(false);\n      NewPN->addIncoming(GEPOp->getOperand(DI), PN->getIncomingBlock(I));\n    }\n\n    NewGEP->setOperand(DI, NewPN);\n  }\n\n  return NewGEP;\n}\n```"
    },
    {
      "role": "user",
      "content": "Feedback:\nCMake Deprecation Warning at /data/zyw/llvm-apr-benchmark/work/llvm-project/cmake/Modules/CMakePolicy.cmake:6 (cmake_policy):\n  The OLD behavior for policy CMP0116 will be removed from a future version\n  of CMake.\n\n  The cmake-policies(7) manual explains that the OLD behaviors of all\n  policies are deprecated and that a policy should be set to OLD only under\n  specific short-term circumstances.  Projects should be ported to the NEW\n  behavior and not rely on setting a policy to OLD.\nCall Stack (most recent call first):\n  CMakeLists.txt:8 (include)\n\n\n-- Could NOT find LibEdit (missing: LibEdit_INCLUDE_DIRS LibEdit_LIBRARIES) \n-- LLVM host triple: x86_64-unknown-linux-gnu\n-- Native target architecture is X86\n-- Threads enabled.\n-- Doxygen disabled.\n-- Ninja version: 1.10.0\n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- Could NOT find OCaml (missing: OCAMLFIND OCAML_VERSION OCAML_STDLIB_PATH) \n-- OCaml bindings disabled.\n-- LLVM default target triple: x86_64-unknown-linux-gnu\n-- Building with -fPIC\n-- Targeting X86\n-- Targeting RISCV\n-- Targeting AArch64\n-- Targeting SystemZ\n-- Targeting Hexagon\n-- Failed to find LLVM FileCheck\n-- Google Benchmark version: v0.0.0, normalized to 0.0.0\n-- Performing Test HAVE_GNU_POSIX_REGEX -- failed to compile\n-- Performing Test HAVE_POSIX_REGEX -- success\n-- Performing Test HAVE_STEADY_CLOCK -- success\n-- Performing Test HAVE_PTHREAD_AFFINITY -- failed to compile\n-- Configuring done (5.7s)\n-- Generating done (3.1s)\n-- Build files have been written to: /data/zyw/llvm-apr-benchmark/work/llvm-build\n\n[1/87] Building CXX object tools/llvm-config/CMakeFiles/llvm-config.dir/llvm-config.cpp.o\n[2/87] Linking CXX executable bin/llvm-config\n[3/87] Building CXX object lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o\nFAILED: lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o \nccache /usr/bin/c++ -DGTEST_HAS_RTTI=0 -DLLVM_EXPORTS -D_DEBUG -D_GLIBCXX_ASSERTIONS -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -I/data/zyw/llvm-apr-benchmark/work/llvm-build/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine -I/data/zyw/llvm-apr-benchmark/work/llvm-build/include -I/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/include -fPIC -fno-semantic-interposition -fvisibility-inlines-hidden -Werror=date-time -fno-lifetime-dse -w -fdiagnostics-color -ffunction-sections -fdata-sections -O2 -g -DNDEBUG -std=c++17 -fPIC  -fno-exceptions -funwind-tables -fno-rtti -UNDEBUG -MD -MT lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o -MF lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o.d -o lib/Transforms/InstCombine/CMakeFiles/LLVMInstCombine.dir/InstructionCombining.cpp.o -c /data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2882:5: error: \u2018NewGEP\u2019 does not name a type\n 2882 |     NewGEP->setOperand(DI, NewPN);\n      |     ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2883:3: error: expected declaration before \u2018}\u2019 token\n 2883 |   }\n      |   ^\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2885:3: error: \u2018NewGEP\u2019 does not name a type\n 2885 |   NewGEP->insertBefore(*GEP.getParent(), GEP.getParent()->getFirstInsertionPt());\n      |   ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2886:3: error: expected unqualified-id before \u2018return\u2019\n 2886 |   return NewGEP;\n      |   ^~~~~~\n/data/zyw/llvm-apr-benchmark/work/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:2887:1: error: expected declaration before \u2018}\u2019 token\n 2887 | }\n      | ^\nninja: build stopped: subcommand failed.\n\nPlease adjust code according to the feedback. Do not include any additional information.\n"
    }
  ]
}