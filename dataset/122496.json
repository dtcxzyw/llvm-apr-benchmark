{
  "bug_id": "122496",
  "issue_url": "https://github.com/llvm/llvm-project/issues/122496",
  "bug_type": "miscompilation",
  "base_commit": "b4ce29ab31b29ca926704c160e3909298ddf2b2b",
  "knowledge_cutoff": "2025-01-10T16:59:46Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "8df64ed77727ab9b7540819f2fe64379e88a50be",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp",
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          3806,
          3812
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          621,
          648
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::collectLoopUniforms"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "legalizeAndOptimizeInductions"
      ]
    }
  },
  "patch": "commit 8df64ed77727ab9b7540819f2fe64379e88a50be\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Sun Jan 12 22:03:21 2025 +0000\n\n    [LV] Don't consider IV increments uniform if exit value is used outside.\n    \n    In some cases, there might be a chain of uniform instructions producing\n    the exit value. To generate correct code in all cases, consider the IV\n    increment not uniform, if there are users outside the loop.\n    \n    Instead, let VPlan narrow the IV, if possible using the logic from\n    3ff1d01985752.\n    \n    Test case from #122602 verified with Alive2:\n        https://alive2.llvm.org/ce/z/bA4EGj\n    \n    Fixes https://github.com/llvm/llvm-project/issues/122496.\n    Fixes https://github.com/llvm/llvm-project/issues/122602.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex b017b61a45a0..d32a463a996c 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -3806,7 +3806,7 @@ void LoopVectorizationCostModel::collectLoopUniforms(ElementCount VF) {\n     // uniform after vectorization.\n     bool UniformIndUpdate = all_of(IndUpdate->users(), [&](User *U) -> bool {\n       auto *I = cast<Instruction>(U);\n-      return I == Ind || !TheLoop->contains(I) || Worklist.count(I) ||\n+      return I == Ind || Worklist.count(I) ||\n              IsVectorizedMemAccessUse(I, IndUpdate);\n     });\n     if (!UniformIndUpdate)\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex f440bf2eb022..545d277d7aa0 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -621,28 +621,6 @@ static void legalizeAndOptimizeInductions(VPlan &Plan) {\n       Def->replaceAllUsesWith(Clone);\n     }\n \n-    // Check if any uniform VPReplicateRecipes using the phi recipe are used by\n-    // ExtractFromEnd. Those must be replaced by a regular VPReplicateRecipe to\n-    // ensure the final value is available.\n-    // TODO: Remove once uniformity analysis is done on VPlan.\n-    for (VPUser *U : Users) {\n-      auto *ExitIRI = dyn_cast<VPIRInstruction>(U);\n-      VPValue *Op;\n-      if (!ExitIRI || !match(ExitIRI->getOperand(0),\n-                             m_VPInstruction<VPInstruction::ExtractFromEnd>(\n-                                 m_VPValue(Op), m_VPValue())))\n-        continue;\n-      auto *RepR = dyn_cast<VPReplicateRecipe>(Op);\n-      if (!RepR || !RepR->isUniform())\n-        continue;\n-      assert(!RepR->isPredicated() && \"RepR must not be predicated\");\n-      Instruction *I = RepR->getUnderlyingInstr();\n-      auto *Clone =\n-          new VPReplicateRecipe(I, RepR->operands(), /*IsUniform*/ false);\n-      Clone->insertAfter(RepR);\n-      RepR->replaceAllUsesWith(Clone);\n-    }\n-\n     // Replace wide pointer inductions which have only their scalars used by\n     // PtrAdd(IndStart, ScalarIVSteps (0, Step)).\n     if (auto *PtrIV = dyn_cast<VPWidenPointerInductionRecipe>(&Phi)) {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/uniform-phi.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7 -debug-only=loop-vectorize -S 2>&1"
      ],
      "tests": [
        {
          "test_name": "foo",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @foo(ptr %a, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ %i.next, %for.body ], [ 0, %entry ]\n  %tmp0 = trunc i64 %i to i32\n  %tmp1 = getelementptr inbounds i32, ptr %a, i32 %tmp0\n  store i32 %tmp0, ptr %tmp1, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp eq i64 %i.next, %n\n  br i1 %cond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @test(ptr noalias nocapture %a, ptr noalias nocapture readonly %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %b, i64 %indvars.iv\n  %tmp0 = load float, ptr %arrayidx, align 4\n  %add = fadd float %tmp0, 1.000000e+00\n  %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  store float %add, ptr %arrayidx5, align 4\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv, 1599\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "goo",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i64 @goo(ptr noalias nocapture %a, ptr noalias nocapture readonly %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %b, i64 %indvars.iv\n  %tmp0 = load float, ptr %arrayidx, align 4\n  %add = fadd float %tmp0, 1.000000e+00\n  %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  store float %add, ptr %arrayidx5, align 4\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv, 1599\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  %retval = add i64 %indvars.iv, %indvars.iv.next\n  ret i64 %retval\n}\n"
        },
        {
          "test_name": "PR38786",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @PR38786(ptr %y, ptr %x, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %phi32 = phi i32 [ 0, %entry ], [ %i32next, %for.body ]\n  %phi64 = phi i64 [ 0, %entry ], [ %i64next, %for.body ]\n  %i32next = add i32 %phi32, 1\n  %i64next = zext i32 %i32next to i64\n  %xip = getelementptr inbounds double, ptr %x, i64 %i64next\n  %yip = getelementptr inbounds double, ptr %y, i64 %phi64\n  %xi = load double, ptr %xip, align 8\n  store double %xi, ptr %yip, align 8\n  %cmp = icmp slt i64 %i64next, %n\n  br i1 %cmp, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/iv_outside_user.ll",
      "commands": [
        "opt -S -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=2 < %s",
        "opt -S -passes=loop-vectorize -force-vector-interleave=2 -force-vector-width=1 < %s"
      ],
      "tests": [
        {
          "test_name": "test_iv_increment_incremented",
          "test_body": "define i64 @test_iv_increment_incremented(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv.1 = phi i64 [ 3, %entry ], [ %iv.1.next, %loop ]\n  %iv.2 = phi i64 [ 2, %entry ], [ %iv.2.next, %loop ]\n  %gep = getelementptr i16, ptr %dst, i64 %iv.1\n  store i16 1, ptr %gep, align 2\n  %iv.2.next = add i64 %iv.2, -1\n  %ec = icmp eq i64 %iv.2.next, 0\n  %iv.1.next = add i64 %iv.2.next, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i64 %iv.1.next\n}\n"
        },
        {
          "test_name": "iv_ext_used_outside",
          "test_body": "define i32 @iv_ext_used_outside(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv.1 = phi i16 [ 0, %entry ], [ %iv.1.next, %loop ]\n  %iv.2 = phi i32 [ 0, %entry ], [ %iv.1.ext, %loop ]\n  %gep = getelementptr inbounds nuw i32, ptr %dst, i16 %iv.1\n  store i32 0, ptr %gep, align 4\n  %iv.1.next = add nuw nsw i16 %iv.1, 1\n  %iv.1.ext = zext nneg i16 %iv.1.next to i32\n  %ec = icmp samesign ult i16 %iv.1, 128\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  %iv.1.ext.lcssa = phi i32 [ %iv.1.ext, %loop ]\n  ret i32 %iv.1.ext.lcssa\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/scalable-iv-outside-user.ll",
      "commands": [
        "opt -scalable-vectorization=on -force-target-supports-scalable-vectors=true -passes=loop-vectorize -force-vector-width=2 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "iv_live_out_wide",
          "test_body": "define i32 @iv_live_out_wide(ptr %dst) {\nentry:\n  %step.1 = sext i8 0 to i32\n  %step.2 = add nsw i32 %step.1, 1\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.dst = getelementptr inbounds i16, ptr %dst, i32 %iv\n  store i16 0, ptr %gep.dst, align 2\n  %iv.next = add i32 %step.2, %iv\n  %cmp.i = icmp slt i32 %iv.next, 2000\n  br i1 %cmp.i, label %loop, label %e.exit\n\ne.exit:                                           ; preds = %loop\n  %res = phi i32 [ %iv.next, %loop ]\n  ret i32 %res\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[clang] Miscompilation at -O2/3",
    "body": "This code prints 0 at `-O0/1` and triggers SIGKILL at `-O2/3`:\n\n```c\nint printf(const char *, ...);\nint a;\nshort b, c;\nlong e;\nint f[8][1];\nunsigned g;\nint h(int i) {\n  long d = 0;\n  for (; (a -= i) >= 0; d += 6)\n    ;\n  return d;\n}\nvoid j() {\n  g = 0;\n  for (; h(90) + g <= 0; g++) {\n    int k = -1;\n    b = 0;\n    for (; k + g - -1 + b <= 3; b++)\n      f[b + 3][0] = c;\n    for (; b + g - 3 + e <= 8; e++)\n      ;\n    for (; e <= 3;)\n      ;\n  }\n}\nint main() {\n  j();\n  printf(\"%d\\n\", f[0][0]);\n}\n```\n\nCompiler Explorer: https://godbolt.org/z/3x8Yc3fnW\n\nIt seems to be a recent regression. ",
    "author": "cardigan1008",
    "labels": [
      "regression",
      "miscompilation",
      "vectorizers"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "Bisecting now"
      },
      {
        "author": "dtcxzyw",
        "body": "Reproducer: https://godbolt.org/z/6bzT9rs3K\n```\n; bin/opt -passes=loop-vectorize test.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@f = global [8 x [1 x i32]] zeroinitializer\n\ndefine i32 @main() {\nentry:\n  br label %for.body6.i\n\nfor.body6.i:                                      ; preds = %for.body6.i, %entry\n  %conv34.i = phi i32 [ %conv.i, %for.body6.i ], [ 0, %entry ]\n  %storemerge3133.i = phi i16 [ %inc.i, %for.body6.i ], [ 0, %entry ]\n  %idxprom.i = zext i32 %conv34.i to i64\n  %arrayidx.i = getelementptr [8 x [1 x i32]], ptr @f, i64 0, i64 %idxprom.i\n  store i32 0, ptr %arrayidx.i, align 4\n  %inc.i = add i16 %storemerge3133.i, 1\n  %conv.i = zext i16 %inc.i to i32\n  %cmp4.i = icmp ult i16 %storemerge3133.i, 3\n  br i1 %cmp4.i, label %for.body6.i, label %for.cond11thread-pre-split.i\n\nfor.cond11thread-pre-split.i:                     ; preds = %for.body6.i\n  %0 = add i32 %conv.i, -9\n  %cmp24.i = icmp ult i32 %0, -6\n  br i1 %cmp24.i, label %for.cond23.i, label %for.end27.i\n\nfor.cond23.i:                                     ; preds = %for.cond23.i, %for.cond11thread-pre-split.i\n  br label %for.cond23.i\n\nfor.end27.i:                                      ; preds = %for.cond11thread-pre-split.i\n  ret i32 0\n}\n```\n[llubi](https://github.com/dtcxzyw/llvm-ub-aware-interpreter) output:\n\nBefore:\n```\nEntering function main\n  br label %for.body6.i jump to %for.body6.i\n    phi i32 %conv34.i -> i32 0\n    phi i16 %storemerge3133.i -> i16 0\n  %idxprom.i = zext i32 %conv34.i to i64 -> i64 0\n  %arrayidx.i = getelementptr [8 x [1 x i32]], ptr @f, i64 0, i64 %idxprom.i -> Ptr 16[@f]\n  store i32 0, ptr %arrayidx.i, align 4\n  %inc.i = add i16 %storemerge3133.i, 1 -> i16 1\n  %conv.i = zext i16 %inc.i to i32 -> i32 1\n  %cmp4.i = icmp ult i16 %storemerge3133.i, 3 -> T\n  br i1 %cmp4.i, label %for.body6.i, label %for.cond11thread-pre-split.i jump to %for.body6.i\n    phi i32 %conv34.i -> i32 1\n    phi i16 %storemerge3133.i -> i16 1\n  %idxprom.i = zext i32 %conv34.i to i64 -> i64 1\n  %arrayidx.i = getelementptr [8 x [1 x i32]], ptr @f, i64 0, i64 %idxprom.i -> Ptr 20[@f + 4]\n  store i32 0, ptr %arrayidx.i, align 4\n  %inc.i = add i16 %storemerge3133.i, 1 -> i16 2\n  %conv.i = zext i16 %inc.i to i32 -> i32 2\n  %cmp4.i = icmp ult i16 %storemerge3133.i, 3 -> T\n  br i1 %cmp4.i, label %for.body6.i, label %for.cond11thread-pre-split.i jump to %for.body6.i\n    phi i32 %conv34.i -> i32 2\n    phi i16 %storemerge3133.i -> i16 2\n  %idxprom.i = zext i32 %conv34.i to i64 -> i64 2\n  %arrayidx.i = getelementptr [8 x [1 x i32]], ptr @f, i64 0, i64 %idxprom.i -> Ptr 24[@f + 8]\n  store i32 0, ptr %arrayidx.i, align 4\n  %inc.i = add i16 %storemerge3133.i, 1 -> i16 3\n  %conv.i = zext i16 %inc.i to i32 -> i32 3\n  %cmp4.i = icmp ult i16 %storemerge3133.i, 3 -> T\n  br i1 %cmp4.i, label %for.body6.i, label %for.cond11thread-pre-split.i jump to %for.body6.i\n    phi i32 %conv34.i -> i32 3\n    phi i16 %storemerge3133.i -> i16 3\n  %idxprom.i = zext i32 %conv34.i to i64 -> i64 3\n  %arrayidx.i = getelementptr [8 x [1 x i32]], ptr @f, i64 0, i64 %idxprom.i -> Ptr 28[@f + 12]\n  store i32 0, ptr %arrayidx.i, align 4\n  %inc.i = add i16 %storemerge3133.i, 1 -> i16 4\n  %conv.i = zext i16 %inc.i to i32 -> i32 4\n  %cmp4.i = icmp ult i16 %storemerge3133.i, 3 -> F\n  br i1 %cmp4.i, label %for.body6.i, label %for.cond11thread-pre-split.i jump to %for.cond11thread-pre-split.i\n  %0 = add i32 %conv.i, -9 -> i32 -5\n  %cmp24.i = icmp ult i32 %0, -6 -> F\n  br i1 %cmp24.i, label %for.cond23.i, label %for.end27.i jump to %for.end27.i\n  ret i32 0\nExiting function main\n```\nAfter:\n```\nEntering function main\n  br i1 false, label %scalar.ph, label %vector.ph jump to %vector.ph\n  br label %vector.body jump to %vector.body\n  %0 = zext i32 0 to i64 -> i64 0\n  %1 = getelementptr [8 x [1 x i32]], ptr @f, i64 0, i64 %0 -> Ptr 16[@f]\n  %2 = getelementptr i32, ptr %1, i32 0 -> Ptr 16[@f]\n  store <4 x i32> zeroinitializer, ptr %2, align 4\n  %3 = add i16 0, 1 -> i16 1\n  %4 = zext i16 %3 to i32 -> i32 1\n  %5 = zext i16 %3 to i32 -> i32 1\n  %6 = zext i16 %3 to i32 -> i32 1\n  %7 = zext i16 %3 to i32 -> i32 1\n  br label %middle.block jump to %middle.block\n  br i1 true, label %for.cond11thread-pre-split.i, label %scalar.ph jump to %for.cond11thread-pre-split.i\n    phi i32 %conv.i.lcssa -> i32 1\n  %8 = add i32 %conv.i.lcssa, -9 -> i32 -8\n  %cmp24.i = icmp ult i32 %8, -6 -> T\n  br i1 %cmp24.i, label %for.cond23.i.preheader, label %for.end27.i jump to %for.cond23.i.preheader\n  br label %for.cond23.i jump to %for.cond23.i\n  br label %for.cond23.i jump to %for.cond23.i\n  br label %for.cond23.i jump to %for.cond23.i\n  ...\n```\n"
      }
    ]
  }
}