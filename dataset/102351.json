{
  "bug_id": "102351",
  "issue_url": "https://github.com/llvm/llvm-project/issues/102351",
  "bug_type": "miscompilation",
  "base_commit": "203a2ca8cd6af505e11a38aebceeaf864271042c",
  "knowledge_cutoff": "2024-08-07T18:49:59Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SimplifyCFG"
  ],
  "hints": {
    "fix_commit": "3c9022c965b85951f30af140da591f819acef8a0",
    "components": [
      "Local"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/Local.cpp": [
        [
          1028,
          1034
        ],
        [
          1133,
          1139
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/Local.cpp": [
        "CanRedirectPredsOfEmptyBBToSucc",
        "llvm::TryToSimplifyUncondBranchFromEmptyBlock"
      ]
    }
  },
  "patch": "commit 3c9022c965b85951f30af140da591f819acef8a0\nAuthor: AdityaK <hiraditya@msn.com>\nDate:   Tue Sep 10 22:39:02 2024 -0700\n\n    Bail out jump threading on indirect branches (#103688)\n    \n    The bug was introduced by\n    https://github.com/llvm/llvm-project/pull/68473\n    \n    Fixes: #102351\n\ndiff --git a/llvm/lib/Transforms/Utils/Local.cpp b/llvm/lib/Transforms/Utils/Local.cpp\nindex d0669e44f821..c85c819263e2 100644\n--- a/llvm/lib/Transforms/Utils/Local.cpp\n+++ b/llvm/lib/Transforms/Utils/Local.cpp\n@@ -1028,7 +1028,14 @@ CanRedirectPredsOfEmptyBBToSucc(BasicBlock *BB, BasicBlock *Succ,\n   if (!BB->hasNPredecessorsOrMore(2))\n     return false;\n \n-  // Get single common predecessors of both BB and Succ\n+  if (any_of(BBPreds, [](const BasicBlock *Pred) {\n+        return isa<PHINode>(Pred->begin()) &&\n+               isa<IndirectBrInst>(Pred->getTerminator());\n+      }))\n+    return false;\n+\n+  // Get the single common predecessor of both BB and Succ. Return false\n+  // when there are more than one common predecessors.\n   for (BasicBlock *SuccPred : SuccPreds) {\n     if (BBPreds.count(SuccPred)) {\n       if (CommonPred)\n@@ -1133,7 +1140,7 @@ bool llvm::TryToSimplifyUncondBranchFromEmptyBlock(BasicBlock *BB,\n \n   bool BBKillable = CanPropagatePredecessorsForPHIs(BB, Succ, BBPreds);\n \n-  // Even if we can not fold bB into Succ, we may be able to redirect the\n+  // Even if we can not fold BB into Succ, we may be able to redirect the\n   // predecessors of BB to Succ.\n   bool BBPhisMergeable =\n       BBKillable ||\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SimplifyCFG/switch-branch-fold-indirectbr-102351.ll",
      "commands": [
        "opt < %s -passes=simplifycfg -S"
      ],
      "tests": [
        {
          "test_name": "main",
          "test_body": "define dso_local noundef i32 @main() {\nbb:\n  %alloca = alloca [2 x ptr], align 16\n  store ptr blockaddress(@main, %bb4), ptr %alloca, align 16, !tbaa !0\n  %getelementptr = getelementptr inbounds [2 x ptr], ptr %alloca, i64 0, i64 1\n  store ptr blockaddress(@main, %bb10), ptr %getelementptr, align 8, !tbaa !0\n  br label %bb1\n\nbb1:                                              ; preds = %bb7, %bb\n  %phi = phi i32 [ 0, %bb ], [ %phi8, %bb7 ]\n  %phi2 = phi i32 [ 0, %bb ], [ %phi9, %bb7 ]\n  switch i32 %phi, label %bb7 [\n    i32 0, label %bb3\n    i32 1, label %bb4\n    i32 2, label %bb6\n  ]\n\nbb3:                                              ; preds = %bb1\n  br label %bb12\n\nbb4:                                              ; preds = %bb12, %bb1\n  %phi5 = phi i32 [ %phi13, %bb12 ], [ %phi2, %bb1 ]\n  br label %bb7\n\nbb6:                                              ; preds = %bb1\n  %call = call i32 @foo(i32 noundef %phi2)\n  %add = add nsw i32 %phi2, 1\n  br label %bb12\n\nbb7:                                              ; preds = %bb4, %bb1\n  %phi8 = phi i32 [ %phi, %bb1 ], [ 2, %bb4 ]\n  %phi9 = phi i32 [ %phi2, %bb1 ], [ %phi5, %bb4 ]\n  br label %bb1, !llvm.loop !4\n\nbb10:                                             ; preds = %bb12\n  %call11 = call i32 @foo(i32 noundef %phi13)\n  ret i32 0\n\nbb12:                                             ; preds = %bb6, %bb3\n  %phi13 = phi i32 [ %add, %bb6 ], [ %phi2, %bb3 ]\n  %sext = sext i32 %phi13 to i64\n  %getelementptr14 = getelementptr inbounds [2 x ptr], ptr %alloca, i64 0, i64 %sext\n  %load = load ptr, ptr %getelementptr14, align 8, !tbaa !0\n  indirectbr ptr %load, [label %bb4, label %bb10]\n}\n\ndeclare i32 @foo(i32)\n\n!0 = !{!1, !1, i64 0}\n!1 = !{!\"any pointer\", !2, i64 0}\n!2 = !{!\"omnipotent char\", !3, i64 0}\n!3 = !{!\"Simple C++ TBAA\"}\n!4 = !{!5, !5, i64 0}\n!5 = !{!\"int\", !2, i64 0}\n",
          "lli_expected_out": "OP_1:(instruction=0)\nTERMINATE:(instruction=1)\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Miscompile in code with indirect gotos",
    "body": "The simplifycfg pass (incorrectly?) optimizes one of the case statements.\r\n\r\n```llvm\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\n@.str = private unnamed_addr constant [23 x i8] c\"OP_1:(instruction=%d)\\0A\\00\", align 1\r\n@.str.1 = private unnamed_addr constant [28 x i8] c\"TERMINATE:(instruction=%d)\\0A\\00\", align 1\r\n\r\n; Function Attrs: mustprogress norecurse uwtable\r\ndefine dso_local noundef i32 @main() #0 {\r\nentry:\r\n  %bytecode = alloca [2 x ptr], align 16\r\n  store ptr blockaddress(@main, %VM__OP_1), ptr %bytecode, align 16, !tbaa !5\r\n  %arrayidx1 = getelementptr inbounds [2 x ptr], ptr %bytecode, i64 0, i64 1\r\n  store ptr blockaddress(@main, %VM__TERMINATE), ptr %arrayidx1, align 8, !tbaa !5\r\n  br label %while.body\r\n\r\nwhile.body:                                       ; preds = %entry, %sw.epilog\r\n  %state.0 = phi i32 [ 0, %entry ], [ %state.1, %sw.epilog ]\r\n  %index.0 = phi i32 [ 0, %entry ], [ %index.2, %sw.epilog ]\r\n  switch i32 %state.0, label %sw.epilog [\r\n    i32 0, label %sw.bb\r\n    i32 1, label %VM__OP_1\r\n    i32 2, label %sw.bb4\r\n  ]\r\n\r\nsw.bb:                                            ; preds = %while.body\r\n  br label %indirectgoto\r\n\r\nVM__OP_1:                                         ; preds = %while.body, %indirectgoto\r\n  %index.1 = phi i32 [ %index.3, %indirectgoto ], [ %index.0, %while.body ]\r\n  br label %sw.epilog\r\n\r\nsw.bb4:                                           ; preds = %while.body\r\n  %call = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %index.0)\r\n  %inc = add nsw i32 %index.0, 1\r\n  br label %indirectgoto\r\n\r\nsw.epilog:                                        ; preds = %while.body, %VM__OP_1\r\n  %state.1 = phi i32 [ %state.0, %while.body ], [ 2, %VM__OP_1 ]\r\n  %index.2 = phi i32 [ %index.0, %while.body ], [ %index.1, %VM__OP_1 ]\r\n  br label %while.body, !llvm.loop !9\r\n\r\nVM__TERMINATE:                                    ; preds = %indirectgoto\r\n  %call7 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i32 noundef %index.3)\r\n  ret i32 0\r\n\r\nindirectgoto:                                     ; preds = %sw.bb4, %sw.bb\r\n  %index.3 = phi i32 [ %inc, %sw.bb4 ], [ %index.0, %sw.bb ]\r\n  %idxprom.pn = sext i32 %index.3 to i64\r\n  %indirect.goto.dest.in = getelementptr inbounds [2 x ptr], ptr %bytecode, i64 0, i64 %idxprom.pn\r\n  %indirect.goto.dest = load ptr, ptr %indirect.goto.dest.in, align 8, !tbaa !5\r\n  indirectbr ptr %indirect.goto.dest, [label %VM__OP_1, label %VM__TERMINATE]\r\n}\r\ndeclare i32 @printf(ptr noundef, ...) #1\r\n\r\nattributes #0 = { mustprogress norecurse uwtable \"min-legal-vector-width\"=\"0\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" }\r\nattributes #1 = { \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" }\r\n\r\n!llvm.module.flags = !{!0, !1, !2, !3}\r\n!llvm.ident = !{!4}\r\n\r\n!0 = !{i32 1, !\"wchar_size\", i32 4}\r\n!1 = !{i32 8, !\"PIC Level\", i32 2}\r\n!2 = !{i32 7, !\"PIE Level\", i32 2}\r\n!3 = !{i32 7, !\"uwtable\", i32 2}\r\n!4 = !{!\"clang version 18.0.0git (https://github.com/llvm/llvm-project.git 67782d2de5ea9c8653b8f0110237a3c355291c0e)\"}\r\n!5 = !{!6, !6, i64 0}\r\n!6 = !{!\"any pointer\", !7, i64 0}\r\n!7 = !{!\"omnipotent char\", !8, i64 0}\r\n!8 = !{!\"Simple C++ TBAA\"}\r\n!9 = !{!10, !10, i64 0}\r\n!10 = !{!\"int\", !7, i64 0}\r\n!11 = distinct !{!11, !12, !13}\r\n!12 = !{!\"llvm.loop.mustprogress\"}\r\n!13 = !{!\"llvm.loop.unroll.disable\"}\r\n```\r\n\r\n$ opt -passes=simplifycfg orig.ll -S -o out.ll\r\n```llvm\r\n; ModuleID = 'orig.ll'\r\nsource_filename = \"orig.ll\"\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\n@.str = private unnamed_addr constant [23 x i8] c\"OP_1:(instruction=%d)\\0A\\00\", align 1\r\n@.str.1 = private unnamed_addr constant [28 x i8] c\"TERMINATE:(instruction=%d)\\0A\\00\", align 1\r\n\r\n; Function Attrs: mustprogress norecurse uwtable\r\ndefine dso_local noundef i32 @main() #0 {\r\nentry:\r\n  %bytecode = alloca [2 x ptr], align 16\r\n  store ptr blockaddress(@main, %VM__OP_1), ptr %bytecode, align 16, !tbaa !5\r\n  %arrayidx1 = getelementptr inbounds [2 x ptr], ptr %bytecode, i64 0, i64 1\r\n  store ptr blockaddress(@main, %VM__TERMINATE), ptr %arrayidx1, align 8, !tbaa !5\r\n  br label %while.body\r\n\r\nwhile.body:                                       ; preds = %sw.epilog, %entry\r\n  %state.0 = phi i32 [ 0, %entry ], [ %state.1, %sw.epilog ]\r\n  %index.0 = phi i32 [ 0, %entry ], [ %index.0, %sw.epilog ]\r\n  switch i32 %state.0, label %sw.epilog [\r\n    i32 0, label %VM__TERMINATE\r\n    i32 1, label %VM__OP_1\r\n    i32 2, label %sw.bb4\r\n  ]\r\n\r\nVM__OP_1:                                         ; preds = %while.body\r\n  br label %sw.epilog\r\n\r\nsw.bb4:                                           ; preds = %while.body\r\n  %call = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %index.0)\r\n  %inc = add nsw i32 %index.0, 1\r\n  br label %VM__TERMINATE\r\n\r\nsw.epilog:                                        ; preds = %VM__OP_1, %while.body\r\n  %state.1 = phi i32 [ %state.0, %while.body ], [ 2, %VM__OP_1 ]\r\n  br label %while.body, !llvm.loop !9\r\n\r\nVM__TERMINATE:                                    ; preds = %sw.bb4, %while.body\r\n  %index.3 = phi i32 [ %inc, %sw.bb4 ], [ %index.0, %while.body ]\r\n  %call7 = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i32 noundef %index.3)\r\n  ret i32 0\r\n}\r\n\r\ndeclare i32 @printf(ptr noundef, ...) #1\r\n\r\nattributes #0 = { mustprogress norecurse uwtable \"min-legal-vector-width\"=\"0\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" }\r\nattributes #1 = { \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" }\r\n\r\n!llvm.module.flags = !{!0, !1, !2, !3}\r\n!llvm.ident = !{!4}\r\n\r\n!0 = !{i32 1, !\"wchar_size\", i32 4}\r\n!1 = !{i32 8, !\"PIC Level\", i32 2}\r\n!2 = !{i32 7, !\"PIE Level\", i32 2}\r\n!3 = !{i32 7, !\"uwtable\", i32 2}\r\n!4 = !{!\"clang version 18.0.0git (https://github.com/llvm/llvm-project.git 67782d2de5ea9c8653b8f0110237a3c355291c0e)\"}\r\n!5 = !{!6, !6, i64 0}\r\n!6 = !{!\"any pointer\", !7, i64 0}\r\n!7 = !{!\"omnipotent char\", !8, i64 0}\r\n!8 = !{!\"Simple C++ TBAA\"}\r\n!9 = !{!10, !10, i64 0}\r\n!10 = !{!\"int\", !7, i64 0}\r\n```",
    "author": "hiraditya",
    "labels": [
      "miscompilation",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "hiraditya",
        "body": "Original C code\r\n\r\n```c\r\nextern int printf(const char *fmt, ...);\r\n\r\nint main() {\r\n  void* bytecode[2];\r\n  bytecode[0] = &&VM__OP_1;\r\n  bytecode[1] = &&VM__TERMINATE;\r\n\r\n  int state = 0;\r\n  int index = 0;\r\n\r\n  while (1) {\r\n    switch (state) {\r\n    case 0:\r\n      goto *bytecode[index];\r\n    case 1:\r\n      // NOTE: THIS IS ONLY REACHABLE VIA INDIRECT GOTOS\r\n      VM__OP_1:\r\n      state = 2;\r\n      break;\r\n    case 2:\r\n      printf(\"OP_1:(instruction=%d)\\n\", index);\r\n      index++;\r\n      goto *bytecode[index];\r\n    }\r\n  }\r\n\r\nVM__TERMINATE:\r\n  printf(\"TERMINATE:(instruction=%d)\\n\", index);\r\n  return 0;\r\n}\r\n```\r\n\r\nhttps://github.com/llvm/llvm-project/pull/76295 makes the miscompile go away(https://godbolt.org/z/d9bGnhhv6) but I think simplifycfg still has the bug.\r\n"
      },
      {
        "author": "efriedma-quic",
        "body": "Looks like TryToSimplifyUncondBranchFromEmptyBlock is not handling indirectbr predecessors correctly: the indirectbr's successor list is rewritten so it has a successor that isn't address-taken.  That edge is then proven impossible, so the indirectbr is completely eliminated."
      }
    ]
  }
}