{
  "bug_id": "91417",
  "issue_url": "https://github.com/llvm/llvm-project/issues/91417",
  "bug_type": "miscompilation",
  "base_commit": "971f1aaad3ca3680bfbab76212f498ca15b280a2",
  "knowledge_cutoff": "2024-05-08T01:40:37Z",
  "lit_test_dir": [
    "llvm/test/Transforms/Reassociate"
  ],
  "hints": {
    "fix_commit": "3bcccb6af685c3132a9ee578b9e11b2503c35a5c",
    "components": [
      "Reassociate"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/Reassociate.cpp": [
        [
          302,
          398
        ],
        [
          562,
          587
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/Reassociate.cpp": [
        "CarmichaelShift",
        "IncorporateWeight",
        "LinearizeExprTree",
        "LowerNegateToMultiply"
      ]
    }
  },
  "patch": "commit 3bcccb6af685c3132a9ee578b9e11b2503c35a5c\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Wed May 29 18:09:23 2024 +0800\n\n    [Reassociate] Drop weight reduction to fix issue 91417 (#91469)\n    \n    See the following case: https://alive2.llvm.org/ce/z/A-fBki\n    ```\n    define i3 @src(i3 %0) {\n      %2 = mul i3 %0, %0\n      %3 = mul i3 %2, %0\n      %4 = mul i3 %3, %0\n      %5 = mul nsw i3 %4, %0\n      ret i3 %5\n    }\n    \n    define i3 @tgt(i3 %0) {\n      %2 = mul i3 %0, %0\n      %5 = mul nsw i3 %2, %0\n      ret i3 %5\n    }\n    ```\n    \n    \n    https://github.com/llvm/llvm-project/commit/d7aeefebd6b049f017711cd7c6ef5f217a17b673\n    introduced weight reduction during weights combination of the same\n    operand. As the weight of `%0` changes from 5 to 3, the nsw flag in `%5`\n    should be dropped.\n    \n    However, the nsw flag isn't cleared by `RewriteExprTree` since `%5 = mul\n    nsw i3 %0, %4` is not included in the range of `[ExpressionChangedStart,\n    ExpressionChangedEnd)`.\n    ```\n    Calculated Rank[] = 3\n    Combine negations for:   %2 = mul i3 %0, %0\n    Calculated Rank[] = 4\n    Combine negations for:   %3 = mul i3 %0, %2\n    Calculated Rank[] = 5\n    Combine negations for:   %4 = mul i3 %0, %3\n    Calculated Rank[] = 6\n    Combine negations for:   %5 = mul nsw i3 %0, %4\n    LINEARIZE:   %5 = mul nsw i3 %0, %4\n    OPERAND: i3 %0 (1)\n    ADD USES LEAF: i3 %0 (1)\n    OPERAND:   %4 = mul i3 %0, %3 (1)\n    DIRECT ADD:   %4 = mul i3 %0, %3 (1)\n    OPERAND: i3 %0 (1)\n    OPERAND:   %3 = mul i3 %0, %2 (1)\n    DIRECT ADD:   %3 = mul i3 %0, %2 (1)\n    OPERAND: i3 %0 (1)\n    OPERAND:   %2 = mul i3 %0, %0 (1)\n    DIRECT ADD:   %2 = mul i3 %0, %0 (1)\n    OPERAND: i3 %0 (1)\n    OPERAND: i3 %0 (1)\n    RAIn:   mul i3  [ %0, #3] [ %0, #3] [ %0, #3]\n    RAOut:  mul i3  [ %0, #3] [ %0, #3] [ %0, #3]\n    RAOut after CSE reorder:        mul i3  [ %0, #3] [ %0, #3] [ %0, #3]\n    RA:   %5 = mul nsw i3 %0, %4\n    TO:   %5 = mul nsw i3 %4, %0\n    RA:   %4 = mul i3 %0, %3\n    TO:   %4 = mul i3 %0, %0\n    ```\n    \n    The best way to fix this is to inform `RewriteExprTree` to clear flags\n    of the whole expr tree when weight reduction happens.\n    \n    But I find that weight reduction based on Carmichael number never\n    happens in practice.\n    See the coverage result\n    https://dtcxzyw.github.io/llvm-opt-benchmark/coverage/home/dtcxzyw/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp.html#L323\n    \n    I think it would be better to drop `IncorporateWeight`.\n    \n    Fixes #91417\n\ndiff --git a/llvm/lib/Transforms/Scalar/Reassociate.cpp b/llvm/lib/Transforms/Scalar/Reassociate.cpp\nindex c903e47a93ca..04c54ed69e93 100644\n--- a/llvm/lib/Transforms/Scalar/Reassociate.cpp\n+++ b/llvm/lib/Transforms/Scalar/Reassociate.cpp\n@@ -302,97 +302,6 @@ static BinaryOperator *LowerNegateToMultiply(Instruction *Neg) {\n   return Res;\n }\n \n-/// Returns k such that lambda(2^Bitwidth) = 2^k, where lambda is the Carmichael\n-/// function. This means that x^(2^k) === 1 mod 2^Bitwidth for\n-/// every odd x, i.e. x^(2^k) = 1 for every odd x in Bitwidth-bit arithmetic.\n-/// Note that 0 <= k < Bitwidth, and if Bitwidth > 3 then x^(2^k) = 0 for every\n-/// even x in Bitwidth-bit arithmetic.\n-static unsigned CarmichaelShift(unsigned Bitwidth) {\n-  if (Bitwidth < 3)\n-    return Bitwidth - 1;\n-  return Bitwidth - 2;\n-}\n-\n-/// Add the extra weight 'RHS' to the existing weight 'LHS',\n-/// reducing the combined weight using any special properties of the operation.\n-/// The existing weight LHS represents the computation X op X op ... op X where\n-/// X occurs LHS times.  The combined weight represents  X op X op ... op X with\n-/// X occurring LHS + RHS times.  If op is \"Xor\" for example then the combined\n-/// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;\n-/// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.\n-static void IncorporateWeight(APInt &LHS, const APInt &RHS, unsigned Opcode) {\n-  // If we were working with infinite precision arithmetic then the combined\n-  // weight would be LHS + RHS.  But we are using finite precision arithmetic,\n-  // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct\n-  // for nilpotent operations and addition, but not for idempotent operations\n-  // and multiplication), so it is important to correctly reduce the combined\n-  // weight back into range if wrapping would be wrong.\n-\n-  // If RHS is zero then the weight didn't change.\n-  if (RHS.isMinValue())\n-    return;\n-  // If LHS is zero then the combined weight is RHS.\n-  if (LHS.isMinValue()) {\n-    LHS = RHS;\n-    return;\n-  }\n-  // From this point on we know that neither LHS nor RHS is zero.\n-\n-  if (Instruction::isIdempotent(Opcode)) {\n-    // Idempotent means X op X === X, so any non-zero weight is equivalent to a\n-    // weight of 1.  Keeping weights at zero or one also means that wrapping is\n-    // not a problem.\n-    assert(LHS == 1 && RHS == 1 && \"Weights not reduced!\");\n-    return; // Return a weight of 1.\n-  }\n-  if (Instruction::isNilpotent(Opcode)) {\n-    // Nilpotent means X op X === 0, so reduce weights modulo 2.\n-    assert(LHS == 1 && RHS == 1 && \"Weights not reduced!\");\n-    LHS = 0; // 1 + 1 === 0 modulo 2.\n-    return;\n-  }\n-  if (Opcode == Instruction::Add || Opcode == Instruction::FAdd) {\n-    // TODO: Reduce the weight by exploiting nsw/nuw?\n-    LHS += RHS;\n-    return;\n-  }\n-\n-  assert((Opcode == Instruction::Mul || Opcode == Instruction::FMul) &&\n-         \"Unknown associative operation!\");\n-  unsigned Bitwidth = LHS.getBitWidth();\n-  // If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth\n-  // can be replaced with W-CM.  That's because x^W=x^(W-CM) for every Bitwidth\n-  // bit number x, since either x is odd in which case x^CM = 1, or x is even in\n-  // which case both x^W and x^(W - CM) are zero.  By subtracting off multiples\n-  // of CM like this weights can always be reduced to the range [0, CM+Bitwidth)\n-  // which by a happy accident means that they can always be represented using\n-  // Bitwidth bits.\n-  // TODO: Reduce the weight by exploiting nsw/nuw?  (Could do much better than\n-  // the Carmichael number).\n-  if (Bitwidth > 3) {\n-    /// CM - The value of Carmichael's lambda function.\n-    APInt CM = APInt::getOneBitSet(Bitwidth, CarmichaelShift(Bitwidth));\n-    // Any weight W >= Threshold can be replaced with W - CM.\n-    APInt Threshold = CM + Bitwidth;\n-    assert(LHS.ult(Threshold) && RHS.ult(Threshold) && \"Weights not reduced!\");\n-    // For Bitwidth 4 or more the following sum does not overflow.\n-    LHS += RHS;\n-    while (LHS.uge(Threshold))\n-      LHS -= CM;\n-  } else {\n-    // To avoid problems with overflow do everything the same as above but using\n-    // a larger type.\n-    unsigned CM = 1U << CarmichaelShift(Bitwidth);\n-    unsigned Threshold = CM + Bitwidth;\n-    assert(LHS.getZExtValue() < Threshold && RHS.getZExtValue() < Threshold &&\n-           \"Weights not reduced!\");\n-    unsigned Total = LHS.getZExtValue() + RHS.getZExtValue();\n-    while (Total >= Threshold)\n-      Total -= CM;\n-    LHS = Total;\n-  }\n-}\n-\n using RepeatedValue = std::pair<Value*, APInt>;\n \n /// Given an associative binary expression, return the leaf\n@@ -562,26 +471,7 @@ static bool LinearizeExprTree(Instruction *I,\n                \"In leaf map but not visited!\");\n \n         // Update the number of paths to the leaf.\n-        IncorporateWeight(It->second, Weight, Opcode);\n-\n-#if 0   // TODO: Re-enable once PR13021 is fixed.\n-        // The leaf already has one use from inside the expression.  As we want\n-        // exactly one such use, drop this new use of the leaf.\n-        assert(!Op->hasOneUse() && \"Only one use, but we got here twice!\");\n-        I->setOperand(OpIdx, UndefValue::get(I->getType()));\n-        Changed = true;\n-\n-        // If the leaf is a binary operation of the right kind and we now see\n-        // that its multiple original uses were in fact all by nodes belonging\n-        // to the expression, then no longer consider it to be a leaf and add\n-        // its operands to the expression.\n-        if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {\n-          LLVM_DEBUG(dbgs() << \"UNLEAF: \" << *Op << \" (\" << It->second << \")\\n\");\n-          Worklist.push_back(std::make_pair(BO, It->second));\n-          Leaves.erase(It);\n-          continue;\n-        }\n-#endif\n+        It->second += Weight;\n \n         // If we still have uses that are not accounted for by the expression\n         // then it is not safe to modify the value.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/Reassociate/repeats.ll",
      "commands": [
        "opt < %s -passes=reassociate -S"
      ],
      "tests": [
        {
          "test_name": "foo4x13",
          "test_body": "define i4 @foo4x13(i4 %x) {\n  %tmp1 = mul i4 %x, %x\n  %tmp2 = mul i4 %tmp1, %x\n  %tmp3 = mul i4 %tmp2, %x\n  %tmp4 = mul i4 %tmp3, %x\n  %tmp5 = mul i4 %tmp4, %x\n  %tmp6 = mul i4 %tmp5, %x\n  %tmp7 = mul i4 %tmp6, %x\n  %tmp8 = mul i4 %tmp7, %x\n  %tmp9 = mul i4 %tmp8, %x\n  %tmp10 = mul i4 %tmp9, %x\n  %tmp11 = mul i4 %tmp10, %x\n  %tmp12 = mul i4 %tmp11, %x\n  ret i4 %tmp12\n}\n"
        },
        {
          "test_name": "foo3x7",
          "test_body": "define i3 @foo3x7(i3 %x) {\n  %tmp1 = mul i3 %x, %x\n  %tmp2 = mul i3 %tmp1, %x\n  %tmp3 = mul i3 %tmp2, %x\n  %tmp4 = mul i3 %tmp3, %x\n  %tmp5 = mul i3 %tmp4, %x\n  %tmp6 = mul i3 %tmp5, %x\n  ret i3 %tmp6\n}\n"
        },
        {
          "test_name": "foo4x10",
          "test_body": "define i4 @foo4x10(i4 %x) {\n  %tmp1 = mul i4 %x, %x\n  %tmp2 = mul i4 %tmp1, %x\n  %tmp3 = mul i4 %tmp2, %x\n  %tmp4 = mul i4 %tmp3, %x\n  %tmp5 = mul i4 %tmp4, %x\n  %tmp6 = mul i4 %tmp5, %x\n  %tmp7 = mul i4 %tmp6, %x\n  %tmp8 = mul i4 %tmp7, %x\n  %tmp9 = mul i4 %tmp8, %x\n  ret i4 %tmp9\n}\n"
        },
        {
          "test_name": "foo4x8",
          "test_body": "define i4 @foo4x8(i4 %x) {\n  %tmp1 = mul i4 %x, %x\n  %tmp2 = mul i4 %tmp1, %x\n  %tmp3 = mul i4 %tmp2, %x\n  %tmp4 = mul i4 %tmp3, %x\n  %tmp5 = mul i4 %tmp4, %x\n  %tmp6 = mul i4 %tmp5, %x\n  %tmp7 = mul i4 %tmp6, %x\n  ret i4 %tmp7\n}\n"
        },
        {
          "test_name": "foo4x14",
          "test_body": "define i4 @foo4x14(i4 %x) {\n  %tmp1 = mul i4 %x, %x\n  %tmp2 = mul i4 %tmp1, %x\n  %tmp3 = mul i4 %tmp2, %x\n  %tmp4 = mul i4 %tmp3, %x\n  %tmp5 = mul i4 %tmp4, %x\n  %tmp6 = mul i4 %tmp5, %x\n  %tmp7 = mul i4 %tmp6, %x\n  %tmp8 = mul i4 %tmp7, %x\n  %tmp9 = mul i4 %tmp8, %x\n  %tmp10 = mul i4 %tmp9, %x\n  %tmp11 = mul i4 %tmp10, %x\n  %tmp12 = mul i4 %tmp11, %x\n  %tmp13 = mul i4 %tmp12, %x\n  ret i4 %tmp13\n}\n"
        },
        {
          "test_name": "foo4x9",
          "test_body": "define i4 @foo4x9(i4 %x) {\n  %tmp1 = mul i4 %x, %x\n  %tmp2 = mul i4 %tmp1, %x\n  %tmp3 = mul i4 %tmp2, %x\n  %tmp4 = mul i4 %tmp3, %x\n  %tmp5 = mul i4 %tmp4, %x\n  %tmp6 = mul i4 %tmp5, %x\n  %tmp7 = mul i4 %tmp6, %x\n  %tmp8 = mul i4 %tmp7, %x\n  ret i4 %tmp8\n}\n"
        },
        {
          "test_name": "foo4x12",
          "test_body": "define i4 @foo4x12(i4 %x) {\n  %tmp1 = mul i4 %x, %x\n  %tmp2 = mul i4 %tmp1, %x\n  %tmp3 = mul i4 %tmp2, %x\n  %tmp4 = mul i4 %tmp3, %x\n  %tmp5 = mul i4 %tmp4, %x\n  %tmp6 = mul i4 %tmp5, %x\n  %tmp7 = mul i4 %tmp6, %x\n  %tmp8 = mul i4 %tmp7, %x\n  %tmp9 = mul i4 %tmp8, %x\n  %tmp10 = mul i4 %tmp9, %x\n  %tmp11 = mul i4 %tmp10, %x\n  ret i4 %tmp11\n}\n"
        },
        {
          "test_name": "foo4x11",
          "test_body": "define i4 @foo4x11(i4 %x) {\n  %tmp1 = mul i4 %x, %x\n  %tmp2 = mul i4 %tmp1, %x\n  %tmp3 = mul i4 %tmp2, %x\n  %tmp4 = mul i4 %tmp3, %x\n  %tmp5 = mul i4 %tmp4, %x\n  %tmp6 = mul i4 %tmp5, %x\n  %tmp7 = mul i4 %tmp6, %x\n  %tmp8 = mul i4 %tmp7, %x\n  %tmp9 = mul i4 %tmp8, %x\n  %tmp10 = mul i4 %tmp9, %x\n  ret i4 %tmp10\n}\n"
        },
        {
          "test_name": "foo3x5",
          "test_body": "define i3 @foo3x5(i3 %x) {\n  %tmp1 = mul i3 %x, %x\n  %tmp2 = mul i3 %tmp1, %x\n  %tmp3 = mul i3 %tmp2, %x\n  %tmp4 = mul i3 %tmp3, %x\n  ret i3 %tmp4\n}\n"
        },
        {
          "test_name": "foo3x6",
          "test_body": "define i3 @foo3x6(i3 %x) {\n  %tmp1 = mul i3 %x, %x\n  %tmp2 = mul i3 %tmp1, %x\n  %tmp3 = mul i3 %tmp2, %x\n  %tmp4 = mul i3 %tmp3, %x\n  %tmp5 = mul i3 %tmp4, %x\n  ret i3 %tmp5\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "incorrect reassociation at low bitwidth",
    "body": "here's a function:\r\n```llvm\r\ndefine i3 @f(i3 %0) {\r\n  %2 = mul i3 %0, %0\r\n  %3 = mul i3 %2, %0\r\n  %4 = mul i3 %3, %0\r\n  %5 = mul nsw i3 %4, %0\r\n  ret i3 %5\r\n}\r\n```\r\n\r\nreassociate seems to be getting it wrong:\r\n```\r\nJohns-MacBook-Pro:reduce regehr$ ~/alive2-regehr/build/alive-tv reduced.ll -passes=reassociate\r\n\r\n----------------------------------------\r\ndefine i3 @f(i3 %#0) {\r\n#1:\r\n  %#2 = mul i3 %#0, %#0\r\n  %#3 = mul i3 %#2, %#0\r\n  %#4 = mul i3 %#3, %#0\r\n  %#5 = mul nsw i3 %#4, %#0\r\n  ret i3 %#5\r\n}\r\n=>\r\ndefine i3 @f(i3 %#0) {\r\n#1:\r\n  %#2 = mul i3 %#0, %#0\r\n  %#3 = mul nsw i3 %#2, %#0\r\n  ret i3 %#3\r\n}\r\nTransformation doesn't verify!\r\n\r\nERROR: Target is more poisonous than source\r\n\r\nExample:\r\ni3 %#0 = #x6 (6, -2)\r\n\r\nSource:\r\ni3 %#2 = #x4 (4, -4)\r\ni3 %#3 = #x0 (0)\r\ni3 %#4 = #x0 (0)\r\ni3 %#5 = #x0 (0)\r\n\r\nTarget:\r\ni3 %#2 = #x4 (4, -4)\r\ni3 %#3 = poison\r\nSource value: #x0 (0)\r\nTarget value: poison\r\n\r\nSummary:\r\n  0 correct transformations\r\n  1 incorrect transformations\r\n  0 failed-to-prove transformations\r\n  0 Alive2 errors\r\nJohns-MacBook-Pro:reduce regehr$ \r\n```\r\n\r\ncc @nunoplopes ",
    "author": "regehr",
    "labels": [
      "miscompilation",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "Introduced by https://github.com/llvm/llvm-project/commit/d7aeefebd6b049f017711cd7c6ef5f217a17b673.\r\n"
      }
    ]
  }
}