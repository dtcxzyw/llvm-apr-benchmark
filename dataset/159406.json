{
  "bug_id": "159406",
  "issue_url": "https://github.com/llvm/llvm-project/issues/159406",
  "bug_type": "crash",
  "base_commit": "3e0c58be49c81931daf285c0973db5fb763e51e4",
  "knowledge_cutoff": "2025-09-17T17:14:39Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "8c41859a21a4d0cfda164cc58f4a5336dbcd30d1",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          20804,
          20815
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::BlockScheduling::tryScheduleBundle"
      ]
    }
  },
  "patch": "commit 8c41859a21a4d0cfda164cc58f4a5336dbcd30d1\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Thu Sep 18 06:20:43 2025 -0700\n\n    [SLP]Clear the operands deps of non-schedulable nodes, if previously all operands were copyable\n    \n    If all operands of the non-schedulable nodes were previously only\n    copyables, need to clear the dependencies of the original schedule data\n    for such copyable operands and recalculate them to correctly handle\n      number of dependecies.\n    \n    Fixes #159406\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 0c94a1d593ce..6ac9018df641 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -20804,12 +20804,45 @@ BoUpSLP::BlockScheduling::tryScheduleBundle(ArrayRef<Value *> VL, BoUpSLP *SLP,\n                                             const EdgeInfo &EI) {\n   // No need to schedule PHIs, insertelement, extractelement and extractvalue\n   // instructions.\n-  bool HasCopyables = S.areInstructionsWithCopyableElements();\n   if (isa<PHINode>(S.getMainOp()) ||\n-      isVectorLikeInstWithConstOps(S.getMainOp()) ||\n-      (!HasCopyables && doesNotNeedToSchedule(VL)) ||\n-      all_of(VL, [&](Value *V) { return S.isNonSchedulable(V); }))\n+      isVectorLikeInstWithConstOps(S.getMainOp()))\n+    return nullptr;\n+  bool HasCopyables = S.areInstructionsWithCopyableElements();\n+  if (((!HasCopyables && doesNotNeedToSchedule(VL)) ||\n+       all_of(VL, [&](Value *V) { return S.isNonSchedulable(V); }))) {\n+    // If all operands were replaced by copyables, the operands of this node\n+    // might be not, so need to recalculate dependencies for schedule data,\n+    // replaced by copyable schedule data.\n+    SmallVector<ScheduleData *> ControlDependentMembers;\n+    for (Value *V : VL) {\n+      auto *I = dyn_cast<Instruction>(V);\n+      if (!I || (HasCopyables && S.isCopyableElement(V)))\n+        continue;\n+      SmallDenseMap<std::pair<Instruction *, Value *>, unsigned> UserOpToNumOps;\n+      for (const Use &U : I->operands()) {\n+        unsigned &NumOps =\n+            UserOpToNumOps.try_emplace(std::make_pair(I, U.get()), 0)\n+                .first->getSecond();\n+        ++NumOps;\n+        if (auto *Op = dyn_cast<Instruction>(U.get());\n+            Op && areAllOperandsReplacedByCopyableData(I, Op, *SLP, NumOps)) {\n+          if (ScheduleData *OpSD = getScheduleData(Op);\n+              OpSD && OpSD->hasValidDependencies()) {\n+            OpSD->clearDirectDependencies();\n+            if (RegionHasStackSave ||\n+                !isGuaranteedToTransferExecutionToSuccessor(OpSD->getInst()))\n+              ControlDependentMembers.push_back(OpSD);\n+          }\n+        }\n+      }\n+    }\n+    if (!ControlDependentMembers.empty()) {\n+      ScheduleBundle Invalid = ScheduleBundle::invalid();\n+      calculateDependencies(Invalid, /*InsertInReadyList=*/true, SLP,\n+                            ControlDependentMembers);\n+    }\n     return nullptr;\n+  }\n \n   // Initialize the instruction bundle.\n   Instruction *OldScheduleEnd = ScheduleEnd;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/non-sched-inst-has-copyable-before.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=x86_64-cros-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n%struct.fe = type { [5 x i64] }\n\ndefine i32 @test(i64 %0, i128 %1, i1 %2) {\n;\n  %4 = alloca %struct.fe, align 8\n  %5 = getelementptr inbounds nuw i8, ptr %4, i64 16\n  %6 = getelementptr inbounds nuw i8, ptr %4, i64 24\n  %7 = getelementptr inbounds nuw i8, ptr %4, i64 32\n  %8 = getelementptr inbounds nuw i8, ptr %4, i64 8\n  br label %9\n\n9:\n  %10 = phi i64 [ undef, %3 ], [ %29, %9 ]\n  %11 = phi i64 [ undef, %3 ], [ %26, %9 ]\n  %12 = phi i64 [ undef, %3 ], [ %23, %9 ]\n  %13 = phi i64 [ undef, %3 ], [ %20, %9 ]\n  %14 = phi i64 [ undef, %3 ], [ %17, %9 ]\n  %.sroa.14.0 = phi i64 [ undef, %3 ], [ %52, %9 ]\n  %.sroa.11.0 = phi i64 [ undef, %3 ], [ %50, %9 ]\n  %.sroa.8.0 = phi i64 [ undef, %3 ], [ %57, %9 ]\n  %.sroa.4.0 = phi i64 [ undef, %3 ], [ %56, %9 ]\n  %.sroa.0.0 = phi i64 [ undef, %3 ], [ %54, %9 ]\n  %15 = xor i64 %.sroa.0.0, %14\n  %16 = and i64 %15, %0\n  %17 = xor i64 %16, 1\n  store i64 %17, ptr %4, align 8\n  %18 = xor i64 %.sroa.4.0, %13\n  %19 = and i64 %18, %0\n  %20 = xor i64 %19, 1\n  store i64 %20, ptr %8, align 8\n  %21 = xor i64 %.sroa.8.0, %12\n  %22 = and i64 %21, %0\n  %23 = xor i64 %22, 1\n  store i64 %23, ptr %5, align 8\n  %24 = xor i64 %.sroa.11.0, %11\n  %25 = and i64 %24, %0\n  %26 = xor i64 %25, 1\n  store i64 %26, ptr %6, align 8\n  %27 = xor i64 %.sroa.14.0, %10\n  %28 = and i64 %27, %0\n  %29 = xor i64 %28, 1\n  store i64 %29, ptr %7, align 8\n  %30 = load i64, ptr null, align 4294967296\n  %31 = or i64 %19, 1\n  %32 = or i64 %16, 1\n  %33 = add i64 %17, 1\n  %34 = mul i64 %29, 19\n  %35 = zext i64 %34 to i128\n  %36 = mul i64 %26, 19\n  %37 = zext i64 %36 to i128\n  %38 = mul i64 %23, 19\n  %39 = zext i64 %38 to i128\n  %40 = mul nuw nsw i128 %39, 24\n  %41 = zext i64 %32 to i128\n  %42 = mul nuw i128 %37, %41\n  %43 = zext i64 %31 to i128\n  %44 = mul nuw i128 %35, %43\n  %45 = zext i64 %33 to i128\n  %46 = mul i128 %1, %45\n  %47 = add i128 %40, %46\n  %48 = add i128 %47, %42\n  %49 = add i128 %48, %44\n  %50 = and i64 %29, 1\n  %51 = trunc i128 %49 to i64\n  %52 = and i64 %30, 1\n  %53 = add i64 %51, 1\n  %54 = and i64 %53, 1\n  %55 = lshr i64 %53, 1\n  %56 = and i64 %19, 1\n  %57 = or i64 %55, 1\n  br i1 %2, label %58, label %9\n\n58:\n  call void @g(ptr nonnull %4)\n  ret i32 0\n}\n\ndeclare void @g(ptr)\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Crash after 57cae2b6a275a8eb3bc8935973263ed84535fb81",
    "body": "```\n$ cat /tmp/a.ll\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-cros-linux-gnu\"\n                                                                            \n%struct.fe = type { [5 x i64] }\n                                                                            \ndefine i32 @f(i64 %0, i128 %1, i1 %2) {\n  %4 = alloca %struct.fe, align 8\n  %5 = getelementptr inbounds nuw i8, ptr %4, i64 16\n  %6 = getelementptr inbounds nuw i8, ptr %4, i64 24\n  %7 = getelementptr inbounds nuw i8, ptr %4, i64 32\n  %8 = getelementptr inbounds nuw i8, ptr %4, i64 8\n  br label %9                            \n\n9:                                                ; preds = %9, %3\n  %10 = phi i64 [ undef, %3 ], [ %29, %9 ]\n  %11 = phi i64 [ undef, %3 ], [ %26, %9 ]\n  %12 = phi i64 [ undef, %3 ], [ %23, %9 ]\n  %13 = phi i64 [ undef, %3 ], [ %20, %9 ]\n  %14 = phi i64 [ undef, %3 ], [ %17, %9 ]\n  %.sroa.14.0 = phi i64 [ undef, %3 ], [ %52, %9 ]\n  %.sroa.11.0 = phi i64 [ undef, %3 ], [ %50, %9 ]\n  %.sroa.8.0 = phi i64 [ undef, %3 ], [ %57, %9 ]\n  %.sroa.4.0 = phi i64 [ undef, %3 ], [ %56, %9 ]\n  %.sroa.0.0 = phi i64 [ undef, %3 ], [ %54, %9 ]\n  %15 = xor i64 %.sroa.0.0, %14\n  %16 = and i64 %15, %0\n  %17 = xor i64 %16, 1\n  store i64 %17, ptr %4, align 8\n  %18 = xor i64 %.sroa.4.0, %13\n  %19 = and i64 %18, %0\n  %20 = xor i64 %19, 1\n  store i64 %20, ptr %8, align 8\n  %21 = xor i64 %.sroa.8.0, %12\n  %22 = and i64 %21, %0\n  %23 = xor i64 %22, 1\n  store i64 %23, ptr %5, align 8\n  %24 = xor i64 %.sroa.11.0, %11\n  %25 = and i64 %24, %0\n  %26 = xor i64 %25, 1\n  store i64 %26, ptr %6, align 8\n  %27 = xor i64 %.sroa.14.0, %10\n  %28 = and i64 %27, %0\n  %29 = xor i64 %28, 1\n  store i64 %29, ptr %7, align 8\n  %30 = load i64, ptr null, align 4294967296\n  %31 = or i64 %19, 1\n  %32 = or i64 %16, 1\n  %33 = add i64 %17, 1\n  %34 = mul i64 %29, 19\n  %35 = zext i64 %34 to i128\n  %36 = mul i64 %26, 19\n  %37 = zext i64 %36 to i128\n  %38 = mul i64 %23, 19\n  %39 = zext i64 %38 to i128\n  %40 = mul nuw nsw i128 %39, 24\n  %41 = zext i64 %32 to i128\n  %42 = mul nuw i128 %37, %41\n  %43 = zext i64 %31 to i128\n  %44 = mul nuw i128 %35, %43\n  %45 = zext i64 %33 to i128\n  %46 = mul i128 %1, %45\n  %47 = add i128 %40, %46\n  %48 = add i128 %47, %42\n  %49 = add i128 %48, %44\n  %50 = and i64 %29, 1\n  %51 = trunc i128 %49 to i64\n  %52 = and i64 %30, 1\n  %53 = add i64 %51, 1\n  %54 = and i64 %53, 1\n  %55 = lshr i64 %53, 1\n  %56 = and i64 %19, 1\n  %57 = or i64 %55, 1\n  br i1 %2, label %58, label %9\n\n58:                                               ; preds = %9\n  call void @g(ptr nonnull %4)\n  ret i32 0\n}\n\ndeclare void @g(ptr)\n\n$ opt -p slp-vectorizer -disable-output /tmp/a.ll\nopt: ../../llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:20859: auto llvm::slpvectorizer::BoUpSLP::BlockScheduling::tryScheduleBundle(ArrayRef<Value *>, BoUpSLP *, const InstructionsState &, const EdgeInfo &)::(anonymous class)::operator()(bool, ScheduleBundle &) const: Assertion `Picked->isReady() && \"m\nust be ready to schedule\"' failed.                                                                                                                                                                                                                                                                                 \n```\n\n@alexey-bataev ",
    "author": "aeubanks",
    "labels": [
      "llvm:SLPVectorizer",
      "crash"
    ],
    "comments": [
      {
        "author": "nico",
        "body": "linkify 57cae2b6a275a8eb3bc8935973263ed84535fb81\n\nref #147366"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true,
  "bisect": "fd93dc5ac515557f30c9a569c73f6ebfd9b3039b"
}