{
  "bug_id": "158259",
  "issue_url": "https://github.com/llvm/llvm-project/issues/158259",
  "bug_type": "crash",
  "base_commit": "da315a3528807574d1c9ba44758d35bfc515e709",
  "knowledge_cutoff": "2025-09-12T09:57:14Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "45ce88758d24df7c2c322b152cf4894f3e8ee45a",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          1762,
          1770
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "GeneratedRTChecks"
      ]
    }
  },
  "patch": "commit 45ce88758d24df7c2c322b152cf4894f3e8ee45a\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Tue Sep 30 11:03:55 2025 +0100\n\n    [LV] Don't preserve LCSSA in SCEVExpander for runtime checks. (#159556)\n    \n    LV does not preserve LCSSA, it constructs it just before processing a\n    loop to vectorize. Runtime check expressions are invariant to that loop,\n    so expanding them should not break LCSSA form for the loop we are about\n    to vectorize.\n    \n    This fixes a crash when discarding instructions generated when expanding\n    runtime checks, if the expansion introduces LCSSA phis for values from\n    other loops which are not in LCSSA form: we would introduce new LCSSA\n    phis and update all outside users, some of which are not created by the\n    expander and cannot be cleaned up.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/158259.\n    \n    PR: https://github.com/llvm/llvm-project/pull/159556\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex ab5c9c99b944..a0043bed2e0c 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -1762,9 +1762,10 @@ public:\n   GeneratedRTChecks(PredicatedScalarEvolution &PSE, DominatorTree *DT,\n                     LoopInfo *LI, TargetTransformInfo *TTI,\n                     const DataLayout &DL, TTI::TargetCostKind CostKind)\n-      : DT(DT), LI(LI), TTI(TTI), SCEVExp(*PSE.getSE(), DL, \"scev.check\"),\n-        MemCheckExp(*PSE.getSE(), DL, \"scev.check\"), PSE(PSE),\n-        CostKind(CostKind) {}\n+      : DT(DT), LI(LI), TTI(TTI),\n+        SCEVExp(*PSE.getSE(), DL, \"scev.check\", /*PreserveLCSSA=*/false),\n+        MemCheckExp(*PSE.getSE(), DL, \"scev.check\", /*PreserveLCSSA=*/false),\n+        PSE(PSE), CostKind(CostKind) {}\n \n   /// Generate runtime checks in SCEVCheckBlock and MemCheckBlock, so we can\n   /// accurately estimate the cost of the runtime checks. The blocks are\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cleanup-runtime-checks.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare ptr @get()\ndeclare i1 @cond()\n\n; Make sure we can clean up the created runtime checks, if vectorization isn't\n; profitable.\ndefine void @widget(i32 %arg, i64 %arg1, ptr %src) #0 {\n;\nentry:\n  br label %loop.1.header\n\nloop.1.header:\n  br label %inner.1\n\ninner.1:\n  %c.1 = call i1 @cond()\n  br i1 %c.1, label %inner.2, label %inner.1\n\ninner.2:\n  %load = call ptr @get()\n  %c.2 = call i1 @cond()\n  br i1 %c.2, label %loop.2, label %loop.1.latch\n\nloop.1.latch:\n  br label %loop.1.header\n\nloop.2:\n  %iv = phi i32 [ %arg, %inner.2 ], [ %iv.next, %loop.2 ]\n  %phi8 = phi i32 [ 99, %inner.2 ], [ %or, %loop.2 ]\n  %gep.src = getelementptr i32, ptr  %src, i32 %iv\n  %l = load i32, ptr %gep.src, align 4\n  %or = or i32 %phi8, %l\n  store i32 %or, ptr %load, align 4\n  %iv.next = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 100\n  br i1 %ec, label %exit, label %loop.2, !prof !0\n\nexit:\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+avx2\" }\n!0 = !{!\"branch_weights\", i32 89478484, i32 1879048192}\n;.\n;."
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/pr45259.ll",
      "commands": [
        "opt < %s -S -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1"
      ],
      "tests": [
        {
          "test_name": "widget",
          "test_body": "define i8 @widget(ptr %arr, i8 %t9) {\nbb:\n  br label %bb6\n\nbb6:                                              ; preds = %bb6, %bb\n  %t1.0 = phi ptr [ %arr, %bb ], [ null, %bb6 ]\n  %c = call i1 @cond()\n  br i1 %c, label %for.preheader, label %bb6\n\nfor.preheader:                                    ; preds = %bb6\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.preheader\n  %iv = phi i8 [ %iv.next, %for.body ], [ 0, %for.preheader ]\n  %iv.next = add i8 %iv, 1\n  %ptr = getelementptr inbounds i8, ptr %arr, i8 %iv.next\n  %t3.i = icmp slt i8 %iv.next, %t9\n  %t3.i8 = zext i1 %t3.i to i8\n  store i8 %t3.i8, ptr %ptr, align 1\n  %ec = icmp eq ptr %t1.0, %ptr\n  br i1 %ec, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  %iv.next.lcssa = phi i8 [ %iv.next, %for.body ]\n  ret i8 %iv.next.lcssa\n}\n\ndeclare i1 @cond()\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/pr47343-expander-lcssa-after-cfg-update.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=2 %s -S"
      ],
      "tests": [
        {
          "test_name": "f",
          "test_body": "@f.e = external global i32, align 1\n@d = external global ptr, align 1\n\ndeclare i1 @cond()\n\ndefine void @f() {\nentry:\n  br label %outer.header\n\nouter.header:                                     ; preds = %outer.latch, %entry\n  %0 = load ptr, ptr @d, align 1\n  %c.0 = call i1 @cond()\n  br i1 %c.0, label %outer.exit.0, label %inner.1.header\n\ninner.1.header:                                   ; preds = %inner.1.latch, %outer.header\n  %c.1 = call i1 @cond()\n  br i1 %c.1, label %inner.1.latch, label %outer.latch\n\ninner.1.latch:                                    ; preds = %inner.1.header\n  %c.2 = call i1 @cond()\n  br i1 %c.2, label %outer.exit.1, label %inner.1.header\n\nouter.latch:                                      ; preds = %inner.1.header\n  br label %outer.header\n\nouter.exit.0:                                     ; preds = %outer.header\n  br label %loop\n\nouter.exit.1:                                     ; preds = %inner.1.latch\n  br label %loop\n\nloop:                                             ; preds = %loop, %outer.exit.1, %outer.exit.0\n  %iv = phi i32 [ %iv.next, %loop ], [ 0, %outer.exit.0 ], [ 0, %outer.exit.1 ]\n  %conv6.us.us.us = zext i1 false to i32\n  store i32 %conv6.us.us.us, ptr @f.e, align 1\n  store i8 10, ptr %0, align 1\n  %iv.next = add nsw i32 %iv, 1\n  %ec = icmp eq i32 %iv.next, 500\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/reuse-lcssa-phi-scev-expansion.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "runtime_checks_ptr_inductions",
          "test_body": "declare i32 @val()\n\ndefine void @runtime_checks_ptr_inductions(ptr %dst.1, ptr %dst.2, i1 %c) {\nentry:\n  br label %loop.1\n\nloop.1:                                           ; preds = %loop.1, %entry\n  %ptr.iv.1 = phi ptr [ %dst.1, %entry ], [ %ptr.iv.1.next, %loop.1 ]\n  %call = call i32 @val()\n  %sel.dst = select i1 %c, ptr %dst.1, ptr %dst.2\n  %ptr.iv.1.next = getelementptr i8, ptr %ptr.iv.1, i64 1\n  %ec.1 = icmp eq i32 %call, 0\n  br i1 %ec.1, label %loop.2.header, label %loop.1\n\nloop.2.header:                                    ; preds = %loop.2.latch, %loop.1\n  %iv = phi i32 [ 1, %loop.1 ], [ %dec7, %loop.2.latch ]\n  %ptr.iv.2 = phi ptr [ %ptr.iv.1, %loop.1 ], [ %ptr.iv.2.next, %loop.2.latch ]\n  %ptr.iv.3 = phi ptr [ %sel.dst, %loop.1 ], [ %ptr.iv.3.next, %loop.2.latch ]\n  %ec.2 = icmp eq i32 %iv, 1024\n  br i1 %ec.2, label %exit, label %loop.2.latch\n\nloop.2.latch:                                     ; preds = %loop.2.header\n  %dec7 = add i32 %iv, 1\n  %ptr.iv.3.next = getelementptr i8, ptr %ptr.iv.3, i64 1\n  %l = load i8, ptr %ptr.iv.3, align 1\n  %ptr.iv.2.next = getelementptr i8, ptr %ptr.iv.2, i64 1\n  store i8 %l, ptr %ptr.iv.2, align 1\n  br label %loop.2.header\n\nexit:                                             ; preds = %loop.2.header\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/skeleton-lcssa-crash.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=2 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define i16 @test(ptr %arg, i64 %N) {\nentry:\n  br label %outer\n\nouter:                                            ; preds = %outer.latch, %outer, %entry\n  %l.1 = load ptr, ptr %arg, align 8\n  %l.2 = load ptr, ptr %arg, align 8\n  %c.1 = call i1 @cond()\n  br i1 %c.1, label %outer, label %inner\n\ninner:                                            ; preds = %inner.latch, %outer\n  %c.2 = call i1 @cond()\n  br i1 %c.2, label %outer.latch, label %inner.bb\n\ninner.bb:                                         ; preds = %inner\n  %c.3 = call i1 @cond()\n  br i1 %c.3, label %loop.3, label %inner.latch\n\ninner.latch:                                      ; preds = %inner.bb\n  %c.4 = call i1 @cond()\n  br i1 %c.4, label %exit, label %inner\n\nouter.latch:                                      ; preds = %inner\n  br label %outer\n\nloop.3:                                           ; preds = %loop.3, %inner.bb\n  %iv = phi i64 [ %iv.next, %loop.3 ], [ 0, %inner.bb ]\n  %iv.next = add nuw nsw i64 %iv, 1\n  %c.5 = icmp ult i64 %iv, %N\n  %gep.1 = getelementptr inbounds i16, ptr %l.1, i64 %iv.next\n  %loop.l.1 = load i16, ptr %gep.1, align 2\n  %gep.2 = getelementptr inbounds i16, ptr %l.2, i64 0\n  store i16 %loop.l.1, ptr %gep.2, align 2\n  br i1 %c.5, label %loop.3, label %exit\n\nexit:                                             ; preds = %loop.3, %inner.latch\n  %l.3 = load i16, ptr %l.1, align 2\n  ret i16 %l.3\n}\n\ndeclare i1 @cond()\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "LoopVectorizer crashes in SCEVExpanderCleanup",
    "body": "Assert in vectorizer during SCEVExpanderCleanup: https://godbolt.org/z/Ezcf68T85\n\nAssert message:\n\n```\nopt: .../llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:2466: void llvm::SCEVExpanderCleaner::cleanup(): Assertion `all_of(I->users(), [&InsertedSet](Value *U) { return InsertedSet.contains(cast<Instruction>(U)); }) && \"removed instruction should only be used by instructions inserted \" \"during expansion\"' failed.\n```\n\nIR reproducer:\n\n```llvm\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @widget(i32 %arg, i64 %arg1) #0 {\nbb:\n  br label %bb2\nbb2:                                              ; preds = %bb4, %bb\n  br label %bb5\nbb3:                                              ; preds = %bb5\n  %load = load ptr addrspace(1), ptr null, align 8%getelementptr = getelementptr i32, ptr addrspace(1) null, i64 %arg1\n  br i1 false, label %bb7, label %bb4\nbb4:                                              ; preds = %bb3\n  br label %bb2\nbb5:                                              ; preds = %bb5, %bb2\n  br i1 false, label %bb3, label %bb5\nbb6:                                              ; preds = %bb7\n  ret void\nbb7:                                              ; preds = %bb7, %bb3\n  %phi = phi i32 [ %add, %bb7 ], [ %arg, %bb3 ]\n  %phi8 = phi i32 [ %or, %bb7 ], [ 0, %bb3 ]\n  %load9 = load i32, ptr addrspace(1) %getelementptr, align 4\n  %or = or i32 %phi8, 0\n  store i32 %or, ptr addrspace(1) %load, align 4\n  %add = add i32 %phi, 1\n  %icmp = icmp eq i32 %phi, 0\n  br i1 %icmp, label %bb6, label %bb7, !prof !0\n}\nattributes #0 = { \"target-features\"=\"+avx2\" }\n!0 = !{!\"branch_weights\", i32 89478484, i32 1879048192}\n```\nRun as: `opt -passes=loop-vectorize`\n",
    "author": "Theodor",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "hiraditya",
        "body": "Stack trace\n```\nopt: /root/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:2466: void llvm::SCEVExpanderCleaner::cleanup(): Assertion `all_of(I->users(), [&InsertedSet](Value *U) { return InsertedSet.contains(cast<Instruction>(U)); }) && \"removed instruction should only be used by instructions inserted \" \"during expansion\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=loop-vectorize <source>\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"<source>\"\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"widget\"\n #0 0x00000000058aae78 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x58aae78)\n #1 0x00000000058a7d24 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x000073e015642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x000073e0156969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x000073e015642476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x000073e0156287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x000073e01562871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x000073e015639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x0000000004b3a12f llvm::SCEVExpanderCleaner::cleanup() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4b3a12f)\n #9 0x00000000035ed532 (anonymous namespace)::GeneratedRTChecks::~GeneratedRTChecks() LoopVectorize.cpp:0:0\n#10 0x00000000036409aa llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36409aa)\n```"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}