{
  "bug_id": "110440",
  "issue_url": "https://github.com/llvm/llvm-project/issues/110440",
  "bug_type": "crash",
  "base_commit": "586736226e3a25b1fd647d3257270c1388f907bf",
  "knowledge_cutoff": "2024-09-29T21:20:15Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "6d6eea92e36c301e34a7ec11b2a40e3080f79f53",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          8420,
          8440
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "VPRecipeBuilder::tryToWidenHistogram"
      ]
    }
  },
  "patch": "commit 6d6eea92e36c301e34a7ec11b2a40e3080f79f53\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Wed Oct 2 13:45:48 2024 +0100\n\n    [LV] Use SCEV to simplify wide binop operand to constant.\n    \n    The legacy cost model uses SCEV to determine if the second operand of a\n    binary op is a constant. Update the VPlan construction logic to mirror\n    the current legacy behavior, to fix a difference in the cost models.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/109528.\n    Fixes https://github.com/llvm/llvm-project/issues/110440.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex e1f9f29ac6d9..de3b981a4fe3 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -8420,21 +8420,28 @@ VPWidenRecipe *VPRecipeBuilder::tryToWiden(Instruction *I,\n   case Instruction::Sub:\n   case Instruction::Xor:\n   case Instruction::Freeze:\n-    if (I->getOpcode() == Instruction::Mul) {\n-      // Simplify operands of multiplications using SCEV. This is needed at the\n-      // moment to match the behavior of the legacy cost-model.\n-      // TODO: Generalize to any opcode and move to VPlan transformation.\n-      SmallVector<VPValue *> NewOps(Operands);\n+    SmallVector<VPValue *> NewOps(Operands);\n+    if (Instruction::isBinaryOp(I->getOpcode())) {\n+      // The legacy cost model uses SCEV to check if some of the operands are\n+      // constants. To match the legacy cost model's behavior, use SCEV to try\n+      // to replace operands with constants.\n       ScalarEvolution &SE = *PSE.getSE();\n-      for (unsigned I = 0; I < Operands.size(); ++I) {\n-        Value *V = NewOps[I]->getUnderlyingValue();\n-        if (!isa<Constant>(V) && SE.isSCEVable(V->getType()))\n-          if (auto *C = dyn_cast<SCEVConstant>(PSE.getSE()->getSCEV(V)))\n-            NewOps[I] = Plan.getOrAddLiveIn(C->getValue());\n-      }\n-      return new VPWidenRecipe(*I, make_range(NewOps.begin(), NewOps.end()));\n+      auto GetConstantViaSCEV = [this, &SE](VPValue *Op) {\n+        Value *V = Op->getUnderlyingValue();\n+        if (isa<Constant>(V) || !SE.isSCEVable(V->getType()))\n+          return Op;\n+        auto *C = dyn_cast<SCEVConstant>(SE.getSCEV(V));\n+        if (!C)\n+          return Op;\n+        return Plan.getOrAddLiveIn(C->getValue());\n+      };\n+      // For Mul, the legacy cost model checks both operands.\n+      if (I->getOpcode() == Instruction::Mul)\n+        NewOps[0] = GetConstantViaSCEV(NewOps[0]);\n+      // For other binops, the legacy cost model only checks the second operand.\n+      NewOps[1] = GetConstantViaSCEV(NewOps[1]);\n     }\n-    return new VPWidenRecipe(*I, make_range(Operands.begin(), Operands.end()));\n+    return new VPWidenRecipe(*I, make_range(NewOps.begin(), NewOps.end()));\n   };\n }\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-constant-known-via-scev.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "test_foldable_live_in_via_scev",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i64 @test_foldable_live_in_via_scev() {\nentry:\n  %conv = zext i16 -6 to i64\n  %add = add nsw i64 %conv, -65528\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 1, %entry ], [ %iv.next, %loop ]\n  %red = phi i64 [ 1, %entry ], [ %mul, %loop ]\n  %mul = mul nsw i64 %red, %add\n  %iv.next = add nsw i32 %iv, 1\n  %ec = icmp eq i32 %iv.next, 100\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  %ret = phi i64 [ %mul, %loop ]\n  ret i64 %ret\n}\n"
        },
        {
          "test_name": "second_lshr_operand_zero_via_scev",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i64 @second_lshr_operand_zero_via_scev() {\nentry:\n  %ext.0 = sext i8 0 to i32\n  br label %loops\n\nloops:                                            ; preds = %loops, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loops ]\n  %red = phi i64 [ 0, %entry ], [ %red.next, %loops ]\n  %c = icmp eq i64 %iv, 0\n  %and = and i64 %iv, 0\n  %0 = trunc i64 %iv to i32\n  %shr = lshr i32 %0, %ext.0\n  %conv.1 = zext i32 %shr to i64\n  %red.next.v = select i1 %c, i64 %and, i64 %conv.1\n  %red.next = or i64 %red.next.v, %red\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, 0\n  br i1 %ec, label %exit, label %loops\n\nexit:                                             ; preds = %loops\n  %res = phi i64 [ %red.next, %loops ]\n  ret i64 %res\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "clang crashes at -O3 on x86_64-linux-gnu: Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed ",
    "body": "Compiler Explorer: https://godbolt.org/z/Gfdabaqco\r\n\r\n```\r\n[509] % clangtk -v\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project.git 2c8836c899015cce49a399a6bc47b260a24a22e7)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /local/suz-local/software/local/clang-trunk/bin\r\nBuild config: +assertions\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/10\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/9\r\nSelected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11\r\nCandidate multilib: .;@m64\r\nSelected multilib: .;@m64\r\n[510] % \r\n[510] % clangtk -O3 -c small.c\r\nclangtk: /local/suz-local/software/clangbuild/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7386: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\r\nStack dump:\r\n0.\tProgram arguments: clangtk -I/usr/local/include -I/local/suz-local/software/local/include -O3 -c small.c\r\n1.\t<eof> parser at end of file\r\n2.\tOptimizer\r\n3.\tRunning pass \"function<eager-inv>(float2int,lower-constant-intrinsics,chr,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O3>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"small.c\"\r\n4.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"main\"\r\n #0 0x00005585b62c08df llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x43bc8df)\r\n #1 0x00005585b62be42c llvm::sys::CleanupOnSignal(unsigned long) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x43ba42c)\r\n #2 0x00005585b6207728 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0\r\n #3 0x00007fd5a3707420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)\r\n #4 0x00007fd5a313e00b raise /build/glibc-LcI20x/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise.c:51:1\r\n #5 0x00007fd5a311d859 abort /build/glibc-LcI20x/glibc-2.31/stdlib/abort.c:81:7\r\n #6 0x00007fd5a311d729 get_sysdep_segment_value /build/glibc-LcI20x/glibc-2.31/intl/loadmsgcat.c:509:8\r\n #7 0x00007fd5a311d729 _nl_load_domain /build/glibc-LcI20x/glibc-2.31/intl/loadmsgcat.c:970:34\r\n #8 0x00007fd5a312efd6 (/lib/x86_64-linux-gnu/libc.so.6+0x33fd6)\r\n #9 0x00005585b7c62959 llvm::LoopVectorizationPlanner::computeBestVF() (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x5d5e959)\r\n#10 0x00005585b7c7bf81 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x5d77f81)\r\n#11 0x00005585b7c7ede1 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x5d7ade1)\r\n#12 0x00005585b7c7f453 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x5d7b453)\r\n#13 0x00005585b77eb946 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x58e7946)\r\n#14 0x00005585b5c4d6b1 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x3d496b1)\r\n#15 0x00005585b37677f6 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x18637f6)\r\n#16 0x00005585b5c4c01d llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x3d4801d)\r\n#17 0x00005585b37663d6 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x18623d6)\r\n#18 0x00005585b5c4ba51 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x3d47a51)\r\n#19 0x00005585b6578d63 (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&, clang::BackendConsumer*) BackendUtil.cpp:0:0\r\n#20 0x00005585b657c338 clang::EmitBackendOutput(clang::DiagnosticsEngine&, clang::HeaderSearchOptions const&, clang::CodeGenOptions const&, clang::TargetOptions const&, clang::LangOptions const&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>, clang::BackendConsumer*) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4678338)\r\n#21 0x00005585b6c59f8c clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4d55f8c)\r\n#22 0x00005585b8afda6c clang::ParseAST(clang::Sema&, bool, bool) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x6bf9a6c)\r\n#23 0x00005585b6c5a3a8 clang::CodeGenAction::ExecuteAction() (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4d563a8)\r\n#24 0x00005585b6f21869 clang::FrontendAction::Execute() (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x501d869)\r\n#25 0x00005585b6e9dd3e clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4f99d3e)\r\n#26 0x00005585b700df56 clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x5109f56)\r\n#27 0x00005585b332e9d5 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x142a9d5)\r\n#28 0x00005585b33264ea ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\r\n#29 0x00005585b6ca005d void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()>(long) Job.cpp:0:0\r\n#30 0x00005585b6207c30 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4303c30)\r\n#31 0x00005585b6ca067f clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const (.part.0) Job.cpp:0:0\r\n#32 0x00005585b6c645d4 clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4d605d4)\r\n#33 0x00005585b6c656ed clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4d616ed)\r\n#34 0x00005585b6c6d6c5 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x4d696c5)\r\n#35 0x00005585b332b7ab clang_main(int, char**, llvm::ToolContext const&) (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x14277ab)\r\n#36 0x00005585b32174bb main (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x13134bb)\r\n#37 0x00007fd5a311f083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3\r\n#38 0x00005585b3325f7e _start (/local/suz-local/software/local/clang-trunk/bin/clang-20+0x1421f7e)\r\nclangtk: error: clang frontend command failed with exit code 134 (use -v to see invocation)\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project.git 2c8836c899015cce49a399a6bc47b260a24a22e7)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /local/suz-local/software/local/clang-trunk/bin\r\nBuild config: +assertions\r\nclangtk: note: diagnostic msg: \r\n********************\r\n\r\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\r\nPreprocessed source(s) and associated run script(s) are located at:\r\nclangtk: note: diagnostic msg: /tmp/small-1383a7.c\r\nclangtk: note: diagnostic msg: /tmp/small-1383a7.sh\r\nclangtk: note: diagnostic msg: \r\n\r\n********************\r\n[511] % \r\n[511] % cat small.c\r\nvolatile unsigned a;\r\nchar b, c, d, e;\r\nint f, g, h, i;\r\nstatic char j[1];\r\nvoid k();\r\nshort l(short m, int n) { return n > 1 || m >> n ? m : m << n; }\r\nint main() {\r\n  char o, p = 0;\r\n  int q, r = 1;\r\n  unsigned short s = g;\r\n  if (f)\r\n    j[0] = o;\r\nt:\r\n  b = f ? g % d : 0;\r\n  d % ~b || a;\r\n  if (d)\r\n    goto t;\r\n  while (e)\r\n    k();\r\n  for (; c; c--) {\r\n    h = 2;\r\n    for (; h; h--) {\r\n      q = s ? 2 / s : 0;\r\n      i = l(q, j[d]) == (r < p);\r\n      for (; p < 3; p++)\r\n        r = 0;\r\n    }\r\n  }\r\n  while (g)\r\n    ;\r\n  while (i)\r\n    if (f)\r\n      goto t;\r\n  return 0;\r\n}\r\n```\r\n\r\n@fhahn ",
    "author": "zhendongsu",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "This looks like a duplicate of https://github.com/llvm/llvm-project/issues/109528"
      }
    ]
  },
  "verified": true
}