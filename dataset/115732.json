{
  "bug_id": "115732",
  "issue_url": "https://github.com/llvm/llvm-project/issues/115732",
  "bug_type": "crash",
  "base_commit": "da78ac5d331953d3386fd56cd7979022be7400cf",
  "knowledge_cutoff": "2024-11-11T16:03:33Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "058ac837bc35419bbbb34f3206f5aa229c669811",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          3045,
          3051
        ],
        [
          9167,
          9174
        ],
        [
          13454,
          13460
        ],
        [
          13560,
          13566
        ],
        [
          14022,
          14028
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::gather",
        "BoUpSLP::setInsertPointAfterBundle",
        "createFreeze",
        "createShuffle"
      ]
    }
  },
  "patch": "commit 058ac837bc35419bbbb34f3206f5aa229c669811\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Mon Nov 11 10:48:15 2024 -0800\n\n    [SLP]Use generic createShuffle for buildvector\n    \n    Use generic createShuffle function, which know how to adjust the vectors\n    correctly, to avoid compiler crash when trying to build a buildvector as\n    a shuffle\n    \n    Fixes #115732\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex da8e0d8cc09a..1bf082d57b8b 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -3045,7 +3045,9 @@ private:\n \n   /// \\returns a vector from a collection of scalars in \\p VL. if \\p Root is not\n   /// specified, the starting vector value is poison.\n-  Value *gather(ArrayRef<Value *> VL, Value *Root, Type *ScalarTy);\n+  Value *\n+  gather(ArrayRef<Value *> VL, Value *Root, Type *ScalarTy,\n+         function_ref<Value *(Value *, Value *, ArrayRef<int>)> CreateShuffle);\n \n   /// \\returns whether the VectorizableTree is fully vectorizable and will\n   /// be beneficial even the tree height is tiny.\n@@ -9167,8 +9169,9 @@ protected:\n     int VF = Mask.size();\n     if (auto *FTy = dyn_cast<FixedVectorType>(V1->getType()))\n       VF = FTy->getNumElements();\n-    if (V2 &&\n-        !isUndefVector(V2, buildUseMask(VF, Mask, UseMask::SecondArg)).all()) {\n+    if (V2 && !isUndefVector</*IsPoisonOnly=*/true>(\n+                   V2, buildUseMask(VF, Mask, UseMask::SecondArg))\n+                   .all()) {\n       // Peek through shuffles.\n       Value *Op1 = V1;\n       Value *Op2 = V2;\n@@ -13454,7 +13457,9 @@ void BoUpSLP::setInsertPointAfterBundle(const TreeEntry *E) {\n   Builder.SetCurrentDebugLocation(Front->getDebugLoc());\n }\n \n-Value *BoUpSLP::gather(ArrayRef<Value *> VL, Value *Root, Type *ScalarTy) {\n+Value *BoUpSLP::gather(\n+    ArrayRef<Value *> VL, Value *Root, Type *ScalarTy,\n+    function_ref<Value *(Value *, Value *, ArrayRef<int>)> CreateShuffle) {\n   // List of instructions/lanes from current block and/or the blocks which are\n   // part of the current loop. These instructions will be inserted at the end to\n   // make it possible to optimize loops and hoist invariant instructions out of\n@@ -13560,7 +13565,7 @@ Value *BoUpSLP::gather(ArrayRef<Value *> VL, Value *Root, Type *ScalarTy) {\n     if (isa<PoisonValue>(Vec)) {\n       Vec = OriginalRoot;\n     } else {\n-      Vec = Builder.CreateShuffleVector(Root, Vec, Mask);\n+      Vec = CreateShuffle(Root, Vec, Mask);\n       if (auto *OI = dyn_cast<Instruction>(OriginalRoot);\n           OI && OI->hasNUses(0))\n         eraseInstruction(OI);\n@@ -14022,7 +14027,10 @@ public:\n   }\n   Value *gather(ArrayRef<Value *> VL, unsigned MaskVF = 0,\n                 Value *Root = nullptr) {\n-    return R.gather(VL, Root, ScalarTy);\n+    return R.gather(VL, Root, ScalarTy,\n+                    [&](Value *V1, Value *V2, ArrayRef<int> Mask) {\n+                      return createShuffle(V1, V2, Mask);\n+                    });\n   }\n   Value *createFreeze(Value *V) { return Builder.CreateFreeze(V); }\n   /// Finalize emission of the shuffles.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/buildvector-shuffle-with-root.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -slp-threshold=-99999 -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine void @test(i16 %arg) {\n;\nbb:\n  %sitofp = sitofp i16 %arg to float\n  %fadd = fadd float 0.000000e+00, 0.000000e+00\n  %fsub = fsub float 0.000000e+00, %sitofp\n  %fsub1 = fsub float 0.000000e+00, %sitofp\n  %fsub2 = fsub float 0.000000e+00, %sitofp\n  %sitofp3 = sitofp i16 0 to float\n  %fsub4 = fsub float %fadd, %sitofp3\n  store float %fsub4, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 20), align 4\n  %fsub5 = fsub float %fsub, %sitofp\n  store float %fsub5, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 24), align 4\n  %fsub6 = fsub float %fsub1, %sitofp\n  store float %fsub6, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 28), align 4\n  %fsub7 = fsub float %fsub2, %sitofp\n  store float %fsub7, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 32), align 4\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion `isValidOperands(V1, V2, Mask) && \"Invalid shuffle vector instruction operands!\"' failed.",
    "body": "To reproduce run the test below with -passes=slp-vectorizer.\r\n```\r\n; ModuleID = './reduced.ll'\r\nsource_filename = \"./reduced.ll\"\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine void @wombat(i16 %arg) gc \"statepoint-example\" {\r\nbb:\r\n  %sitofp = sitofp i16 %arg to float\r\n  %fadd = fadd float 0.000000e+00, 0.000000e+00\r\n  %fsub = fsub float 0.000000e+00, %sitofp\r\n  %fsub1 = fsub float 0.000000e+00, %sitofp\r\n  %fsub2 = fsub float 0.000000e+00, %sitofp\r\n  %sitofp3 = sitofp i16 0 to float\r\n  %fsub4 = fsub float %fadd, %sitofp3\r\n  store float %fsub4, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 20), align 4\r\n  %fsub5 = fsub float %fsub, %sitofp\r\n  store float %fsub5, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 24), align 4\r\n  %fsub6 = fsub float %fsub1, %sitofp\r\n  store float %fsub6, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 28), align 4\r\n  %fsub7 = fsub float %fsub2, %sitofp\r\n  store float %fsub7, ptr addrspace(1) getelementptr inbounds (i8, ptr addrspace(1) null, i64 32), align 4\r\n  ret void\r\n}\r\n```\r\nReproducer: https://godbolt.org/z/6h4xzhGa1\r\nStack dump:\r\n```\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=slp-vectorizer <source>\r\n1.\tRunning pass \"function(slp-vectorizer)\" on module \"<source>\"\r\n2.\tRunning pass \"slp-vectorizer\" on function \"wombat\"\r\n #0 0x00000000051494c8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x51494c8)\r\n #1 0x0000000005146ebc SignalHandler(int) Signals.cpp:0:0\r\n #2 0x000072f583642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x000072f5836969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #4 0x000072f583642476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #5 0x000072f5836287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #6 0x000072f58362871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #7 0x000072f583639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #8 0x0000000004eb74ce llvm::ShuffleVectorInst::ShuffleVectorInst(llvm::Value*, llvm::Value*, llvm::ArrayRef<int>, llvm::Twine const&, llvm::InsertPosition) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4eb74ce)\r\n #9 0x0000000000d09e93 llvm::IRBuilderBase::CreateShuffleVector(llvm::Value*, llvm::Value*, llvm::ArrayRef<int>, llvm::Twine const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xd09e93)\r\n#10 0x00000000041a0bdd llvm::slpvectorizer::BoUpSLP::gather(llvm::ArrayRef<llvm::Value*>, llvm::Value*, llvm::Type*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x41a0bdd)\r\n#11 0x00000000041a13fc void llvm::function_ref<void (llvm::Value*&, llvm::SmallVectorImpl<int>&)>::callback_fn<llvm::Value* llvm::slpvectorizer::BoUpSLP::processBuildVector<llvm::slpvectorizer::BoUpSLP::ShuffleInstructionBuilder, llvm::Value*, llvm::IRBuilder<llvm::TargetFolder, llvm::IRBuilderDefaultInserter>, llvm::slpvectorizer::BoUpSLP>(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::Type*, llvm::IRBuilder<llvm::TargetFolder, llvm::IRBuilderDefaultInserter>&, llvm::slpvectorizer::BoUpSLP&)::'lambda15'(llvm::Value*&, llvm::SmallVectorImpl<int>&)>(long, llvm::Value*&, llvm::SmallVectorImpl<int>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x41a13fc)\r\n#12 0x00000000041a26b9 llvm::slpvectorizer::BoUpSLP::ShuffleInstructionBuilder::finalize(llvm::ArrayRef<int>, llvm::ArrayRef<std::pair<llvm::slpvectorizer::BoUpSLP::TreeEntry const*, unsigned int>>, llvm::ArrayRef<int>, unsigned int, llvm::function_ref<void (llvm::Value*&, llvm::SmallVectorImpl<int>&)>) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x41a26b9)\r\n#13 0x00000000041d5335 llvm::Value* llvm::slpvectorizer::BoUpSLP::processBuildVector<llvm::slpvectorizer::BoUpSLP::ShuffleInstructionBuilder, llvm::Value*, llvm::IRBuilder<llvm::TargetFolder, llvm::IRBuilderDefaultInserter>, llvm::slpvectorizer::BoUpSLP>(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::Type*, llvm::IRBuilder<llvm::TargetFolder, llvm::IRBuilderDefaultInserter>&, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x41d5335)\r\n#14 0x00000000041e168e llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x41e168e)\r\n#15 0x000000000420234a llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::SmallDenseSet<llvm::Value*, 4u, llvm::DenseMapInfo<llvm::Value*, void>> const&, llvm::Instruction*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x420234a)\r\n#16 0x0000000004205c7d llvm::slpvectorizer::BoUpSLP::vectorizeTree() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4205c7d)\r\n#17 0x0000000004224402 llvm::SLPVectorizerPass::vectorizeStoreChain(llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP&, unsigned int, unsigned int, unsigned int&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4224402)\r\n#18 0x0000000004225e6b llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&)::'lambda'(std::set<std::pair<unsigned int, int>, llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&)::StoreDistCompare, std::allocator<std::pair<unsigned int, int>>> const&)::operator()(std::set<std::pair<unsigned int, int>, llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&)::StoreDistCompare, std::allocator<std::pair<unsigned int, int>>> const&) const SLPVectorizer.cpp:0:0\r\n#19 0x0000000004227d98 llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4227d98)\r\n#20 0x00000000042285e9 llvm::SLPVectorizerPass::vectorizeStoreChains(llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x42285e9)\r\n#21 0x0000000004229b35 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (.part.0) SLPVectorizer.cpp:0:0\r\n#22 0x000000000422a63b llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x422a63b)\r\n#23 0x0000000002f9948e llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2f9948e)\r\n#24 0x0000000004f47488 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4f47488)\r\n#25 0x0000000000e3bf3e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe3bf3e)\r\n#26 0x0000000004f45eae llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4f45eae)\r\n#27 0x0000000000e3b64e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe3b64e)\r\n#28 0x0000000004f458e0 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4f458e0)\r\n#29 0x000000000091103a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x91103a)\r\n#30 0x000000000090399a optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x90399a)\r\n#31 0x000072f583629d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#32 0x000072f583629e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#33 0x00000000008fb41e _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8fb41e)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139\r\n```",
    "author": "TatyanaDoubts",
    "labels": [
      "llvm:SLPVectorizer",
      "crash"
    ],
    "comments": [
      {
        "author": "RKSimon",
        "body": "CC @alexey-bataev "
      }
    ]
  },
  "verified": true
}