{
  "bug_id": "104718",
  "issue_url": "https://github.com/llvm/llvm-project/issues/104718",
  "bug_type": "crash",
  "base_commit": "08a0dece2b2431db8abe650bb43cba01e781e1ce",
  "knowledge_cutoff": "2024-08-18T19:02:15Z",
  "lit_test_dir": [
    "llvm/test/Instrumentation/ThreadSanitizer",
    "llvm/test/Transforms/CodeExtractor",
    "llvm/test/Transforms/Attributor",
    "llvm/test/Transforms/FunctionAttrs",
    "llvm/test/Verifier"
  ],
  "hints": {
    "fix_commit": "472c79ca52806856c0dc7548a6f82d3bd9e7530c",
    "components": [
      "IR"
    ],
    "files": [
      "llvm/lib/IR/Verifier.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/IR/Verifier.cpp": [
        [
          2777,
          2782
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/IR/Verifier.cpp": [
        "Verifier::visitFunction"
      ]
    }
  },
  "patch": "commit 472c79ca52806856c0dc7548a6f82d3bd9e7530c\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Tue Aug 20 09:29:05 2024 +0200\n\n    [IR] Check that arguments of naked function are not used (#104757)\n    \n    Verify that the arguments of a naked function are not used. They can\n    only be referenced via registers/stack in inline asm, not as IR values.\n    Doing so will result in assertion failures in the backend.\n    \n    There's probably more that we should verify, though I'm not completely\n    sure what the constraints are (would it be correct to require that naked\n    functions are exactly an inline asm call + unreachable, or is more\n    allowed?)\n    \n    Fixes https://github.com/llvm/llvm-project/issues/104718.\n\ndiff --git a/llvm/lib/IR/Verifier.cpp b/llvm/lib/IR/Verifier.cpp\nindex 7d71ce3230b2..4e097b732cc2 100644\n--- a/llvm/lib/IR/Verifier.cpp\n+++ b/llvm/lib/IR/Verifier.cpp\n@@ -2777,6 +2777,10 @@ void Verifier::visitFunction(const Function &F) {\n   Check(!Attrs.hasAttrSomewhere(Attribute::ElementType),\n         \"Attribute 'elementtype' can only be applied to a callsite.\", &F);\n \n+  if (Attrs.hasFnAttr(Attribute::Naked))\n+    for (const Argument &Arg : F.args())\n+      Check(Arg.use_empty(), \"cannot use argument of naked function\", &Arg);\n+\n   // Check that this function meets the restrictions on this calling convention.\n   // Sometimes varargs is used for perfectly forwarding thunks, so some of these\n   // restrictions can be lifted.\n",
  "tests": [
    {
      "file": "llvm/test/Instrumentation/ThreadSanitizer/tsan_basic.ll",
      "commands": [
        "opt < %s -passes='function(tsan),module(tsan-module)' -S"
      ],
      "tests": [
        {
          "test_name": "SwiftErrorCall",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n; Function Attrs: sanitize_thread\ndeclare void @SwiftError(ptr swifterror) #0\n\n; Function Attrs: sanitize_thread\ndefine void @SwiftErrorCall(ptr swifterror %0) #0 {\n  %swifterror_addr = alloca swifterror ptr, align 8\n  store ptr null, ptr %0, align 8\n  call void @SwiftError(ptr %0)\n  ret void\n}\n\nattributes #0 = { sanitize_thread }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/Attributor/nonnull.ll",
      "commands": [
        "opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -S < %s",
        "opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s"
      ],
      "tests": [
        {
          "test_name": "naked",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n\n; Function Attrs: naked\ndefine hidden void @naked(ptr dereferenceable(4) %a) #0 {\n  ret void\n}\n\nattributes #0 = { naked }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/CodeExtractor/PartialInlineAttributes.ll",
      "commands": [
        "opt < %s -S -passes=partial-inliner -skip-partial-inlining-cost-analysis=true"
      ],
      "tests": [
        {
          "test_name": "callee_most",
          "test_body": "; Function Attrs: convergent inlinehint minsize noduplicate noimplicitfloat norecurse noredzone noreturn nounwind nonlazybind optsize returns_twice safestack sanitize_address sanitize_hwaddress sanitize_memory sanitize_thread speculatable ssp sspreq sspstrong memory(none) alignstack(16) uwtable\ndefine i32 @callee_most(i32 %v) unnamed_addr #0 {\nentry:\n  %cmp = icmp sgt i32 %v, 2000\n  br i1 %cmp, label %if.then, label %if.end\n\nif.then:                                          ; preds = %entry\n  br label %if.then2\n\nif.then2:                                         ; preds = %if.then\n  %sub = sub i32 %v, 10\n  br label %if.end\n\nif.end:                                           ; preds = %if.then2, %entry\n  %v2 = phi i32 [ %v, %entry ], [ %sub, %if.then2 ]\n  %add = add nsw i32 %v2, 200\n  ret i32 %add\n}\n\nattributes #0 = { convergent inlinehint minsize noduplicate noimplicitfloat norecurse noredzone noreturn nounwind nonlazybind optsize returns_twice safestack sanitize_address sanitize_hwaddress sanitize_memory sanitize_thread speculatable ssp sspreq sspstrong memory(none) alignstack=16 uwtable \"foo\"=\"bar\" \"patchable-function\"=\"prologue-short-redirect\" \"probe-stack\"=\"_foo_guard\" \"stack-probe-size\"=\"4096\" \"thunk\" }\n"
        },
        {
          "test_name": "callee_writeonly",
          "test_body": "; Function Attrs: ssp memory(write)\ndefine i32 @callee_writeonly(i32 %v) #0 {\nentry:\n  %cmp = icmp sgt i32 %v, 2000\n  br i1 %cmp, label %if.then, label %if.end\n\nif.then:                                          ; preds = %entry\n  br label %if.then2\n\nif.then2:                                         ; preds = %if.then\n  %sub = sub i32 %v, 10\n  br label %if.end\n\nif.end:                                           ; preds = %if.then2, %entry\n  %v2 = phi i32 [ %v, %entry ], [ %sub, %if.then2 ]\n  %add = add nsw i32 %v2, 200\n  ret i32 %add\n}\n\nattributes #0 = { ssp memory(write) }\n"
        },
        {
          "test_name": "callee_noinline",
          "test_body": "; Function Attrs: noinline optnone\ndefine i32 @callee_noinline(i32 %v) #0 {\nentry:\n  %cmp = icmp sgt i32 %v, 2000\n  br i1 %cmp, label %if.then, label %if.end\n\nif.then:                                          ; preds = %entry\n  br label %if.then2\n\nif.then2:                                         ; preds = %if.then\n  %sub = sub i32 %v, 10\n  br label %if.end\n\nif.end:                                           ; preds = %if.then2, %entry\n  %v2 = phi i32 [ %v, %entry ], [ %sub, %if.then2 ]\n  %add = add nsw i32 %v2, 200\n  ret i32 %add\n}\n\nattributes #0 = { noinline optnone }\n"
        },
        {
          "test_name": "caller",
          "test_body": "; Function Attrs: convergent inlinehint minsize noduplicate noimplicitfloat norecurse noredzone noreturn nounwind nonlazybind optsize returns_twice safestack sanitize_address sanitize_hwaddress sanitize_memory sanitize_thread speculatable ssp sspreq sspstrong memory(none) alignstack(16) uwtable\ndeclare i32 @callee_most(i32) unnamed_addr #0\n\n; Function Attrs: noinline optnone\ndeclare i32 @callee_noinline(i32) #1\n\n; Function Attrs: ssp memory(write)\ndeclare i32 @callee_writeonly(i32) #2\n\n; Function Attrs: ssp\ndefine i32 @caller(i32 %v) #3 {\nentry:\n  %c1 = call i32 @callee_most(i32 %v)\n  %c2 = call i32 @callee_noinline(i32 %v)\n  %c3 = call i32 @callee_writeonly(i32 %v)\n  ret i32 %c3\n}\n\nattributes #0 = { convergent inlinehint minsize noduplicate noimplicitfloat norecurse noredzone noreturn nounwind nonlazybind optsize returns_twice safestack sanitize_address sanitize_hwaddress sanitize_memory sanitize_thread speculatable ssp sspreq sspstrong memory(none) alignstack=16 uwtable \"foo\"=\"bar\" \"patchable-function\"=\"prologue-short-redirect\" \"probe-stack\"=\"_foo_guard\" \"stack-probe-size\"=\"4096\" \"thunk\" }\nattributes #1 = { noinline optnone }\nattributes #2 = { ssp memory(write) }\nattributes #3 = { ssp }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/FunctionAttrs/nonnull.ll",
      "commands": [
        "opt -S -passes=function-attrs -enable-nonnull-arg-prop %s",
        "opt -S -passes=attributor-light %s"
      ],
      "tests": [
        {
          "test_name": "control",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n\n; Function Attrs: nounwind memory(none)\ndeclare void @use_i32_ptr(ptr) #0\n\ndefine hidden void @control(ptr dereferenceable(4) %a) {\n  call void @use_i32_ptr(ptr %a)\n  ret void\n}\n\nattributes #0 = { nounwind memory(none) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Verifier/naked.ll",
      "commands": [
        "not llvm-as %s -o /dev/null 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "; Function Attrs: naked\ndefine void @test(ptr %ptr) #0 {\n  %1 = getelementptr i8, ptr %ptr, i64 1\n  call void @llvm.trap()\n  unreachable\n}\n\n; Function Attrs: cold noreturn nounwind memory(inaccessiblemem: write)\ndeclare void @llvm.trap() #1\n\nattributes #0 = { naked }\nattributes #1 = { cold noreturn nounwind memory(inaccessiblemem: write) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "SelectionDAGBuilder.cpp's `llvm_unreachable` is quite reachable, actually",
    "body": "This IR:\r\n\r\n```llvmir\r\nsource_filename = \"example.1c26dad09674458a-cgu.0\"\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-none-elf\"\r\n\r\n@llvm.used = appending global [1 x ptr] [ptr @asan.module_ctor], section \"llvm.metadata\"\r\n@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 1, ptr @asan.module_ctor, ptr null }]\r\n\r\ndefine x86_intrcc void @_ZN7example18page_fault_handler17hdb4acb34a86c6a8bE(ptr byval([8 x i8]) align 8 %0, i64 %1) unnamed_addr #0 !dbg !8 {\r\nstart:\r\n  %Arg0.byval = alloca [8 x i8], align 8, !dbg !13\r\n  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %Arg0.byval, ptr align 8 %0, i64 8, i1 false), !dbg !13\r\n  call void asm sideeffect alignstack inteldialect \"ud2\", \"~{dirflag},~{fpsr},~{flags},~{memory}\"(), !dbg !13, !srcloc !14\r\n  unreachable, !dbg !13\r\n}\r\n\r\ndeclare void @__asan_report_load_n(i64, i64)\r\ndeclare void @__asan_loadN(i64, i64)\r\ndeclare void @__asan_report_load1(i64)\r\ndeclare void @__asan_load1(i64)\r\ndeclare void @__asan_report_load2(i64)\r\ndeclare void @__asan_load2(i64)\r\ndeclare void @__asan_report_load4(i64)\r\ndeclare void @__asan_load4(i64)\r\ndeclare void @__asan_report_load8(i64)\r\ndeclare void @__asan_load8(i64)\r\ndeclare void @__asan_report_load16(i64)\r\ndeclare void @__asan_load16(i64)\r\ndeclare void @__asan_report_store_n(i64, i64)\r\ndeclare void @__asan_storeN(i64, i64)\r\ndeclare void @__asan_report_store1(i64)\r\ndeclare void @__asan_store1(i64)\r\ndeclare void @__asan_report_store2(i64)\r\ndeclare void @__asan_store2(i64)\r\ndeclare void @__asan_report_store4(i64)\r\ndeclare void @__asan_store4(i64)\r\ndeclare void @__asan_report_store8(i64)\r\ndeclare void @__asan_store8(i64)\r\ndeclare void @__asan_report_store16(i64)\r\ndeclare void @__asan_store16(i64)\r\ndeclare void @__asan_report_exp_load_n(i64, i64, i32)\r\ndeclare void @__asan_exp_loadN(i64, i64, i32)\r\ndeclare void @__asan_report_exp_load1(i64, i32)\r\ndeclare void @__asan_exp_load1(i64, i32)\r\ndeclare void @__asan_report_exp_load2(i64, i32)\r\ndeclare void @__asan_exp_load2(i64, i32)\r\ndeclare void @__asan_report_exp_load4(i64, i32)\r\ndeclare void @__asan_exp_load4(i64, i32)\r\ndeclare void @__asan_report_exp_load8(i64, i32)\r\ndeclare void @__asan_exp_load8(i64, i32)\r\ndeclare void @__asan_report_exp_load16(i64, i32)\r\ndeclare void @__asan_exp_load16(i64, i32)\r\ndeclare void @__asan_report_exp_store_n(i64, i64, i32)\r\ndeclare void @__asan_exp_storeN(i64, i64, i32)\r\ndeclare void @__asan_report_exp_store1(i64, i32)\r\ndeclare void @__asan_exp_store1(i64, i32)\r\ndeclare void @__asan_report_exp_store2(i64, i32)\r\ndeclare void @__asan_exp_store2(i64, i32)\r\ndeclare void @__asan_report_exp_store4(i64, i32)\r\ndeclare void @__asan_exp_store4(i64, i32)\r\ndeclare void @__asan_report_exp_store8(i64, i32)\r\ndeclare void @__asan_exp_store8(i64, i32)\r\ndeclare void @__asan_report_exp_store16(i64, i32)\r\ndeclare void @__asan_exp_store16(i64, i32)\r\ndeclare ptr @memmove(ptr, ptr, i64)\r\ndeclare ptr @memcpy(ptr, ptr, i64)\r\ndeclare ptr @memset(ptr, i32, i64)\r\ndeclare void @__asan_handle_no_return()\r\ndeclare void @__sanitizer_ptr_cmp(i64, i64)\r\ndeclare void @__sanitizer_ptr_sub(i64, i64)\r\ndeclare i1 @llvm.amdgcn.is.shared(ptr nocapture) #1\r\ndeclare i1 @llvm.amdgcn.is.private(ptr nocapture) #1\r\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #2\r\ndeclare void @__asan_before_dynamic_init(i64)\r\ndeclare void @__asan_after_dynamic_init()\r\ndeclare void @__asan_register_globals(i64, i64)\r\ndeclare void @__asan_unregister_globals(i64, i64)\r\ndeclare void @__asan_register_image_globals(i64)\r\ndeclare void @__asan_unregister_image_globals(i64)\r\ndeclare void @__asan_register_elf_globals(i64, i64, i64)\r\ndeclare void @__asan_unregister_elf_globals(i64, i64, i64)\r\n\r\ndefine internal void @asan.module_ctor() #3 {\r\n  ret void\r\n}\r\n\r\nattributes #0 = { naked nocf_check noinline noredzone nounwind nonlazybind sanitize_address \"probe-stack\"=\"inline-asm\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-avx,-avx2,+soft-float\" }\r\nattributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\r\nattributes #2 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\r\nattributes #3 = { nounwind }\r\n\r\n!llvm.module.flags = !{!0, !1, !2, !3, !4}\r\n!llvm.ident = !{!5}\r\n!llvm.dbg.cu = !{!6}\r\n\r\n!0 = !{i32 8, !\"PIC Level\", i32 2}\r\n!1 = !{i32 1, !\"Code Model\", i32 2}\r\n!2 = !{i32 2, !\"RtLibUseGOT\", i32 1}\r\n!3 = !{i32 2, !\"Dwarf Version\", i32 4}\r\n!4 = !{i32 2, !\"Debug Info Version\", i32 3}\r\n!5 = !{!\"rustc version 1.82.0-nightly (2c93fabd9 2024-08-15)\"}\r\n!6 = distinct !DICompileUnit(language: DW_LANG_Rust, file: !7, producer: \"clang LLVM (rustc version 1.82.0-nightly (2c93fabd9 2024-08-15))\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)\r\n!7 = !DIFile(filename: \"/app/example.rs/@/example.1c26dad09674458a-cgu.0\", directory: \"/app\")\r\n!8 = distinct !DISubprogram(name: \"page_fault_handler\", linkageName: \"_ZN7example18page_fault_handler17hdb4acb34a86c6a8bE\", scope: !10, file: !9, line: 6, type: !11, scopeLine: 6, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !6, templateParams: !12)\r\n!9 = !DIFile(filename: \"example.rs\", directory: \"/app\", checksumkind: CSK_MD5, checksum: \"85bf207046f646941a20021898b6c9b6\")\r\n!10 = !DINamespace(name: \"example\", scope: null)\r\n!11 = !DISubroutineType(types: !12)\r\n!12 = !{}\r\n!13 = !DILocation(line: 8, column: 9, scope: !8)\r\n!14 = !{i32 187}\r\n```\r\n\r\nHits this `llvm_unreachable`: https://github.com/llvm/llvm-project/blob/bf5cd4220d20d0ee5533d55f463612fbe2980071/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp#L1957\r\n\r\nIf you don't enable trap on `llvm_unreachable` in the CMake, we get this instead:\r\n```\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-trunk/bin/llc -o /app/output.s -x86-asm-syntax=intel <source>\r\n1.\tRunning pass 'Function Pass Manager' on module '<source>'.\r\n2.\tRunning pass 'X86 Assembly Printer' on function '@_ZN7example18page_fault_handler17hdb4acb34a86c6a8bE'\r\n #0 0x00000000037ec688 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-trunk/bin/llc+0x37ec688)\r\n #1 0x00000000037ea02c SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007f26b2442520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x0000000002306054 (anonymous namespace)::X86MCCodeEmitter::emitPrefixImpl(unsigned int&, llvm::MCInst const&, llvm::MCSubtargetInfo const&, llvm::SmallVectorImpl<char>&) const X86MCCodeEmitter.cpp:0:0\r\n #4 0x00000000023093e8 (anonymous namespace)::X86MCCodeEmitter::encodeInstruction(llvm::MCInst const&, llvm::SmallVectorImpl<char>&, llvm::SmallVectorImpl<llvm::MCFixup>&, llvm::MCSubtargetInfo const&) const X86MCCodeEmitter.cpp:0:0\r\n #5 0x0000000001b8b846 llvm::X86AsmPrinter::emitInstruction(llvm::MachineInstr const*) (/opt/compiler-explorer/clang-trunk/bin/llc+0x1b8b846)\r\n #6 0x000000000261e787 llvm::AsmPrinter::emitFunctionBody() (/opt/compiler-explorer/clang-trunk/bin/llc+0x261e787)\r\n #7 0x0000000001b7dedb llvm::X86AsmPrinter::runOnMachineFunction(llvm::MachineFunction&) (/opt/compiler-explorer/clang-trunk/bin/llc+0x1b7dedb)\r\n #8 0x00000000028aac6b llvm::MachineFunctionPass::runOnFunction(llvm::Function&) (.part.0) MachineFunctionPass.cpp:0:0\r\n #9 0x0000000002df8272 llvm::FPPassManager::runOnFunction(llvm::Function&) (/opt/compiler-explorer/clang-trunk/bin/llc+0x2df8272)\r\n#10 0x0000000002df8531 llvm::FPPassManager::runOnModule(llvm::Module&) (/opt/compiler-explorer/clang-trunk/bin/llc+0x2df8531)\r\n#11 0x0000000002df77cb llvm::legacy::PassManagerImpl::run(llvm::Module&) (/opt/compiler-explorer/clang-trunk/bin/llc+0x2df77cb)\r\n#12 0x0000000000859e94 compileModule(char**, llvm::LLVMContext&) llc.cpp:0:0\r\n#13 0x000000000074c296 main (/opt/compiler-explorer/clang-trunk/bin/llc+0x74c296)\r\n#14 0x00007f26b2429d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#15 0x00007f26b2429e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#16 0x0000000000851f1e _start (/opt/compiler-explorer/clang-trunk/bin/llc+0x851f1e)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139\r\n```\r\n\r\nIt seems to me, given the frequency with which code hits this, that LLVM prefers to put this macro in reachable branches of code. May I suggest renaming it, or perhaps removing the feature that it causes undefined behavior if reached at runtime?",
    "author": "workingjubilee",
    "labels": [
      "crash-on-valid",
      "llvm:ir"
    ],
    "comments": [
      {
        "author": "workingjubilee",
        "body": "Mind, it is *probably* the case that rustc should not emit the IR in question, but it seems incorrect to call something unreachable if it isn't. Especially if this causes errors to flow downstream to places in the machine optimizer and emitter which probably shouldn't be asked to handle such questionably-formed IR, and it should instead be eagerly rejected, perhaps with an inquiry as to why the author ever thought that LLVMIR would pass muster."
      },
      {
        "author": "nikic",
        "body": "Reduced test case:\r\n```llvm\r\ndefine void @test(ptr %ptr) naked {\r\n  getelementptr i8, ptr %ptr, i64 1\r\n  call void @llvm.trap()\r\n  unreachable\r\n}\r\n```\r\n\r\nProbably the IR verifier should check that the arguments of a naked function are not used?\r\n\r\nWe don't lower arguments for naked functions, so everything in the backend will blow up if you try to use them."
      },
      {
        "author": "topperc",
        "body": "Should we change SelectionDAGBuilder to have a report_fatal_error instead of llvm_unreachable too? That way compiler optimizations can't send the code down some random path the next time something like this happens?"
      }
    ]
  }
}