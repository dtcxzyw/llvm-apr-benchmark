{
  "bug_id": "166496",
  "issue_url": "https://github.com/llvm/llvm-project/issues/166496",
  "bug_type": "miscompilation",
  "base_commit": "9100001cd08ccb9a4091200c2421ff2aee7829c6",
  "knowledge_cutoff": "2025-11-05T03:18:58Z",
  "lit_test_dir": [
    "llvm/test/Transforms/IndVarSimplify"
  ],
  "hints": {
    "fix_commit": "eaf3a91722fbb0f6598907c9dfa14ca632cc71c4",
    "components": [
      "IndVarSimplify"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/IndVarSimplify.cpp": [
        [
          196,
          201
        ],
        [
          212,
          218
        ],
        [
          262,
          268
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/IndVarSimplify.cpp": [
        "ConvertToSInt",
        "IndVarSimplify::handleFloatingPointIV"
      ]
    }
  },
  "patch": "commit eaf3a91722fbb0f6598907c9dfa14ca632cc71c4\nAuthor: Antonio Frighetto <me@antoniofrighetto.com>\nDate:   Tue Nov 11 10:28:35 2025 +0100\n\n    [IndVarSimplify] Ensure fp values can be represented as exact integers\n    \n    When transforming floating-point induction variables into integer ones,\n    make sure we stay within the bounds of fp values that can be represented\n    as integers without gaps, i.e., 2^24 and 2^53 for IEEE-754 single and\n    double precision respectively (both on negative and positive side).\n    \n    Fixes: https://github.com/llvm/llvm-project/issues/166496.\n\ndiff --git a/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp b/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp\nindex 4ba4ba3850e5..eab1d4975ac9 100644\n--- a/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp\n+++ b/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp\n@@ -196,6 +196,18 @@ static bool ConvertToSInt(const APFloat &APF, int64_t &IntVal) {\n   return true;\n }\n \n+// Ensure we stay within the bounds of fp values that can be represented as\n+// integers without gaps, which are 2^24 and 2^53 for IEEE-754 single and double\n+// precision respectively (both on negative and positive side).\n+static bool isRepresentableAsExactInteger(ConstantFP *FPVal, int64_t IntVal) {\n+  const auto &InitValueFltSema = FPVal->getValueAPF().getSemantics();\n+  if (!APFloat::isIEEELikeFP(InitValueFltSema))\n+    return false;\n+\n+  return isUIntN(APFloat::semanticsPrecision(InitValueFltSema),\n+                 AbsoluteValue(IntVal));\n+}\n+\n /// If the loop has floating induction variable then insert corresponding\n /// integer induction variable if possible.\n /// For example,\n@@ -212,7 +224,8 @@ bool IndVarSimplify::handleFloatingPointIV(Loop *L, PHINode *PN) {\n   auto *InitValueVal = dyn_cast<ConstantFP>(PN->getIncomingValue(IncomingEdge));\n \n   int64_t InitValue;\n-  if (!InitValueVal || !ConvertToSInt(InitValueVal->getValueAPF(), InitValue))\n+  if (!InitValueVal || !ConvertToSInt(InitValueVal->getValueAPF(), InitValue) ||\n+      !isRepresentableAsExactInteger(InitValueVal, InitValue))\n     return false;\n \n   // Check IV increment. Reject this PN if increment operation is not\n@@ -262,7 +275,8 @@ bool IndVarSimplify::handleFloatingPointIV(Loop *L, PHINode *PN) {\n   ConstantFP *ExitValueVal = dyn_cast<ConstantFP>(Compare->getOperand(1));\n   int64_t ExitValue;\n   if (ExitValueVal == nullptr ||\n-      !ConvertToSInt(ExitValueVal->getValueAPF(), ExitValue))\n+      !ConvertToSInt(ExitValueVal->getValueAPF(), ExitValue) ||\n+      !isRepresentableAsExactInteger(ExitValueVal, ExitValue))\n     return false;\n \n   // Find new predicate for integer comparison.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/IndVarSimplify/floating-point-iv.ll",
      "commands": [
        "opt < %s -passes=indvars -S"
      ],
      "tests": [
        {
          "test_name": "test_fp_to_int_irrealizable_exitval",
          "test_body": "define void @test_fp_to_int_irrealizable_exitval() {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi float [ 2.500000e+01, %entry ], [ %iv.next, %loop ]\n  call void @opaque()\n  %iv.next = fadd float %iv, 1.700000e+01\n  %cmp = fcmp ugt float %iv.next, 1.000000e+08\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\ndeclare void @opaque()\n"
        },
        {
          "test_name": "test_fp_to_int_irrealizable_initval",
          "test_body": "define void @test_fp_to_int_irrealizable_initval() {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi float [ 1.000000e+08, %entry ], [ %iv.next, %loop ]\n  call void @opaque()\n  %iv.next = fadd float %iv, -1.700000e+01\n  %cmp = fcmp ult float %iv.next, 2.500000e+01\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\ndeclare void @opaque()\n"
        },
        {
          "test_name": "test_fp_to_int_irrealizable_exitval_pow_2_24",
          "test_body": "define void @test_fp_to_int_irrealizable_exitval_pow_2_24() {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi float [ 0.000000e+00, %entry ], [ %iv.next, %loop ]\n  call void @opaque()\n  %iv.next = fadd float %iv, 1.000000e+00\n  %cmp = fcmp ugt float %iv.next, 0x4170000000000000\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\ndeclare void @opaque()\n"
        },
        {
          "test_name": "test_fp_to_int_irrealizable_negative_exitval",
          "test_body": "define void @test_fp_to_int_irrealizable_negative_exitval() {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi float [ -2.500000e+01, %entry ], [ %iv.next, %loop ]\n  call void @opaque()\n  %iv.next = fadd float %iv, -1.700000e+01\n  %cmp = fcmp ult float %iv.next, -1.000000e+08\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\ndeclare void @opaque()\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "miscompile when IndVarSimplify turns a float induction variable into an int?",
    "body": "IndVarSimplify can turn a float induction variable into an integer, but this isn't behavior-preserving when we get out of the range that can be represented exactly. it seems like an extra safety check on this transformation is needed.\n\n```\n~$ cat foo.c\nvoid bar(void);\n\nvoid foo(void) {\n    for (float f = 25.0; f <= 100000000.0; f += 17.0)\n        bar();\n}\n~$ cat bar.c\n#include <stdio.h>\n\nlong cnt;\n\nvoid bar(void) {\n  ++cnt;\n}\n\nvoid foo(void);\n\nint main(void) {\n  foo();\n  printf(\"%ld\\n\", cnt);\n}\n~$ clang -O0 foo.c bar.c && ./a.out\n6188318\n~$ clang -O1 foo.c bar.c && ./a.out\n5882352\n~$\n```",
    "author": "regehr",
    "labels": [
      "miscompilation",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "nelhage",
        "body": "Single-file reproducer via `__attribute__((noinline))` ([godbolt link](https://godbolt.org/z/965G167Y8)):\n\n```c\n#include <stdio.h>\n\nunsigned long count;\nvoid __attribute__((noinline)) bar() {\n    count += 1;\n}\n\nvoid foo(void) {\n    for (float f = 25.0; f <= 100000000.0; f += 17.0)\n        bar();\n}\n\nint main() {\n    foo();\n    printf(\"%ld\\n\", count);\n}\n```"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true
}