{
  "bug_id": "153295",
  "issue_url": "https://github.com/llvm/llvm-project/issues/153295",
  "bug_type": "crash",
  "base_commit": "e2dcb8b7a5998bf29dfce9412697295ae6b89a18",
  "knowledge_cutoff": "2025-08-12T20:59:46Z",
  "lit_test_dir": [
    "llvm/test/Transforms/FunctionSpecialization"
  ],
  "hints": {
    "fix_commit": "6bd844812385dd5cb65e08fe9561be9f91ace876",
    "components": [
      "FunctionSpecialization",
      "SCCP"
    ],
    "bug_location_lineno": {
      "llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h": [
        [
          246,
          252
        ],
        [
          270,
          275
        ]
      ],
      "llvm/lib/Transforms/IPO/FunctionSpecialization.cpp": [
        [
          838,
          851
        ],
        [
          1206,
          1213
        ]
      ],
      "llvm/lib/Transforms/IPO/SCCP.cpp": [
        [
          169,
          174
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h": [
        "getInstCostVisitorFor"
      ],
      "llvm/lib/Transforms/IPO/FunctionSpecialization.cpp": [
        "FunctionSpecializer::removeDeadFunctions",
        "FunctionSpecializer::updateCallSites"
      ],
      "llvm/lib/Transforms/IPO/SCCP.cpp": [
        "runIPSCCP"
      ]
    }
  },
  "patch": "commit 6bd844812385dd5cb65e08fe9561be9f91ace876\nAuthor: XChy <xxs_chy@outlook.com>\nDate:   Thu Aug 28 01:04:52 2025 +0800\n\n    [FuncSpec] Skip SCCP on blocks of dead functions and poison their callsites (#154668)\n    \n    Fixes #153295.\n    For test case below:\n    ```llvm\n    define i32 @caller() {\n    entry:\n      %call1 = call i32 @callee(i32 1)\n      %call2 = call i32 @callee(i32 0)\n      %cond = icmp eq i32 %call2, 0\n      br i1 %cond, label %common.ret, label %if.then\n    \n    common.ret:                                       ; preds = %entry\n      ret i32 0\n    \n    if.then:                                         ; preds = %entry\n      %unreachable_call = call i32 @callee(i32 2)\n      ret i32 %unreachable_call\n    }\n    \n    define internal i32 @callee(i32 %ac) {\n    entry:\n      br label %ai\n    \n    ai:                                               ; preds = %ai, %entry\n      %add = or i32 0, 0\n      %cond = icmp eq i32 %ac, 1\n      br i1 %cond, label %aj, label %ai\n    \n    aj:                                               ; preds = %ai\n      ret i32 0\n    }\n    ```\n    Before specialization, the SCCP solver determines that\n    `unreachable_call` is unexecutable, as the value of `callee` can only be\n    zero.\n    After specializing the call sites `call1` and `call2`, FnSpecializer\n    announces `callee` is a dead function since all executable call sites\n    are specialized. However, the unexecutable call sites can become\n    executable again after solving specialized calls.\n    In this testcase, `call2` is considered `Overdefined` after\n    specialization, making `cond` also `Overdefined`. Thus,\n    `unreachable_call` becomes executable.\n    This patch skips SCCP on the blocks in dead functions, and poisons the\n    call sites of dead functions.\n\ndiff --git a/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h b/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h\nindex 1575afa50e19..5a682e8c7b5e 100644\n--- a/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h\n+++ b/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h\n@@ -246,7 +246,7 @@ class FunctionSpecializer {\n   std::function<AssumptionCache &(Function &)> GetAC;\n \n   SmallPtrSet<Function *, 32> Specializations;\n-  SmallPtrSet<Function *, 32> FullySpecialized;\n+  SmallPtrSet<Function *, 32> DeadFunctions;\n   DenseMap<Function *, CodeMetrics> FunctionMetrics;\n   DenseMap<Function *, unsigned> FunctionGrowth;\n   unsigned NGlobals = 0;\n@@ -270,6 +270,8 @@ public:\n     return InstCostVisitor(GetBFI, F, M.getDataLayout(), TTI, Solver);\n   }\n \n+  bool isDeadFunction(Function *F) { return DeadFunctions.contains(F); }\n+\n private:\n   Constant *getPromotableAlloca(AllocaInst *Alloca, CallInst *Call);\n \ndiff --git a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\nindex 9196a0147c43..a459a9eddbcf 100644\n--- a/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n+++ b/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp\n@@ -838,14 +838,24 @@ bool FunctionSpecializer::run() {\n }\n \n void FunctionSpecializer::removeDeadFunctions() {\n-  for (Function *F : FullySpecialized) {\n+  for (Function *F : DeadFunctions) {\n     LLVM_DEBUG(dbgs() << \"FnSpecialization: Removing dead function \"\n                       << F->getName() << \"\\n\");\n     if (FAM)\n       FAM->clear(*F, F->getName());\n+\n+    // Remove all the callsites that were proven unreachable once, and replace\n+    // them with poison.\n+    for (User *U : make_early_inc_range(F->users())) {\n+      assert((isa<CallInst>(U) || isa<InvokeInst>(U)) &&\n+             \"User of dead function must be call or invoke\");\n+      Instruction *CS = cast<Instruction>(U);\n+      CS->replaceAllUsesWith(PoisonValue::get(CS->getType()));\n+      CS->eraseFromParent();\n+    }\n     F->eraseFromParent();\n   }\n-  FullySpecialized.clear();\n+  DeadFunctions.clear();\n }\n \n /// Clone the function \\p F and remove the ssa_copy intrinsics added by\n@@ -1206,8 +1216,11 @@ void FunctionSpecializer::updateCallSites(Function *F, const Spec *Begin,\n \n   // If the function has been completely specialized, the original function\n   // is no longer needed. Mark it unreachable.\n-  if (NCallsLeft == 0 && Solver.isArgumentTrackedFunction(F)) {\n+  // NOTE: If the address of a function is taken, we cannot treat it as dead\n+  // function.\n+  if (NCallsLeft == 0 && Solver.isArgumentTrackedFunction(F) &&\n+      !F->hasAddressTaken()) {\n     Solver.markFunctionUnreachable(F);\n-    FullySpecialized.insert(F);\n+    DeadFunctions.insert(F);\n   }\n }\ndiff --git a/llvm/lib/Transforms/IPO/SCCP.cpp b/llvm/lib/Transforms/IPO/SCCP.cpp\nindex d50de34dfa48..e98a70f228ad 100644\n--- a/llvm/lib/Transforms/IPO/SCCP.cpp\n+++ b/llvm/lib/Transforms/IPO/SCCP.cpp\n@@ -169,6 +169,10 @@ static bool runIPSCCP(\n   for (Function &F : M) {\n     if (F.isDeclaration())\n       continue;\n+    // Skip the dead functions marked by FunctionSpecializer, avoiding removing\n+    // blocks in dead functions.\n+    if (IsFuncSpecEnabled && Specializer.isDeadFunction(&F))\n+      continue;\n \n     SmallVector<BasicBlock *, 512> BlocksToErase;\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/FunctionSpecialization/reachable-after-specialization.ll",
      "commands": [
        "opt -passes=ipsccp  --funcspec-min-function-size=1 -S < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine i32 @caller() {\n;\nentry:\n  %call1 = call i32 @callee(i32 1)\n  %call2 = call i32 @callee(i32 0)\n  %cond = icmp eq i32 %call2, 0\n  br i1 %cond, label %common.ret, label %if.then\n\ncommon.ret:                                       ; preds = %entry\n  ret i32 0\n\nif.then:                                         ; preds = %entry\n  %unreachable_call = call i32 @callee(i32 2)\n  ret i32 %unreachable_call\n}\n\ndefine internal i32 @callee(i32 %arg) {\nentry:\n  br label %loop\n\nloop:                                               ; preds = %ai, %entry\n  %add = or i32 0, 0\n  %cond = icmp eq i32 %arg, 1\n  br i1 %cond, label %exit, label %loop\n\nexit:                                               ; preds = %ai\n  ret i32 0\n}\n\ndeclare void @other_user(ptr)\n\ndefine i32 @caller2() {\n;\nentry:\n  call void @other_user(ptr @callee2)\n  %call1 = call i32 @callee2(i32 1)\n  %call2 = call i32 @callee2(i32 0)\n  %cond = icmp eq i32 %call2, 0\n  br i1 %cond, label %common.ret, label %if.then\n\ncommon.ret:                                       ; preds = %entry\n  ret i32 0\n\nif.then:                                         ; preds = %entry\n  %unreachable_call = call i32 @callee2(i32 2)\n  ret i32 %unreachable_call\n}\n\ndefine internal i32 @callee2(i32 %arg) {\n;\nentry:\n  br label %loop\n\nloop:                                               ; preds = %ai, %entry\n  %add = or i32 0, 0\n  %cond = icmp eq i32 %arg, 1\n  br i1 %cond, label %exit, label %loop\n\nexit:                                               ; preds = %ai\n  ret i32 0\n}\n\ndefine i32 @caller3(i32 %arg) {\n;\nentry:\n  %call1 = call i32 @callee3(i32 0)\n  %call2 = call i32 @callee3(i32 1)\n  %cond = icmp eq i32 %call2, 0\n  br i1 %cond, label %common.ret, label %if.then\n\ncommon.ret:                                       ; preds = %entry\n  ret i32 0\n\nif.then:                                         ; preds = %entry\n  %unreachable_call = call i32 @callee3(i32 %arg)\n  ret i32 %unreachable_call\n}\n\ndefine internal i32 @callee3(i32 %arg) {\nentry:\n  br label %loop\n\nloop:                                               ; preds = %ai, %entry\n  %add = or i32 0, 0\n  %cond = icmp ne i32 %arg, 1\n  br i1 %cond, label %exit, label %loop\n\nexit:                                               ; preds = %ai\n  ret i32 %arg\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "clang crashes at -O{1,2,3} on x86_64-linux-gnu: Assertion `pred_empty(DelBB) && \"DelBB has one or more predecessors.\"' failed",
    "body": "Compiler Explorer: https://godbolt.org/z/xcE69Pj9E\n\nNote:\n- fails: 20.1.0 and trunk\n- works: 19.1.0 and earlier\n- original code was valid, but the reduced isn't\n\n```\n[599] % clangtk -v\nclang version 22.0.0git (https://github.com/llvm/llvm-project.git 44f41f55b4df5ec490df0d69e046b2d1a58acaeb)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /local/home/suz/suz-local/software/local/clang-trunk/bin\nBuild config: +assertions\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12\nSelected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12\nCandidate multilib: .;@m64\nSelected multilib: .;@m64\nFound CUDA installation: /usr/local/cuda, version 12.1\n[600] % \n[600] % clangtk -O1 -w -c small.c\nclangtk: /local/suz-local/software/clangbuild/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:91: void llvm::DomTreeUpdater::validateDeleteBB(llvm::BasicBlock*): Assertion `pred_empty(DelBB) && \"DelBB has one or more predecessors.\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\nStack dump:\n0.\tProgram arguments: clangtk -I/usr/local/include -I/local/suz-local/software/local/include -O1 -w -c small.c\n1.\t<eof> parser at end of file\n2.\tOptimizer\n3.\tRunning pass \"ipsccp\" on module \"small.c\"\n #0 0x000055bd288ea430 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x4263430)\n #1 0x000055bd288e70df llvm::sys::RunSignalHandlers() (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x42600df)\n #2 0x000055bd288277d8 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0\n #3 0x00007f13e112e520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007f13e11829fc __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\n #5 0x00007f13e11829fc __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\n #6 0x00007f13e11829fc pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\n #7 0x00007f13e112e476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007f13e11147f3 abort ./stdlib/./stdlib/abort.c:81:7\n #9 0x00007f13e111471b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\n#10 0x00007f13e1125e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n#11 0x000055bd276cf797 llvm::DomTreeUpdater::validateDeleteBB(llvm::BasicBlock*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x3048797)\n#12 0x000055bd276cf926 llvm::DomTreeUpdater::deleteBB(llvm::BasicBlock*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x3048926)\n#13 0x000055bd2a1de05a runIPSCCP(llvm::Module&, llvm::DataLayout const&, llvm::AnalysisManager<llvm::Function>*, std::function<llvm::TargetLibraryInfo const& (llvm::Function&)>, std::function<llvm::TargetTransformInfo& (llvm::Function&)>, std::function<llvm::AssumptionCache& (llvm::Function&)>, std::function<llvm::DominatorTree& (llvm::Function&)>, std::function<llvm::BlockFrequencyInfo& (llvm::Function&)>, bool) SCCP.cpp:0:0\n#14 0x000055bd2a1deca7 llvm::IPSCCPPass::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x5b57ca7)\n#15 0x000055bd299cf216 llvm::detail::PassModel<llvm::Module, llvm::IPSCCPPass, llvm::AnalysisManager<llvm::Module> >::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x5348216)\n#16 0x000055bd2822a194 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module> >::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x3ba3194)\n#17 0x000055bd28b90d13 (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream> >&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> >&, clang::BackendConsumer*) BackendUtil.cpp:0:0\n#18 0x000055bd28b952b3 clang::emitBackendOutput(clang::CompilerInstance&, clang::CodeGenOptions&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream> >, clang::BackendConsumer*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x450e2b3)\n#19 0x000055bd2928f05f clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x4c0805f)\n#20 0x000055bd2acf2a0c clang::ParseAST(clang::Sema&, bool, bool) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x666ba0c)\n#21 0x000055bd295acb59 clang::FrontendAction::Execute() (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x4f25b59)\n#22 0x000055bd295284c5 clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x4ea14c5)\n#23 0x000055bd2969d628 clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x5016628)\n#24 0x000055bd25500d58 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0xe79d58)\n#25 0x000055bd254f735a ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\n#26 0x000055bd292fe17d void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, bool*) const::'lambda'()>(long) Job.cpp:0:0\n#27 0x000055bd28827c80 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x41a0c80)\n#28 0x000055bd292fea1e clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, bool*) const (.part.0) Job.cpp:0:0\n#29 0x000055bd292bbf31 clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x4c34f31)\n#30 0x000055bd292bd051 clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*> >&, bool) const (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x4c36051)\n#31 0x000055bd292c9a34 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*> >&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0x4c42a34)\n#32 0x000055bd254fcbfb clang_main(int, char**, llvm::ToolContext const&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0xe75bfb)\n#33 0x000055bd253c806b main (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0xd4106b)\n#34 0x00007f13e1115d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\n#35 0x00007f13e1115e40 call_init ./csu/../csu/libc-start.c:128:20\n#36 0x00007f13e1115e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\n#37 0x000055bd254f6a85 _start (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-22+0xe6fa85)\nclangtk: error: clang frontend command failed with exit code 134 (use -v to see invocation)\nclang version 22.0.0git (https://github.com/llvm/llvm-project.git 44f41f55b4df5ec490df0d69e046b2d1a58acaeb)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /local/home/suz/suz-local/software/local/clang-trunk/bin\nBuild config: +assertions\nclangtk: note: diagnostic msg: \n********************\n\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\nPreprocessed source(s) and associated run script(s) are located at:\nclangtk: note: diagnostic msg: /tmp/small-9f4e27.c\nclangtk: note: diagnostic msg: /tmp/small-9f4e27.sh\nclangtk: note: diagnostic msg: \n\n********************\n[601] % \n[601] % cat small.c\nint a, b, c, d, e, f, h, i, j, l, n;\nlong g;\nchar k, m;\nint q() {}\nlong r();\nint s();\nint t();\nint u();\nint v() {}\nint w();\nint x(int, int, int, int) { return 0; }\nchar y();\nint z(long);\nint aa(int[]) { return 0; }\nstatic int ab(int ac, int ad, int ae, int af, int ag) {\n  int o = 0, p;\n  a / 1;\n  goto ah;\nai:\n  1 % a + 1 % b + 0;\n  if (5 * s(d + 2, d + 9 + d - 1) + d - 1 % ac - 2 * b + 9 + b - 3 + b -\n      2 * s(ad + ad - 3) + ad - 1)\n    a = o = (char)u - 1 + c + 7 / y(b + 1) + b - 3 + b + 1;\n  if (1 % (s(o + 8 + o - 2) + o) + -p + 1 % (s(0, d + 2, d + 4 + d - 2) + d) +\n      1 / ad - 3)\n    goto ai;\n  ad = 1 + -r(o - 2) + o + 3;\n  if (1 + s(r) + ad - -s(c + 8 + c - 2) + c - 2 / a - 5)\n    d = 1 % p + -z(a + 4 - 2) + a + -s((char)q + 5, a + 7, a + 9 + a - 6) + a -\n        1 % s(p + 1 + p - 3) + p - 1;\n  if (-(-u(0, o + o + 3, o + 3 + o - 1) + o - 1 % (v() + af - 2) + b - 7))\n    goto aj;\nah:\n  d + s(c + 6 + u) - 4294967294 + c + o + -s(0, 0, ad + 3 + ad - 4 - 8) + ad +\n      -a + 1 % s(b + 9, b + 5 + b - 2) + b + 0;\n  if (1 / (char)a - 2 + a + 2 * r(6, 5) - 4 + ac + 1 / s(0) - b + 7 / d + 1)\n    p = -18 / (x(a + 5, 0, a + 2, ac + 3) + ae + ac + o + ag + af - 2) + ae -\n        -ad - 1;\n  goto ai;\naj:\n  b = -s(ac + a + d - 4) + ac - -z(d + 1 + d - 3) + d - 1 % t(p + 1 + p - 1) +\n      p - 1 % s((char)a + 4 + c + a + ad + q) + a - 2 + c - 1;\n  n = m = u(ac + 9);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  w(w);\n  l = s((char)s);\n  k = y(b + 5);\n  j = s(0, b + 7);\n  i = s((char)c + c + 209);\n  h = s(p + 4);\n  g = r(8, 6, 9, 6, 5, 9, 6, 4, 5, 8, 4);\n  f = w(r);\n  e = s(d);\n  int bb[] = {n + a - 2 + a, m + (char)q - 2 + ac, f + ad, l + a - 3 + a,\n                    k + (char)t - 8 + b, j + b - 2 + b, i - 1 + c,\n                    h + p - 5 + p, 0, g + -e + -d};\n  return aa(bb);\n}\nvoid ak() {\n  ab(2, 2, 3, -2, 2);\n  if (q())\n    if (ab(2, 2, 3, 2, 2))\n      ab(2, 2, 9, 1, 1);\n}\n```\n\n",
    "author": "zhendongsu",
    "labels": [
      "ipo",
      "confirmed",
      "crash",
      "function-specialization",
      "regression:20"
    ],
    "comments": [
      {
        "author": "XChy",
        "body": "Interesting case. This is the minimal testcase I can reproduce: https://godbolt.org/z/4r68e88zd. It's still very large. When I tried reducing it manually, I found that even removing one instruction made it not reproducible."
      },
      {
        "author": "XChy",
        "body": "Reduce to minimal by adding parameter `--funcspec-min-function-size=1`:\n```llvm\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i32 @ak() {\nentry:\n  %call34 = call i32 @ab(i32 1)\n  %call223 = call i32 @ab(i32 0)\n  %tobool3.not = icmp eq i32 %call223, 0\n  br i1 %tobool3.not, label %common.ret, label %if.then4\n\ncommon.ret:                                       ; preds = %entry\n  ret i32 0\n\nif.then4:                                         ; preds = %entry\n  %call512 = call i32 @ab(i32 0)\n  ret i32 %call512\n}\n\ndefine internal i32 @ab(i32 %ac) {\nentry:\n  br label %ai\n\nai:                                               ; preds = %ai, %entry\n  %add37 = or i32 0, 0\n  %tobool52.not = icmp eq i32 %ac, 1\n  br i1 %tobool52.not, label %aj, label %ai\n\naj:                                               ; preds = %ai\n  ret i32 0\n}\n```\nI will look into this case this week."
      }
    ]
  },
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  },
  "verified": true
}