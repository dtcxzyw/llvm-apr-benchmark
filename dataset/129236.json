{
  "bug_id": "129236",
  "issue_url": "https://github.com/llvm/llvm-project/issues/129236",
  "bug_type": "crash",
  "base_commit": "fa5db05ca36a732bffb8128ff017c575ec6e1201",
  "knowledge_cutoff": "2025-02-28T12:37:14Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "f937b17e8570082d4710b6dca7a91b5c235c1c70",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          6673,
          6679
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::getInstructionCost"
      ]
    }
  },
  "patch": "commit f937b17e8570082d4710b6dca7a91b5c235c1c70\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Sun Mar 2 10:55:42 2025 +0000\n\n    [LV] Don't query SCEV for non-invariant values in cost model.\n    \n    This fixes a divergence between VPlan and legacy cost model, matching\n    behavior further up in getInstructionCost as well.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/129236.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex c447fa484359..f3bdc95713af 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -6673,7 +6673,8 @@ LoopVectorizationCostModel::getInstructionCost(Instruction *I,\n     // Certain instructions can be cheaper to vectorize if they have a constant\n     // second vector operand. One example of this are shifts on x86.\n     Value *Op2 = I->getOperand(1);\n-    if (!isa<Constant>(Op2) && PSE.getSE()->isSCEVable(Op2->getType()) &&\n+    if (!isa<Constant>(Op2) && TheLoop->isLoopInvariant(Op2) &&\n+        PSE.getSE()->isSCEVable(Op2->getType()) &&\n         isa<SCEVConstant>(PSE.getSCEV(Op2))) {\n       Op2 = cast<SCEVConstant>(PSE.getSCEV(Op2))->getValue();\n     }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-model.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7-avx -S"
      ],
      "tests": [
        {
          "test_name": "cost_ashr_with_op_known_invariant_via_scev",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i32 @cost_ashr_with_op_known_invariant_via_scev(i8 %a) {\nentry:\n  %cmp.i = icmp eq i16 0, 0\n  %conv.i = sext i16 0 to i32\n  %conv5.i = sext i8 %a to i32\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i8 [ 100, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %cmp.i, label %then, label %else\n\nthen:                                             ; preds = %else, %loop.header\n  %p.1 = phi i32 [ %rem.i, %else ], [ 0, %loop.header ]\n  %shr.i = ashr i32 %conv5.i, %p.1\n  %tobool6.not.i = icmp eq i32 %shr.i, 0\n  %sext.i = shl i32 %p.1, 24\n  %0 = ashr exact i32 %sext.i, 24\n  %1 = select i1 %tobool6.not.i, i32 %0, i32 0\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  %rem.i = urem i32 -1, %conv.i\n  %cmp3.i = icmp sgt i32 %rem.i, 1\n  br i1 %cmp3.i, label %loop.latch, label %then\n\nloop.latch:                                       ; preds = %else, %then\n  %p.2 = phi i32 [ 0, %else ], [ %1, %then ]\n  %iv.next = add i8 %iv, -1\n  %ec = icmp eq i8 %iv.next, 0\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret i32 %p.2\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[clang] Crash at -O2: Assertion Assertion `(BestFactor.Width == LegacyVF.Width || PlanForEarlyExitLoop...' failed.",
    "body": "This code crashes at `-O2`:\n\n```c\nchar a;\nstruct b {\n  short c;\n  char d;\n  long e;\n  int f;\n} static g;\nint h;\nvoid i(struct b j) {\n  char k;\n  int l;\n  for (; j.d; --j.d) {\n    l = g.c == 0 ? 0 : 4294967295U % g.c;\n    k = l >= 2 || a >> l ? 0 : l;\n    h = k;\n  }\n}\nvoid m() { i(g); }\n```\n\nCompiler Explorer: https://godbolt.org/z/WG85qYnc6\n\nBisected to https://github.com/llvm/llvm-project/commit/30f3752e54fa7cd595a434a985efbe9a7abe9b65, which was committed by @fhahn \n\nCrash:\n\n```console\nclang: /root/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7589: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || PlanForEarlyExitLoop || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop) || planContainsAdditionalSimplifications(getPlanFor(LegacyVF.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\n```\n\nBacktrace:\n\n```console\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/clang -gdwarf-4 -g -o /app/output.s -mllvm --x86-asm-syntax=intel -fno-verbose-asm -S --gcc-toolchain=/opt/compiler-explorer/gcc-snapshot -fcolor-diagnostics -fno-crash-diagnostics -O2 -Wall -Wextra <source>\n1.\t<eof> parser at end of file\n2.\tOptimizer\n3.\tRunning pass \"function<eager-inv>(float2int,lower-constant-intrinsics,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O2>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"<source>\"\n4.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"i\"\n #0 0x0000000003e76828 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3e76828)\n #1 0x0000000003e744e4 llvm::sys::CleanupOnSignal(unsigned long) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3e744e4)\n #2 0x0000000003dc0e18 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0\n #3 0x00007e3b78e42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x00007e3b78e969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #5 0x00007e3b78e42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #6 0x00007e3b78e287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #7 0x00007e3b78e2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #8 0x00007e3b78e39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #9 0x00000000059b6042 llvm::LoopVectorizationPlanner::computeBestVF() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x59b6042)\n#10 0x00000000059cd46c llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x59cd46c)\n#11 0x00000000059cfb19 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x59cfb19)\n#12 0x00000000059d0193 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x59d0193)\n#13 0x0000000005546d4e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x5546d4e)\n#14 0x000000000381d3f0 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x381d3f0)\n#15 0x000000000119ab8e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x119ab8e)\n#16 0x000000000381bd0b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x381bd0b)\n#17 0x0000000001199e3e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x1199e3e)\n#18 0x000000000381b710 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x381b710)\n#19 0x00000000041305e8 (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&, clang::BackendConsumer*) BackendUtil.cpp:0:0\n#20 0x000000000413485e clang::emitBackendOutput(clang::CompilerInstance&, clang::CodeGenOptions&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>, clang::BackendConsumer*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x413485e)\n#21 0x0000000004835d60 clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4835d60)\n#22 0x000000000642100c clang::ParseAST(clang::Sema&, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x642100c)\n#23 0x0000000004836168 clang::CodeGenAction::ExecuteAction() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4836168)\n#24 0x0000000004afe6e5 clang::FrontendAction::Execute() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4afe6e5)\n#25 0x0000000004a81dce clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4a81dce)\n#26 0x0000000004bec53e clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4bec53e)\n#27 0x0000000000d4401f cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xd4401f)\n#28 0x0000000000d3b93a ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\n#29 0x000000000487e099 void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()>(long) Job.cpp:0:0\n#30 0x0000000003dc12c4 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3dc12c4)\n#31 0x000000000487e68f clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const (.part.0) Job.cpp:0:0\n#32 0x00000000048412ad clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x48412ad)\n#33 0x000000000484232e clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x484232e)\n#34 0x000000000484a2c5 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x484a2c5)\n#35 0x0000000000d40e13 clang_main(int, char**, llvm::ToolContext const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xd40e13)\n#36 0x0000000000c11aa4 main (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xc11aa4)\n#37 0x00007e3b78e29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#38 0x00007e3b78e29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#39 0x0000000000d3b3e5 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xd3b3e5)\n```",
    "author": "cardigan1008",
    "labels": [
      "regression",
      "vectorizers",
      "crash"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "30f3752e54fa7cd595a434a985efbe9a7abe9b65"
}