{
  "bug_id": "157238",
  "issue_url": "https://github.com/llvm/llvm-project/issues/157238",
  "bug_type": "miscompilation",
  "base_commit": "18507a7a6bf1c82e2614b3995320ebab8dd60ef2",
  "knowledge_cutoff": "2025-09-06T06:55:06Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "ea59be552f1db4f8f2e8a3edd909f17802339970",
    "components": [
      "ValueTracking"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        [
          5070,
          5075
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        "computeKnownFPClass"
      ]
    }
  },
  "patch": "commit ea59be552f1db4f8f2e8a3edd909f17802339970\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Tue Sep 16 20:59:42 2025 +0800\n\n    [ValueTracking] Don't take sign bit from NaN operands (#157250)\n    \n    Closes https://github.com/llvm/llvm-project/issues/157238.\n\ndiff --git a/llvm/lib/Analysis/ValueTracking.cpp b/llvm/lib/Analysis/ValueTracking.cpp\nindex 129823e0e98a..73192a75fa50 100644\n--- a/llvm/lib/Analysis/ValueTracking.cpp\n+++ b/llvm/lib/Analysis/ValueTracking.cpp\n@@ -5070,6 +5070,11 @@ void computeKnownFPClass(const Value *V, const APInt &DemandedElts,\n                      KnownRHS.isKnownNeverPosZero()) &&\n                     (KnownLHS.isKnownNeverPosZero() ||\n                      KnownRHS.isKnownNeverNegZero()))) {\n+          // Don't take sign bit from NaN operands.\n+          if (!KnownLHS.isKnownNeverNaN())\n+            KnownLHS.SignBit = std::nullopt;\n+          if (!KnownRHS.isKnownNeverNaN())\n+            KnownRHS.SignBit = std::nullopt;\n           if ((IID == Intrinsic::maximum || IID == Intrinsic::maximumnum ||\n                IID == Intrinsic::maxnum) &&\n               (KnownLHS.SignBit == false || KnownRHS.SignBit == false))\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/is_fpclass.ll",
      "commands": [
        "opt -S -passes=instcombine < %s"
      ],
      "tests": [
        {
          "test_name": "minnum_qnan",
          "test_body": "define i1 @minnum_qnan(i32 %x) {\nentry:\n  %qnan_bits = or i32 %x, -5938\n  %qnan = bitcast i32 %qnan_bits to float\n  %min = call float @llvm.minnum.f32(float %qnan, float 0.000000e+00)\n  %test = call i1 @llvm.is.fpclass.f32(float %min, i32 64)\n  ret i1 %test\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i1 @llvm.is.fpclass.f32(float, i32 immarg) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.minnum.f32(float, float) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "test_class_is_not_psub_pnorm_pinf__dynamic",
          "test_body": "define i1 @test_class_is_not_psub_pnorm_pinf__dynamic(float %arg) #0 {\n  %class = call i1 @llvm.is.fpclass.f32(float %arg, i32 127)\n  ret i1 %class\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i1 @llvm.is.fpclass.f32(float, i32 immarg) #1\n\nattributes #0 = { \"denormal-fp-math\"=\"dynamic,dynamic\" }\nattributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "minnum_qnan_commuted",
          "test_body": "define i1 @minnum_qnan_commuted(i32 %x, float nofpclass(nan ninf nzero nsub nnorm) %y) {\nentry:\n  %qnan_bits = or i32 %x, -5938\n  %qnan = bitcast i32 %qnan_bits to float\n  %min = call float @llvm.minnum.f32(float %y, float %qnan)\n  %test = call i1 @llvm.is.fpclass.f32(float %min, i32 64)\n  ret i1 %test\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i1 @llvm.is.fpclass.f32(float, i32 immarg) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.minnum.f32(float, float) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] Wrong folding of is.fpclass + minnum",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/zTqnNp\n```\n; bin/opt -passes=instcombine test.ll -S\ndefine i1 @src(i32 %x) {\nentry:\n  %or102.i.i = or i32 %x, -5938\n  %0 = bitcast i32 %or102.i.i to float\n  %1 = call float @llvm.minnum.f32(float %0, float 0.000000e+00)\n  %tobool106.not2.i.i = call i1 @llvm.is.fpclass.f32(float %1, i32 64)\n  ret i1 %tobool106.not2.i.i\n}\n```\n```\n\n----------------------------------------\ndefine i1 @src(i32 %x) {\nentry:\n  %or102.i.i = or i32 %x, 4294961358\n  %#0 = bitcast i32 %or102.i.i to float\n  %#1 = fmin float %#0, 0.000000\n  %tobool106.not2.i.i = is.fpclass float %#1, i32 64\n  ret i1 %tobool106.not2.i.i\n}\n=>\ndefine i1 @src(i32 %x) nofree noundef willreturn memory(none) {\nentry:\n  ret i1 0\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nExample:\ni32 %x = #x00000000 (0)\n\nSource:\ni32 %or102.i.i = #xffffe8ce (4294961358, -5938)\nfloat %#0 = #xffffe8ce (QNaN)\nfloat %#1 = #x00000000 (+0.0)\ni1 %tobool106.not2.i.i = #x1 (1)\n\nTarget:\nSource value: #x1 (1)\nTarget value: #x0 (0)\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors\n```\n",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "floating-point",
      "llvm:analysis",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "I hit another case reported by riscv-tv: https://alive2.llvm.org/ce/z/DGiq7g\nPerhaps this is an Alive2 bug.\n"
      },
      {
        "author": "dtcxzyw",
        "body": "> I hit another case reported by riscv-tv: https://alive2.llvm.org/ce/z/DGiq7g Perhaps this is an Alive2 bug.\n\nThey are different bugs."
      },
      {
        "author": "nikic",
        "body": "> I hit another case reported by riscv-tv: https://alive2.llvm.org/ce/z/DGiq7g Perhaps this is an Alive2 bug.\n\nI think this is because alive2 does not implement the \"new\" minnum semantics (see https://github.com/llvm/llvm-project/pull/138451). We should really update LangRef to specify nondet behavior for sNaN input."
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}