{
  "bug_id": "157714",
  "issue_url": "https://github.com/llvm/llvm-project/issues/157714",
  "bug_type": "miscompilation",
  "base_commit": "924bf242c8e0ef61544471488eb9e729dda72a50",
  "knowledge_cutoff": "2025-09-09T17:00:35Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "dcdbb39786a56181e1612354ecb8ecf5a7b0f449",
    "components": [
      "InstCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp": [
        [
          2115,
          2120
        ],
        [
          2123,
          2129
        ],
        [
          2132,
          2144
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp": [
        "CommonPointerBase::compute"
      ]
    }
  },
  "patch": "commit dcdbb39786a56181e1612354ecb8ecf5a7b0f449\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Wed Sep 10 15:57:27 2025 +0200\n\n    [InstCombine] Use intersectForOffsetAdd() in CommonPointerBase (#157851)\n    \n    Transforms using this helper will add up all the offsets, so we should\n    use intersectForOffsetAdd() instead of plain intersection.\n    \n    Annoyingly, this requires specially handling the first GEP to avoid\n    losing flags in that case.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/157714.\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp b/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp\nindex d934638c15e7..f9155cc66031 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp\n@@ -2115,6 +2115,7 @@ CommonPointerBase CommonPointerBase::compute(Value *LHS, Value *RHS) {\n   }\n \n   // Find common base and collect RHS GEPs.\n+  bool First = true;\n   while (true) {\n     if (Ptrs.contains(RHS)) {\n       Base.Ptr = RHS;\n@@ -2123,7 +2124,12 @@ CommonPointerBase CommonPointerBase::compute(Value *LHS, Value *RHS) {\n \n     if (auto *GEP = dyn_cast<GEPOperator>(RHS)) {\n       Base.RHSGEPs.push_back(GEP);\n-      Base.RHSNW &= GEP->getNoWrapFlags();\n+      if (First) {\n+        First = false;\n+        Base.RHSNW = GEP->getNoWrapFlags();\n+      } else {\n+        Base.RHSNW = Base.RHSNW.intersectForOffsetAdd(GEP->getNoWrapFlags());\n+      }\n       RHS = GEP->getPointerOperand();\n     } else {\n       // No common base.\n@@ -2132,13 +2138,19 @@ CommonPointerBase CommonPointerBase::compute(Value *LHS, Value *RHS) {\n   }\n \n   // Collect LHS GEPs.\n+  First = true;\n   while (true) {\n     if (LHS == Base.Ptr)\n       break;\n \n     auto *GEP = cast<GEPOperator>(LHS);\n     Base.LHSGEPs.push_back(GEP);\n-    Base.LHSNW &= GEP->getNoWrapFlags();\n+    if (First) {\n+      First = false;\n+      Base.LHSNW = GEP->getNoWrapFlags();\n+    } else {\n+      Base.LHSNW = Base.LHSNW.intersectForOffsetAdd(GEP->getNoWrapFlags());\n+    }\n     LHS = GEP->getPointerOperand();\n   }\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/icmp-gep.ll",
      "commands": [
        "opt -passes=instcombine -S  < %s"
      ],
      "tests": [
        {
          "test_name": "gep_mugtiple_ugt_not_all_nuw",
          "test_body": "target datalayout = \"e-p:64:64:64-p1:16:16:16-p2:32:32:32-p3:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\"\n\ndefine i1 @gep_mugtiple_ugt_not_all_nuw(ptr %base, i64 %idx, i64 %idx2) {\n  %gep1 = getelementptr nuw i32, ptr %base, i64 %idx\n  %gep2 = getelementptr i32, ptr %gep1, i64 %idx2\n  %cmp = icmp ugt ptr %gep2, %base\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "gep_mugtiple_ugt_inbounds_nusw",
          "test_body": "target datalayout = \"e-p:64:64:64-p1:16:16:16-p2:32:32:32-p3:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\"\n\ndefine i1 @gep_mugtiple_ugt_inbounds_nusw(ptr %base, i64 %idx, i64 %idx2) {\n  %gep1 = getelementptr inbounds i32, ptr %base, i64 %idx\n  %gep2 = getelementptr nusw i32, ptr %gep1, i64 %idx2\n  %cmp = icmp ugt ptr %gep2, %base\n  ret i1 %cmp\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] Miscompilation in foldGEPICmp",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/SLybDz\n```\ndefine i1 @gep_mugtiple_ugt_inbounds_nusw(ptr %base, i64 %idx, i64 %idx2) {\n  %gep1 = getelementptr inbounds i8, ptr %base, i64 %idx\n  %gep2 = getelementptr nusw i8, ptr %gep1, i64 %idx2\n  %cmp = icmp ugt ptr %gep2, %base\n  ret i1 %cmp\n}\n```\n```\n=>\ndefine i1 @gep_mugtiple_ugt_inbounds_nusw(ptr %base, i64 %idx, i64 %idx2) {\n#0:\n  %#1 = add i64 %idx, %idx2\n  %cmp = icmp sgt i64 %#1, 0\n  ret i1 %cmp\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nExample:\nptr %base = pointer(non-local, block_id=1, offset=0) / Address=#x000000000000000c\ni64 %idx = #x7ffffffffffffffc (9223372036854775804)\ni64 %idx2 = #x0000000000000005 (5)\n\nSource:\nptr %gep1 = pointer(non-local, block_id=1, offset=9223372036854775804) / Address=#x8000000000000008\nptr %gep2 = pointer(non-local, block_id=1, offset=-9223372036854775807) / Address=#x800000000000000d\ni1 %cmp = #x1 (1)\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\tsize: 0\talign: 1\talloc type: 0\talive: false\taddress: #x0000000000000000\nBlock 1 >\tsize: 9223372036854775804\talign: 1\talloc type: 0\talive: true\taddress: #x000000000000000c\n\nTarget:\ni64 %#1 = #x8000000000000001 (9223372036854775809, -9223372036854775807)\ni1 %cmp = #x0 (0)\nSource value: #x1 (1)\nTarget value: #x0 (0)\n```\ncc @nikic ",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:instcombine",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "nikic",
        "body": "Probably CommonPointerBase needs to use intersectForOffsetAdd."
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true,
  "bisect": "N/A"
}