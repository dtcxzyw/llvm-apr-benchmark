{
  "bug_id": "157322",
  "issue_url": "https://github.com/llvm/llvm-project/issues/157322",
  "bug_type": "crash",
  "base_commit": "4c6a56225f3982ab2de7f8acb8d8560079a830c8",
  "knowledge_cutoff": "2025-09-07T04:03:31Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "fe6e17840159f7ae9785d8506ff2987a2df7ab08",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp": [
        [
          193,
          198
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp": [
        "PlainCFGBuilder::createVPInstructionsForVPBB"
      ]
    }
  },
  "patch": "commit fe6e17840159f7ae9785d8506ff2987a2df7ab08\nAuthor: Luke Lau <luke@igalia.com>\nDate:   Mon Sep 8 17:01:43 2025 +0800\n\n    [VPlan] Don't build recipes for unconditional switches (#157323)\n    \n    In #157322 we crash because we try to infer a type for a VPReplicate\n    switch recipe.\n    \n    My understanding was that these switches should be removed by\n    VPlanPredicator, but this switch survived through it because it was\n    unconditional, i.e. had no cases other than the default case.\n    \n    This fixes #157322 by not emitting any recipes for unconditional\n    switches to begin with, similar to how we treat unconditional branches.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp b/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\nindex c1c525ee2312..cef91c15dd87 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\n@@ -193,6 +193,9 @@ void PlainCFGBuilder::createVPInstructionsForVPBB(VPBasicBlock *VPBB,\n     }\n \n     if (auto *SI = dyn_cast<SwitchInst>(Inst)) {\n+      // Don't emit recipes for unconditional switch instructions.\n+      if (SI->getNumCases() == 0)\n+        continue;\n       SmallVector<VPValue *> Ops = {getOrCreateVPOperand(SI->getCondition())};\n       for (auto Case : SI->cases())\n         Ops.push_back(getOrCreateVPOperand(Case.getCaseValue()));\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/predicate-switch.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=2 -force-vector-interleave=1 -S %s",
        "opt -p loop-vectorize -force-vector-width=2 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "switch_unconditional",
          "test_body": "define void @switch_unconditional(ptr %start) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %gep = getelementptr i32, ptr %start, i64 %iv\n  %x = load i32, ptr %gep, align 4\n  switch i32 %x, label %foo [\n  ]\n\nfoo:                                              ; preds = %loop\n  br label %latch\n\nlatch:                                            ; preds = %foo\n  store i32 0, ptr %gep, align 4\n  %iv.next = add i64 %iv, 1\n  %cmp = icmp eq i64 %iv.next, 100\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %latch\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[Loop Vectorizer] Unhandled opcode UNREACHABLE executed at /root/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp:257!",
    "body": "Reproducer:\nhttps://godbolt.org/z/M3rojTjfc\n\nBacktrace:\n```console\nUnhandled opcode\nUNREACHABLE executed at /root/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp:257!\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=loop-vectorize <source>\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"<source>\"\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"switch\"\n #0 0x00000000057a4688 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x57a4688)\n #1 0x00000000057a1534 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x0000705e12842520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x0000705e128969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x0000705e12842476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x0000705e128287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x00000000056db7aa (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x56db7aa)\n #7 0x00000000036a2db0 llvm::VPTypeAnalysis::inferScalarTypeForRecipe(llvm::VPReplicateRecipe const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36a2db0)\n #8 0x00000000036a295c llvm::VPTypeAnalysis::inferScalarType(llvm::VPValue const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36a295c)\n #9 0x000000000372765d (anonymous namespace)::VPlanVerifier::verifyVPBasicBlock(llvm::VPBasicBlock const*) VPlanVerifier.cpp:0:0\n#10 0x0000000003729f01 (anonymous namespace)::VPlanVerifier::verifyBlock(llvm::VPBlockBase const*) VPlanVerifier.cpp:0:0\n#11 0x000000000372b34a (anonymous namespace)::VPlanVerifier::verifyRegionRec(llvm::VPRegionBlock const*) VPlanVerifier.cpp:0:0\n#12 0x000000000372d952 llvm::verifyVPlanIsValid(llvm::VPlan const&, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x372d952)\n#13 0x000000000352ce13 llvm::LoopVectorizationPlanner::tryToBuildVPlanWithVPRecipes(std::unique_ptr<llvm::VPlan, std::default_delete<llvm::VPlan>>, llvm::VFRange&, llvm::LoopVersioning*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x352ce13)\n#14 0x000000000352d428 llvm::LoopVectorizationPlanner::buildVPlansWithVPRecipes(llvm::ElementCount, llvm::ElementCount) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x352d428)\n#15 0x000000000352dd34 llvm::LoopVectorizationPlanner::plan(llvm::ElementCount, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x352dd34)\n#16 0x0000000003531b77 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3531b77)\n#17 0x0000000003534da0 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3534da0)\n#18 0x000000000353544d llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x353544d)\n#19 0x0000000002e2b1ee llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2e2b1ee)\n#20 0x00000000055904d1 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x55904d1)\n#21 0x0000000000ee0cbe llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xee0cbe)\n#22 0x000000000558ea3a llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x558ea3a)\n#23 0x000000000096d5ae llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x96d5ae)\n#24 0x000000000558e3f1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x558e3f1)\n#25 0x00000000009778a8 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9778a8)\n#26 0x000000000096b917 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x96b917)\n#27 0x0000705e12829d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#28 0x0000705e12829e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#29 0x0000000000962a35 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x962a35)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "k-arrows",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "k-arrows",
        "body": "This comes from the following:\nhttps://github.com/llvm/llvm-project/blob/main/llvm/test/Transforms/LoopUnroll/full-unroll-crashers.ll"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true,
  "bisect": "95ba5508e5dca4c9a3dd50c80b89e3f56016a4f3"
}