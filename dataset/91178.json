{
  "bug_id": "91178",
  "issue_url": "https://github.com/llvm/llvm-project/issues/91178",
  "bug_type": "miscompilation",
  "base_commit": "7098cd215b95286794d9e0c822e8323ad0509750",
  "knowledge_cutoff": "2024-05-06T09:44:48Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine",
    "llvm/test/Transforms/PGOProfile"
  ],
  "hints": {
    "fix_commit": "d085b42cbbefe79a41113abcd2b1e1f2a203acef",
    "components": [
      "InstructionSimplify"
    ],
    "files": [
      "llvm/lib/Analysis/InstructionSimplify.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/InstructionSimplify.cpp": [
        [
          4312,
          4317
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/InstructionSimplify.cpp": [
        "simplifyWithOpReplaced"
      ]
    }
  },
  "patch": "commit d085b42cbbefe79a41113abcd2b1e1f2a203acef\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Wed May 8 10:04:09 2024 +0800\n\n    [InstSimplify] Do not simplify freeze in `simplifyWithOpReplaced` (#91215)\n    \n    See the LangRef:\n    > All uses of a value returned by the same \u2018freeze\u2019 instruction are\n    guaranteed to always observe the same value, while different \u2018freeze\u2019\n    instructions may yield different values.\n    \n    It is incorrect to replace freezes with the simplified value.\n    \n    Proof:\n    https://alive2.llvm.org/ce/z/3Dn9Cd\n    https://alive2.llvm.org/ce/z/Qyh5h6\n    \n    Fixes https://github.com/llvm/llvm-project/issues/91178\n\ndiff --git a/llvm/lib/Analysis/InstructionSimplify.cpp b/llvm/lib/Analysis/InstructionSimplify.cpp\nindex 4061dae83c10..37a7259a5cd0 100644\n--- a/llvm/lib/Analysis/InstructionSimplify.cpp\n+++ b/llvm/lib/Analysis/InstructionSimplify.cpp\n@@ -4312,6 +4312,10 @@ static Value *simplifyWithOpReplaced(Value *V, Value *Op, Value *RepOp,\n   if (match(I, m_Intrinsic<Intrinsic::is_constant>()))\n     return nullptr;\n \n+  // Don't simplify freeze.\n+  if (isa<FreezeInst>(I))\n+    return nullptr;\n+\n   // Replace Op with RepOp in instruction operands.\n   SmallVector<Value *, 8> NewOps;\n   bool AnyReplaced = false;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/icmp.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "icmp_freeze_sext",
          "test_body": "target datalayout = \"e-p:64:64:64-p1:16:16:16-p2:32:32:32-p3:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\"\n\ndefine i1 @icmp_freeze_sext(i16 %x, i16 %y) {\n  %cmp1 = icmp uge i16 %x, %y\n  %ext = sext i1 %cmp1 to i16\n  %ext.fr = freeze i16 %ext\n  %cmp2 = icmp uge i16 %ext.fr, %y\n  ret i1 %cmp2\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/InstCombine/select.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "test_replace_freeze_multiuse",
          "test_body": "target datalayout = \"e-p:64:64-p1:16:16-p2:32:32:32-p3:64:64:64\"\n\ndefine i8 @test_replace_freeze_multiuse(i1 %x, i8 %y) {\n  %ext = zext i1 %x to i8\n  %shl = shl nuw i8 %ext, %y\n  %shl.fr = freeze i8 %shl\n  %sel = select i1 %x, i8 0, i8 %shl.fr\n  %add = add i8 %shl.fr, %sel\n  ret i8 %add\n}\n"
        },
        {
          "test_name": "test_replace_freeze_oneuse",
          "test_body": "target datalayout = \"e-p:64:64-p1:16:16-p2:32:32:32-p3:64:64:64\"\n\ndefine i8 @test_replace_freeze_oneuse(i1 %x, i8 %y) {\n  %ext = zext i1 %x to i8\n  %shl = shl nuw i8 %ext, %y\n  %shl.fr = freeze i8 %shl\n  %sel = select i1 %x, i8 0, i8 %shl.fr\n  ret i8 %sel\n}\n"
        },
        {
          "test_name": "sequence_select_with_same_cond_extra_use",
          "test_body": "target datalayout = \"e-p:64:64-p1:16:16-p2:32:32:32-p3:64:64:64\"\n\ndeclare void @use32(i32)\n\ndefine i32 @sequence_select_with_same_cond_extra_use(i1 %c1, i1 %c2) {\n  %s1 = select i1 %c1, i32 23, i32 45\n  call void @use32(i32 %s1)\n  %s2 = select i1 %c2, i32 666, i32 %s1\n  %s3 = select i1 %c1, i32 789, i32 %s2\n  ret i32 %s3\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/PGOProfile/chr.ll",
      "commands": [
        "opt < %s -passes='require<profile-summary>,function(chr,instcombine,simplifycfg)' -S"
      ],
      "tests": [
        {
          "test_name": "test_chr_14",
          "test_body": "declare void @foo()\n\ndefine i32 @test_chr_14(ptr %i, ptr %j, i32 %sum0, i1 %pred, i32 %z) !prof !14 {\nentry:\n  %i0 = load i32, ptr %i, align 4\n  %v0 = icmp eq i32 %z, 0\n  %v1 = icmp ne i32 %z, 1\n  %v2 = select i1 %v1, i1 %pred, i1 true, !prof !15\n  %v3 = and i1 %v0, %pred\n  br i1 %v3, label %bb0, label %bb1, !prof !15\n\nbb0:                                              ; preds = %entry\n  call void @foo()\n  br label %bb1\n\nbb1:                                              ; preds = %bb0, %entry\n  %j0 = load i32, ptr %j, align 4\n  %v6 = and i32 %i0, 2\n  %v4 = icmp eq i32 %v6, %j0\n  %v8 = add i32 %sum0, 43\n  %sum2 = select i1 %v4, i32 %sum0, i32 %v8, !prof !15\n  %v5 = icmp eq i32 %i0, %j0\n  %sum3 = select i1 %v5, i32 %sum0, i32 %v8, !prof !15\n  call void @foo()\n  %v9 = and i32 %i0, 4\n  %v10 = icmp eq i32 %v9, 0\n  br i1 %v10, label %bb3, label %bb2\n\nbb2:                                              ; preds = %bb1\n  call void @foo()\n  br label %bb3\n\nbb3:                                              ; preds = %bb2, %bb1\n  %v11 = add i32 %i0, %sum3\n  ret i32 %v11\n}\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 1, !\"ProfileSummary\", !1}\n!1 = !{!2, !3, !4, !5, !6, !7, !8, !9}\n!2 = !{!\"ProfileFormat\", !\"InstrProf\"}\n!3 = !{!\"TotalCount\", i64 10000}\n!4 = !{!\"MaxCount\", i64 10}\n!5 = !{!\"MaxInternalCount\", i64 1}\n!6 = !{!\"MaxFunctionCount\", i64 1000}\n!7 = !{!\"NumCounts\", i64 3}\n!8 = !{!\"NumFunctions\", i64 3}\n!9 = !{!\"DetailedSummary\", !10}\n!10 = !{!11, !12, !13}\n!11 = !{i32 10000, i64 100, i32 1}\n!12 = !{i32 999000, i64 100, i32 1}\n!13 = !{i32 999999, i64 1, i32 2}\n!14 = !{!\"function_entry_count\", i64 100}\n!15 = !{!\"branch_weights\", i32 0, i32 1}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] Miscompilation which simplifies a use of a multi-use freeze",
    "body": "Reduced test case: https://alive2.llvm.org/ce/z/_JyUGw\r\n```\r\ndefine i8 @func78(i1 %0, i8 %1) {\r\n  %3 = zext i1 %0 to i8\r\n  %4 = shl i8 %3, %1\r\n  %5 = freeze i8 %4\r\n  %6 = select i1 %0, i8 0, i8 %5\r\n  %7 = call i8 @llvm.fshr.i8(i8 0, i8 %5, i8 %6)\r\n  ret i8 %7\r\n}\r\n```\r\n\r\n```\r\n----------------------------------------\r\ndefine i8 @func78(i1 %#0, i8 %#1) {\r\n#2:\r\n  %#3 = zext i1 %#0 to i8\r\n  %#4 = shl i8 %#3, %#1\r\n  %#5 = freeze i8 %#4\r\n  %#6 = select i1 %#0, i8 0, i8 %#5\r\n  %#7 = fshr i8 0, i8 %#5, i8 %#6\r\n  ret i8 %#7\r\n}\r\n=>\r\ndefine i8 @func78(i1 %#0, i8 %#1) nofree noundef willreturn memory(none) {\r\n#2:\r\n  %#3 = zext i1 %#0 to i8\r\n  %#4 = shl nuw i8 %#3, %#1\r\n  %#5 = freeze i8 %#4\r\n  ret i8 %#5\r\n}\r\nTransformation doesn't verify!\r\n\r\nERROR: Value mismatch\r\n\r\nExample:\r\ni1 %#0 = #x0 (0)\r\ni8 %#1 = #x08 (8)\r\n\r\nSource:\r\ni8 %#3 = #x00 (0)\r\ni8 %#4 = poison\r\ni8 %#5 = #x00 (0)\r\ni8 %#6 = #x00 (0)\r\ni8 %#7 = #x00 (0)\r\n\r\nTarget:\r\ni8 %#3 = #x00 (0)\r\ni8 %#4 = poison\r\ni8 %#5 = #x9d (157, -99)\r\nSource value: #x00 (0)\r\nTarget value: #x9d (157, -99)\r\n\r\nSummary:\r\n  0 correct transformations\r\n  1 incorrect transformations\r\n  0 failed-to-prove transformations\r\n  0 Alive2 errors\r\n```",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:instcombine"
    ],
    "comments": []
  }
}
