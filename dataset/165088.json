{
  "bug_id": "165088",
  "issue_url": "https://github.com/llvm/llvm-project/issues/165088",
  "bug_type": "crash",
  "base_commit": "d604ab62885fcc4aaa66b712125377a01dcc7e1a",
  "knowledge_cutoff": "2025-10-25T08:59:06Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SimplifyCFG"
  ],
  "hints": {
    "fix_commit": "e8a1162b7be6cf11041260886097843ce9f5e4a3",
    "components": [
      "SimplifyCFG"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp": [
        [
          5228,
          5259
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp": [
        "SimplifyCFGOpt::simplifyBranchOnICmpChain"
      ]
    }
  },
  "patch": "commit e8a1162b7be6cf11041260886097843ce9f5e4a3\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Wed Oct 29 10:52:28 2025 +0800\n\n    [SimplifyCFG] Use range check in simplifyBranchOnICmpChain if possible (#165105)\n    \n    In `simplifyBranchOnICmpChain`, if we can merge the comparisons into a\n    range check, use a conditional branch instead. This change also breaks\n    the cycle found in https://github.com/llvm/llvm-project/issues/165088.\n    \n    Closes https://github.com/llvm/llvm-project/issues/165088.\n    \n    Detailed description of the cycle:\n    \n    ```\n    define void @pr165088_cycle_1(i8 %x) {\n    entry:\n      %switch = icmp uge i8 %x, 2\n      %cond1 = icmp ugt i8 %x, 1\n      %or.cond = and i1 %switch, %cond1\n      br i1 %or.cond, label %block3, label %block2\n    \n    block1:\n      %cond2 = icmp ugt i8 %x, 1\n      br i1 %cond2, label %block3, label %block2\n    \n    block2:\n      br label %block3\n    \n    block3:\n      %cond3 = icmp eq i8 %x, 0\n      br i1 %cond3, label %exit, label %block1\n    \n    exit:\n      ret void\n    }\n    ```\n    \n    `simplifyBranchOnICmpChain` folds the branch in `entry` to a switch.\n    Then we get:\n    ```\n    entry:\n      switch i8 %x, label %block3 [\n      i8 1, label %block2\n      i8 0, label %block2\n      ]\n    \n    ...\n    ```\n    \n    `performValueComparisonIntoPredecessorFolding` redirects the default\n    target `block3` into `block1` because `%x` is never zero.\n    ```\n    entry:\n      switch i8 %x, label %block1 [\n      i8 1, label %block2\n      i8 0, label %block2\n      ]\n    ...\n    ```\n    \n    Then `turnSwitchRangeIntoICmp` will convert the switch back into a\n    branch on icmp.\n    ```\n    entry:\n      %switch = icmp ult i8 %x, 2\n      br i1 %switch, label %block2, label %block1\n    ...\n    ```\n    \n    Since `block1` and `block2` share the same successor `block3`,\n    `performBranchToCommonDestFolding` merges the conditions of `entry` and\n    `block1`, resulting in the original pattern again.\n\ndiff --git a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\nindex c537be5cba37..4fac5d36ddb3 100644\n--- a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\n+++ b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\n@@ -5228,32 +5228,52 @@ bool SimplifyCFGOpt::simplifyBranchOnICmpChain(BranchInst *BI,\n         CompVal, DL.getIntPtrType(CompVal->getType()), \"magicptr\");\n   }\n \n-  // Create the new switch instruction now.\n-  SwitchInst *New = Builder.CreateSwitch(CompVal, DefaultBB, Values.size());\n-  if (HasProfile) {\n-    // We know the weight of the default case. We don't know the weight of the\n-    // other cases, but rather than completely lose profiling info, we split\n-    // the remaining probability equally over them.\n-    SmallVector<uint32_t> NewWeights(Values.size() + 1);\n-    NewWeights[0] = BranchWeights[1]; // this is the default, and we swapped if\n-                                      // TrueWhenEqual.\n-    for (auto &V : drop_begin(NewWeights))\n-      V = BranchWeights[0] / Values.size();\n-    setBranchWeights(*New, NewWeights, /*IsExpected=*/false);\n-  }\n-\n-  // Add all of the 'cases' to the switch instruction.\n-  for (ConstantInt *Val : Values)\n-    New->addCase(Val, EdgeBB);\n-\n-  // We added edges from PI to the EdgeBB.  As such, if there were any\n-  // PHI nodes in EdgeBB, they need entries to be added corresponding to\n-  // the number of edges added.\n-  for (BasicBlock::iterator BBI = EdgeBB->begin(); isa<PHINode>(BBI); ++BBI) {\n-    PHINode *PN = cast<PHINode>(BBI);\n-    Value *InVal = PN->getIncomingValueForBlock(BB);\n-    for (unsigned i = 0, e = Values.size() - 1; i != e; ++i)\n-      PN->addIncoming(InVal, BB);\n+  // Check if we can represent the values as a contiguous range. If so, we use a\n+  // range check + conditional branch instead of a switch.\n+  if (Values.front()->getValue() - Values.back()->getValue() ==\n+      Values.size() - 1) {\n+    ConstantRange RangeToCheck = ConstantRange::getNonEmpty(\n+        Values.back()->getValue(), Values.front()->getValue() + 1);\n+    APInt Offset, RHS;\n+    ICmpInst::Predicate Pred;\n+    RangeToCheck.getEquivalentICmp(Pred, RHS, Offset);\n+    Value *X = CompVal;\n+    if (!Offset.isZero())\n+      X = Builder.CreateAdd(X, ConstantInt::get(CompVal->getType(), Offset));\n+    Value *Cond =\n+        Builder.CreateICmp(Pred, X, ConstantInt::get(CompVal->getType(), RHS));\n+    BranchInst *NewBI = Builder.CreateCondBr(Cond, EdgeBB, DefaultBB);\n+    if (HasProfile)\n+      setBranchWeights(*NewBI, BranchWeights, /*IsExpected=*/false);\n+    // We don't need to update PHI nodes since we don't add any new edges.\n+  } else {\n+    // Create the new switch instruction now.\n+    SwitchInst *New = Builder.CreateSwitch(CompVal, DefaultBB, Values.size());\n+    if (HasProfile) {\n+      // We know the weight of the default case. We don't know the weight of the\n+      // other cases, but rather than completely lose profiling info, we split\n+      // the remaining probability equally over them.\n+      SmallVector<uint32_t> NewWeights(Values.size() + 1);\n+      NewWeights[0] = BranchWeights[1]; // this is the default, and we swapped\n+                                        // if TrueWhenEqual.\n+      for (auto &V : drop_begin(NewWeights))\n+        V = BranchWeights[0] / Values.size();\n+      setBranchWeights(*New, NewWeights, /*IsExpected=*/false);\n+    }\n+\n+    // Add all of the 'cases' to the switch instruction.\n+    for (ConstantInt *Val : Values)\n+      New->addCase(Val, EdgeBB);\n+\n+    // We added edges from PI to the EdgeBB.  As such, if there were any\n+    // PHI nodes in EdgeBB, they need entries to be added corresponding to\n+    // the number of edges added.\n+    for (BasicBlock::iterator BBI = EdgeBB->begin(); isa<PHINode>(BBI); ++BBI) {\n+      PHINode *PN = cast<PHINode>(BBI);\n+      Value *InVal = PN->getIncomingValueForBlock(BB);\n+      for (unsigned i = 0, e = Values.size() - 1; i != e; ++i)\n+        PN->addIncoming(InVal, BB);\n+    }\n   }\n \n   // Erase the old branch instruction.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SimplifyCFG/pr165088.ll",
      "commands": [
        "opt -S -passes=\"simplifycfg<switch-range-to-icmp>\" < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n; Avoid getting stuck in the cycle pr165088_cycle_[1-4].\n\ndefine void @pr165088_cycle_1(i8 %x) {\n;\nentry:\n  %switch = icmp uge i8 %x, 2\n  %cond1 = icmp ugt i8 %x, 1\n  %or.cond = and i1 %switch, %cond1\n  br i1 %or.cond, label %block3, label %block2\n\nblock1:\n  %cond2 = icmp ugt i8 %x, 1\n  br i1 %cond2, label %block3, label %block2\n\nblock2:\n  br label %block3\n\nblock3:\n  %cond3 = icmp eq i8 %x, 0\n  br i1 %cond3, label %exit, label %block1\n\nexit:\n  ret void\n}\n\ndefine void @pr165088_cycle_2(i8 %x) {\n;\nentry:\n  switch i8 %x, label %block3 [\n  i8 1, label %block2\n  i8 0, label %block2\n  ]\n\nblock1:                                              ; preds = %block3\n  %cond2 = icmp ugt i8 %x, 1\n  br i1 %cond2, label %block3, label %block2\n\nblock2:                                              ; preds = %entry, %entry, %block1\n  br label %block3\n\nblock3:                                              ; preds = %entry, %block2, %block1\n  %cond3 = icmp eq i8 %x, 0\n  br i1 %cond3, label %exit, label %block1\n\nexit:                                             ; preds = %block3\n  ret void\n}\n\ndefine void @pr165088_cycle_3(i8 %x) {\n;\nentry:\n  switch i8 %x, label %block1 [\n  i8 1, label %block2\n  i8 0, label %block2\n  ]\n\nblock1:                                              ; preds = %entry, %block3\n  %cond2 = icmp ugt i8 %x, 1\n  br i1 %cond2, label %block3, label %block2\n\nblock2:                                              ; preds = %entry, %entry, %block1\n  br label %block3\n\nblock3:                                              ; preds = %block2, %block1\n  %cond3 = icmp eq i8 %x, 0\n  br i1 %cond3, label %exit, label %block1\n\nexit:                                             ; preds = %block3\n  ret void\n}\n\ndefine void @pr165088_cycle_4(i8 %x) {\n;\nentry:\n  %switch = icmp ult i8 %x, 2\n  br i1 %switch, label %block2, label %block1\n\nblock1:                                              ; preds = %entry, %block3\n  %cond2 = icmp ugt i8 %x, 1\n  br i1 %cond2, label %block3, label %block2\n\nblock2:                                              ; preds = %entry, %block1\n  br label %block3\n\nblock3:                                              ; preds = %block2, %block1\n  %cond3 = icmp eq i8 %x, 0\n  br i1 %cond3, label %exit, label %block1\n\nexit:                                             ; preds = %block3\n  ret void\n}\n\ndefine void @pr165088_original(i8 %x) {\n;\nentry:\n  %cond = icmp ne i8 %x, 0\n  %cond3 = icmp ne i8 %x, 0\n  %or.cond = and i1 %cond, %cond3\n  br i1 %or.cond, label %block3, label %block2\n\nblock1:                                              ; preds = %block3\n  %cond3.old = icmp ugt i8 %x, 1\n  br i1 %cond3.old, label %block3, label %block2\n\nblock2:                                              ; preds = %block1, %entry\n  br label %block3\n\nblock3:                                              ; preds = %block2, %block1, %entry\n  %cond4 = icmp eq i8 %x, 0\n  br i1 %cond4, label %exit, label %block1\n\nexit:                                             ; preds = %block3\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SimplifyCFG] Assertion `IterCnt++ < 1000 && \"Iterative simplification didn't converge!\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/6q17cxYWh\n```\n; bin/opt -passes=\"simplifycfg<switch-range-to-icmp>\" test.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine fastcc i32 @func_209(i8 %conv74) {\nentry:\n  %cmp.i.i = icmp eq i8 %conv74, 0\n  %cond = icmp ne i8 %conv74, 0\n  %cmp.i44.i.old = icmp ugt i8 %conv74, 0\n  %or.cond = and i1 %cond, %cmp.i44.i.old\n  br i1 %or.cond, label %safe_mod_func_int16_t_s_s.exit.i, label %cond.false.i45.i\n\nsafe_div_func_uint16_t_u_u.exit.i:                ; preds = %safe_mod_func_int16_t_s_s.exit.i\n  %cmp.i44.i.old.old = icmp ugt i8 %conv74, 1\n  br i1 %cmp.i44.i.old.old, label %safe_mod_func_int16_t_s_s.exit.i, label %cond.false.i45.i\n\ncond.false.i45.i:                                 ; preds = %safe_div_func_uint16_t_u_u.exit.i, %entry\n  br label %safe_mod_func_int16_t_s_s.exit.i\n\nsafe_mod_func_int16_t_s_s.exit.i:                 ; preds = %cond.false.i45.i, %safe_div_func_uint16_t_u_u.exit.i, %entry\n  br i1 %cmp.i.i, label %func_238.exit, label %safe_div_func_uint16_t_u_u.exit.i\n\nfunc_238.exit:                                    ; preds = %safe_mod_func_int16_t_s_s.exit.i\n  ret i32 0\n}\n```\n```\nopt: /root/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:247: bool iterativelySimplifyCFG(llvm::Function&, const llvm::TargetTransformInfo&, llvm::DomTreeUpdater*, const llvm::SimplifyCFGOptions&): Assertion `IterCnt++ < 1000 && \"Iterative simplification didn't converge!\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=simplifycfg<switch-range-to-icmp> <source>\n1.\tRunning pass \"function(simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-arithmetic;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>)\" on module \"<source>\"\n2.\tRunning pass \"simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-arithmetic;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>\" on function \"func_209\"\n #0 0x0000000005965e58 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5965e58)\n #1 0x0000000005962d04 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x000075fcf1c42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x000075fcf1c969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x000075fcf1c42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x000075fcf1c287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x000075fcf1c2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x000075fcf1c39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x00000000048445bc iterativelySimplifyCFG(llvm::Function&, llvm::TargetTransformInfo const&, llvm::DomTreeUpdater*, llvm::SimplifyCFGOptions const&) SimplifyCFGPass.cpp:0:0\n #9 0x0000000004845304 simplifyFunctionCFGImpl(llvm::Function&, llvm::TargetTransformInfo const&, llvm::DominatorTree*, llvm::SimplifyCFGOptions const&) SimplifyCFGPass.cpp:0:0\n#10 0x0000000004846485 simplifyFunctionCFG(llvm::Function&, llvm::TargetTransformInfo const&, llvm::DominatorTree*, llvm::SimplifyCFGOptions const&) SimplifyCFGPass.cpp:0:0\n#11 0x00000000048465ca llvm::SimplifyCFGPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x48465ca)\n#12 0x00000000016da59e llvm::detail::PassModel<llvm::Function, llvm::SimplifyCFGPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x16da59e)\n#13 0x0000000005740571 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5740571)\n#14 0x0000000000efabfe llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xefabfe)\n#15 0x000000000573eada llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x573eada)\n#16 0x000000000097af4e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97af4e)\n#17 0x000000000573e491 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x573e491)\n#18 0x00000000009850ea llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9850ea)\n#19 0x0000000000979361 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x979361)\n#20 0x000075fcf1c29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#21 0x000075fcf1c29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#22 0x0000000000970775 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x970775)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\n",
    "author": "dtcxzyw",
    "labels": [
      "crash-on-valid",
      "llvm:transforms",
      "generated by fuzzer"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}