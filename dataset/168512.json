{
  "bug_id": "168512",
  "issue_url": "https://github.com/llvm/llvm-project/issues/168512",
  "bug_type": "crash",
  "base_commit": "4e275f727439af9589ee54bc6ac2e95fac9f63ae",
  "knowledge_cutoff": "2025-11-18T10:58:39Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "2c3aa92089695713a1fd4264e80941fd9679150b",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          2082,
          2087
        ],
        [
          4593,
          4598
        ],
        [
          17894,
          17899
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::setInsertPointAfterBundle",
        "deleteTree"
      ]
    }
  },
  "patch": "commit 2c3aa92089695713a1fd4264e80941fd9679150b\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Wed Nov 19 11:42:18 2025 -0800\n\n    [SLP]Fix insertion point for setting for the nodes\n    \n    The problem with the many def-use chain problems in SLP vectorizer are\n    related to the fact that some nodes reuse the same instruction as\n    insertion point. Insertion point is not the instruction, but the place\n    between instructions. To set it correctly, better to generate pseudo\n    instruction immediately after the last instruction, and use it as\n    insertion point. It resolves the issues in most cases.\n    \n    Fixes #168512 #168576\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 4b9ac52748e7..22253f5118a1 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -2082,6 +2082,7 @@ public:\n     MustGather.clear();\n     NonScheduledFirst.clear();\n     EntryToLastInstruction.clear();\n+    LastInstructionToPos.clear();\n     LoadEntriesToVectorize.clear();\n     IsGraphTransformMode = false;\n     GatheredLoadsEntriesFirst.reset();\n@@ -4593,6 +4594,10 @@ private:\n   /// pre-gather them before.\n   SmallDenseMap<const TreeEntry *, WeakTrackingVH> EntryToLastInstruction;\n \n+  /// Keeps the mapping between the last instructions and their insertion\n+  /// points, which is an instruction-after-the-last-instruction.\n+  SmallDenseMap<const Instruction *, Instruction *> LastInstructionToPos;\n+\n   /// List of gather nodes, depending on other gather/vector nodes, which should\n   /// be emitted after the vector instruction emission process to correctly\n   /// handle order of the vector instructions and shuffles.\n@@ -17894,6 +17899,16 @@ void BoUpSLP::setInsertPointAfterBundle(const TreeEntry *E) {\n     Builder.SetInsertPoint(\n         LastInst->getParent(),\n         LastInst->getNextNode()->getIterator());\n+    if (Instruction *Res = LastInstructionToPos.lookup(LastInst)) {\n+      Builder.SetInsertPoint(LastInst->getParent(), Res->getIterator());\n+    } else {\n+      Res = Builder.CreateAlignedLoad(Builder.getPtrTy(),\n+                                      PoisonValue::get(Builder.getPtrTy()),\n+                                      MaybeAlign());\n+      Builder.SetInsertPoint(LastInst->getParent(), Res->getIterator());\n+      eraseInstruction(Res);\n+      LastInstructionToPos.try_emplace(LastInst, Res);\n+    }\n   }\n   Builder.SetCurrentDebugLocation(Front->getDebugLoc());\n }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/gathered-node-with-in-order-parent.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -slp-threshold=-99999 -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define double @test() {\nbb:\n  br label %bb1\n\nbb1:                                              ; preds = %bb4, %bb\n  %phi = phi i32 [ 0, %bb ], [ 0, %bb4 ]\n  %phi2 = phi i32 [ 0, %bb ], [ 0, %bb4 ]\n  %phi3 = phi i32 [ 0, %bb ], [ %or5, %bb4 ]\n  br label %bb4\n\nbb4:                                              ; preds = %bb1\n  %or = or i32 %phi2, 0\n  %mul = mul i32 0, 1\n  %or5 = or i32 %phi3, %mul\n  %and = and i32 %or, 0\n  %or6 = or i32 %phi2, 1\n  br i1 false, label %bb7, label %bb1\n\nbb7:                                              ; preds = %bb4\n  %phi8 = phi i32 [ %phi, %bb4 ]\n  %phi9 = phi i32 [ %or, %bb4 ]\n  %phi10 = phi i32 [ %or5, %bb4 ]\n  %phi11 = phi i32 [ %or6, %bb4 ]\n  ret double 0.000000e+00\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/matching-insert-point-for-nodes.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -slp-threshold=-99999 -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine i32 @test() {\n;\nbb:\n  br label %bb1\n\nbb1:\n  %phi = phi i32 [ %lshr25, %bb24 ], [ 0, %bb ]\n  %phi2 = phi i32 [ %or26, %bb24 ], [ 0, %bb ]\n  %phi3 = phi i32 [ 0, %bb24 ], [ 0, %bb ]\n  br i1 false, label %bb4, label %bb11\n\nbb4:\n  %phi6 = phi i32 [ poison, %bb1 ]\n  %phi7 = phi i32 [ poison, %bb1 ]\n  %phi9 = phi i32 [ %phi2, %bb1 ]\n  %phi10 = phi i32 [ %phi, %bb1 ]\n  %0 = phi <2 x double> [ zeroinitializer, %bb1 ]\n  br label %bb19\n\nbb11:\n  br i1 false, label %bb12, label %bb16\n\nbb12:\n  %or = or i32 0, %phi3\n  br label %bb13\n\nbb13:\n  %phi14 = phi i32 [ %phi, %bb12 ]\n  %phi15 = phi i32 [ %or, %bb12 ]\n  br label %bb16\n\nbb16:\n  %phi17 = phi i32 [ 0, %bb11 ], [ %phi14, %bb13 ]\n  %phi18 = phi i32 [ 0, %bb11 ], [ %phi15, %bb13 ]\n  br label %bb19\n\nbb19:\n  %phi20 = phi i32 [ 0, %bb4 ], [ %phi17, %bb16 ]\n  %phi21 = phi i32 [ 0, %bb4 ], [ %phi18, %bb16 ]\n  %phi22 = phi double [ 0.000000e+00, %bb4 ], [ 0.000000e+00, %bb16 ]\n  %or23 = or i32 %phi21, 0\n  br label %bb24\n\nbb24:\n  %lshr = lshr i32 %phi20, 0\n  %and = and i32 %lshr, 0\n  %lshr25 = lshr i32 %phi, %and\n  %or26 = or i32 0, %or23\n  br label %bb1\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/reused-last-instruction-in-split-node.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine float @test() {\n;\nlabel:\n  %tmp.0.4.vec.extract = extractelement <4 x float> zeroinitializer, i64 0\n  %tmp.0.0.vec.extract = extractelement <4 x float> zeroinitializer, i64 0\n  %tmp.12.36.vec.extract = extractelement <4 x float> zeroinitializer, i64 0\n  %tmp.7.28.vec.extract = extractelement <4 x float> zeroinitializer, i64 0\n  %tmp.0.12.vec.extract = extractelement <4 x float> zeroinitializer, i64 0\n  %mul3.i128.i = fmul float 0.000000e+00, 0.000000e+00\n  %mul3.i138.i = fmul float 0.000000e+00, 0.000000e+00\n  %sub.i102.i = fsub float 0.000000e+00, 0.000000e+00\n  %mul.i136.i = fmul float %sub.i102.i, 0.000000e+00\n  %v.0.4.vec.extract = extractelement <8 x float> zeroinitializer, i64 0\n  %v.0.24.vec.extract = extractelement <8 x float> zeroinitializer, i64 0\n  %v.0.28.vec.extract = extractelement <8 x float> zeroinitializer, i64 0\n  %v.11.48.vec.extract = extractelement <8 x float> zeroinitializer, i64 0\n  %v.20.72.vec.extract = extractelement <8 x float> zeroinitializer, i64 0\n  %v.20.76.vec.extract = extractelement <8 x float> zeroinitializer, i64 0\n  %0 = fmul float %v.0.4.vec.extract, %tmp.0.0.vec.extract\n  %1 = fadd float %0, 0.000000e+00\n  %2 = fmul float %v.0.28.vec.extract, 0.000000e+00\n  %3 = fmul float %v.0.28.vec.extract, %tmp.0.0.vec.extract\n  %4 = fadd float %3, 0.000000e+00\n  %5 = fmul float %tmp.0.4.vec.extract, %v.11.48.vec.extract\n  %6 = fadd float 0.000000e+00, %5\n  %7 = fmul float %v.20.76.vec.extract, %tmp.0.0.vec.extract\n  %8 = fadd float %7, 0.000000e+00\n  %9 = fmul float 0.000000e+00, %tmp.0.12.vec.extract\n  %10 = fadd float %2, %9\n  %11 = fadd float %10, 0.000000e+00\n  %12 = fsub float 0.000000e+00, %11\n  %13 = fadd float 0.000000e+00, %1\n  %14 = fadd float 0.000000e+00, %4\n  %15 = fadd float 0.000000e+00, %6\n  %16 = fadd float 0.000000e+00, %8\n  %17 = fmul float 0.000000e+00, 0.000000e+00\n  %18 = fmul float 0.000000e+00, %tmp.7.28.vec.extract\n  %19 = fmul float 0.000000e+00, 0.000000e+00\n  %20 = fmul float 0.000000e+00, 0.000000e+00\n  %21 = fmul float 0.000000e+00, %tmp.7.28.vec.extract\n  %22 = fmul float 0.000000e+00, 0.000000e+00\n  %23 = fmul float 0.000000e+00, %tmp.12.36.vec.extract\n  %24 = fadd float %18, %23\n  %25 = fmul float 0.000000e+00, %tmp.12.36.vec.extract\n  %26 = fadd float %21, %25\n  %27 = fsub float 0.000000e+00, poison\n  %28 = fadd float %24, 0.000000e+00\n  %29 = fsub float 0.000000e+00, %28\n  %30 = fadd float %26, 0.000000e+00\n  %31 = fsub float 0.000000e+00, %30\n  %32 = fadd float 0.000000e+00, %17\n  %33 = fadd float 0.000000e+00, %19\n  %34 = fadd float 0.000000e+00, %20\n  %35 = fadd float 0.000000e+00, %22\n  %36 = fmul float 0.000000e+00, %mul3.i138.i\n  %37 = fmul float %v.0.4.vec.extract, %mul.i136.i\n  %38 = fadd float %37, 0.000000e+00\n  %39 = fmul float 0.000000e+00, %mul3.i138.i\n  %40 = fmul float %mul3.i138.i, %v.0.24.vec.extract\n  %41 = fadd float 0.000000e+00, %40\n  %42 = fmul float 0.000000e+00, %mul3.i138.i\n  %43 = fmul float 0.000000e+00, %mul3.i138.i\n  %44 = fmul float %mul3.i138.i, %v.20.72.vec.extract\n  %45 = fadd float 0.000000e+00, %44\n  %46 = fmul float 0.000000e+00, 1.000000e+00\n  %47 = fmul float 0.000000e+00, %mul3.i128.i\n  %48 = fadd float %36, %47\n  %49 = fmul float 0.000000e+00, %mul3.i128.i\n  %50 = fadd float %39, %49\n  %51 = fmul float 0.000000e+00, %mul3.i128.i\n  %52 = fadd float %42, %51\n  %53 = fmul float 0.000000e+00, %mul3.i128.i\n  %54 = fadd float %43, %53\n  %55 = fadd float %46, 0.000000e+00\n  %56 = fadd float %48, 0.000000e+00\n  %57 = fsub float %55, %56\n  %58 = fadd float %50, 0.000000e+00\n  %59 = fsub float 0.000000e+00, %58\n  %60 = fadd float %52, 0.000000e+00\n  %61 = fsub float 0.000000e+00, %60\n  %62 = fadd float %mul.i136.i, 0.000000e+00\n  %63 = fadd float %54, 0.000000e+00\n  %64 = fsub float %62, %63\n  %65 = fadd float 0.000000e+00, %38\n  %66 = fadd float 0.000000e+00, %41\n  %67 = fadd float 0.000000e+00, %45\n  br label %region.30\n\nregion.30:\n  %68 = phi float [ %29, %label ]\n  %69 = phi float [ %66, %label ]\n  %70 = phi float [ %59, %label ]\n  %71 = phi float [ %15, %label ]\n  %72 = phi float [ %34, %label ]\n  %73 = phi float [ poison, %label ]\n  %74 = phi float [ %61, %label ]\n  %75 = phi float [ %16, %label ]\n  %76 = phi float [ %35, %label ]\n  %77 = phi float [ %31, %label ]\n  %78 = phi float [ %67, %label ]\n  %79 = phi float [ %64, %label ]\n  %80 = phi float [ %33, %label ]\n  %81 = phi float [ %12, %label ]\n  %82 = phi float [ %14, %label ]\n  %83 = phi float [ %57, %label ]\n  %84 = phi float [ %65, %label ]\n  %85 = phi float [ %27, %label ]\n  %86 = phi float [ %32, %label ]\n  %87 = phi float [ %13, %label ]\n  ret float %87\n}"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/shuffle-mask-emission.ll",
      "commands": [
        "opt -S -passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define i1 @test() {\nentry:\n  %h.promoted118.i.fr = freeze i32 1\n  %invariant.op.i51 = add i32 %h.promoted118.i.fr, 0\n  %conv25.i = xor i32 0, 0\n  %add.i.i = add i32 %conv25.i, %h.promoted118.i.fr\n  %sext.i.mask = and i32 %add.i.i, 0\n  %cmp27.i = icmp eq i32 %sext.i.mask, 1\n  %0 = or i1 %cmp27.i, false\n  %conv25.i.1 = add i32 0, 0\n  %add.i.i.1 = add i32 %conv25.i.1, %h.promoted118.i.fr\n  %sext.i.1.mask = and i32 %add.i.i.1, 1\n  %cmp27.i.1 = icmp eq i32 %sext.i.1.mask, 0\n  %conv25.1.i.1 = xor i32 0, 0\n  %add.i.1.i.1 = add i32 %conv25.1.i.1, %h.promoted118.i.fr\n  %sext.1.i.1.mask = and i32 %add.i.1.i.1, 1\n  %cmp27.1.i.1 = icmp eq i32 %sext.1.i.1.mask, 0\n  %add.i.2.reass.i.1 = add i32 %invariant.op.i51, %conv25.i.1\n  %sext.2.i.1.mask = and i32 %add.i.2.reass.i.1, 1\n  %cmp27.2.i.1 = icmp eq i32 %sext.2.i.1.mask, 0\n  %1 = or i1 %cmp27.1.i.1, %cmp27.2.i.1\n  %2 = or i1 %cmp27.i.1, %1\n  %3 = or i1 %0, %2\n  ret i1 %3\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Instruction does not dominate all uses!...LLVM ERROR: Broken module found, compilation aborted! (once again)",
    "body": "To reproduce run opt with the test below (-passes=slp-vectorizer -slp-threshold=-99999):\n\n```\n; ModuleID = './reduced.ll'\nsource_filename = \"./reduced.ll\"\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i32 @wombat() #0 gc \"statepoint-example\" {\nbb:\n  br label %bb1\n\nbb1:                                              ; preds = %bb24, %bb\n  %phi = phi i32 [ %lshr25, %bb24 ], [ 0, %bb ]\n  %phi2 = phi i32 [ %or26, %bb24 ], [ 0, %bb ]\n  %phi3 = phi i32 [ 0, %bb24 ], [ 0, %bb ]\n  br i1 false, label %bb4, label %bb11\n\nbb4:                                              ; preds = %bb1\n  %phi5 = phi double [ 0.000000e+00, %bb1 ]\n  %phi6 = phi i32 [ poison, %bb1 ]\n  %phi7 = phi i32 [ poison, %bb1 ]\n  %phi8 = phi double [ 0.000000e+00, %bb1 ]\n  %phi9 = phi i32 [ %phi2, %bb1 ]\n  %phi10 = phi i32 [ %phi, %bb1 ]\n  br label %bb19\n\nbb11:                                             ; preds = %bb1\n  br i1 false, label %bb12, label %bb16\n\nbb12:                                             ; preds = %bb11\n  %or = or i32 0, %phi3\n  br label %bb13\n\nbb13:                                             ; preds = %bb12\n  %phi14 = phi i32 [ %phi, %bb12 ]\n  %phi15 = phi i32 [ %or, %bb12 ]\n  br label %bb16\n\nbb16:                                             ; preds = %bb13, %bb11\n  %phi17 = phi i32 [ 0, %bb11 ], [ %phi14, %bb13 ]\n  %phi18 = phi i32 [ 0, %bb11 ], [ %phi15, %bb13 ]\n  br label %bb19\n\nbb19:                                             ; preds = %bb16, %bb4\n  %phi20 = phi i32 [ 0, %bb4 ], [ %phi17, %bb16 ]\n  %phi21 = phi i32 [ 0, %bb4 ], [ %phi18, %bb16 ]\n  %phi22 = phi double [ 0.000000e+00, %bb4 ], [ 0.000000e+00, %bb16 ]\n  %or23 = or i32 %phi21, 0\n  br label %bb24\n\nbb24:                                             ; preds = %bb19\n  %lshr = lshr i32 %phi20, 0\n  %and = and i32 %lshr, 0\n  %lshr25 = lshr i32 %phi, %and\n  %or26 = or i32 0, %or23\n  br label %bb1\n}\n\nattributes #0 = { \"target-features\"=\"+prfchw,-cldemote,+avx,+aes,+sahf,+pclmul,-xop,+crc32,-amx-fp8,+xsaves,-avx512fp16,-usermsr,-sm4,-egpr,+sse4.1,-avx10.1,-avx512ifma,+xsave,+sse4.2,-tsxldtrk,-sm3,-ptwrite,-widekl,-movrs,-invpcid,+64bit,+xsavec,-avx512vpopcntdq,+cmov,-avx512vp2intersect,-avx512cd,+movbe,-avxvnniint8,-ccmp,-amx-int8,-kl,-sha512,-avxvnni,-rtm,+adx,+avx2,-hreset,-movdiri,-serialize,-vpclmulqdq,-avx512vl,-uintr,-cf,+clflushopt,-raoint,-cmpccxadd,+bmi,-amx-tile,+sse,-gfni,-avxvnniint16,-amx-fp16,-zu,-ndd,+xsaveopt,+rdrnd,-avx512f,-amx-bf16,-avx512bf16,-avx512vnni,-push2pop2,+cx8,-avx512bw,+sse3,-pku,-nf,-amx-tf32,-amx-avx512,+fsgsbase,+clzero,-mwaitx,-lwp,+lzcnt,+sha,-movdir64b,-ppx,+wbnoinvd,-enqcmd,-avxneconvert,-tbm,-pconfig,-amx-complex,+ssse3,+cx16,-avx10.2,+bmi2,+fma,+popcnt,-avxifma,+f16c,-avx512bitalg,-rdpru,+clwb,+mmx,+sse2,+rdseed,-avx512vbmi2,-prefetchi,-amx-movrs,+rdpid,-fma4,-avx512vbmi,-shstk,-vaes,-waitpkg,-sgx,+fxsr,-avx512dq,+sse4a\" }\n```\nReproducer: https://godbolt.org/z/3GjPaK9b8\n\nStack dump:\n```\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=slp-vectorizer -slp-threshold=-99999 <source>\n1.\tRunning pass \"verify\" on module \"<source>\"\n #0 0x0000000005977768 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5977768)\n #1 0x0000000005974614 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x000073d16ec42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x000073d16ec969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x000073d16ec42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x000073d16ec287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x000000000082da77 llvm::json::operator==(llvm::json::Value const&, llvm::json::Value const&) (.cold) JSON.cpp:0:0\n #7 0x00000000058abe41 (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x58abe41)\n #8 0x0000000005797b68 (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5797b68)\n #9 0x000000000097321e llvm::detail::PassModel<llvm::Module, llvm::VerifierPass, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97321e)\n#10 0x0000000005756121 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5756121)\n#11 0x000000000097d4a8 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::RTLIB::RuntimeLibcallsInfo&, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97d4a8)\n#12 0x00000000009714fd optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9714fd)\n#13 0x000073d16ec29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#14 0x000073d16ec29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#15 0x0000000000968745 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x968745)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "TatyanaDoubts",
    "labels": [
      "llvm:SLPVectorizer",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true
}