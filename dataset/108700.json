{
  "bug_id": "108700",
  "issue_url": "https://github.com/llvm/llvm-project/issues/108700",
  "bug_type": "crash",
  "base_commit": "4c6f313cb340c435f47ac032857030768c81c341",
  "knowledge_cutoff": "2024-09-14T13:45:54Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "f564a48f0ea4d2100c0cadfa6e6f20f97244025e",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          7481,
          7487
        ],
        [
          7492,
          7506
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::buildTree_rec"
      ]
    }
  },
  "patch": "commit f564a48f0ea4d2100c0cadfa6e6f20f97244025e\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Mon Sep 16 09:19:42 2024 -0700\n\n    [SLP]Fix PR108700: correctly identify id of the operand node\n    \n    If the operand node for truncs is not created during construction, but\n    one of the previous ones is reused instead, need to correctly identify\n    its index, to correctly emit the code.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/108700\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 5f2bf082fb87..282bb8eac7e2 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -7481,7 +7481,16 @@ void BoUpSLP::buildTree_rec(ArrayRef<Value *> VL, unsigned Depth,\n                 PrevMaxBW),\n             std::min<unsigned>(DL->getTypeSizeInBits(VL0->getType()),\n                                PrevMinBW));\n-        ExtraBitWidthNodes.insert(VectorizableTree.size() + 1);\n+      }\n+      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n+                                   ReuseShuffleIndices);\n+      LLVM_DEBUG(dbgs() << \"SLP: added a vector of casts.\\n\");\n+\n+      TE->setOperandsInOrder();\n+      for (unsigned I : seq<unsigned>(0, VL0->getNumOperands()))\n+        buildTree_rec(TE->getOperand(I), Depth + 1, {TE, I});\n+      if (ShuffleOrOp == Instruction::Trunc) {\n+        ExtraBitWidthNodes.insert(getOperandEntry(TE, 0)->Idx);\n       } else if (ShuffleOrOp == Instruction::SIToFP ||\n                  ShuffleOrOp == Instruction::UIToFP) {\n         unsigned NumSignBits =\n@@ -7492,15 +7501,8 @@ void BoUpSLP::buildTree_rec(ArrayRef<Value *> VL, unsigned Depth,\n         }\n         if (NumSignBits * 2 >=\n             DL->getTypeSizeInBits(VL0->getOperand(0)->getType()))\n-          ExtraBitWidthNodes.insert(VectorizableTree.size() + 1);\n+          ExtraBitWidthNodes.insert(getOperandEntry(TE, 0)->Idx);\n       }\n-      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n-                                   ReuseShuffleIndices);\n-      LLVM_DEBUG(dbgs() << \"SLP: added a vector of casts.\\n\");\n-\n-      TE->setOperandsInOrder();\n-      for (unsigned I : seq<unsigned>(0, VL0->getNumOperands()))\n-        buildTree_rec(TE->getOperand(I), Depth + 1, {TE, I});\n       return;\n     }\n     case Instruction::ICmp:\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/minbitwidth-user-not-min.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define void @test(ptr %block, ptr noalias %pixels, i1 %b) {\nentry:\n  %0 = load i16, ptr %block, align 2\n  %tobool.not.i78 = icmp ult i16 %0, 0\n  %conv.i80 = sext i1 true to i8\n  %conv1.i81 = trunc i16 %0 to i8\n  %retval.0.i82 = select i1 %tobool.not.i78, i8 %conv1.i81, i8 %conv.i80\n  store i8 %retval.0.i82, ptr %pixels, align 1\n  %arrayidx2 = getelementptr i8, ptr %block, i64 2\n  %1 = load i16, ptr %arrayidx2, align 2\n  %tobool.not.i73 = icmp ult i16 %1, 0\n  %conv.i75 = sext i1 %b to i8\n  %conv1.i76 = trunc i16 %1 to i8\n  %retval.0.i77 = select i1 %tobool.not.i73, i8 %conv1.i76, i8 %conv.i75\n  %arrayidx5 = getelementptr i8, ptr %pixels, i64 1\n  store i8 %retval.0.i77, ptr %arrayidx5, align 1\n  %arrayidx6 = getelementptr i8, ptr %block, i64 4\n  %2 = load i16, ptr %arrayidx6, align 2\n  %tobool.not.i68 = icmp ult i16 %2, 0\n  %conv.i70 = sext i1 false to i8\n  %conv1.i71 = trunc i16 %2 to i8\n  %retval.0.i72 = select i1 %tobool.not.i68, i8 %conv1.i71, i8 %conv.i70\n  %arrayidx9 = getelementptr i8, ptr %pixels, i64 2\n  store i8 %retval.0.i72, ptr %arrayidx9, align 1\n  %arrayidx10 = getelementptr i8, ptr %block, i64 6\n  %3 = load i16, ptr %arrayidx10, align 2\n  %tobool.not.i63 = icmp ult i16 %3, 0\n  %conv.i65 = sext i1 false to i8\n  %conv1.i66 = trunc i16 %3 to i8\n  %retval.0.i67 = select i1 %tobool.not.i63, i8 %conv1.i66, i8 %conv.i65\n  %arrayidx13 = getelementptr i8, ptr %pixels, i64 3\n  store i8 %retval.0.i67, ptr %arrayidx13, align 1\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/trunc-node-reused.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define i16 @test() {\nentry:\n  %conv73 = xor i64 0, 0\n  %and.i = and i64 0, 0\n  %xor2.i = or i64 %and.i, 0\n  %sub.i = or i64 %xor2.i, 0\n  %xor3.i = xor i64 %sub.i, %conv73\n  %and4.i = and i64 %xor3.i, 0\n  %cmp.i = icmp slt i64 %and4.i, 0\n  %0 = trunc i64 %conv73 to i16\n  %1 = or i16 0, %0\n  %conv73i = xor i64 0, 0\n  %andi.i = and i64 0, 0\n  %xor2i.i = or i64 %andi.i, 0\n  %subi.i = or i64 %xor2i.i, 0\n  %xor3i.i = xor i64 %subi.i, %conv73i\n  %and4i.i = and i64 %xor3i.i, 0\n  %cmpi.i = icmp slt i64 %and4i.i, 0\n  %2 = trunc i64 %conv73i to i16\n  %3 = or i16 0, %2\n  %4 = select i1 %cmpi.i, i16 0, i16 %3\n  %5 = select i1 %cmp.i, i16 0, i16 %1\n  %6 = zext i32 0 to i64\n  %add.ip = or i64 %6, 0\n  %orp = or i64 %add.ip, 0\n  %conv72p = shl i64 %orp, 0\n  %sextp = ashr i64 %conv72p, 0\n  %conv73p = xor i64 %sextp, 0\n  %and.ip = and i64 0, 0\n  %xor2.ip = or i64 %and.ip, 0\n  %sub.ip = or i64 %xor2.ip, 0\n  %xor3.ip = xor i64 %sub.ip, %conv73p\n  %and4.ip = and i64 %xor3.ip, 0\n  %cmp.ip = icmp slt i64 %and4.ip, 0\n  %7 = trunc i64 %conv73p to i16\n  %8 = or i16 0, %7\n  %9 = select i1 %cmp.ip, i16 0, i16 %8\n  %conv76i = and i16 %4, %5\n  %conv76p = and i16 %conv76i, %9\n  %10 = zext i32 0 to i64\n  %add.ip1 = or i64 %10, 0\n  %orp1 = or i64 %add.ip1, 0\n  %conv72p1 = shl i64 %orp1, 0\n  %sextp1 = ashr i64 %conv72p1, 0\n  %conv73p1 = xor i64 %sextp1, 0\n  %and.ip1 = and i64 0, 0\n  %xor2.ip1 = or i64 %and.ip1, 0\n  %sub.ip1 = or i64 %xor2.ip1, 0\n  %xor3.ip1 = xor i64 %sub.ip1, %conv73p1\n  %and4.ip1 = and i64 %xor3.ip1, 0\n  %cmp.ip1 = icmp slt i64 %and4.ip1, 0\n  %11 = trunc i64 %conv73p1 to i16\n  %12 = or i16 0, %11\n  %13 = select i1 %cmp.ip1, i16 0, i16 %12\n  %conv76p2 = and i16 %conv76p, %13\n  ret i16 %conv76p2\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Assertion `OpIdx < Operands.size() && \"Off bounds\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/8Es17cqcW\r\n```\r\n; bin/opt -passes=slp-vectorizer reduced.ll -S\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine i16 @main() {\r\nentry:\r\n  %conv73.i.peel.i.i.i.i.i = xor i64 0, 0\r\n  %and.i.i.peel.i.i.i.i.i = and i64 0, 0\r\n  %xor2.i.i.peel.i.i.i.i.i = or i64 %and.i.i.peel.i.i.i.i.i, 0\r\n  %sub.i.i.peel.i.i.i.i.i = or i64 %xor2.i.i.peel.i.i.i.i.i, 0\r\n  %xor3.i.i.peel.i.i.i.i.i = xor i64 %sub.i.i.peel.i.i.i.i.i, %conv73.i.peel.i.i.i.i.i\r\n  %and4.i.i.peel.i.i.i.i.i = and i64 %xor3.i.i.peel.i.i.i.i.i, 0\r\n  %cmp.i.i.peel.i.i.i.i.i = icmp slt i64 %and4.i.i.peel.i.i.i.i.i, 0\r\n  %0 = trunc i64 %conv73.i.peel.i.i.i.i.i to i16\r\n  %1 = or i16 0, %0\r\n  %conv73.i.i.i.i.i.i = xor i64 0, 0\r\n  %and.i.i.i.i.i.i.i = and i64 0, 0\r\n  %xor2.i.i.i.i.i.i.i = or i64 %and.i.i.i.i.i.i.i, 0\r\n  %sub.i.i.i.i.i.i.i = or i64 %xor2.i.i.i.i.i.i.i, 0\r\n  %xor3.i.i.i.i.i.i.i = xor i64 %sub.i.i.i.i.i.i.i, %conv73.i.i.i.i.i.i\r\n  %and4.i.i.i.i.i.i.i = and i64 %xor3.i.i.i.i.i.i.i, 0\r\n  %cmp.i.i.i.i.i.i.i = icmp slt i64 %and4.i.i.i.i.i.i.i, 0\r\n  %2 = trunc i64 %conv73.i.i.i.i.i.i to i16\r\n  %3 = or i16 0, %2\r\n  %4 = select i1 %cmp.i.i.i.i.i.i.i, i16 0, i16 %3\r\n  %5 = select i1 %cmp.i.i.peel.i.i.i.i.i, i16 0, i16 %1\r\n  %6 = zext i32 0 to i64\r\n  %add.i.i.peel.i369.i.i.i.i = or i64 %6, 0\r\n  %or.i.peel.i371.i.i.i.i = or i64 %add.i.i.peel.i369.i.i.i.i, 0\r\n  %conv72.i.peel.i372.i.i.i.i = shl i64 %or.i.peel.i371.i.i.i.i, 0\r\n  %sext.i.peel.i373.i.i.i.i = ashr i64 %conv72.i.peel.i372.i.i.i.i, 0\r\n  %conv73.i.peel.i374.i.i.i.i = xor i64 %sext.i.peel.i373.i.i.i.i, 0\r\n  %and.i.i.peel.i376.i.i.i.i = and i64 0, 0\r\n  %xor2.i.i.peel.i377.i.i.i.i = or i64 %and.i.i.peel.i376.i.i.i.i, 0\r\n  %sub.i.i.peel.i378.i.i.i.i = or i64 %xor2.i.i.peel.i377.i.i.i.i, 0\r\n  %xor3.i.i.peel.i379.i.i.i.i = xor i64 %sub.i.i.peel.i378.i.i.i.i, %conv73.i.peel.i374.i.i.i.i\r\n  %and4.i.i.peel.i380.i.i.i.i = and i64 %xor3.i.i.peel.i379.i.i.i.i, 0\r\n  %cmp.i.i.peel.i381.i.i.i.i = icmp slt i64 %and4.i.i.peel.i380.i.i.i.i, 0\r\n  %7 = trunc i64 %conv73.i.peel.i374.i.i.i.i to i16\r\n  %8 = or i16 0, %7\r\n  %9 = select i1 %cmp.i.i.peel.i381.i.i.i.i, i16 0, i16 %8\r\n  %conv76.i.i.i.i.i.i = and i16 %4, %5\r\n  %conv76.i.peel.i384.i.i.i.i = and i16 %conv76.i.i.i.i.i.i, %9\r\n  %10 = zext i32 0 to i64\r\n  %add.i.i.peel.i417.i.i.i.i = or i64 %10, 0\r\n  %or.i.peel.i419.i.i.i.i = or i64 %add.i.i.peel.i417.i.i.i.i, 0\r\n  %conv72.i.peel.i420.i.i.i.i = shl i64 %or.i.peel.i419.i.i.i.i, 0\r\n  %sext.i.peel.i421.i.i.i.i = ashr i64 %conv72.i.peel.i420.i.i.i.i, 0\r\n  %conv73.i.peel.i422.i.i.i.i = xor i64 %sext.i.peel.i421.i.i.i.i, 0\r\n  %and.i.i.peel.i424.i.i.i.i = and i64 0, 0\r\n  %xor2.i.i.peel.i425.i.i.i.i = or i64 %and.i.i.peel.i424.i.i.i.i, 0\r\n  %sub.i.i.peel.i426.i.i.i.i = or i64 %xor2.i.i.peel.i425.i.i.i.i, 0\r\n  %xor3.i.i.peel.i427.i.i.i.i = xor i64 %sub.i.i.peel.i426.i.i.i.i, %conv73.i.peel.i422.i.i.i.i\r\n  %and4.i.i.peel.i428.i.i.i.i = and i64 %xor3.i.i.peel.i427.i.i.i.i, 0\r\n  %cmp.i.i.peel.i429.i.i.i.i = icmp slt i64 %and4.i.i.peel.i428.i.i.i.i, 0\r\n  %11 = trunc i64 %conv73.i.peel.i422.i.i.i.i to i16\r\n  %12 = or i16 0, %11\r\n  %13 = select i1 %cmp.i.i.peel.i429.i.i.i.i, i16 0, i16 %12\r\n  %conv76.i.peel.i432.i.i.i.i = and i16 %conv76.i.peel.i384.i.i.i.i, %13\r\n  ret i16 %conv76.i.peel.i432.i.i.i.i\r\n}\r\n```\r\n```\r\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3180: llvm::slpvectorizer::BoUpSLP::ValueList& llvm::slpvectorizer::BoUpSLP::TreeEntry::getOperand(unsigned int): Assertion `OpIdx < Operands.size() && \"Off bounds\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S --passes=slp-vectorizer <source>\r\n1.\tRunning pass \"function(slp-vectorizer)\" on module \"<source>\"\r\n2.\tRunning pass \"slp-vectorizer\" on function \"main\"\r\n #0 0x0000000005016bb8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5016bb8)\r\n #1 0x00000000050142fc SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007955e2242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x00007955e22969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #4 0x00007955e2242476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #5 0x00007955e22287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #6 0x00007955e222871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #7 0x00007955e2239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #8 0x000000000406f2b8 llvm::slpvectorizer::BoUpSLP::TreeEntry::getOperand(unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x406f2b8)\r\n #9 0x00000000040f675e llvm::slpvectorizer::BoUpSLP::getEntryCost(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::SmallPtrSetImpl<llvm::Value*>&)::'lambda0'(llvm::function_ref<llvm::InstructionCost (unsigned int)>, llvm::function_ref<llvm::InstructionCost (llvm::InstructionCost)>)::operator()(llvm::function_ref<llvm::InstructionCost (unsigned int)>, llvm::function_ref<llvm::InstructionCost (llvm::InstructionCost)>) const SLPVectorizer.cpp:0:0\r\n#10 0x00000000040f74aa llvm::slpvectorizer::BoUpSLP::getEntryCost(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::SmallPtrSetImpl<llvm::Value*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x40f74aa)\r\n#11 0x0000000004114641 llvm::slpvectorizer::BoUpSLP::getTreeCost(llvm::ArrayRef<llvm::Value*>) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4114641)\r\n#12 0x00000000041198c8 (anonymous namespace)::HorizontalReduction::tryToReduce(llvm::slpvectorizer::BoUpSLP&, llvm::DataLayout const&, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo const&) SLPVectorizer.cpp:0:0\r\n#13 0x000000000411bfe1 llvm::SLPVectorizerPass::vectorizeHorReduction(llvm::PHINode*, llvm::Instruction*, llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&, llvm::TargetTransformInfo*, llvm::SmallVectorImpl<llvm::WeakTrackingVH>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x411bfe1)\r\n#14 0x0000000004120876 llvm::SLPVectorizerPass::vectorizeRootInstruction(llvm::PHINode*, llvm::Instruction*, llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&, llvm::TargetTransformInfo*) (.constprop.0) SLPVectorizer.cpp:0:0\r\n#15 0x0000000004124e16 llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4124e16)\r\n#16 0x000000000412b2e1 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (.part.0) SLPVectorizer.cpp:0:0\r\n#17 0x000000000412bf6b llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x412bf6b)\r\n#18 0x0000000002f0034e llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2f0034e)\r\n#19 0x0000000004e18ff8 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e18ff8)\r\n#20 0x0000000000e06a0e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe06a0e)\r\n#21 0x0000000004e17a1e llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e17a1e)\r\n#22 0x0000000000e0621e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe0621e)\r\n#23 0x0000000004e17450 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e17450)\r\n#24 0x00000000008fce52 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8fce52)\r\n#25 0x00000000008efcdc optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8efcdc)\r\n#26 0x00007955e2229d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#27 0x00007955e2229e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#28 0x00000000008e77ae _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8e77ae)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139\r\n```",
    "author": "dtcxzyw",
    "labels": [
      "llvm:SLPVectorizer",
      "crash-on-valid"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}