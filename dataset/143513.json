{
  "bug_id": "143513",
  "issue_url": "https://github.com/llvm/llvm-project/issues/143513",
  "bug_type": "crash",
  "base_commit": "cf637b7e3554976419a0d672ad4c252137dc34f3",
  "knowledge_cutoff": "2025-06-10T12:05:35Z",
  "lit_test_dir": [
    "llvm/test/Transforms/PhaseOrdering",
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "0108a5908cab5e418c683ef9b6e1810755344b5e",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          12085,
          12091
        ],
        [
          12130,
          12136
        ],
        [
          12152,
          12159
        ],
        [
          12171,
          12182
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "computeExtractCost"
      ]
    }
  },
  "patch": "commit 0108a5908cab5e418c683ef9b6e1810755344b5e\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Tue Jun 17 07:55:52 2025 -0700\n\n    [SLP]Fix a crash on an subvector size calculation for non-power-of-2 vector\n    \n    Patch fixes cost estimation for the extractelements from non-power-of-2\n    vectors, defined as subvector extracts. In this case the subvector size\n    might be not adjusted to a whole register size, need to get the minimum\n    between whole vector size and the actual difference to prevent compiler\n    crash.\n    \n    Fixes #143513\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex d811e9d77d18..4551a365a696 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -12085,7 +12085,8 @@ class BoUpSLP::ShuffleCostEstimator : public BaseShuffleAnalysis {\n     // FIXME: this must be moved to TTI for better estimation.\n     unsigned EltsPerVector = getPartNumElems(VL.size(), NumParts);\n     auto CheckPerRegistersShuffle = [&](MutableArrayRef<int> Mask,\n-                                        SmallVectorImpl<unsigned> &Indices)\n+                                        SmallVectorImpl<unsigned> &Indices,\n+                                        SmallVectorImpl<unsigned> &SubVecSizes)\n         -> std::optional<TTI::ShuffleKind> {\n       if (NumElts <= EltsPerVector)\n         return std::nullopt;\n@@ -12130,7 +12131,9 @@ class BoUpSLP::ShuffleCostEstimator : public BaseShuffleAnalysis {\n                       return std::min(S, I);\n                     }),\n                 EltsPerVector);\n-            Indices.push_back(OffsetReg1 % NumElts);\n+            unsigned Index = OffsetReg1 % NumElts;\n+            Indices.push_back(Index);\n+            SubVecSizes.push_back(std::min(NumElts - Index, EltsPerVector));\n           }\n           Idx = I - OffsetReg1;\n         }\n@@ -12152,8 +12155,9 @@ class BoUpSLP::ShuffleCostEstimator : public BaseShuffleAnalysis {\n       SmallVector<int> SubMask(EltsPerVector, PoisonMaskElem);\n       copy(MaskSlice, SubMask.begin());\n       SmallVector<unsigned, 2> Indices;\n+      SmallVector<unsigned, 2> SubVecSizes;\n       std::optional<TTI::ShuffleKind> RegShuffleKind =\n-          CheckPerRegistersShuffle(SubMask, Indices);\n+          CheckPerRegistersShuffle(SubMask, Indices, SubVecSizes);\n       if (!RegShuffleKind) {\n         if (*ShuffleKinds[Part] != TTI::SK_PermuteSingleSrc ||\n             !ShuffleVectorInst::isIdentityMask(\n@@ -12171,12 +12175,12 @@ class BoUpSLP::ShuffleCostEstimator : public BaseShuffleAnalysis {\n       }\n       const unsigned BaseVF = getFullVectorNumberOfElements(\n           *R.TTI, VL.front()->getType(), alignTo(NumElts, EltsPerVector));\n-      for (unsigned Idx : Indices) {\n-        assert((Idx + EltsPerVector) <= BaseVF &&\n+      for (const auto [Idx, SubVecSize] : zip(Indices, SubVecSizes)) {\n+        assert((Idx + SubVecSize) <= BaseVF &&\n                \"SK_ExtractSubvector index out of range\");\n         Cost += ::getShuffleCost(TTI, TTI::SK_ExtractSubvector,\n                                  getWidenedType(ScalarTy, BaseVF), {}, CostKind,\n-                                 Idx, getWidenedType(ScalarTy, EltsPerVector));\n+                                 Idx, getWidenedType(ScalarTy, SubVecSize));\n       }\n       // Second attempt to check, if just a permute is better estimated than\n       // subvector extract.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/PhaseOrdering/X86/hadd.ll",
      "commands": [
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64",
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64-v2",
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64-v3",
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64-v4",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64-v2",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64-v3",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64-v4"
      ],
      "tests": [
        {
          "test_name": "add_v16i16_0123u56789uBCDEF",
          "test_body": "define <16 x i16> @add_v16i16_0123u56789uBCDEF(<16 x i16> %a, <16 x i16> %b) {\n  %a0 = extractelement <16 x i16> %a, i32 0\n  %a1 = extractelement <16 x i16> %a, i32 1\n  %a2 = extractelement <16 x i16> %a, i32 2\n  %a3 = extractelement <16 x i16> %a, i32 3\n  %a4 = extractelement <16 x i16> %a, i32 4\n  %a5 = extractelement <16 x i16> %a, i32 5\n  %a6 = extractelement <16 x i16> %a, i32 6\n  %a7 = extractelement <16 x i16> %a, i32 7\n  %a8 = extractelement <16 x i16> %a, i32 8\n  %a9 = extractelement <16 x i16> %a, i32 9\n  %aA = extractelement <16 x i16> %a, i32 10\n  %aB = extractelement <16 x i16> %a, i32 11\n  %aC = extractelement <16 x i16> %a, i32 12\n  %aD = extractelement <16 x i16> %a, i32 13\n  %aE = extractelement <16 x i16> %a, i32 14\n  %aF = extractelement <16 x i16> %a, i32 15\n  %a01 = add i16 %a0, %a1\n  %a23 = add i16 %a2, %a3\n  %a45 = add i16 %a4, %a5\n  %a67 = add i16 %a6, %a7\n  %a89 = add i16 %a8, %a9\n  %aAB = add i16 %aA, %aB\n  %aCD = add i16 %aC, %aD\n  %aEF = add i16 %aE, %aF\n  %b0 = extractelement <16 x i16> %b, i32 0\n  %b1 = extractelement <16 x i16> %b, i32 1\n  %b2 = extractelement <16 x i16> %b, i32 2\n  %b3 = extractelement <16 x i16> %b, i32 3\n  %b4 = extractelement <16 x i16> %b, i32 4\n  %b5 = extractelement <16 x i16> %b, i32 5\n  %b6 = extractelement <16 x i16> %b, i32 6\n  %b7 = extractelement <16 x i16> %b, i32 7\n  %b8 = extractelement <16 x i16> %b, i32 8\n  %b9 = extractelement <16 x i16> %b, i32 9\n  %bA = extractelement <16 x i16> %b, i32 10\n  %bB = extractelement <16 x i16> %b, i32 11\n  %bC = extractelement <16 x i16> %b, i32 12\n  %bD = extractelement <16 x i16> %b, i32 13\n  %bE = extractelement <16 x i16> %b, i32 14\n  %bF = extractelement <16 x i16> %b, i32 15\n  %b01 = add i16 %b0, %b1\n  %b23 = add i16 %b2, %b3\n  %b45 = add i16 %b4, %b5\n  %b67 = add i16 %b6, %b7\n  %b89 = add i16 %b8, %b9\n  %bAB = add i16 %bA, %bB\n  %bCD = add i16 %bC, %bD\n  %bEF = add i16 %bE, %bF\n  %hadd0 = insertelement <16 x i16> poison, i16 %a01, i32 0\n  %hadd1 = insertelement <16 x i16> %hadd0, i16 %a23, i32 1\n  %hadd2 = insertelement <16 x i16> %hadd1, i16 %a45, i32 2\n  %hadd3 = insertelement <16 x i16> %hadd2, i16 %a67, i32 3\n  %hadd4 = insertelement <16 x i16> %hadd3, i16 %b01, i32 4\n  %hadd5 = insertelement <16 x i16> %hadd4, i16 %b23, i32 5\n  %hadd6 = insertelement <16 x i16> %hadd5, i16 %b45, i32 6\n  %hadd7 = insertelement <16 x i16> %hadd6, i16 %b67, i32 7\n  %hadd8 = insertelement <16 x i16> %hadd7, i16 %a89, i32 8\n  %hadd9 = insertelement <16 x i16> %hadd8, i16 %aAB, i32 9\n  %haddA = insertelement <16 x i16> %hadd9, i16 %aCD, i32 10\n  %haddB = insertelement <16 x i16> %haddA, i16 %aEF, i32 11\n  %haddC = insertelement <16 x i16> %haddB, i16 %b89, i32 12\n  %haddD = insertelement <16 x i16> %haddC, i16 %bAB, i32 13\n  %haddE = insertelement <16 x i16> %haddD, i16 %bCD, i32 14\n  %haddF = insertelement <16 x i16> %haddE, i16 %bEF, i32 15\n  %result = shufflevector <16 x i16> %haddF, <16 x i16> %a, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 5, i32 6, i32 7, i32 8, i32 9, i32 poison, i32 11, i32 12, i32 13, i32 14, i32 15>\n  ret <16 x i16> %result\n}\n"
        },
        {
          "test_name": "add_v16i16_0123456789ABCDEF",
          "test_body": "define <16 x i16> @add_v16i16_0123456789ABCDEF(<16 x i16> %a, <16 x i16> %b) {\n  %a0 = extractelement <16 x i16> %a, i32 0\n  %a1 = extractelement <16 x i16> %a, i32 1\n  %a2 = extractelement <16 x i16> %a, i32 2\n  %a3 = extractelement <16 x i16> %a, i32 3\n  %a4 = extractelement <16 x i16> %a, i32 4\n  %a5 = extractelement <16 x i16> %a, i32 5\n  %a6 = extractelement <16 x i16> %a, i32 6\n  %a7 = extractelement <16 x i16> %a, i32 7\n  %a8 = extractelement <16 x i16> %a, i32 8\n  %a9 = extractelement <16 x i16> %a, i32 9\n  %aA = extractelement <16 x i16> %a, i32 10\n  %aB = extractelement <16 x i16> %a, i32 11\n  %aC = extractelement <16 x i16> %a, i32 12\n  %aD = extractelement <16 x i16> %a, i32 13\n  %aE = extractelement <16 x i16> %a, i32 14\n  %aF = extractelement <16 x i16> %a, i32 15\n  %a01 = add i16 %a0, %a1\n  %a23 = add i16 %a2, %a3\n  %a45 = add i16 %a4, %a5\n  %a67 = add i16 %a6, %a7\n  %a89 = add i16 %a8, %a9\n  %aAB = add i16 %aA, %aB\n  %aCD = add i16 %aC, %aD\n  %aEF = add i16 %aE, %aF\n  %b0 = extractelement <16 x i16> %b, i32 0\n  %b1 = extractelement <16 x i16> %b, i32 1\n  %b2 = extractelement <16 x i16> %b, i32 2\n  %b3 = extractelement <16 x i16> %b, i32 3\n  %b4 = extractelement <16 x i16> %b, i32 4\n  %b5 = extractelement <16 x i16> %b, i32 5\n  %b6 = extractelement <16 x i16> %b, i32 6\n  %b7 = extractelement <16 x i16> %b, i32 7\n  %b8 = extractelement <16 x i16> %b, i32 8\n  %b9 = extractelement <16 x i16> %b, i32 9\n  %bA = extractelement <16 x i16> %b, i32 10\n  %bB = extractelement <16 x i16> %b, i32 11\n  %bC = extractelement <16 x i16> %b, i32 12\n  %bD = extractelement <16 x i16> %b, i32 13\n  %bE = extractelement <16 x i16> %b, i32 14\n  %bF = extractelement <16 x i16> %b, i32 15\n  %b01 = add i16 %b0, %b1\n  %b23 = add i16 %b2, %b3\n  %b45 = add i16 %b4, %b5\n  %b67 = add i16 %b6, %b7\n  %b89 = add i16 %b8, %b9\n  %bAB = add i16 %bA, %bB\n  %bCD = add i16 %bC, %bD\n  %bEF = add i16 %bE, %bF\n  %hadd0 = insertelement <16 x i16> poison, i16 %a01, i32 0\n  %hadd1 = insertelement <16 x i16> %hadd0, i16 %a23, i32 1\n  %hadd2 = insertelement <16 x i16> %hadd1, i16 %a45, i32 2\n  %hadd3 = insertelement <16 x i16> %hadd2, i16 %a67, i32 3\n  %hadd4 = insertelement <16 x i16> %hadd3, i16 %b01, i32 4\n  %hadd5 = insertelement <16 x i16> %hadd4, i16 %b23, i32 5\n  %hadd6 = insertelement <16 x i16> %hadd5, i16 %b45, i32 6\n  %hadd7 = insertelement <16 x i16> %hadd6, i16 %b67, i32 7\n  %hadd8 = insertelement <16 x i16> %hadd7, i16 %a89, i32 8\n  %hadd9 = insertelement <16 x i16> %hadd8, i16 %aAB, i32 9\n  %haddA = insertelement <16 x i16> %hadd9, i16 %aCD, i32 10\n  %haddB = insertelement <16 x i16> %haddA, i16 %aEF, i32 11\n  %haddC = insertelement <16 x i16> %haddB, i16 %b89, i32 12\n  %haddD = insertelement <16 x i16> %haddC, i16 %bAB, i32 13\n  %haddE = insertelement <16 x i16> %haddD, i16 %bCD, i32 14\n  %haddF = insertelement <16 x i16> %haddE, i16 %bEF, i32 15\n  %result = shufflevector <16 x i16> %haddF, <16 x i16> %a, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n  ret <16 x i16> %result\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/PhaseOrdering/X86/hsub.ll",
      "commands": [
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64",
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64-v2",
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64-v3",
        "opt < %s -O3 -S -mtriple=x86_64-- -mcpu=x86-64-v4",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64-v2",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64-v3",
        "opt < %s -passes=\"default<O3>\" -S -mtriple=x86_64-- -mcpu=x86-64-v4"
      ],
      "tests": [
        {
          "test_name": "sub_v16i16_0123456789ABCDEF",
          "test_body": "define <16 x i16> @sub_v16i16_0123456789ABCDEF(<16 x i16> %a, <16 x i16> %b) {\n  %a0 = extractelement <16 x i16> %a, i32 0\n  %a1 = extractelement <16 x i16> %a, i32 1\n  %a2 = extractelement <16 x i16> %a, i32 2\n  %a3 = extractelement <16 x i16> %a, i32 3\n  %a4 = extractelement <16 x i16> %a, i32 4\n  %a5 = extractelement <16 x i16> %a, i32 5\n  %a6 = extractelement <16 x i16> %a, i32 6\n  %a7 = extractelement <16 x i16> %a, i32 7\n  %a8 = extractelement <16 x i16> %a, i32 8\n  %a9 = extractelement <16 x i16> %a, i32 9\n  %aA = extractelement <16 x i16> %a, i32 10\n  %aB = extractelement <16 x i16> %a, i32 11\n  %aC = extractelement <16 x i16> %a, i32 12\n  %aD = extractelement <16 x i16> %a, i32 13\n  %aE = extractelement <16 x i16> %a, i32 14\n  %aF = extractelement <16 x i16> %a, i32 15\n  %a01 = sub i16 %a0, %a1\n  %a23 = sub i16 %a2, %a3\n  %a45 = sub i16 %a4, %a5\n  %a67 = sub i16 %a6, %a7\n  %a89 = sub i16 %a8, %a9\n  %aAB = sub i16 %aA, %aB\n  %aCD = sub i16 %aC, %aD\n  %aEF = sub i16 %aE, %aF\n  %b0 = extractelement <16 x i16> %b, i32 0\n  %b1 = extractelement <16 x i16> %b, i32 1\n  %b2 = extractelement <16 x i16> %b, i32 2\n  %b3 = extractelement <16 x i16> %b, i32 3\n  %b4 = extractelement <16 x i16> %b, i32 4\n  %b5 = extractelement <16 x i16> %b, i32 5\n  %b6 = extractelement <16 x i16> %b, i32 6\n  %b7 = extractelement <16 x i16> %b, i32 7\n  %b8 = extractelement <16 x i16> %b, i32 8\n  %b9 = extractelement <16 x i16> %b, i32 9\n  %bA = extractelement <16 x i16> %b, i32 10\n  %bB = extractelement <16 x i16> %b, i32 11\n  %bC = extractelement <16 x i16> %b, i32 12\n  %bD = extractelement <16 x i16> %b, i32 13\n  %bE = extractelement <16 x i16> %b, i32 14\n  %bF = extractelement <16 x i16> %b, i32 15\n  %b01 = sub i16 %b0, %b1\n  %b23 = sub i16 %b2, %b3\n  %b45 = sub i16 %b4, %b5\n  %b67 = sub i16 %b6, %b7\n  %b89 = sub i16 %b8, %b9\n  %bAB = sub i16 %bA, %bB\n  %bCD = sub i16 %bC, %bD\n  %bEF = sub i16 %bE, %bF\n  %hsub0 = insertelement <16 x i16> poison, i16 %a01, i32 0\n  %hsub1 = insertelement <16 x i16> %hsub0, i16 %a23, i32 1\n  %hsub2 = insertelement <16 x i16> %hsub1, i16 %a45, i32 2\n  %hsub3 = insertelement <16 x i16> %hsub2, i16 %a67, i32 3\n  %hsub4 = insertelement <16 x i16> %hsub3, i16 %b01, i32 4\n  %hsub5 = insertelement <16 x i16> %hsub4, i16 %b23, i32 5\n  %hsub6 = insertelement <16 x i16> %hsub5, i16 %b45, i32 6\n  %hsub7 = insertelement <16 x i16> %hsub6, i16 %b67, i32 7\n  %hsub8 = insertelement <16 x i16> %hsub7, i16 %a89, i32 8\n  %hsub9 = insertelement <16 x i16> %hsub8, i16 %aAB, i32 9\n  %hsubA = insertelement <16 x i16> %hsub9, i16 %aCD, i32 10\n  %hsubB = insertelement <16 x i16> %hsubA, i16 %aEF, i32 11\n  %hsubC = insertelement <16 x i16> %hsubB, i16 %b89, i32 12\n  %hsubD = insertelement <16 x i16> %hsubC, i16 %bAB, i32 13\n  %hsubE = insertelement <16 x i16> %hsubD, i16 %bCD, i32 14\n  %hsubF = insertelement <16 x i16> %hsubE, i16 %bEF, i32 15\n  %result = shufflevector <16 x i16> %hsubF, <16 x i16> %a, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n  ret <16 x i16> %result\n}\n"
        },
        {
          "test_name": "sub_v16i16_0123u56789uBCDEF",
          "test_body": "define <16 x i16> @sub_v16i16_0123u56789uBCDEF(<16 x i16> %a, <16 x i16> %b) {\n  %a0 = extractelement <16 x i16> %a, i32 0\n  %a1 = extractelement <16 x i16> %a, i32 1\n  %a2 = extractelement <16 x i16> %a, i32 2\n  %a3 = extractelement <16 x i16> %a, i32 3\n  %a4 = extractelement <16 x i16> %a, i32 4\n  %a5 = extractelement <16 x i16> %a, i32 5\n  %a6 = extractelement <16 x i16> %a, i32 6\n  %a7 = extractelement <16 x i16> %a, i32 7\n  %a8 = extractelement <16 x i16> %a, i32 8\n  %a9 = extractelement <16 x i16> %a, i32 9\n  %aA = extractelement <16 x i16> %a, i32 10\n  %aB = extractelement <16 x i16> %a, i32 11\n  %aC = extractelement <16 x i16> %a, i32 12\n  %aD = extractelement <16 x i16> %a, i32 13\n  %aE = extractelement <16 x i16> %a, i32 14\n  %aF = extractelement <16 x i16> %a, i32 15\n  %a01 = sub i16 %a0, %a1\n  %a23 = sub i16 %a2, %a3\n  %a45 = sub i16 %a4, %a5\n  %a67 = sub i16 %a6, %a7\n  %a89 = sub i16 %a8, %a9\n  %aAB = sub i16 %aA, %aB\n  %aCD = sub i16 %aC, %aD\n  %aEF = sub i16 %aE, %aF\n  %b0 = extractelement <16 x i16> %b, i32 0\n  %b1 = extractelement <16 x i16> %b, i32 1\n  %b2 = extractelement <16 x i16> %b, i32 2\n  %b3 = extractelement <16 x i16> %b, i32 3\n  %b4 = extractelement <16 x i16> %b, i32 4\n  %b5 = extractelement <16 x i16> %b, i32 5\n  %b6 = extractelement <16 x i16> %b, i32 6\n  %b7 = extractelement <16 x i16> %b, i32 7\n  %b8 = extractelement <16 x i16> %b, i32 8\n  %b9 = extractelement <16 x i16> %b, i32 9\n  %bA = extractelement <16 x i16> %b, i32 10\n  %bB = extractelement <16 x i16> %b, i32 11\n  %bC = extractelement <16 x i16> %b, i32 12\n  %bD = extractelement <16 x i16> %b, i32 13\n  %bE = extractelement <16 x i16> %b, i32 14\n  %bF = extractelement <16 x i16> %b, i32 15\n  %b01 = sub i16 %b0, %b1\n  %b23 = sub i16 %b2, %b3\n  %b45 = sub i16 %b4, %b5\n  %b67 = sub i16 %b6, %b7\n  %b89 = sub i16 %b8, %b9\n  %bAB = sub i16 %bA, %bB\n  %bCD = sub i16 %bC, %bD\n  %bEF = sub i16 %bE, %bF\n  %hsub0 = insertelement <16 x i16> poison, i16 %a01, i32 0\n  %hsub1 = insertelement <16 x i16> %hsub0, i16 %a23, i32 1\n  %hsub2 = insertelement <16 x i16> %hsub1, i16 %a45, i32 2\n  %hsub3 = insertelement <16 x i16> %hsub2, i16 %a67, i32 3\n  %hsub4 = insertelement <16 x i16> %hsub3, i16 %b01, i32 4\n  %hsub5 = insertelement <16 x i16> %hsub4, i16 %b23, i32 5\n  %hsub6 = insertelement <16 x i16> %hsub5, i16 %b45, i32 6\n  %hsub7 = insertelement <16 x i16> %hsub6, i16 %b67, i32 7\n  %hsub8 = insertelement <16 x i16> %hsub7, i16 %a89, i32 8\n  %hsub9 = insertelement <16 x i16> %hsub8, i16 %aAB, i32 9\n  %hsubA = insertelement <16 x i16> %hsub9, i16 %aCD, i32 10\n  %hsubB = insertelement <16 x i16> %hsubA, i16 %aEF, i32 11\n  %hsubC = insertelement <16 x i16> %hsubB, i16 %b89, i32 12\n  %hsubD = insertelement <16 x i16> %hsubC, i16 %bAB, i32 13\n  %hsubE = insertelement <16 x i16> %hsubD, i16 %bCD, i32 14\n  %hsubF = insertelement <16 x i16> %hsubE, i16 %bEF, i32 15\n  %result = shufflevector <16 x i16> %hsubF, <16 x i16> %a, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 5, i32 6, i32 7, i32 8, i32 9, i32 poison, i32 11, i32 12, i32 13, i32 14, i32 15>\n  ret <16 x i16> %result\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/SystemZ/non-power-2-subvector-extract.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=s390x-ibm-linux -mcpu=z13 -slp-max-reg-size=256 -slp-vectorize-hor-store -slp-vectorize-non-power-of-2 < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n@c = external global [1 x [10 x i32]]\n@j.0 = external global i32\n\ndefine void @p() {\n;\nentry:\n  %arrayidx12.promoted.5.i = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 200), align 4\n  %conv14.5.i = xor i32 %arrayidx12.promoted.5.i, 1\n  store i32 %conv14.5.i, ptr getelementptr inbounds nuw (i8, ptr @c, i64 200), align 4\n  %arrayidx12.promoted.5.i.1 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 204), align 4\n  %conv14.5.i.1 = xor i32 %arrayidx12.promoted.5.i.1, 1\n  store i32 %conv14.5.i.1, ptr getelementptr inbounds nuw (i8, ptr @c, i64 204), align 4\n  %arrayidx12.promoted.5.i.2 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 208), align 4\n  %conv14.5.i.2 = xor i32 %arrayidx12.promoted.5.i.2, 1\n  store i32 %conv14.5.i.2, ptr getelementptr inbounds nuw (i8, ptr @c, i64 208), align 4\n  %arrayidx12.promoted.1.i.3 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 52), align 4\n  %conv14.1.i.3 = xor i32 %arrayidx12.promoted.1.i.3, 1\n  store i32 %conv14.1.i.3, ptr getelementptr inbounds nuw (i8, ptr @c, i64 52), align 4\n  %arrayidx12.promoted.5.i.3 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 212), align 4\n  %conv14.5.i.3 = xor i32 %arrayidx12.promoted.5.i.3, 1\n  store i32 %conv14.5.i.3, ptr getelementptr inbounds nuw (i8, ptr @c, i64 212), align 4\n  %arrayidx12.promoted.6.i.3 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 252), align 4\n  %conv14.6.i.3 = xor i32 %arrayidx12.promoted.6.i.3, 1\n  %or.1.5.i.3 = or i32 %arrayidx12.promoted.1.i.3, %arrayidx12.promoted.5.i.3\n  store i32 %conv14.6.i.3, ptr getelementptr inbounds nuw (i8, ptr @c, i64 252), align 4\n  store i32 %or.1.5.i.3, ptr @j.0, align 4\n  %arrayidx12.promoted.1.i.4 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 56), align 4\n  %conv14.1.i.4 = xor i32 %arrayidx12.promoted.1.i.4, 1\n  store i32 %conv14.1.i.4, ptr getelementptr inbounds nuw (i8, ptr @c, i64 56), align 4\n  %arrayidx12.promoted.5.i.4 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 216), align 4\n  %conv14.5.i.4 = xor i32 %arrayidx12.promoted.5.i.4, 1\n  store i32 %conv14.5.i.4, ptr getelementptr inbounds nuw (i8, ptr @c, i64 216), align 4\n  %arrayidx12.promoted.6.i.4 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 256), align 4\n  %conv14.6.i.4 = xor i32 %arrayidx12.promoted.6.i.4, 1\n  store i32 %conv14.6.i.4, ptr getelementptr inbounds nuw (i8, ptr @c, i64 256), align 4\n  %arrayidx12.promoted.1.i.5 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 60), align 4\n  %conv14.1.i.5 = xor i32 %arrayidx12.promoted.1.i.5, 1\n  store i32 %conv14.1.i.5, ptr getelementptr inbounds nuw (i8, ptr @c, i64 60), align 4\n  %arrayidx12.promoted.5.i.5 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 220), align 4\n  %conv14.5.i.5 = xor i32 %arrayidx12.promoted.5.i.5, 1\n  store i32 %conv14.5.i.5, ptr getelementptr inbounds nuw (i8, ptr @c, i64 220), align 4\n  %arrayidx12.promoted.6.i.5 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 260), align 4\n  %conv14.6.i.5 = xor i32 %arrayidx12.promoted.6.i.5, 1\n  %0 = or i32 %arrayidx12.promoted.6.i.4, %arrayidx12.promoted.1.i.5\n  %or.1.5.i.5 = or i32 %0, %arrayidx12.promoted.5.i.5\n  %or.1.6.i.5 = or i32 %or.1.5.i.5, %arrayidx12.promoted.6.i.5\n  store i32 %conv14.6.i.5, ptr getelementptr inbounds nuw (i8, ptr @c, i64 260), align 4\n  store i32 %or.1.6.i.5, ptr @j.0, align 4\n  %arrayidx12.promoted.1.i.6 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 64), align 4\n  %conv14.1.i.6 = xor i32 %arrayidx12.promoted.1.i.6, 1\n  store i32 %conv14.1.i.6, ptr getelementptr inbounds nuw (i8, ptr @c, i64 64), align 4\n  %arrayidx12.promoted.5.i.6 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 224), align 4\n  %conv14.5.i.6 = xor i32 %arrayidx12.promoted.5.i.6, 1\n  store i32 %conv14.5.i.6, ptr getelementptr inbounds nuw (i8, ptr @c, i64 224), align 4\n  %arrayidx12.promoted.6.i.6 = load i32, ptr getelementptr inbounds nuw (i8, ptr @c, i64 264), align 4\n  %conv14.6.i.6 = xor i32 %arrayidx12.promoted.6.i.6, 1\n  store i32 %conv14.6.i.6, ptr getelementptr inbounds nuw (i8, ptr @c, i64 264), align 4\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "SLP Vectorizer Options trigger Assertion in cost computation on `s390x`",
    "body": "While running experiments with `csmith`, i ran into the following example (already reduced with `cvise`):\n```C\nstatic int c[][10];\nshort d;\nlong *e;\nlong f;\nint g, k;\nchar h, i;\nstatic int j[3];\nvoid l();\nstatic int *m() {\n  short *n = &d;\n  d = 0;\n  for (; d <= 2;)\n    if (*n)\n      ;\n    else\n      return j;\n  return &g;\n}\nvoid p() { l(); }\nvoid l() {\n  int *q;\n  h = 0;\n  for (; h <= 6; h++) {\n    int **r = &q;\n    *e = 4073709551615;\n    *r = m();\n    k = 0;\n    for (; k <= 6; k++) {\n      i = 2;\n      for (; i <= 6; i++)\n        **r |= c[k][h] ^= f;\n    }\n  }\n}\n```\n When compiling this with the options\n```\n  -O3 \\\n  -S \\\n  -w \\\n  -c \\\n  -o a.out \\\n  --target=s390x-ibm-linux \\\n  -march=z13 \\\n  -mllvm -slp-max-reg-size=256 \\\n  -mllvm -slp-vectorize-hor-store \\\n  -mllvm -slp-vectorize-non-power-of-2 \\\n  -mllvm -enable-tbaa=false \\\n```\nThe assertion `(Idx + EltsPerVector) <= BaseVF && \"SK_ExtractSubvector index out of range\"` fails in `llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::computeExtractCost`. This does not seem to be an issue on X86.\n\n[repro.tar.gz](https://github.com/user-attachments/files/20672338/repro.tar.gz)",
    "author": "dominik-steenken",
    "labels": [
      "llvm:SLPVectorizer",
      "crash"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "N/A"
}