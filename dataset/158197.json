{
  "bug_id": "158197",
  "issue_url": "https://github.com/llvm/llvm-project/issues/158197",
  "bug_type": "miscompilation",
  "base_commit": "2c091e6aec2d48fbcafc9cc5909a62f0321db1fd",
  "knowledge_cutoff": "2025-09-12T05:03:21Z",
  "lit_test_dir": [
    "llvm/test/Transforms/VectorCombine"
  ],
  "hints": {
    "fix_commit": "994a6a39e13dcc335247a127a5da05905d1ac541",
    "components": [
      "VectorCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VectorCombine.cpp": [
        [
          2014,
          2025
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VectorCombine.cpp": [
        "VectorCombine::scalarizeExtExtract"
      ]
    }
  },
  "patch": "commit 994a6a39e13dcc335247a127a5da05905d1ac541\nAuthor: Uyiosa Iyekekpolor <96444432+uyoyo0@users.noreply.github.com>\nDate:   Mon Sep 15 06:08:16 2025 -0400\n\n    [VectorCombine] Fix scalarizeExtExtract for big-endian (#157962)\n    \n    The scalarizeExtExtract transform assumed little-endian lane ordering,\n    causing miscompiles on big-endian targets such as AIX/PowerPC under -O3\n    -flto.\n    \n    This patch updates the shift calculation to handle endianness correctly\n    for big-endian targets. No functional change\n    for little-endian targets.\n    \n    Fixes #158197.\n    \n    ---------\n    \n    Co-authored-by: Simon Pilgrim <llvm-dev@redking.me.uk>\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\nindex a84b6f59971c..0ef933f59660 100644\n--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n@@ -2014,12 +2014,19 @@ bool VectorCombine::scalarizeExtExtract(Instruction &I) {\n       IntegerType::get(SrcTy->getContext(), DL->getTypeSizeInBits(SrcTy)));\n   uint64_t SrcEltSizeInBits = DL->getTypeSizeInBits(SrcTy->getElementType());\n   uint64_t EltBitMask = (1ull << SrcEltSizeInBits) - 1;\n+  uint64_t TotalBits = DL->getTypeSizeInBits(SrcTy);\n+  Type *PackedTy = IntegerType::get(SrcTy->getContext(), TotalBits);\n+  Value *Mask = ConstantInt::get(PackedTy, EltBitMask);\n   for (User *U : Ext->users()) {\n     auto *Extract = cast<ExtractElementInst>(U);\n     uint64_t Idx =\n         cast<ConstantInt>(Extract->getIndexOperand())->getZExtValue();\n-    Value *LShr = Builder.CreateLShr(ScalarV, Idx * SrcEltSizeInBits);\n-    Value *And = Builder.CreateAnd(LShr, EltBitMask);\n+    uint64_t ShiftAmt =\n+        DL->isBigEndian()\n+            ? (TotalBits - SrcEltSizeInBits - Idx * SrcEltSizeInBits)\n+            : (Idx * SrcEltSizeInBits);\n+    Value *LShr = Builder.CreateLShr(ScalarV, ShiftAmt);\n+    Value *And = Builder.CreateAnd(LShr, Mask);\n     U->replaceAllUsesWith(And);\n   }\n   return true;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/VectorCombine/AArch64/scalarize-ext-extract-endian.ll",
      "commands": [
        "opt -passes='vector-combine' -S -mtriple=aarch64-unknown-linux-gnu %s -o -",
        "opt -passes='vector-combine' -S -mtriple=aarch64_be-unknown-linux-gnu %s -o -"
      ],
      "tests": [
        {
          "test_name": "g",
          "test_body": "define i64 @g(<8 x i8> %v) {\n  %z = zext <8 x i8> %v to <8 x i64>\n  %e0 = extractelement <8 x i64> %z, i32 0\n  %e7 = extractelement <8 x i64> %z, i32 7\n  %sum = add i64 %e0, %e7\n  ret i64 %sum\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/VectorCombine/PowerPC/scalarize-ext-extract.ll",
      "commands": [
        "opt -passes='vector-combine' -S -mtriple=powerpc64-ibm-aix-xcoff     %s -o -"
      ],
      "tests": [
        {
          "test_name": "g",
          "test_body": "define i64 @g(<8 x i8> %v) {\n  %z = zext <8 x i8> %v to <8 x i64>\n  %e0 = extractelement <8 x i64> %z, i32 0\n  %e7 = extractelement <8 x i64> %z, i32 7\n  %sum = add i64 %e0, %e7\n  ret i64 %sum\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[VectorCombine] scalarizeExtExtract uses LE lane mapping on BE targets",
    "body": "The `scalarizeExtExtract` combine packs <N x i8> into i(N*8) and then extracts lanes via lshr/and. The shift amount assumes little-endian ordering which is incorrect for big-endian targets.\n\nThis causes miscompiles on big-endian targets such as AIX/PowerPC under -O3 -flto. ",
    "author": "uyoyo0",
    "labels": [
      "miscompilation",
      "release:backport",
      "llvm::vectorcombine"
    ],
    "comments": [
      {
        "author": "RKSimon",
        "body": "Reopening - will backport once its had time to stew for a few days in trunk"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}