{
  "bug_id": "173784",
  "issue_url": "https://github.com/llvm/llvm-project/issues/173784",
  "bug_type": "miscompilation",
  "base_commit": "5f5560f62bfbaf3b38c90ae926fd07463ab74b8e",
  "knowledge_cutoff": "2025-12-28T15:59:03Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "d9ce80db7aaa985160276aa59a405e5f47fd7354",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          25024,
          25036
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "tryToReduce"
      ]
    }
  },
  "patch": "commit d9ce80db7aaa985160276aa59a405e5f47fd7354\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Sun Dec 28 11:20:42 2025 -0800\n\n    [SLP]FIx order of bool logical ops, if the right op is used in the first reduction operarion\n    \n    If the LHS of the first reduction op is not a first operand, but RHS is,\n    and RHS is the second operand of the first reductoin op, still need to\n    emit RHS as a second reduction operand, though without freeze of the\n    LHS operand\n    \n    https://alive2.llvm.org/ce/z/2_JLBu\n    \n    Fixes #173784\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 6e05fcfe421c..a7b41631594d 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -25024,13 +25024,21 @@ public:\n                                         getRdxOperand(RedOp1, 0) == LHS ||\n                                         isGuaranteedNotToBePoison(LHS, AC)))\n             return;\n+          bool NeedFreeze = LHS != VectorizedTree;\n           if (isBoolLogicOp(RedOp2) && ((!InitStep && RHS == VectorizedTree) ||\n                                         getRdxOperand(RedOp2, 0) == RHS ||\n                                         isGuaranteedNotToBePoison(RHS, AC))) {\n-            std::swap(LHS, RHS);\n-            return;\n+            if ((InitStep || RHS != VectorizedTree) &&\n+                getRdxOperand(RedOp2, 0) == RHS &&\n+                (!isBoolLogicOp(RedOp1) ||\n+                 getRdxOperand(RedOp1, 1) == RedOp2)) {\n+              NeedFreeze = false;\n+            } else {\n+              std::swap(LHS, RHS);\n+              return;\n+            }\n           }\n-          if (LHS != VectorizedTree)\n+          if (NeedFreeze)\n             LHS = Builder.CreateFreeze(LHS);\n         };\n     // Finish the reduction.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/boolean-op-with-poisons.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer < %s"
      ],
      "tests": [
        {
          "test_name": "test_explicit_poison_leaves",
          "test_body": "define i1 @test_explicit_poison_leaves(i1 %a, i1 %b) {\n  %op1 = select i1 %a, i1 true, i1 poison\n  %op2 = select i1 %b, i1 true, i1 poison\n  %res = select i1 %op1, i1 true, i1 %op2\n  ret i1 %res\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLP] Miscompilation when vectorizing boolean selects with poison",
    "body": "In https://github.com/llvm/llvm-project/commit/899336735aeb2b41a48b6ac2c895da5e0f22dbf0, there seems to be an uncovered correctness issue in the handling of boolean select chains involving poison. \n\nConsider the following scalar IR:\n\n```llvm\n%op1 = select i1 %a, i1 true, i1 poison\n%op2 = select i1 %b, i1 true, i1 poison\n%res = select i1 %op1, i1 true, i1 %op2\nret i1 %res\n```\n\nSemantically, this code is safe:\nif `%a` is true, `%op1` is true, and `%res` immediately becomes true.\nIn this case, the value of `%op2` (and the poison on its false branch) is never observed.\n\nAfter the current transformation, this pattern is rewritten by grouping `%op1` and `%op2` into a vector and lowering the logic to a `llvm.vector.reduce.or`. This transformation eagerly evaluates all vector lanes.\n\nAs a result, if `%op2` is poison, the reduction observes that poison and produces a poison result, even when `%op1` is true. This introduces poison in cases where the original scalar code would have produced a well-defined true.\n\nAlive2 proof: https://alive2.llvm.org/ce/z/oE2h69\n\ncc @alexey-bataev \n",
    "author": "cardigan1008",
    "labels": [
      "miscompilation",
      "llvm:SLPVectorizer"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}