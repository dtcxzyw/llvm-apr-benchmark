{
  "bug_id": "154116",
  "issue_url": "https://github.com/llvm/llvm-project/issues/154116",
  "bug_type": "miscompilation",
  "base_commit": "4ff7ac23301bee8cab04993b6047e360571adde3",
  "knowledge_cutoff": "2025-08-18T13:25:53Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SeparateConstOffsetFromGEP"
  ],
  "hints": {
    "fix_commit": "2d3167f8d86ca9bdaff44cf839488c5a513f5583",
    "components": [
      "SeparateConstOffsetFromGEP"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp": [
        [
          642,
          647
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp": [
        "ConstantOffsetExtractor::applyExts"
      ]
    }
  },
  "patch": "commit 2d3167f8d86ca9bdaff44cf839488c5a513f5583\nAuthor: Bjorn Pettersson <bjorn.a.pettersson@ericsson.com>\nDate:   Wed Aug 20 19:26:11 2025 +0200\n\n    [SeparateConstOffsetFromGEP] Avoid miscompiles related to trunc nuw/nsw (#154582)\n    \n    Drop poison generating flags on trunc when distributing trunc over\n    add/sub/or. We need to do this since for example\n    (add (trunc nuw A), (trunc nuw B)) is more poisonous than\n    (trunc nuw (add A, B))).\n    \n    In some situations it is pessimistic to drop the flags. Such as\n    if the add in the example above also has the nuw flag. For now we\n    keep it simple and always drop the flags.\n    \n    Worth mentioning is that we drop the flags when cloning\n    instructions and rebuilding the chain. This is done after the\n    \"allowsPreservingNUW\" checks in ConstantOffsetExtractor::Extract.\n    So we still take the \"trunc nuw\" into consideration when determining\n    if nuw can be preserved in the gep (which should be ok since that\n    check also require that all the involved binary operations has nuw).\n    \n    Fixes #154116\n\ndiff --git a/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp b/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp\nindex a88f8f19f852..8b9d06d7e443 100644\n--- a/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp\n+++ b/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp\n@@ -642,6 +642,13 @@ Value *ConstantOffsetExtractor::applyExts(Value *V) {\n \n     Instruction *Ext = I->clone();\n     Ext->setOperand(0, Current);\n+    // In ConstantOffsetExtractor::find we do not analyze nuw/nsw for trunc, so\n+    // we assume that it is ok to redistribute trunc over add/sub/or. But for\n+    // example (add (trunc nuw A), (trunc nuw B)) is more poisonous than (trunc\n+    // nuw (add A, B))). To make such redistributions legal we drop all the\n+    // poison generating flags from cloned trunc instructions here.\n+    if (isa<TruncInst>(Ext))\n+      Ext->dropPoisonGeneratingFlags();\n     Ext->insertBefore(*IP->getParent(), IP);\n     Current = Ext;\n   }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SeparateConstOffsetFromGEP/AMDGPU/preserve-inbounds.ll",
      "commands": [
        "opt < %s -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1200 -passes=separate-const-offset-from-gep -S"
      ],
      "tests": [
        {
          "test_name": "nuw_inbounds_implies_nuw_inbounds_trunc_nuw",
          "test_body": "define ptr @nuw_inbounds_implies_nuw_inbounds_trunc_nuw(ptr %p, i128 %i) {\nentry:\n  %idx = add nuw i128 %i, 1\n  %idx.conv = trunc nuw i128 %idx to i64\n  %arrayidx = getelementptr inbounds nuw i32, ptr %p, i64 %idx.conv\n  ret ptr %arrayidx\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SeparateConstOffsetFromGEP/AMDGPU/rebuild-trunc.ll",
      "commands": [
        "opt < %s -mtriple=x86_64-- -passes=separate-const-offset-from-gep -S"
      ],
      "tests": [
        {
          "test_name": "pr154116_nsw",
          "test_body": "define ptr @pr154116_nsw(ptr %p, i128 %i) {\n  %idx = add i128 %i, 1\n  %idx.conv = trunc nsw i128 %idx to i64\n  %arrayidx = getelementptr i32, ptr %p, i64 %idx.conv\n  ret ptr %arrayidx\n}\n"
        },
        {
          "test_name": "pr154116_nuw",
          "test_body": "define ptr @pr154116_nuw(ptr %p, i128 %i) {\n  %idx = add i128 %i, 20\n  %idx.conv = trunc nuw i128 %idx to i64\n  %arrayidx = getelementptr i32, ptr %p, i64 %idx.conv\n  ret ptr %arrayidx\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "separate-const-offset-from-gep miscompile related to \"trunc nuw\"",
    "body": "llvm commit: 673750feea\n\nReproduce with:\n```\nopt -passes=separate-const-offset-from-gep bbi-109669_sep.ll -S -o - -mtriple=hexagon\n```\nThe input program does\n```\n%0 = phi i32 [ -20, %entry ]\n%1 = add i32 %0, 20\n%2 = trunc nuw i32 %1 to i16\n```\nwhere the \"trunc nuw\" is ok since %1 is 0. No truncated bits are set.\n\nHowever, in the result we get:\n```\n%0 = phi i32 [ -20, %entry ]\n[...]\n%1 = trunc nuw i32 %0 to i16\n```\nso here the input to \"trunc nuw\" is negative and the result is poison.\nLangref https://llvm.org/docs/LangRef.html#trunc-to-instruction says\n\"If the nuw keyword is present, and any of the truncated bits are non-zero, the result is a [poison value](https://llvm.org/docs/LangRef.html#poisonvalues).\"\n\nThen %1 is further used to compute the return value from the function so the whole thing results in poison which it did not in the input.\n\n(I stumbled upon this as a miscompile after\n https://github.com/llvm/llvm-project/pull/152990\nwhich I first incorrectly blamed.)\n\n[bbi-109669_sep.ll.gz](https://github.com/user-attachments/files/21836248/bbi-109669_sep.ll.gz)",
    "author": "mikaelholmen",
    "labels": [
      "miscompilation",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "bjope",
        "body": "I don't think I'm an expert at SeparateConstOffsetFromGEP, but some ideas after looking at the source code:\n* One idea is to let `ConstantOffsetExtractor::applyExts `drop poison generating flags from any TruncInst when cloning the chain. Afaict distributing trunc over add/sub (and disjoint or) should be fine if we drop the flags.\n* Another idea is to track if we have truncate with nuw/nsw in `ConstantOffsetExtractor::find` and `ConstantOffsetExtractor::CanTraceInto` to skip rewrites in scenarios when we can't keep `trunc nuw`.\n\nBut maybe there are other solutions?"
      },
      {
        "author": "nikic",
        "body": "cc @ritter-x2a @jrbyrnes @krzysz00 \n\n> One idea is to let `ConstantOffsetExtractor::applyExts `drop poison generating flags from any TruncInst when cloning the chain. Afaict distributing trunc over add/sub (and disjoint or) should be fine if we drop the flags.\n\nThat sounds reasonable to me."
      },
      {
        "author": "krzysz00",
        "body": "Yeah, dropping the `nsw` or `nuw` is probablyt he safe thing\n\n(That or doing some analysis on the operands to the add to see if they're also small enough)"
      },
      {
        "author": "ritter-x2a",
        "body": "I think there is more broken around distributing truncs in separate-const-offset-from-gep. For example, I got this miscompilation while checking if the fix makes sense: https://alive2.llvm.org/ce/z/hLPfcw\n\nIt seems odd that `NonNegative` in `ConstantOffsetExtractor::find` [isn't cleared for trunc](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L606-L609) but [it is for zext](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L617-L620) \"because zext(a) >= 0 does not imply a >= 0\" -- that doesn't hold for trunc either.\nThe meaning of `NonNegative` also seems odd: [the doxygen comment](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L235-L239) says\n> NonNegative -- Whether V is guaranteed to be non-negative. For example, an index of an inbounds GEP is guaranteed to be non-negative. Levaraging this, we can better split inbounds GEPs.\"\n\nI don't think that's right, inbounds GEP indices can be negative."
      },
      {
        "author": "bjope",
        "body": "> It seems odd that `NonNegative` in `ConstantOffsetExtractor::find` [isn't cleared for trunc](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L606-L609) but [it is for zext](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L617-L620) \"because zext(a) >= 0 does not imply a >= 0\" -- that doesn't hold for trunc either. \n \nI've been suspecting that there could be more problems in that area. Wondering if perhaps `NonNegative` should be cleared for trunc. And I'm not quite sure it is correct to just pass on `SignExtended` and `ZeroExtended` either for trunc.\n\nI'm not sure if there is any comprehensive tests involving scenarios with combinarions of sext/zext/trunc/add/sub/or/xor. The support for xor is for example not using CanTraceInto, so unclear to me how that works together with `NonNegative`, `SignExtended` and `ZeroExtended`.\n\nStill think dropping the nuw/nsw flags (https://github.com/llvm/llvm-project/pull/154582) would solve the problem given the IR reproducer in this issue. But agree that more problems might be lurking."
      },
      {
        "author": "mikaelholmen",
        "body": "> I think there is more broken around distributing truncs in separate-const-offset-from-gep. For example, I got this miscompilation while checking if the fix makes sense: https://alive2.llvm.org/ce/z/hLPfcw\n> \n> It seems odd that `NonNegative` in `ConstantOffsetExtractor::find` [isn't cleared for trunc](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L606-L609) but [it is for zext](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L617-L620) \"because zext(a) >= 0 does not imply a >= 0\" -- that doesn't hold for trunc either. The meaning of `NonNegative` also seems odd: [the doxygen comment](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L235-L239) says\n> \n> > NonNegative -- Whether V is guaranteed to be non-negative. For example, an index of an inbounds GEP is guaranteed to be non-negative. Levaraging this, we can better split inbounds GEPs.\"\n> \n> I don't think that's right, inbounds GEP indices can be negative.\n\n@ritter-x2a : \nWill you write a new issue about the miscompile you found or how do we make sure that is not just forgotten?"
      },
      {
        "author": "ritter-x2a",
        "body": "> > I think there is more broken around distributing truncs in separate-const-offset-from-gep. For example, I got this miscompilation while checking if the fix makes sense: https://alive2.llvm.org/ce/z/hLPfcw\n> > It seems odd that `NonNegative` in `ConstantOffsetExtractor::find` [isn't cleared for trunc](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L606-L609) but [it is for zext](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L617-L620) \"because zext(a) >= 0 does not imply a >= 0\" -- that doesn't hold for trunc either. The meaning of `NonNegative` also seems odd: [the doxygen comment](https://github.com/llvm/llvm-project/blob/f306e0aeb2c72e040c59e160e88af3bf76457693/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp#L235-L239) says\n> > > NonNegative -- Whether V is guaranteed to be non-negative. For example, an index of an inbounds GEP is guaranteed to be non-negative. Levaraging this, we can better split inbounds GEPs.\"\n> > \n> > \n> > I don't think that's right, inbounds GEP indices can be negative.\n> \n> [@ritter-x2a](https://github.com/ritter-x2a) : Will you write a new issue about the miscompile you found or how do we make sure that is not just forgotten?\n\nHere it is: #154936\nI might be able to look into this myself in a few weeks, but right now I don't have the capacity."
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true,
  "bisect": "N/A"
}