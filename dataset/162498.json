{
  "bug_id": "162498",
  "issue_url": "https://github.com/llvm/llvm-project/issues/162498",
  "bug_type": "miscompilation",
  "base_commit": "55bd6fb8dbb0b167a98bbea751d74493353e60b3",
  "knowledge_cutoff": "2025-10-08T15:20:54Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "7f54fccc0e556a9ca6e6df42911f05f23eb9889d",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlan.h": [
        [
          1012,
          1017
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp": [
        [
          116,
          121
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanPatternMatch.h": [
        [
          372,
          377
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          511,
          516
        ],
        [
          878,
          886
        ],
        [
          1166,
          1171
        ],
        [
          1229,
          1234
        ],
        [
          1376,
          1381
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          1209,
          1215
        ],
        [
          1275,
          1287
        ],
        [
          1289,
          1294
        ],
        [
          1326,
          1333
        ],
        [
          1341,
          1347
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp": [
        "VPTypeAnalysis::inferScalarTypeForRecipe"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanPatternMatch.h": [
        "m_ActiveLaneMask",
        "m_ExtractLastElement"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPInstruction::generate",
        "VPInstruction::getNumOperandsForOpcode",
        "VPInstruction::isVectorToScalar",
        "VPInstruction::opcodeMayReadOrWriteFromMemory",
        "VPInstruction::print"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::simplifyRecipes",
        "narrowToSingleScalarRecipes"
      ]
    }
  },
  "patch": "commit 7f54fccc0e556a9ca6e6df42911f05f23eb9889d\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Wed Oct 15 13:46:09 2025 +0100\n\n    [VPlan] Add ExtractLastLanePerPart, use in narrowToSingleScalar. (#163056)\n    \n    When narrowing stores of a single-scalar, we currently use\n    ExtractLastElement, which extracts the last element across all parts.\n    This is not correct if the store's address is not uniform across all\n    parts. If it is only uniform-per-part, the last lane per part must be\n    extracted. Add a new ExtractLastLanePerPart opcode to handle this\n    correctly. Most transforms apply to both ExtractLastElement and\n    ExtractLastLanePerPart, with the only difference being their treatment\n    during unrolling.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/162498.\n    \n    PR: https://github.com/llvm/llvm-project/pull/163056\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlan.h b/llvm/lib/Transforms/Vectorize/VPlan.h\nindex 09e9ec574a6b..3bcd7cc80b86 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlan.h\n+++ b/llvm/lib/Transforms/Vectorize/VPlan.h\n@@ -1012,6 +1012,8 @@ public:\n     // part if scalar. In the latter case, the recipe will be removed during\n     // unrolling.\n     ExtractLastElement,\n+    // Extracts the last lane for each part from its operand.\n+    ExtractLastLanePerPart,\n     // Extracts the second-to-last lane from its operand or the second-to-last\n     // part if it is scalar. In the latter case, the recipe will be removed\n     // during unrolling.\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp b/llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp\nindex 07bfe7a896d8..f413c63c6d14 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanAnalysis.cpp\n@@ -116,6 +116,7 @@ Type *VPTypeAnalysis::inferScalarTypeForRecipe(const VPInstruction *R) {\n   case VPInstruction::FirstActiveLane:\n     return Type::getIntNTy(Ctx, 64);\n   case VPInstruction::ExtractLastElement:\n+  case VPInstruction::ExtractLastLanePerPart:\n   case VPInstruction::ExtractPenultimateElement: {\n     Type *BaseTy = inferScalarType(R->getOperand(0));\n     if (auto *VecTy = dyn_cast<VectorType>(BaseTy))\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanPatternMatch.h b/llvm/lib/Transforms/Vectorize/VPlanPatternMatch.h\nindex b42b04946f3c..ecd5e96a1b8d 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanPatternMatch.h\n+++ b/llvm/lib/Transforms/Vectorize/VPlanPatternMatch.h\n@@ -372,6 +372,12 @@ m_ExtractLastElement(const Op0_t &Op0) {\n   return m_VPInstruction<VPInstruction::ExtractLastElement>(Op0);\n }\n \n+template <typename Op0_t>\n+inline VPInstruction_match<VPInstruction::ExtractLastLanePerPart, Op0_t>\n+m_ExtractLastLanePerPart(const Op0_t &Op0) {\n+  return m_VPInstruction<VPInstruction::ExtractLastLanePerPart>(Op0);\n+}\n+\n template <typename Op0_t, typename Op1_t, typename Op2_t>\n inline VPInstruction_match<VPInstruction::ActiveLaneMask, Op0_t, Op1_t, Op2_t>\n m_ActiveLaneMask(const Op0_t &Op0, const Op1_t &Op1, const Op2_t &Op2) {\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex bc9a85186809..775837f84e2e 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -511,6 +511,7 @@ unsigned VPInstruction::getNumOperandsForOpcode(unsigned Opcode) {\n   case VPInstruction::CanonicalIVIncrementForPart:\n   case VPInstruction::ExplicitVectorLength:\n   case VPInstruction::ExtractLastElement:\n+  case VPInstruction::ExtractLastLanePerPart:\n   case VPInstruction::ExtractPenultimateElement:\n   case VPInstruction::FirstActiveLane:\n   case VPInstruction::Not:\n@@ -878,9 +879,11 @@ Value *VPInstruction::generate(VPTransformState &State) {\n \n     return ReducedPartRdx;\n   }\n+  case VPInstruction::ExtractLastLanePerPart:\n   case VPInstruction::ExtractLastElement:\n   case VPInstruction::ExtractPenultimateElement: {\n-    unsigned Offset = getOpcode() == VPInstruction::ExtractLastElement ? 1 : 2;\n+    unsigned Offset =\n+        getOpcode() == VPInstruction::ExtractPenultimateElement ? 2 : 1;\n     Value *Res;\n     if (State.VF.isVector()) {\n       assert(Offset <= State.VF.getKnownMinValue() &&\n@@ -1166,6 +1169,7 @@ InstructionCost VPInstruction::computeCost(ElementCount VF,\n \n bool VPInstruction::isVectorToScalar() const {\n   return getOpcode() == VPInstruction::ExtractLastElement ||\n+         getOpcode() == VPInstruction::ExtractLastLanePerPart ||\n          getOpcode() == VPInstruction::ExtractPenultimateElement ||\n          getOpcode() == Instruction::ExtractElement ||\n          getOpcode() == VPInstruction::ExtractLane ||\n@@ -1229,6 +1233,7 @@ bool VPInstruction::opcodeMayReadOrWriteFromMemory() const {\n   case VPInstruction::CanonicalIVIncrementForPart:\n   case VPInstruction::ExtractLane:\n   case VPInstruction::ExtractLastElement:\n+  case VPInstruction::ExtractLastLanePerPart:\n   case VPInstruction::ExtractPenultimateElement:\n   case VPInstruction::ActiveLaneMask:\n   case VPInstruction::FirstActiveLane:\n@@ -1376,6 +1381,9 @@ void VPInstruction::print(raw_ostream &O, const Twine &Indent,\n   case VPInstruction::ExtractLastElement:\n     O << \"extract-last-element\";\n     break;\n+  case VPInstruction::ExtractLastLanePerPart:\n+    O << \"extract-last-lane-per-part\";\n+    break;\n   case VPInstruction::ExtractPenultimateElement:\n     O << \"extract-penultimate-element\";\n     break;\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex a7d38dc8daf6..011466be40aa 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -1209,7 +1209,8 @@ static void simplifyRecipe(VPRecipeBase &R, VPTypeAnalysis &TypeInfo) {\n   }\n \n   // Look through ExtractLastElement (BuildVector ....).\n-  if (match(&R, m_ExtractLastElement(m_BuildVector()))) {\n+  if (match(&R, m_CombineOr(m_ExtractLastElement(m_BuildVector()),\n+                            m_ExtractLastLanePerPart(m_BuildVector())))) {\n     auto *BuildVector = cast<VPInstruction>(R.getOperand(0));\n     Def->replaceAllUsesWith(\n         BuildVector->getOperand(BuildVector->getNumOperands() - 1));\n@@ -1275,13 +1276,15 @@ static void simplifyRecipe(VPRecipeBase &R, VPTypeAnalysis &TypeInfo) {\n     return;\n   }\n \n-  if (match(Def, m_ExtractLastElement(m_Broadcast(m_VPValue(A))))) {\n+  if (match(Def,\n+            m_CombineOr(m_ExtractLastElement(m_Broadcast(m_VPValue(A))),\n+                        m_ExtractLastLanePerPart(m_Broadcast(m_VPValue(A)))))) {\n     Def->replaceAllUsesWith(A);\n     return;\n   }\n \n-  if (match(Def,\n-            m_VPInstruction<VPInstruction::ExtractLastElement>(m_VPValue(A))) &&\n+  if (match(Def, m_CombineOr(m_ExtractLastElement(m_VPValue(A)),\n+                             m_ExtractLastLanePerPart(m_VPValue(A)))) &&\n       ((isa<VPInstruction>(A) && vputils::isSingleScalar(A)) ||\n        (isa<VPReplicateRecipe>(A) &&\n         cast<VPReplicateRecipe>(A)->isSingleScalar())) &&\n@@ -1289,6 +1292,12 @@ static void simplifyRecipe(VPRecipeBase &R, VPTypeAnalysis &TypeInfo) {\n              [Def, A](VPUser *U) { return U->usesScalars(A) || Def == U; })) {\n     return Def->replaceAllUsesWith(A);\n   }\n+\n+  if (Plan->getUF() == 1 &&\n+      match(Def, m_ExtractLastLanePerPart(m_VPValue(A)))) {\n+    return Def->replaceAllUsesWith(\n+        Builder.createNaryOp(VPInstruction::ExtractLastElement, {A}));\n+  }\n }\n \n void VPlanTransforms::simplifyRecipes(VPlan &Plan) {\n@@ -1326,8 +1335,11 @@ static void narrowToSingleScalarRecipes(VPlan &Plan) {\n             RepOrWidenR->getUnderlyingInstr(), RepOrWidenR->operands(),\n             true /*IsSingleScalar*/, nullptr /*Mask*/, *RepR /*Metadata*/);\n         Clone->insertBefore(RepOrWidenR);\n-        auto *Ext = new VPInstruction(VPInstruction::ExtractLastElement,\n-                                      {Clone->getOperand(0)});\n+        unsigned ExtractOpc =\n+            vputils::isUniformAcrossVFsAndUFs(RepR->getOperand(1))\n+                ? VPInstruction::ExtractLastElement\n+                : VPInstruction::ExtractLastLanePerPart;\n+        auto *Ext = new VPInstruction(ExtractOpc, {Clone->getOperand(0)});\n         Ext->insertBefore(Clone);\n         Clone->setOperand(0, Ext);\n         RepR->eraseFromParent();\n@@ -1341,7 +1353,8 @@ static void narrowToSingleScalarRecipes(VPlan &Plan) {\n           !all_of(RepOrWidenR->users(), [RepOrWidenR](const VPUser *U) {\n             return U->usesScalars(RepOrWidenR) ||\n                    match(cast<VPRecipeBase>(U),\n-                         m_ExtractLastElement(m_VPValue()));\n+                         m_CombineOr(m_ExtractLastElement(m_VPValue()),\n+                                     m_ExtractLastLanePerPart(m_VPValue())));\n           }))\n         continue;\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/replicating-load-store-costs.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "uniform_gep_for_replicating_gep",
          "test_body": "target triple = \"arm64-apple-macosx15.0.0\"\n\ndefine void @uniform_gep_for_replicating_gep(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %c = icmp eq i32 %iv, 0\n  %shift = lshr i32 %iv, 1\n  %ext = zext i1 %c to i8\n  %ext.shift = zext i32 %shift to i64\n  %gep = getelementptr i64, ptr %dst, i64 %ext.shift\n  store i8 %ext, ptr %gep, align 1\n  %iv.next = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 128\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/narrow-to-single-scalar.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -S %s",
        "opt -p loop-vectorize -force-vector-width=2 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "narrow_to_single_scalar_store_address_not_uniform_across_all_parts",
          "test_body": "define void @narrow_to_single_scalar_store_address_not_uniform_across_all_parts(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.shift = lshr i32 %iv, 1\n  %gep.dst = getelementptr i32, ptr %dst, i32 %iv.shift\n  store i32 %iv, ptr %gep.dst, align 4\n  %iv.next = add i32 %iv, 1\n  %ec = icmp eq i32 %iv.next, 100\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize] Miscompile since uniform pointers change.",
    "body": "After this https://github.com/llvm/llvm-project/commit/0c028bbf33d96045871f254fa1810f9767292506 commit the following IR snippet:\n```llvm\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine ptr @foo(ptr %0) {\nentry:\n  %1 = call noalias ptr null(i64 0, i32 0, i32 0, i32 0)\n  %2 = getelementptr i8, ptr %1, i64 16\n  br label %loop\n\nloop:\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %loop ]\n  %3 = lshr i64 %indvars.iv, 1\n  %addr = getelementptr i64, ptr %2, i64 %indvars.iv\n  store i64 0, ptr %addr, align 8\n  %addr19 = getelementptr i32, ptr %0, i64 %3\n  %4 = trunc i64 %indvars.iv to i32\n  store i32 %4, ptr %addr19, align 4\n  %indvars.iv.next = add i64 %indvars.iv, 1\n  %5 = icmp ult i64 %indvars.iv, 97\n  br i1 %5, label %loop, label %unreached\n\nunreached:\n  ret ptr null\n}\n```\nIs getting miscompiled by `opt -passes=loop-vectorize`.\nIt gets vectorized as\n```llvm\ndefine ptr @foo(ptr %0) {\nentry:\n  %1 = call noalias ptr null(i64 0, i32 0, i32 0, i32 0)\n  %2 = getelementptr i8, ptr %1, i64 16\n  br label %vector.ph\n\nvector.ph:\n  br label %vector.body\n\nvector.body:\n  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]\n  %3 = add i64 %index, 2\n  %4 = trunc i64 %index to i32\n  %5 = add i32 %4, 2\n  %6 = add i32 %4, 3\n  %7 = lshr i64 %index, 1\n  %8 = lshr i64 %3, 1\n  %9 = getelementptr i64, ptr %2, i64 %index\n  %10 = getelementptr i64, ptr %9, i32 2\n  store <2 x i64> zeroinitializer, ptr %9, align 8\n  store <2 x i64> zeroinitializer, ptr %10, align 8\n  %11 = getelementptr i32, ptr %0, i64 %7\n  %12 = getelementptr i32, ptr %0, i64 %8\n  store i32 %6, ptr %11, align 4\n  store i32 %6, ptr %12, align 4\n  %index.next = add nuw i64 %index, 4\n  %13 = icmp eq i64 %index.next, 96\n  br i1 %13, label %middle.block, label %vector.body\n\nmiddle.block:\n  br label %scalar.ph\n\nscalar.ph:\n  br label %loop\n\nloop:\n  %indvars.iv = phi i64 [ 96, %scalar.ph ], [ %indvars.iv.next, %loop ]\n  %14 = lshr i64 %indvars.iv, 1\n  %addr = getelementptr i64, ptr %2, i64 %indvars.iv\n  store i64 0, ptr %addr, align 8\n  %addr19 = getelementptr i32, ptr %0, i64 %14\n  %15 = trunc i64 %indvars.iv to i32\n  store i32 %15, ptr %addr19, align 4\n  %indvars.iv.next = add i64 %indvars.iv, 1\n  %16 = icmp ult i64 %indvars.iv, 97\n  br i1 %16, label %loop, label %unreached\n\nunreached:\n  ret ptr null\n}\n```\nNote the double stores of the same value:\n```llvm\n  store i32 %6, ptr %11, align 4\n  store i32 %6, ptr %12, align 4\n```\nwhile before vectorization new value (indvar) was stored on each iteration.\n\nGodbolt link:  https://godbolt.org/z/beeraoETf",
    "author": "danilaml",
    "labels": [
      "miscompilation",
      "vectorizers"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "Looks like a VPlan transform incorrectly assuming uniform-per-part (single-scalar) implies unifirom across UF and VF. Will fix"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  }
}