{
  "bug_id": "173180",
  "issue_url": "https://github.com/llvm/llvm-project/issues/173180",
  "bug_type": "crash",
  "base_commit": "11a1fc412b37b8907064db447bebf5f0d42ff6a4",
  "knowledge_cutoff": "2025-12-21T07:55:41Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SCCP"
  ],
  "hints": {
    "fix_commit": "991455e69e93c0ce88e927eddd28a9ab34d1f8b2",
    "components": [
      "SCCPSolver"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/SCCPSolver.cpp": [
        [
          1498,
          1505
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/SCCPSolver.cpp": [
        "SCCPInstVisitor::visitCastInst"
      ]
    }
  },
  "patch": "commit 991455e69e93c0ce88e927eddd28a9ab34d1f8b2\nAuthor: Milo\u0161 Poletanovi\u0107 <poletanovicmilos97@gmail.com>\nDate:   Thu Dec 25 13:41:50 2025 +0100\n\n    [SCCP] Use mergeInValue instead of markConstant when folding CastInst (#173190)\n    \n    Fixes #173180\n    \n    The crash occurs when a vector constant refines its value during\n    iterative analysis.\n    In `SCCPInstVisitor::visitCastInst`, the logic for folding constants\n    through a `CastInst` uses `markConstant`. This function is strictly\n    designed for initial assignments and contains an assertion that prevents\n    a lattice element from being updated with a different constant pointer.\n    \n    During the analysis of loops or complex data flows, a vector constant\n    may \"refine.\" For example:\n    \n    First Pass: SCCP identifies a value as `<4 x i64> {poison, poison,\n    poison, 0}`.\n    \n    Second Pass: The value refines to `<4 x i64> zeroinitializer`.\n    \n    Because these are distinct `Constant*` objects, `markConstant` triggers\n    a `\"Marking constant with different value\"` assertion failure.\n    \n    The call to `markConstant` is replaced with `mergeInValue`. Unlike the\n    former, `mergeInValue` is lattice-aware, it allows for valid refinement\n    (moving from a less-defined to a more-defined state) and gracefully\n    handles transitions to Overdefined if a true conflict occurs. This\n    brings BitCast handling in line with how Trunc and Ext instructions are\n    already safely handled in the same pass.\n    \n    Co-authored-by: Milos Poletanovic <mpoletanovic@syrmia.com>\n\ndiff --git a/llvm/lib/Transforms/Utils/SCCPSolver.cpp b/llvm/lib/Transforms/Utils/SCCPSolver.cpp\nindex 021bf0618754..90ee55b87439 100644\n--- a/llvm/lib/Transforms/Utils/SCCPSolver.cpp\n+++ b/llvm/lib/Transforms/Utils/SCCPSolver.cpp\n@@ -1498,8 +1498,11 @@ void SCCPInstVisitor::visitCastInst(CastInst &I) {\n   if (Constant *OpC = getConstant(OpSt, I.getOperand(0)->getType())) {\n     // Fold the constant as we build.\n     if (Constant *C =\n-            ConstantFoldCastOperand(I.getOpcode(), OpC, I.getType(), DL))\n-      return (void)markConstant(&I, C);\n+            ConstantFoldCastOperand(I.getOpcode(), OpC, I.getType(), DL)) {\n+      auto &LV = ValueState[&I];\n+      mergeInValue(LV, &I, ValueLatticeElement::get(C));\n+      return;\n+    }\n   }\n \n   // Ignore bitcasts, as they may change the number of vector elements.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SCCP/bitcast-vector-refinement.l.ll",
      "commands": [
        "opt -passes=sccp -S < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine <32 x i8> @test(i1 %cond) {\n;\nentry:\n  br label %for.cond2\n\nfor.cond2:                                        ; preds = %for.cond2, %entry\n  %BS_VAR_1.0 = phi <4 x i64> [ <i64 poison, i64 poison, i64 poison, i64 0>, %entry ], [ zeroinitializer, %for.cond2 ]\n  %0 = phi <4 x i64> [ zeroinitializer, %entry ], [ splat (i64 1), %for.cond2 ]\n  br i1 %cond, label %for.cond2, label %if.then\n\nif.then:                                          ; preds = %for.cond2\n  %sub = sub <4 x i64> <i64 poison, i64 poison, i64 poison, i64 0>, %BS_VAR_1.0\n  %and = and <4 x i64> %0, %sub\n  %1 = bitcast <4 x i64> %and to <32 x i8>\n  ret <32 x i8> %1\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SCCP] Assertion `getConstant() == V && \"Marking constant with different value\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/6EPEPEvnc\nTestcase:\n```llvm\ndefine <32 x i8> @backsmith_pure_1(i1 %cond) {\nentry:\n  br label %for.cond2\n\nfor.cond2:                                        ; preds = %for.cond2, %entry\n  %BS_VAR_1.0 = phi <4 x i64> [ <i64 poison, i64 poison, i64 poison, i64 0>, %entry ], [ zeroinitializer, %for.cond2 ]\n  %0 = phi <4 x i64> [ zeroinitializer, %entry ], [ splat (i64 1), %for.cond2 ]\n  br i1 %cond, label %for.cond2, label %if.then\n\nif.then:                                          ; preds = %for.cond2\n  %sub = sub <4 x i64> <i64 poison, i64 poison, i64 poison, i64 0>, %BS_VAR_1.0\n  %and = and <4 x i64> %0, %sub\n  %1 = bitcast <4 x i64> %and to <32 x i8>\n  ret <32 x i8> %1\n}\n```\n\nDump:\n```\nopt: /root/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:319: bool llvm::ValueLatticeElement::markConstant(llvm::Constant*, bool): Assertion `getConstant() == V && \"Marking constant with different value\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S --passes=sccp <source>\n1.\tRunning pass \"function(sccp)\" on module \"<source>\"\n2.\tRunning pass \"sccp\" on function \"backsmith_pure_1\"\n #0 0x00000000059be998 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x59be998)\n #1 0x00000000059bb844 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x0000759af6642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x0000759af66969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x0000759af6642476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x0000759af66287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x0000759af662871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x0000759af6639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x0000000004c46f35 llvm::ValueLatticeElement::markConstant(llvm::Constant*, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c46f35)\n #9 0x0000000004c57414 llvm::SCCPInstVisitor::markConstant(llvm::Value*, llvm::Constant*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c57414)\n#10 0x0000000004c58f4e llvm::SCCPInstVisitor::visitCastInst(llvm::CastInst&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c58f4e)\n#11 0x0000000004c592e3 llvm::SCCPInstVisitor::solve() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c592e3)\n#12 0x000000000482f15a llvm::SCCPPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x482f15a)\n#13 0x0000000002ff434e llvm::detail::PassModel<llvm::Function, llvm::SCCPPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2ff434e)\n#14 0x000000000579be41 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x579be41)\n#15 0x0000000000f0774e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xf0774e)\n#16 0x000000000579a50a llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x579a50a)\n#17 0x0000000000973a7e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x973a7e)\n#18 0x0000000005799ec1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5799ec1)\n#19 0x000000000097ddaa llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97ddaa)\n#20 0x0000000000971c28 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x971c28)\n#21 0x0000759af6629d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#22 0x0000759af6629e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#23 0x00000000009686c5 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9686c5)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "XChy",
    "labels": [
      "crash-on-valid",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "milos1397",
        "body": "can you assign this one to me?\n"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}