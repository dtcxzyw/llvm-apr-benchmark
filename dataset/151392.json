{
  "bug_id": "151392",
  "issue_url": "https://github.com/llvm/llvm-project/issues/151392",
  "bug_type": "crash",
  "base_commit": "c7500a2ec3baae1f0d7de0de94407d4bdb2e5d4d",
  "knowledge_cutoff": "2025-07-30T20:45:12Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "39c30665e99145e07b0170b552f18371a67b2e03",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          2836,
          2847
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "scalarizeInstruction"
      ]
    }
  },
  "patch": "commit 39c30665e99145e07b0170b552f18371a67b2e03\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Sat Aug 2 19:49:59 2025 +0100\n\n    [VPlan] Update type of cloned instruction in scalarizeInstruction.\n    \n    The operands of the replicate recipe may have been narrowed, resulting\n    in a narrower result type. Update the type of the cloned instruction to\n    the correct type.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/151392.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 11b4677ec102..98d11f0bc789 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -2836,12 +2836,12 @@ static void scalarizeInstruction(const Instruction *Instr,\n   Instruction *Cloned = Instr->clone();\n   if (!IsVoidRetTy) {\n     Cloned->setName(Instr->getName() + \".cloned\");\n-#if !defined(NDEBUG)\n-    // Verify that VPlan type inference results agree with the type of the\n-    // generated values.\n-    assert(State.TypeAnalysis.inferScalarType(RepRecipe) == Cloned->getType() &&\n-           \"inferred type and type from generated instructions do not match\");\n-#endif\n+    Type *ResultTy = State.TypeAnalysis.inferScalarType(RepRecipe);\n+    // The operands of the replicate recipe may have been narrowed, resulting in\n+    // a narrower result type. Update the type of the cloned instruction to the\n+    // correct type.\n+    if (ResultTy != Cloned->getType())\n+      Cloned->mutateType(ResultTy);\n   }\n \n   RepRecipe->applyFlags(*Cloned);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/single-scalar-cast-minbw.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -S %s"
      ],
      "tests": [
        {
          "test_name": "single_scalar_cast_stored",
          "test_body": "define void @single_scalar_cast_stored(ptr %src, ptr %dst, i32 %n) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %l = load i16, ptr %src, align 2\n  %cmp = icmp eq i16 %l, 0\n  %l.ext = zext i16 %l to i32\n  %and = and i32 %l.ext, 15\n  %sel = select i1 %cmp, i32 0, i32 %and\n  %sel.trunc = trunc i32 %sel to i16\n  store i16 %sel.trunc, ptr %dst, align 2\n  %iv.next = add nuw i32 %iv, 1\n  %ec = icmp ne i32 %iv.next, %n\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize] Assertion `State.TypeAnalysis.inferScalarType(RepRecipe) == Cloned->getType() && \"inferred type and type from generated instructions do not match\"' failed.",
    "body": "Testcase:\n```llvm ir\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\n@b = external global [0 x i16]\n@n = internal global i16 9\n@u = external global [9 x i64]\n@p = external global [9 x i16]\n\ndefine i64 @c(i8 %k, i16 %n, ptr %p, ptr %u, ptr %w, i64 %indvars.iv133, i8 %sub, i8 %add98.us.us.us) {\nentry:\n  %arrayidx36 = getelementptr i8, ptr %u, i64 64\n  br label %for.cond18.preheader.us.us.us\n\nfor.cond18.preheader.us.us.us:                    ; preds = %cond.false.us.us.us, %entry\n  br label %cond.false.us.us.us\n\ncond.false.us.us.us:                              ; preds = %for.body27.us.us.us, %for.cond18.preheader.us.us.us\n  %ah.0.us.us.us = phi i32 [ %add67.us.us.us, %for.body27.us.us.us ], [ 0, %for.cond18.preheader.us.us.us ]\n  %0 = load i16, ptr %p, align 2\n  %conv22.us.us.us = sext i16 %0 to i32\n  %cmp24.us.us.us = icmp slt i32 %ah.0.us.us.us, %conv22.us.us.us\n  br i1 %cmp24.us.us.us, label %for.body27.us.us.us, label %for.cond18.preheader.us.us.us\n\nfor.body27.us.us.us:                              ; preds = %cond.false.us.us.us\n  %1 = load i16, ptr %w, align 2\n  %tobool.not.us.us.us = icmp eq i16 %1, 0\n  %narrow.us.us.us = select i1 %tobool.not.us.us.us, i16 0, i16 %n\n  %cond35.us.us.us = sext i16 %narrow.us.us.us to i32\n  %2 = load i64, ptr %arrayidx36, align 8\n  %conv37.us.us.us = trunc i64 %2 to i32\n  %cond43.us.us.us = tail call i32 @llvm.smin.i32(i32 %cond35.us.us.us, i32 %conv37.us.us.us)\n  %conv46.us.us.us = trunc i32 %cond43.us.us.us to i16\n  store i16 %conv46.us.us.us, ptr @b, align 2\n  %3 = load i8, ptr %w, align 1\n  %conv54.us.us.us = sext i8 %3 to i16\n  store i16 %conv54.us.us.us, ptr %u, align 2\n  %add67.us.us.us = add i32 %ah.0.us.us.us, 1\n  br label %cond.false.us.us.us\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.smin.i32(i32, i32) #0\n\ndefine i64 @main(ptr %k) #1 {\nentry:\n  store i64 57, ptr getelementptr inbounds nuw (i8, ptr @u, i64 64), align 32\n  %0 = load i16, ptr @n, align 2\n  %1 = call i64 @c(i8 0, i16 %0, ptr @p, ptr @u, ptr %k, i64 0, i8 0, i8 0)\n  ret i64 %1\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { \"target-features\"=\"+v\" }\n```\n\nCommands/backtrace\n```\n$ /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt \"-passes=lto<O3>\" reduced.ll\nWARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\nopt: /scratch/ewlu/daily-upstream-build/llvm/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:2842: void scalarizeInstruction(const llvm::Instruction*, llvm::VPReplicateRecipe*, const llvm::VPLane&, llvm::VPTransformState&): Assertion `State.TypeAnalysis.inferScalarType(RepRecipe) == Cloned->getType() && \"inferred type and type from generated instructions do not match\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.      Program arguments: /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt -passes=lto<O3> reduced.ll\n1.      Running pass \"function<eager-inv>(loop-mssa(licm<allowspeculation>),gvn<>,memcpyopt,dse,move-auto-init,mldst-motion<no-split-footer-bb>,loop(indvars,loop-deletion,loop-unroll-full),loop-distribute,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-unroll<O3>,transform-warning,sroa<preserve-cfg>,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,sccp,instcombine<max-iterations=1;no-verify-fixpoint>,bdce,slp-vectorizer,vector-combine,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop(evl-iv-simplify),jump-threading)\" on module \"reduced.ll\"\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"main\"\n #0 0x0000645af6577e72 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x338ee72)\n #1 0x0000645af6574b6f llvm::sys::RunSignalHandlers() (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x338bb6f)\n #2 0x0000645af6574cbc SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x000079da8fc45330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x000079da8fc9eb2c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\n #5 0x000079da8fc9eb2c __pthread_kill_internal ./nptl/pthread_kill.c:78:10\n #6 0x000079da8fc9eb2c pthread_kill ./nptl/pthread_kill.c:89:10\n #7 0x000079da8fc4527e raise ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x000079da8fc288ff abort ./stdlib/abort.c:81:7\n #9 0x000079da8fc2881b _nl_load_domain ./intl/loadmsgcat.c:1177:9\n#10 0x000079da8fc3b517 (/lib/x86_64-linux-gnu/libc.so.6+0x3b517)\n#11 0x0000645af4394a5d (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11aba5d)\n#12 0x0000645af43986a3 llvm::VPReplicateRecipe::execute(llvm::VPTransformState&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11af6a3)\n#13 0x0000645af433bee1 llvm::VPBasicBlock::executeRecipes(llvm::VPTransformState*, llvm::BasicBlock*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x1152ee1)\n#14 0x0000645af43510d7 llvm::VPBasicBlock::execute(llvm::VPTransformState*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11680d7)\n#15 0x0000645af43582c1 llvm::VPlan::execute(llvm::VPTransformState*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x116f2c1)\n#16 0x0000645af41d802f llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoopVectorizer&, llvm::DominatorTree*, bool) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0xfef02f)\n#17 0x0000645af41e69f7 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0xffd9f7)\n#18 0x0000645af41e96a1 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x10006a1)\n#19 0x0000645af41e9c67 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x1000c67)\n#20 0x0000645af3a81535 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x898535)\n#21 0x0000645af635bb7d llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x3172b7d)\n#22 0x0000645af3a83d15 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x89ad15)\n#23 0x0000645af635bf67 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x3172f67)\n#24 0x0000645af3719fe5 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x530fe5)\n#25 0x0000645af635d10d llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x317410d)\n#26 0x0000645af3726099 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x53d099)\n#27 0x0000645af37181a8 optMain (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x52f1a8)\n#28 0x000079da8fc2a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#29 0x000079da8fc2a28b call_init ./csu/../csu/libc-start.c:128:20\n#30 0x000079da8fc2a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#31 0x0000645af370e0b5 _start (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x5250b5)\nAborted (core dumped)\n```\n\nGodbolt: https://godbolt.org/z/T3cbfY9zG\n\nFound via fuzzer (C program before reduction)",
    "author": "ewlu",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "3b7b95f78e24aca5175b8f864bfea2953a2dd34f"
}