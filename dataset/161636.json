{
  "bug_id": "161636",
  "issue_url": "https://github.com/llvm/llvm-project/issues/161636",
  "bug_type": "miscompilation",
  "base_commit": "92d83134b44161cad50198e663b543b46d25b45a",
  "knowledge_cutoff": "2025-10-02T08:03:44Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "c41611bacb0ca72a283accd7680061421454e152",
    "components": [
      "InstCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        [
          17,
          22
        ],
        [
          42,
          47
        ],
        [
          1451,
          1460
        ],
        [
          1469,
          1480
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        "InstCombinerImpl::foldSelectValueEquivalence"
      ]
    }
  },
  "patch": "commit c41611bacb0ca72a283accd7680061421454e152\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Sun Oct 5 14:02:00 2025 +0800\n\n    [InstCombine] Fix pointer replacement in `foldSelectValueEquivalence` (#161701)\n    \n    Closes https://github.com/llvm/llvm-project/issues/161636.\n    \n    Compile-time impact (+0.06%):\n    https://llvm-compile-time-tracker.com/compare.php?from=c2ef022aa7413ddc9aba48fa6fbe6fbd0cb14e19&to=9a0f0302efc30580136d191e66bac929f08ee25f&stat=instructions%3Au\n    I used to disable this fold for pointers, because I cannot construct a\n    positive test that is covered by `foldSelectValueEquivalence ` but not\n    covered by `simplifySelectWithICmpCond`. But the IR diff shows we still\n    benefit from the fold in InstCombine:\n    + Bail out on pointers:\n    https://github.com/dtcxzyw/llvm-opt-benchmark/pull/2880\n    + This patch: https://github.com/dtcxzyw/llvm-opt-benchmark/pull/2882\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\nindex 3df448ddde99..8f60e506e8a3 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n@@ -17,6 +17,7 @@\n #include \"llvm/Analysis/AssumptionCache.h\"\n #include \"llvm/Analysis/CmpInstAnalysis.h\"\n #include \"llvm/Analysis/InstructionSimplify.h\"\n+#include \"llvm/Analysis/Loads.h\"\n #include \"llvm/Analysis/OverflowInstAnalysis.h\"\n #include \"llvm/Analysis/ValueTracking.h\"\n #include \"llvm/Analysis/VectorUtils.h\"\n@@ -42,6 +43,7 @@\n #include \"llvm/Support/KnownBits.h\"\n #include \"llvm/Transforms/InstCombine/InstCombiner.h\"\n #include <cassert>\n+#include <optional>\n #include <utility>\n \n #define DEBUG_TYPE \"instcombine\"\n@@ -1451,10 +1453,16 @@ Instruction *InstCombinerImpl::foldSelectValueEquivalence(SelectInst &Sel,\n     return nullptr;\n   };\n \n-  if (Instruction *R = ReplaceOldOpWithNewOp(CmpLHS, CmpRHS))\n-    return R;\n-  if (Instruction *R = ReplaceOldOpWithNewOp(CmpRHS, CmpLHS))\n-    return R;\n+  bool CanReplaceCmpLHSWithRHS = canReplacePointersIfEqual(CmpLHS, CmpRHS, DL);\n+  if (CanReplaceCmpLHSWithRHS) {\n+    if (Instruction *R = ReplaceOldOpWithNewOp(CmpLHS, CmpRHS))\n+      return R;\n+  }\n+  bool CanReplaceCmpRHSWithLHS = canReplacePointersIfEqual(CmpRHS, CmpLHS, DL);\n+  if (CanReplaceCmpRHSWithLHS) {\n+    if (Instruction *R = ReplaceOldOpWithNewOp(CmpRHS, CmpLHS))\n+      return R;\n+  }\n \n   auto *FalseInst = dyn_cast<Instruction>(FalseVal);\n   if (!FalseInst)\n@@ -1469,12 +1477,14 @@ Instruction *InstCombinerImpl::foldSelectValueEquivalence(SelectInst &Sel,\n   // Example:\n   // (X == 42) ? 43 : (X + 1) --> (X == 42) ? (X + 1) : (X + 1) --> X + 1\n   SmallVector<Instruction *> DropFlags;\n-  if (simplifyWithOpReplaced(FalseVal, CmpLHS, CmpRHS, SQ,\n-                             /* AllowRefinement */ false,\n-                             &DropFlags) == TrueVal ||\n-      simplifyWithOpReplaced(FalseVal, CmpRHS, CmpLHS, SQ,\n-                             /* AllowRefinement */ false,\n-                             &DropFlags) == TrueVal) {\n+  if ((CanReplaceCmpLHSWithRHS &&\n+       simplifyWithOpReplaced(FalseVal, CmpLHS, CmpRHS, SQ,\n+                              /* AllowRefinement */ false,\n+                              &DropFlags) == TrueVal) ||\n+      (CanReplaceCmpRHSWithLHS &&\n+       simplifyWithOpReplaced(FalseVal, CmpRHS, CmpLHS, SQ,\n+                              /* AllowRefinement */ false,\n+                              &DropFlags) == TrueVal)) {\n     for (Instruction *I : DropFlags) {\n       I->dropPoisonGeneratingAnnotations();\n       Worklist.add(I);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/select-gep.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "ptr_eq_replace_freeze1",
          "test_body": "define ptr @ptr_eq_replace_freeze1(ptr %p, ptr %q) {\n  %p.fr = freeze ptr %p\n  %q.fr = freeze ptr %q\n  %cmp = icmp eq ptr %p.fr, %q.fr\n  %select = select i1 %cmp, ptr %p.fr, ptr %q.fr\n  ret ptr %select\n}\n"
        },
        {
          "test_name": "ptr_eq_replace_freeze2",
          "test_body": "define ptr @ptr_eq_replace_freeze2(ptr %p, ptr %q) {\n  %gep1 = getelementptr i32, ptr %p, i64 4\n  %gep2 = getelementptr i32, ptr %q, i64 4\n  %cmp = icmp eq ptr %p, %q\n  %cmp.fr = freeze i1 %cmp\n  %select = select i1 %cmp.fr, ptr %gep1, ptr %gep2\n  ret ptr %select\n}\n"
        },
        {
          "test_name": "test7",
          "test_body": "define <2 x ptr> @test7(<2 x ptr> %p1, i64 %idx, <2 x i1> %cc) {\n  %gep = getelementptr i64, <2 x ptr> %p1, i64 %idx\n  %select = select <2 x i1> %cc, <2 x ptr> %p1, <2 x ptr> %gep\n  ret <2 x ptr> %select\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] Pointer equality propagated without regard to provenance",
    "body": "It is a variant of https://github.com/llvm/llvm-project/issues/115574.\nReproducer: https://alive2.llvm.org/ce/z/FLg923\n```\ndefine ptr @src1(ptr %p, ptr %q) {\n#0:\n  %cmp = icmp eq ptr %p, %q\n  %#1 = freeze i1 %cmp\n  %select = select i1 %#1, ptr %p, ptr %q\n  ret ptr %select\n}\n=>\ndefine ptr @src1(ptr %p, ptr %q) {\n#0:\n  %q.fr = freeze ptr %q\n  ret ptr %q.fr\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nExample:\nptr %p = pointer(non-local, block_id=1, offset=0) / Address=#x1\nptr %q = pointer(non-local, block_id=0, offset=1) / Address=#x1\n\nSource:\ni1 %cmp = #x1 (1)\ni1 %#1 = #x1 (1)\nptr %select = pointer(non-local, block_id=1, offset=0) / Address=#x1\n\nSOURCE MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\tsize: 0\talign: 1\talloc type: 0\talive: false\taddress: #x0\nBlock 1 >\tsize: 13\talign: 1\talloc type: 0\talive: true\taddress: #x1\nBlock 2 >\tsize: 0\talign: 1\talloc type: 0\talive: true\taddress: #xf\n\nTarget:\nptr %q.fr = pointer(non-local, block_id=0, offset=1) / Address=#x1\n\nTARGET MEMORY STATE\n===================\nNON-LOCAL BLOCKS:\nBlock 0 >\tsize: 0\talign: 1\talloc type: 0\talive: false\taddress: #x0\nBlock 1 >\tsize: 13\talign: 1\talloc type: 0\talive: true\taddress: #x1\nBlock 2 >\tsize: 0\talign: 1\talloc type: 0\talive: true\taddress: #xf\nSource value: pointer(non-local, block_id=1, offset=0) / Address=#x1\nTarget value: pointer(non-local, block_id=0, offset=1) / Address=#x1\n```",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:instcombine",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "nikic",
        "body": "I expect it's due to this special case fold: https://github.com/llvm/llvm-project/blob/99ce20624629921771de2674946bbb2f9707ca5a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp#L2937-L2961\n\nNote that this fold has become useless due to https://github.com/llvm/llvm-project/pull/154336 and should be deleted entirely, I just forgot about it."
      },
      {
        "author": "nikic",
        "body": "> I expect it's due to this special case fold: \n\nOkay, having tried that, it's not this fold. I'll still put up a PR to delete it..."
      },
      {
        "author": "dtcxzyw",
        "body": "I am preparing for a fix: https://github.com/llvm/llvm-project/compare/main...dtcxzyw:llvm-project:perf/fix-161636\n"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}