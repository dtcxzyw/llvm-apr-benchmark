{
  "bug_id": "105713",
  "issue_url": "https://github.com/llvm/llvm-project/issues/105713",
  "bug_type": "crash",
  "base_commit": "a2d8743cc86f96f6b1cbd85798328bd3fb2bf4de",
  "knowledge_cutoff": "2024-08-22T18:25:29Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "cb4efe1d078144a72306732a56afea3885650e8d",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          7237,
          7242
        ],
        [
          7292,
          7298
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationPlanner::computeBestVF",
        "canTruncateToMinimalBitwidth",
        "LoopVectorizationCostModel",
        "LoopVectorizationPlanner::cost"
      ]
    }
  },
  "patch": "commit cb4efe1d078144a72306732a56afea3885650e8d\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Thu Aug 22 21:38:06 2024 +0100\n\n    [VPlan] Don't trigger VF assertion if VPlan has extra simplifications.\n    \n    There are cases where VPlans contain some simplifications that are very\n    hard to accurately account for up-front in the legacy cost model. Those\n    cases are caused by un-simplified inputs, which trigger the assert\n    ensuring both the legacy and VPlan-based cost model agree on the VF.\n    \n    To avoid false positives due to missed simplifications in general, only\n    trigger the assert if the chosen VPlan doesn't contain any additional\n    simplifications.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/104714.\n    Fixes https://github.com/llvm/llvm-project/issues/105713.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 8e9324ba718b..32e8f3312578 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -7237,6 +7237,56 @@ InstructionCost LoopVectorizationPlanner::cost(VPlan &Plan,\n   return Cost;\n }\n \n+/// Return true if the original loop \\ TheLoop contains any instructions that do\n+/// not have corresponding recipes in \\p Plan and are not marked to be ignored\n+/// in \\p CostCtx. This means the VPlan contains simplification that the legacy\n+/// cost-model did not account for.\n+static bool\n+planContainsAdditionalSimplifications(VPlan &Plan, ElementCount VF,\n+                                      VPCostContext &CostCtx, Loop *TheLoop,\n+                                      LoopVectorizationCostModel &CM) {\n+  // First collect all instructions for the recipes in Plan.\n+  auto GetInstructionForCost = [](const VPRecipeBase *R) -> Instruction q {\n+    if (auto *S = dyn_cast<VPSingleDefRecipe>(R))\n+      return dyn_cast_or_null<Instruction>(S->getUnderlyingValue());\n+    if (auto *WidenMem = dyn_cast<VPWidenMemoryRecipe>(R))\n+      return &WidenMem->getIngredient();\n+    return nullptr;\n+  };\n+\n+  DenseSet<Instruction *> SeenInstrs;\n+  auto Iter = vp_depth_first_deep(Plan.getEntry());\n+  for (VPBasicBlock *VPBB : VPBlockUtils::blocksOnly<VPBasicBlock>(Iter)) {\n+    for (VPRecipeBase &R : *VPBB) {\n+      if (auto *IR = dyn_cast<VPInterleaveRecipe>(&R)) {\n+        auto *IG = IR->getInterleaveGroup();\n+        unsigned NumMembers = IG->getNumMembers();\n+        for (unsigned I = 0; I != NumMembers; ++I) {\n+          if (Instruction *M = IG->getMember(I))\n+            SeenInstrs.insert(M);\n+        }\n+        continue;\n+      }\n+      if (Instruction *UI = GetInstructionForCost(&R))\n+        SeenInstrs.insert(UI);\n+    }\n+  }\n+\n+  // Return true if the loop contains any instructions that are not also part of\n+  // the VPlan or are skipped for VPlan-based cost computations. This indicates\n+  // that the VPlan contains extra simplifications.\n+  return any_of(\n+      TheLoop->blocks(), [&SeenInstrs, VF, &CostCtx, &CM](BasicBlock *BB) {\n+        return any_of(*BB, [&SeenInstrs, VF, &CostCtx, &CM](Instruction &I) {\n+          if (isa<PHINode>(&I))\n+            return false;\n+          return !SeenInstrs.contains(&I) &&\n+                 !CostCtx.skipCostComputation(&I, true) &&\n+                 !CM.canTruncateToMinimalBitwidth(&I, VF);\n+        });\n+      });\n+}\n+\n VectorizationFactor LoopVectorizationPlanner::computeBestVF() {\n   if (VPlans.empty())\n     return VectorizationFactor::Disabled();\n@@ -7292,7 +7342,20 @@ VectorizationFactor LoopVectorizationPlanner::computeBestVF() {\n   // cost-model and will be retired once the VPlan-based cost-model is\n   // stabilized.\n   VectorizationFactor LegacyVF = selectVectorizationFactor();\n-  assert(BestFactor.Width == LegacyVF.Width &&\n+  VPlan &BestPlan = getPlanFor(BestFactor.Width);\n+\n+  // Pre-compute the cost and use it to check if BestPlan contains any\n+  // simplifications not accounted for in the legacy cost model. If that's the\n+  // case, don't trigger the assertion, as the extra simplifications may cause a\n+  // different VF to be picked by the VPlan-based cost model.\n+  LLVMContext &LLVMCtx = OrigLoop->getHeader()->getContext();\n+  VPCostContext CostCtx(CM.TTI, *CM.TLI, Legal->getWidestInductionType(),\n+                        LLVMCtx, CM);\n+  precomputeCosts(BestPlan, BestFactor.Width, CostCtx);\n+  assert((BestFactor.Width == LegacyVF.Width ||\n+          planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width),\n+                                                BestFactor.Width, CostCtx,\n+                                                OrigLoop, CM)) &&\n          \" VPlan cost model and legacy cost model disagreed\");\n   assert((BestFactor.Width.isScalar() || BestFactor.ScalarCost > 0) &&\n          \"when vectorizing, the scalar cost must be computed.\");\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/blocks-with-dead-instructions.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "multiple_blocks_with_dead_inst_multiple_successors_5",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_inst_multiple_successors_5(ptr %src) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  br label %then.1\n\nthen.1:                                           ; preds = %then\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  br label %else.2\n\nelse.2:                                           ; preds = %else\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else.2, %then.1\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "empty_block_with_phi_2",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @empty_block_with_phi_2(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i32 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i32 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %loop.latch, label %else\n\nelse:                                             ; preds = %loop.header\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %loop.header\n  %p = phi i16 [ %l, %loop.header ], [ 99, %else ]\n  store i16 %p, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 1\n  %0 = icmp eq i64 %iv.next, %N\n  br i1 %0, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "dead_load_in_block",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @dead_load_in_block(ptr %dst, ptr %src, i8 %N, i64 %x) #0 {\nentry:\n  %N.ext = zext i8 %N to i64\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %l.0 = load i32, ptr %src, align 4\n  %c.0 = icmp eq i32 %l.0, 0\n  br i1 %c.0, label %loop.latch, label %then\n\nthen:                                             ; preds = %loop.header\n  %gep.src.x = getelementptr i32, ptr %src, i64 %x\n  %l.dead = load i32, ptr %gep.src.x, align 4\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %gep.dst = getelementptr i32, ptr %dst, i64 %iv\n  store i32 0, ptr %gep.dst, align 4\n  %iv.next = add i64 %iv, 3\n  %cmp = icmp ult i64 %iv, %N.ext\n  br i1 %cmp, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "multiple_blocks_with_dead_insts_4",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_insts_4(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  br label %then.1\n\nthen.1:                                           ; preds = %then\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %then.1\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "empty_block_with_phi_1",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @empty_block_with_phi_1(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i32 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i32 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %p = phi i16 [ %l, %loop.header ], [ 99, %then ]\n  store i16 %p, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 1\n  %0 = icmp eq i64 %iv.next, %N\n  br i1 %0, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "multiple_blocks_with_dead_insts_3",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_insts_3(ptr %src) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 0, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %then\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "block_with_dead_inst_1",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @block_with_dead_inst_1(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  %dead.gep = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %0 = icmp eq i64 %iv.next, %N\n  br i1 %0, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "multiple_blocks_with_dead_inst_multiple_successors_6",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_inst_multiple_successors_6(ptr %src, i1 %ic, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  br i1 %ic, label %then.1, label %else\n\nthen.1:                                           ; preds = %then\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %then, %loop.header\n  br label %else.2\n\nelse.2:                                           ; preds = %else\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else.2, %then.1\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "block_with_dead_inst_2",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @block_with_dead_inst_2(ptr %src) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 0, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %loop.latch, label %else\n\nelse:                                             ; preds = %loop.header\n  %dead.gep = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %loop.header\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion `BestFactor.Width == LegacyVF.Width && \" VPlan cost model and legacy cost model disagreed\"' failed.",
    "body": "To reproduce run the test below with -passes=loop-vectorize\r\n```\r\n; ModuleID = './reduced.ll'\r\nsource_filename = \"/home/ec2-user/fuzzer/builds/zvm-dev-4531/lib/server/boilerplate.ll\"\r\ntarget datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32-ni:1-p2:32:8:8:32-ni:2\"\r\ntarget triple = \"aarch64-none-linux-gnu\"\r\n\r\n; Function Attrs: uwtable\r\ndefine noundef i32 @wombat() #0 gc \"statepoint-example\" {\r\nbb:\r\n  %load = load i32, ptr addrspace(1) null, align 4, !range !60\r\n  %load1 = load i32, ptr addrspace(1) null, align 4, !range !60\r\n  br label %bb10\r\n\r\nbb2:                                              ; preds = %bb10\r\n  %phi = phi i8 [ %add19, %bb10 ]\r\n  %phi3 = phi i32 [ %add20, %bb10 ]\r\n  ret i32 0\r\n\r\nbb4:                                              ; preds = %bb10\r\n  %phi5 = phi i32 [ %add20, %bb10 ]\r\n  %add = add nuw nsw i64 %phi12, 3\r\n  %trunc = trunc i64 %add to i32\r\n  %icmp = icmp ugt i32 %load, %trunc\r\n  %add6 = add nuw nsw i64 %phi11, 3\r\n  %trunc7 = trunc i64 %add6 to i32\r\n  %icmp8 = icmp ugt i32 %load1, %trunc7\r\n  %and = and i1 %icmp, %icmp8\r\n  br i1 %and, label %bb10, label %bb9\r\n\r\nbb9:                                              ; preds = %bb4\r\n  ret i32 0\r\n\r\nbb10:                                             ; preds = %bb4, %bb\r\n  %phi11 = phi i64 [ 0, %bb ], [ %add6, %bb4 ]\r\n  %phi12 = phi i64 [ 0, %bb ], [ %add, %bb4 ]\r\n  %phi13 = phi i32 [ 0, %bb ], [ %add15, %bb4 ]\r\n  %phi14 = phi i32 [ 0, %bb ], [ %phi5, %bb4 ]\r\n  %add15 = add i32 %phi13, 1\r\n  %getelementptr = getelementptr inbounds double, ptr addrspace(1) null, i64 %phi12\r\n  store double 0.000000e+00, ptr addrspace(1) %getelementptr, align 8, !tbaa !61\r\n  %getelementptr16 = getelementptr inbounds i64, ptr addrspace(1) null, i64 %phi11\r\n  %load17 = load i64, ptr addrspace(1) %getelementptr16, align 8, !tbaa !64\r\n  %add18 = add i64 %load17, 1\r\n  store i64 %add18, ptr addrspace(1) %getelementptr16, align 8, !tbaa !64\r\n  %add19 = add i8 0, 0\r\n  %add20 = add nsw i32 %phi14, 3\r\n  %icmp21 = icmp slt i32 %phi14, 115\r\n  br i1 %icmp21, label %bb4, label %bb2\r\n}\r\n\r\ndeclare i32 @llvm.experimental.deoptimize.i32(...) #1\r\n\r\n!60 = !{i32 0, i32 2147483646}\r\n!61 = !{!62, !62, i64 0}\r\n!62 = !{!\"double.array\", !63}\r\n!63 = !{!\"dolphin-tbaa-access-type\"}\r\n!64 = !{!65, !65, i64 0}\r\n!65 = !{!\"long.array\", !63}\r\n```\r\nReproducer: https://godbolt.org/z/Yzs8McbnK\r\n\r\n```\r\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7288: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `BestFactor.Width == LegacyVF.Width && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=loop-vectorize <source>\r\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"<source>\"\r\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"wombat\"\r\n #0 0x0000000004f90548 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4f90548)\r\n #1 0x0000000004f8dcbc SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007b8528242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x00007b85282969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #4 0x00007b8528242476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #5 0x00007b85282287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #6 0x00007b852822871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #7 0x00007b8528239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #8 0x0000000003fdf468 llvm::LoopVectorizationPlanner::computeBestVF() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3fdf468)\r\n #9 0x0000000003ffa76a llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3ffa76a)\r\n#10 0x0000000003ffd429 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3ffd429)\r\n#11 0x0000000003ffdab3 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3ffdab3)\r\n#12 0x0000000002ec3f4e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2ec3f4e)\r\n#13 0x0000000004d8d638 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4d8d638)\r\n#14 0x0000000000def2ee llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xdef2ee)\r\n#15 0x0000000004d8c03e llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4d8c03e)\r\n#16 0x0000000000deebde llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xdeebde)\r\n#17 0x0000000004d8a1d0 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4d8a1d0)\r\n#18 0x00000000008e6d92 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8e6d92)\r\n#19 0x00000000008d9c6c optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8d9c6c)\r\n#20 0x00007b8528229d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#21 0x00007b8528229e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#22 0x00000000008d16fe _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8d16fe)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139\r\n```",
    "author": "TatyanaDoubts",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "Duplicate of #104714 / #100591 \r\n"
      }
    ]
  }
}
