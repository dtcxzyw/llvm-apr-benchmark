{
  "bug_id": "129057",
  "issue_url": "https://github.com/llvm/llvm-project/issues/129057",
  "bug_type": "miscompilation",
  "base_commit": "6a5bb4c2f1e7a48d5c8ffd7b5ab4a7addc3e661f",
  "knowledge_cutoff": "2025-02-27T13:44:09Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "69effe054c136defda8766688ac0de4626a0eb05",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          18071,
          18076
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::collectValuesToDemote"
      ]
    }
  },
  "patch": "commit 69effe054c136defda8766688ac0de4626a0eb05\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Thu Feb 27 08:33:07 2025 -0800\n\n    [SLP]Check for potential safety of the truncation for vectorized scalars with multi uses\n    \n    If the vectorized scalars has multiple uses, need to check if it is safe\n    to truncate the vectorized value, before actually trying doing it.\n    Otherwise, the compiler may loose some important bits, which may lead to\n    a miscompilation.\n    \n    Fixes #129057\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex e8c91ebd508c..2d343ca31f07 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -18071,6 +18071,12 @@ bool BoUpSLP::collectValuesToDemote(\n           (void)for_each(E.Scalars, std::bind(IsPotentiallyTruncated, _1,\n                                               std::ref(BitWidth)));\n         } else {\n+          // Several vectorized uses? Check if we can truncate it, otherwise -\n+          // exit.\n+          if (any_of(E.Scalars, [&](Value *V) {\n+                return !V->hasOneUse() && !IsPotentiallyTruncated(V, BitWidth);\n+              }))\n+            return false;\n           bool NeedToExit = false;\n           if (Checker && !AttemptCheckBitwidth(Checker, NeedToExit))\n             return false;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/ext-used-scalar-different-bitwidth.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu -slp-threshold=-100 < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@f = global i32 zeroinitializer\n@.str = constant [4 x i8] c\"%d\\0A\\00\"\n\ndefine i32 @main() {\nentry:\n  store i32 152, ptr @f, align 4\n  %agg.tmp.sroa.0.0.copyload.i = load i32, ptr @f, align 4\n  %add.i.i = shl i32 %agg.tmp.sroa.0.0.copyload.i, 24\n  %sext.i = add i32 %add.i.i, 83886080\n  %conv2.i = ashr i32 %sext.i, 24\n  %and.i = and i32 %conv2.i, 66440127\n  %cmp3.i.i = icmp ugt i32 %and.i, 33554431\n  %shl.i.i = select i1 %cmp3.i.i, i32 0, i32 6\n  %cond.i.i = shl i32 %and.i, %shl.i.i\n  %0 = trunc i32 %cond.i.i to i8\n  %sext.1.i = add i32 0, 83886080\n  %conv2.1.i = ashr i32 %sext.1.i, 24\n  %and.1.i = and i32 %conv2.1.i, 1\n  %cmp3.i.1.i = icmp ugt i32 0, 0\n  %shl.i.1.i = select i1 %cmp3.i.1.i, i32 0, i32 0\n  %cond.i.1.i = shl i32 %and.1.i, %shl.i.1.i\n  %1 = trunc i32 %cond.i.1.i to i8\n  %conv17.1.i = and i8 %0, %1\n  %sext.2.i = add i32 0, 83886080\n  %conv2.2.i = ashr i32 %sext.2.i, 24\n  %and.2.i = and i32 %conv2.2.i, 1\n  %shl.i.2.i = select i1 false, i32 0, i32 0\n  %cond.i.2.i = shl i32 %and.2.i, %shl.i.2.i\n  %2 = trunc i32 %cond.i.2.i to i8\n  %conv17.2.i = and i8 %conv17.1.i, %2\n  %sext.3.i = add i32 0, 83886080\n  %conv2.3.i = ashr i32 %sext.3.i, 24\n  %and.3.i = and i32 %conv2.3.i, 1\n  %shl.i.3.i = select i1 false, i32 0, i32 0\n  %cond.i.3.i = shl i32 %and.3.i, %shl.i.3.i\n  %3 = trunc i32 %cond.i.3.i to i8\n  %conv17.3.i = and i8 %conv17.2.i, %3\n  %sext.4.i = add i32 0, 83886080\n  %conv2.4.i = ashr i32 %sext.4.i, 24\n  %and.4.i = and i32 %conv2.4.i, 1\n  %shl.i.4.i = select i1 false, i32 0, i32 0\n  %cond.i.4.i = shl i32 %and.4.i, %shl.i.4.i\n  %4 = trunc i32 %cond.i.4.i to i8\n  %conv17.4.i = and i8 %conv17.3.i, %4\n  %sext.5.i = add i32 0, 83886080\n  %conv2.5.i = ashr i32 %sext.5.i, 24\n  %and.5.i = and i32 %conv2.5.i, 1\n  %shl.i.5.i = select i1 false, i32 0, i32 0\n  %cond.i.5.i = shl i32 %and.5.i, %shl.i.5.i\n  %5 = trunc i32 %cond.i.5.i to i8\n  %conv17.5.i = and i8 %conv17.4.i, %5\n  %sext.6.i = add i32 0, 83886080\n  %conv2.6.i = ashr i32 %sext.6.i, 24\n  %and.6.i = and i32 %conv2.6.i, 1\n  %shl.i.6.i = select i1 false, i32 0, i32 0\n  %cond.i.6.i = shl i32 %and.6.i, %shl.i.6.i\n  %6 = trunc i32 %cond.i.6.i to i8\n  %conv17.6.i = and i8 %conv17.5.i, %6\n  %sext.7.i = add i32 0, 83886080\n  %conv2.7.i = ashr i32 %sext.7.i, 24\n  %and.7.i = and i32 %conv2.7.i, 1\n  %shl.i.7.i = select i1 false, i32 0, i32 0\n  %cond.i.7.i = shl i32 %and.7.i, %shl.i.7.i\n  %7 = trunc i32 %cond.i.7.i to i8\n  %conv17.7.i = and i8 %conv17.6.i, %7\n  %conv = zext i8 %conv17.7.i to i32\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n  ret i32 0\n}\n\ndeclare i32 @printf(ptr, ...)",
          "lli_expected_out": "1\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Miscompilation at O3",
    "body": "Reproducer:\n```\n; bin/opt -passes=slp-vectorizer reduced.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@f = global i32 zeroinitializer\n@.str = constant [4 x i8] c\"%d\\0A\\00\"\n\ndefine i32 @main() {\nentry:\n  store i32 152, ptr @f, align 4\n  %agg.tmp.sroa.0.0.copyload.i = load i32, ptr @f, align 4\n  %add.i.i = shl i32 %agg.tmp.sroa.0.0.copyload.i, 24\n  %sext.i = add i32 %add.i.i, 83886080\n  %conv2.i = ashr i32 %sext.i, 24\n  %and.i = and i32 %conv2.i, 66440127\n  %cmp3.i.i = icmp ugt i32 %and.i, 33554431\n  %shl.i.i = select i1 %cmp3.i.i, i32 0, i32 6\n  %cond.i.i = shl i32 %and.i, %shl.i.i\n  %0 = trunc i32 %cond.i.i to i8\n  %sext.1.i = add i32 0, 83886080\n  %conv2.1.i = ashr i32 %sext.1.i, 24\n  %and.1.i = and i32 %conv2.1.i, 1\n  %cmp3.i.1.i = icmp ugt i32 0, 0\n  %shl.i.1.i = select i1 %cmp3.i.1.i, i32 0, i32 0\n  %cond.i.1.i = shl i32 %and.1.i, %shl.i.1.i\n  %1 = trunc i32 %cond.i.1.i to i8\n  %conv17.1.i = and i8 %0, %1\n  %sext.2.i = add i32 0, 83886080\n  %conv2.2.i = ashr i32 %sext.2.i, 24\n  %and.2.i = and i32 %conv2.2.i, 1\n  %shl.i.2.i = select i1 false, i32 0, i32 0\n  %cond.i.2.i = shl i32 %and.2.i, %shl.i.2.i\n  %2 = trunc i32 %cond.i.2.i to i8\n  %conv17.2.i = and i8 %conv17.1.i, %2\n  %sext.3.i = add i32 0, 83886080\n  %conv2.3.i = ashr i32 %sext.3.i, 24\n  %and.3.i = and i32 %conv2.3.i, 1\n  %shl.i.3.i = select i1 false, i32 0, i32 0\n  %cond.i.3.i = shl i32 %and.3.i, %shl.i.3.i\n  %3 = trunc i32 %cond.i.3.i to i8\n  %conv17.3.i = and i8 %conv17.2.i, %3\n  %sext.4.i = add i32 0, 83886080\n  %conv2.4.i = ashr i32 %sext.4.i, 24\n  %and.4.i = and i32 %conv2.4.i, 1\n  %shl.i.4.i = select i1 false, i32 0, i32 0\n  %cond.i.4.i = shl i32 %and.4.i, %shl.i.4.i\n  %4 = trunc i32 %cond.i.4.i to i8\n  %conv17.4.i = and i8 %conv17.3.i, %4\n  %sext.5.i = add i32 0, 83886080\n  %conv2.5.i = ashr i32 %sext.5.i, 24\n  %and.5.i = and i32 %conv2.5.i, 1\n  %shl.i.5.i = select i1 false, i32 0, i32 0\n  %cond.i.5.i = shl i32 %and.5.i, %shl.i.5.i\n  %5 = trunc i32 %cond.i.5.i to i8\n  %conv17.5.i = and i8 %conv17.4.i, %5\n  %sext.6.i = add i32 0, 83886080\n  %conv2.6.i = ashr i32 %sext.6.i, 24\n  %and.6.i = and i32 %conv2.6.i, 1\n  %shl.i.6.i = select i1 false, i32 0, i32 0\n  %cond.i.6.i = shl i32 %and.6.i, %shl.i.6.i\n  %6 = trunc i32 %cond.i.6.i to i8\n  %conv17.6.i = and i8 %conv17.5.i, %6\n  %sext.7.i = add i32 0, 83886080\n  %conv2.7.i = ashr i32 %sext.7.i, 24\n  %and.7.i = and i32 %conv2.7.i, 1\n  %shl.i.7.i = select i1 false, i32 0, i32 0\n  %cond.i.7.i = shl i32 %and.7.i, %shl.i.7.i\n  %7 = trunc i32 %cond.i.7.i to i8\n  %conv17.7.i = and i8 %conv17.6.i, %7\n  %conv = zext i8 %conv17.7.i to i32\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n  ret i32 0\n}\n\ndeclare i32 @printf(ptr, ...)\n```\n```\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@f = global i32 0\n@.str = constant [4 x i8] c\"%d\\0A\\00\"\n\ndefine i32 @main() {\nentry:\n  store i32 152, ptr @f, align 4\n  %agg.tmp.sroa.0.0.copyload.i = load i32, ptr @f, align 4\n  %add.i.i = shl i32 %agg.tmp.sroa.0.0.copyload.i, 24\n  %0 = insertelement <8 x i32> <i32 poison, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080>, i32 %add.i.i, i32 0\n  %1 = add <8 x i32> <i32 83886080, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0>, %0\n  %2 = ashr <8 x i32> %1, splat (i32 24)\n  %3 = trunc <8 x i32> %2 to <8 x i8>\n  %4 = and <8 x i8> %3, <i8 -65, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1>\n  %5 = zext <8 x i8> %4 to <8 x i32>\n  %6 = shufflevector <8 x i32> %5, <8 x i32> poison, <2 x i32> <i32 0, i32 poison>\n  %7 = shufflevector <2 x i32> %6, <2 x i32> <i32 poison, i32 0>, <2 x i32> <i32 0, i32 3>\n  %8 = icmp ugt <2 x i32> %7, <i32 33554431, i32 0>\n  %9 = call <8 x i1> @llvm.vector.insert.v8i1.v2i1(<8 x i1> <i1 poison, i1 poison, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <2 x i1> %8, i64 0)\n  %10 = select <8 x i1> %9, <8 x i8> zeroinitializer, <8 x i8> <i8 6, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>\n  %11 = shl <8 x i8> %4, %10\n  %12 = call i8 @llvm.vector.reduce.and.v8i8(<8 x i8> %11)\n  %conv = zext i8 %12 to i32\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n  ret i32 0\n}\n\ndeclare i32 @printf(ptr, ...)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <8 x i1> @llvm.vector.insert.v8i1.v2i1(<8 x i1>, <2 x i1>, i64 immarg) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i8 @llvm.vector.reduce.and.v8i8(<8 x i8>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n```\nllubi output:\nBefore SLP:\n```\nEntering function main\n  store i32 152, ptr @f, align 4\n  %agg.tmp.sroa.0.0.copyload.i = load i32, ptr @f, align 4 -> i32 152\n  %add.i.i = shl i32 %agg.tmp.sroa.0.0.copyload.i, 24 -> i32 -1744830464\n  %sext.i = add i32 %add.i.i, 83886080 -> i32 -1660944384\n  %conv2.i = ashr i32 %sext.i, 24 -> i32 -99\n  %and.i = and i32 %conv2.i, 66440127 -> i32 66440093\n  %cmp3.i.i = icmp ugt i32 %and.i, 33554431 -> T\n  %shl.i.i = select i1 %cmp3.i.i, i32 0, i32 6 -> i32 0\n  %cond.i.i = shl i32 %and.i, %shl.i.i -> i32 66440093\n  %0 = trunc i32 %cond.i.i to i8 -> i8 -99\n  %sext.1.i = add i32 0, 83886080 -> i32 83886080\n  %conv2.1.i = ashr i32 %sext.1.i, 24 -> i32 5\n  %and.1.i = and i32 %conv2.1.i, 1 -> i32 1\n  %cmp3.i.1.i = icmp ugt i32 0, 0 -> F\n  %shl.i.1.i = select i1 %cmp3.i.1.i, i32 0, i32 0 -> i32 0\n  %cond.i.1.i = shl i32 %and.1.i, %shl.i.1.i -> i32 1\n  %1 = trunc i32 %cond.i.1.i to i8 -> i8 1\n  %conv17.1.i = and i8 %0, %1 -> i8 1\n  %sext.2.i = add i32 0, 83886080 -> i32 83886080\n  %conv2.2.i = ashr i32 %sext.2.i, 24 -> i32 5\n  %and.2.i = and i32 %conv2.2.i, 1 -> i32 1\n  %shl.i.2.i = select i1 false, i32 0, i32 0 -> i32 0\n  %cond.i.2.i = shl i32 %and.2.i, %shl.i.2.i -> i32 1\n  %2 = trunc i32 %cond.i.2.i to i8 -> i8 1\n  %conv17.2.i = and i8 %conv17.1.i, %2 -> i8 1\n  %sext.3.i = add i32 0, 83886080 -> i32 83886080\n  %conv2.3.i = ashr i32 %sext.3.i, 24 -> i32 5\n  %and.3.i = and i32 %conv2.3.i, 1 -> i32 1\n  %shl.i.3.i = select i1 false, i32 0, i32 0 -> i32 0\n  %cond.i.3.i = shl i32 %and.3.i, %shl.i.3.i -> i32 1\n  %3 = trunc i32 %cond.i.3.i to i8 -> i8 1\n  %conv17.3.i = and i8 %conv17.2.i, %3 -> i8 1\n  %sext.4.i = add i32 0, 83886080 -> i32 83886080\n  %conv2.4.i = ashr i32 %sext.4.i, 24 -> i32 5\n  %and.4.i = and i32 %conv2.4.i, 1 -> i32 1\n  %shl.i.4.i = select i1 false, i32 0, i32 0 -> i32 0\n  %cond.i.4.i = shl i32 %and.4.i, %shl.i.4.i -> i32 1\n  %4 = trunc i32 %cond.i.4.i to i8 -> i8 1\n  %conv17.4.i = and i8 %conv17.3.i, %4 -> i8 1\n  %sext.5.i = add i32 0, 83886080 -> i32 83886080\n  %conv2.5.i = ashr i32 %sext.5.i, 24 -> i32 5\n  %and.5.i = and i32 %conv2.5.i, 1 -> i32 1\n  %shl.i.5.i = select i1 false, i32 0, i32 0 -> i32 0\n  %cond.i.5.i = shl i32 %and.5.i, %shl.i.5.i -> i32 1\n  %5 = trunc i32 %cond.i.5.i to i8 -> i8 1\n  %conv17.5.i = and i8 %conv17.4.i, %5 -> i8 1\n  %sext.6.i = add i32 0, 83886080 -> i32 83886080\n  %conv2.6.i = ashr i32 %sext.6.i, 24 -> i32 5\n  %and.6.i = and i32 %conv2.6.i, 1 -> i32 1\n  %shl.i.6.i = select i1 false, i32 0, i32 0 -> i32 0\n  %cond.i.6.i = shl i32 %and.6.i, %shl.i.6.i -> i32 1\n  %6 = trunc i32 %cond.i.6.i to i8 -> i8 1\n  %conv17.6.i = and i8 %conv17.5.i, %6 -> i8 1\n  %sext.7.i = add i32 0, 83886080 -> i32 83886080\n  %conv2.7.i = ashr i32 %sext.7.i, 24 -> i32 5\n  %and.7.i = and i32 %conv2.7.i, 1 -> i32 1\n  %shl.i.7.i = select i1 false, i32 0, i32 0 -> i32 0\n  %cond.i.7.i = shl i32 %and.7.i, %shl.i.7.i -> i32 1\n  %7 = trunc i32 %cond.i.7.i to i8 -> i8 1\n  %conv17.7.i = and i8 %conv17.6.i, %7 -> i8 1\n  %conv = zext i8 %conv17.7.i to i32 -> i32 1\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n    Printf: 1\n   -> i32 2\n  ret i32 0\nExiting function main\n```\nAfter SLP:\n```\nEntering function main\n  store i32 152, ptr @f, align 4\n  %agg.tmp.sroa.0.0.copyload.i = load i32, ptr @f, align 4 -> i32 152\n  %add.i.i = shl i32 %agg.tmp.sroa.0.0.copyload.i, 24 -> i32 -1744830464\n  %0 = insertelement <8 x i32> <i32 poison, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080>, i32 %add.i.i, i32 0 -> { i32 -1744830464, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080 }\n  %1 = add <8 x i32> <i32 83886080, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0>, %0 -> { i32 -1660944384, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080, i32 83886080 }\n  %2 = ashr <8 x i32> %1, splat (i32 24) -> { i32 -99, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5 }\n  %3 = trunc <8 x i32> %2 to <8 x i8> -> { i8 -99, i8 5, i8 5, i8 5, i8 5, i8 5, i8 5, i8 5 }\n  %4 = and <8 x i8> %3, <i8 -65, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1> -> { i8 -99, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1 }\n  %5 = zext <8 x i8> %4 to <8 x i32> -> { i32 157, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1 }\n  %6 = shufflevector <8 x i32> %5, <8 x i32> poison, <2 x i32> <i32 0, i32 poison> -> { i32 157, poison }\n  %7 = shufflevector <2 x i32> %6, <2 x i32> <i32 poison, i32 0>, <2 x i32> <i32 0, i32 3> -> { i32 157, i32 0 }\n  %8 = icmp ugt <2 x i32> %7, <i32 33554431, i32 0> -> { F, F }\n  %9 = call <8 x i1> @llvm.vector.insert.v8i1.v2i1(<8 x i1> <i1 poison, i1 poison, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <2 x i1> %8, i64 0) -> { F, F, F, F, F, F, F, F }\n  %10 = select <8 x i1> %9, <8 x i8> zeroinitializer, <8 x i8> <i8 6, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0> -> { i8 6, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0 }\n  %11 = shl <8 x i8> %4, %10 -> { i8 64, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1 }\n  %12 = call i8 @llvm.vector.reduce.and.v8i8(<8 x i8> %11) -> i8 0\n  %conv = zext i8 %12 to i32 -> i32 0\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n    Printf: 0\n   -> i32 2\n  ret i32 0\nExiting function main\n```\nllvm version: a88f4f1962b47aa8db49b8687a7f8b9097a3d13b\n\nC reproducer:\n```\n#include \"csmith.h\"\nstruct d {\n  uint8_t a;\n  uint16_t b\n} f;\nstatic uint64_t c[] = {66440127};\nuint64_t e;\nuint8_t h = 5;\nuint32_t g(uint8_t, struct d);\nint32_t j() {\n  int16_t i = 10;\n  struct d k = {152};\n  for (e = 0; e < 22; ++e) {\n    int32_t l[0];\n    struct d *m = &f;\n    h &= safe_lshift_func_int32_t_s_u(\n        safe_add_func_int8_t_s_s(g(0, *m = k), 5) & c[0],\n        safe_add_func_int16_t_s_s(6, (k.a > k.b) < l));\n  }\n  return i;\n}\nuint32_t g(uint8_t, struct d n) { return n.a; }\nint main() {\n  j();\n  printf(\"%d\\n\", h);\n}\n```\n```\n> gcc -w -I/usr/include/csmith -fsanitize=address,undefined test.c && ./a.out\n5\n> bin/clang -w -I/usr/include/csmith -O3 test.c && ./a.out\n0\n```\n",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:SLPVectorizer"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "N/A"
}