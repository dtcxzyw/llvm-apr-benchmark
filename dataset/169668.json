{
  "bug_id": "169668",
  "issue_url": "https://github.com/llvm/llvm-project/issues/169668",
  "bug_type": "crash",
  "base_commit": "135ddf1e8efef7c8ac9b01caa660210e3ca12327",
  "knowledge_cutoff": "2025-11-26T15:29:51Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "b76089c7f3d6593d2e2c83db7dbf4965b656bd8c",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          1522,
          1553
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "narrowToSingleScalarRecipes"
      ]
    }
  },
  "patch": "commit b76089c7f3d6593d2e2c83db7dbf4965b656bd8c\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Fri Nov 28 10:26:27 2025 +0000\n\n    [VPlan] Skip uses-scalars restriction if one of ops needs broadcast. (#168246)\n    \n    Update the logic in narrowToSingleScalar to allow narrowing even if not\n    all users use scalars, if at least one of the operands already needs\n    broadcasting.\n    \n    In that case, there won't be any additional broadcasts introduced. This\n    should allow removing the special handling for stores, which can\n    introduce additional broadcasts currently.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/169668.\n    \n    PR: https://github.com/llvm/llvm-project/pull/168246\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex 67aca48bcaf8..b12f8ccc73c7 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -1522,32 +1522,36 @@ static void narrowToSingleScalarRecipes(VPlan &Plan) {\n         continue;\n       }\n \n-      // Skip recipes that aren't single scalars or don't have only their\n-      // scalar results used. In the latter case, we would introduce extra\n-      // broadcasts.\n-      if (!vputils::isSingleScalar(RepOrWidenR) ||\n-          !all_of(RepOrWidenR->users(), [RepOrWidenR](const VPUser *U) {\n-            if (auto *Store = dyn_cast<VPWidenStoreRecipe>(U)) {\n-              // VPWidenStore doesn't have users, and stores are always\n-              // profitable to widen: hence, permitting address and mask\n-              // operands, and single-scalar stored values is an important leaf\n-              // condition. The assert must hold as we checked the RepOrWidenR\n-              // operand against vputils::isSingleScalar.\n-              assert(RepOrWidenR != Store->getStoredValue() ||\n-                     vputils::isSingleScalar(Store->getStoredValue()));\n-              (void)Store;\n-              return true;\n-            }\n-\n-            if (auto *VPI = dyn_cast<VPInstruction>(U)) {\n-              unsigned Opcode = VPI->getOpcode();\n-              if (Opcode == VPInstruction::ExtractLastElement ||\n-                  Opcode == VPInstruction::ExtractLastLanePerPart ||\n-                  Opcode == VPInstruction::ExtractPenultimateElement)\n-                return true;\n-            }\n-\n-            return U->usesScalars(RepOrWidenR);\n+      // Skip recipes that aren't single scalars.\n+      if (!vputils::isSingleScalar(RepOrWidenR))\n+        continue;\n+\n+      // Skip recipes for which conversion to single-scalar does introduce\n+      // additional broadcasts. No extra broadcasts are needed, if either only\n+      // the scalars of the recipe are used, or at least one of the operands\n+      // would require a broadcast. In the latter case, the single-scalar may\n+      // need to be broadcasted, but another broadcast is removed.\n+      if (!all_of(RepOrWidenR->users(),\n+                  [RepOrWidenR](const VPUser *U) {\n+                    if (auto *VPI = dyn_cast<VPInstruction>(U)) {\n+                      unsigned Opcode = VPI->getOpcode();\n+                      if (Opcode == VPInstruction::ExtractLastElement ||\n+                          Opcode == VPInstruction::ExtractLastLanePerPart ||\n+                          Opcode == VPInstruction::ExtractPenultimateElement)\n+                        return true;\n+                    }\n+\n+                    return U->usesScalars(RepOrWidenR);\n+                  }) &&\n+          none_of(RepOrWidenR->operands(), [RepOrWidenR](VPValue *Op) {\n+            if (Op->getSingleUser() != RepOrWidenR)\n+              return false;\n+            // Non-constant live-ins require broadcasts, while constants do not\n+            // need explicit broadcasts.\n+            bool LiveInNeedsBroadcast =\n+                Op->isLiveIn() && !isa<Constant>(Op->getLiveInIRValue());\n+            auto *OpR = dyn_cast<VPReplicateRecipe>(Op);\n+            return LiveInNeedsBroadcast || (OpR && OpR->isSingleScalar());\n           }))\n         continue;\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/conditional-branches-cost.ll",
      "commands": [
        "opt -p loop-vectorize -S %s",
        "opt -p loop-vectorize  -prefer-predicate-over-epilogue=predicate-else-scalar-epilogue -S %s"
      ],
      "tests": [
        {
          "test_name": "multiple_exit_conditions",
          "test_body": "target datalayout = \"e-m:o-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"arm64-apple-macosx14.0.0\"\n\ndefine void @multiple_exit_conditions(ptr %src, ptr noalias %dst) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %ptr.iv = phi ptr [ %dst, %entry ], [ %ptr.iv.next, %loop ]\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %l = load i16, ptr %src, align 2\n  %o = or i16 %l, 1\n  %conv = uitofp i16 %o to double\n  store double %conv, ptr %ptr.iv, align 8\n  %iv.next = add nsw i64 %iv, 2\n  %ptr.iv.next = getelementptr i8, ptr %ptr.iv, i64 8\n  %iv.clamp = and i64 %iv, 4294967294\n  %ec = icmp eq i64 %iv.clamp, 512\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"neoverse-512tvb\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/reduction-recurrence-costs-sve.ll",
      "commands": [
        "opt -p loop-vectorize -S %s",
        "opt -p loop-vectorize -mcpu=neoverse-v1 -S %s",
        "opt -p loop-vectorize -mcpu=neoverse-v1 -prefer-predicate-over-epilogue=predicate-else-scalar-epilogue -S %s"
      ],
      "tests": [
        {
          "test_name": "chained_recurrences",
          "test_body": "target datalayout = \"e-m:o-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"arm64-apple-macosx14.0.0\"\n\ndefine i32 @chained_recurrences(i32 %x, i64 %y, ptr %src.1, i32 %z, ptr %src.2) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %0 = phi i32 [ 0, %entry ], [ %3, %loop ]\n  %1 = phi i32 [ 0, %entry ], [ %0, %loop ]\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %sum.red = phi i32 [ 0, %entry ], [ %red.2, %loop ]\n  %2 = add i64 %y, 1\n  %gep.1 = getelementptr i32, ptr %src.1, i64 %2\n  %3 = load i32, ptr %gep.1, align 4\n  %or3 = or i32 %1, %x\n  %iv.next = add i64 %iv, 1\n  %shr = lshr i32 %x, 1\n  %4 = shl i32 %or3, 1\n  %5 = or i32 %4, 2\n  %shl19 = shl i32 %x, 1\n  %6 = or i32 %shr, %shl19\n  %7 = or i32 %6, %5\n  %8 = or i32 %7, %x\n  %or20 = or i32 %z, %x\n  %not = and i32 %or20, 1\n  %and = xor i32 %not, 1\n  %idx.ext.1 = zext i32 %and to i64\n  %gep.2 = getelementptr i32, ptr %src.2, i64 %idx.ext.1\n  %9 = load i32, ptr %gep.2, align 4\n  %shr24 = lshr i32 %8, 1\n  %idx.ext.2 = zext i32 %shr24 to i64\n  %gep.3 = getelementptr i32, ptr %src.2, i64 %idx.ext.2\n  %10 = load i32, ptr %gep.3, align 4\n  %red.1 = or i32 %9, %sum.red\n  %red.2 = or i32 %red.1, %10\n  %ec = icmp eq i64 %iv, %y\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i32 %red.2\n}\n\nattributes #0 = { \"target-features\"=\"+sve\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/widen-gep-all-indices-invariant.ll",
      "commands": [
        "opt -passes=loop-vectorize -mtriple=arm64-apple-macosx -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n; Test case for https://github.com/llvm/llvm-project/issues/169668.\ndefine i32 @gep_with_all_invariant_operands(ptr %src.0, ptr %src.1, i64 %n, i1 %cond) #0 {\n;\nentry:\n  br label %loop\n\nloop:\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %gep = getelementptr i32, ptr %src.0, i64 %n\n  %ptr = select i1 %cond, ptr %src.1, ptr %gep\n  %val = load i32, ptr %ptr, align 4\n  %iv.next = add i64 %iv, 1\n  %cmp = icmp ult i64 %iv, %n\n  br i1 %cmp, label %loop, label %exit, !llvm.loop !0\n\nexit:\n  ret i32 %val\n}\n\nattributes #0 = { \"target-cpu\"=\"neoverse-v2\" }\n\n!0 = distinct !{!0, !1, !2}\n!1 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n!2 = !{!\"llvm.loop.vectorize.predicate.enable\", i1 true}\n;.\n;."
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/pr88802.ll",
      "commands": [
        "opt -passes=loop-vectorize -mtriple=riscv64 -mattr=+v -S %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define void @test(ptr %p, i64 %a, i8 %b) {\nentry:\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.body, %entry\n  %iv = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %add = add i32 %iv, 1\n  %cmp.slt = icmp slt i32 %iv, 2\n  %shl = shl i64 %a, 48\n  %ashr = ashr i64 %shl, 52\n  %trunc.i32 = trunc i64 %ashr to i32\n  br i1 %cmp.slt, label %cond.false, label %for.body\n\ncond.false:                                       ; preds = %for.cond\n  %zext = zext i8 %b to i32\n  br label %for.body\n\nfor.body:                                         ; preds = %cond.false, %for.cond\n  %cond = phi i32 [ %trunc.i32, %for.cond ], [ %zext, %cond.false ]\n  %shl.i32 = shl i32 %cond, 8\n  %trunc = trunc i32 %shl.i32 to i8\n  store i8 %trunc, ptr %p, align 1\n  %cmp = icmp slt i32 %iv, 8\n  br i1 %cmp, label %for.cond, label %exit\n\nexit:                                             ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-conditional-branches.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7-avx -S"
      ],
      "tests": [
        {
          "test_name": "sdiv_by_zero",
          "test_body": "target triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @sdiv_by_zero(ptr noalias %src, ptr noalias %dst, i32 %d) #0 {\nbb:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %bb\n  %iv = phi i64 [ %iv.next, %loop.latch ], [ 0, %bb ]\n  %gep.src = getelementptr inbounds i32, ptr %src, i64 %iv\n  %l = load i32, ptr %gep.src, align 4\n  %icmp = icmp eq i32 %l, 0\n  br i1 %icmp, label %loop.latch, label %then\n\nthen:                                             ; preds = %loop.header\n  %sdiv = sdiv i32 %l, 0\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %merge = phi i32 [ %sdiv, %then ], [ 0, %loop.header ]\n  %gep.dst = getelementptr inbounds i32, ptr %dst, i64 %iv\n  store i32 %merge, ptr %gep.dst, align 4\n  %iv.next = add i64 %iv, 1\n  %ec = icmp ult i64 %iv, 16\n  br i1 %ec, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"znver3\" }\n"
        },
        {
          "test_name": "cost_ashr_with_op_known_invariant_via_scev",
          "test_body": "target triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i32 @cost_ashr_with_op_known_invariant_via_scev(i8 %a) {\nentry:\n  %cmp.i = icmp eq i16 0, 0\n  %conv.i = sext i16 0 to i32\n  %conv5.i = sext i8 %a to i32\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i8 [ 100, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %cmp.i, label %then, label %else\n\nthen:                                             ; preds = %else, %loop.header\n  %p.1 = phi i32 [ %rem.i, %else ], [ 0, %loop.header ]\n  %shr.i = ashr i32 %conv5.i, %p.1\n  %tobool6.not.i = icmp eq i32 %shr.i, 0\n  %sext.i = shl i32 %p.1, 24\n  %0 = ashr exact i32 %sext.i, 24\n  %1 = select i1 %tobool6.not.i, i32 %0, i32 0\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  %rem.i = urem i32 -1, %conv.i\n  %cmp3.i = icmp sgt i32 %rem.i, 1\n  br i1 %cmp3.i, label %loop.latch, label %then\n\nloop.latch:                                       ; preds = %else, %then\n  %p.2 = phi i32 [ 0, %else ], [ %1, %then ]\n  %iv.next = add i8 %iv, -1\n  %ec = icmp eq i8 %iv.next, 0\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret i32 %p.2\n}\n"
        },
        {
          "test_name": "test_predicated_udiv",
          "test_body": "target triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @test_predicated_udiv(i32 %d, i1 %c) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %c, label %loop.latch, label %then\n\nthen:                                             ; preds = %loop.header\n  %call = tail call i32 @llvm.usub.sat.i32(i32 %iv, i32 1)\n  %udiv = udiv i32 %call, %d\n  %zext = zext i32 %udiv to i64\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %merge = phi i64 [ %zext, %then ], [ 0, %loop.header ]\n  %iv.next = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret i64 %merge\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.usub.sat.i32(i32, i32) #1\n\nattributes #0 = { \"target-cpu\"=\"znver3\" }\nattributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-model.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7-avx -S"
      ],
      "tests": [
        {
          "test_name": "cost_loop_invariant_recipes",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @cost_loop_invariant_recipes(i1 %x, i64 %y) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next.i.i.i, %loop ]\n  %red = phi i64 [ 1, %entry ], [ %red.mul, %loop ]\n  %not.x = xor i1 %x, true\n  %ext = zext i1 %not.x to i64\n  %shl = shl i64 %y, %ext\n  %red.mul = mul i64 %shl, %red\n  %iv.next.i.i.i = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i64 %red.mul\n}\n"
        },
        {
          "test_name": "multi_exit",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @multi_exit(ptr %dst, ptr %src.1, ptr %src.2, i64 %A, i64 %B) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop.latch, %entry\n  %iv.1.wide = phi i64 [ 0, %entry ], [ %iv.1.next.wide, %loop.latch ]\n  %iv.1 = phi i32 [ 0, %entry ], [ %iv.1.next, %loop.latch ]\n  %ec.1 = icmp ult i64 %iv.1.wide, %A\n  br i1 %ec.1, label %loop.latch, label %exit\n\nloop.latch:                                       ; preds = %loop\n  %gep.src.1 = getelementptr inbounds i64, ptr %src.1, i32 %iv.1\n  %l.1 = load i64, ptr %gep.src.1, align 8\n  %l.2 = load i64, ptr %src.2, align 8\n  %cmp55.us = icmp eq i64 %l.1, 0\n  %cmp.i.us = icmp ne i64 %l.2, 0\n  %and = and i1 %cmp.i.us, %cmp55.us\n  %ext = zext i1 %and to i8\n  store i8 %ext, ptr %dst, align 1\n  %iv.1.next = add i32 %iv.1, 1\n  %iv.1.next.wide = zext i32 %iv.1.next to i64\n  %ec.2 = icmp ult i64 %iv.1.next.wide, %B\n  br i1 %ec.2, label %loop, label %exit\n\nexit:                                             ; preds = %loop.latch, %loop\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"penryn\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/replicating-load-store-costs.ll",
      "commands": [
        "opt -p loop-vectorize -mtriple=x86_64-linux-gnu -S %s",
        "opt -p loop-vectorize -mtriple=i386-pc-linux-gnu -S %s"
      ],
      "tests": [
        {
          "test_name": "test_load_used_by_other_load_scev_low_trip_count",
          "test_body": "declare i1 @cond()\n\ndefine double @test_load_used_by_other_load_scev_low_trip_count(ptr %ptr.a, ptr %ptr.b, ptr %ptr.c) {\nentry:\n  br label %outer.loop\n\nouter.loop:                                       ; preds = %inner.loop, %entry\n  %accum = phi double [ 0.000000e+00, %entry ], [ %result, %inner.loop ]\n  %cond = call i1 @cond()\n  br i1 %cond, label %inner.loop, label %exit\n\ninner.loop:                                       ; preds = %inner.loop, %outer.loop\n  %iv = phi i64 [ 0, %outer.loop ], [ %iv.next, %inner.loop ]\n  %accum.inner = phi double [ %accum, %outer.loop ], [ %mul1, %inner.loop ]\n  %idx.plus1 = add i64 %iv, 1\n  %gep.c = getelementptr i8, ptr %ptr.c, i64 %idx.plus1\n  %gep.a.i64 = getelementptr i64, ptr %ptr.a, i64 %idx.plus1\n  %load.idx = load i64, ptr %gep.a.i64, align 8\n  %gep.b = getelementptr double, ptr %ptr.b, i64 %load.idx\n  %load.a = load double, ptr %ptr.a, align 8\n  %add1 = fadd double %load.a, 0.000000e+00\n  %gep.c.offset = getelementptr i8, ptr %gep.c, i64 8\n  %load.c = load double, ptr %gep.c.offset, align 8\n  %mul1 = fmul double %add1, 0.000000e+00\n  %mul2 = fmul double %load.c, 0.000000e+00\n  %add2 = fadd double %mul2, 0.000000e+00\n  %add3 = fadd double %add2, 1.000000e+00\n  %load.b = load double, ptr %gep.b, align 8\n  %div = fdiv double %load.b, %add3\n  %result = fsub double %accum.inner, %div\n  %iv.next = add i64 %iv, 1\n  %exitcond = icmp eq i64 %iv, 1\n  br i1 %exitcond, label %outer.loop, label %inner.loop\n\nexit:                                             ; preds = %outer.loop\n  ret double %accum\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/cse-casts.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "preserve_flags_when_cloning_trunc",
          "test_body": "define i8 @preserve_flags_when_cloning_trunc(i8 %start, ptr noalias %src, ptr noalias %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %red = phi i8 [ %red.next, %loop ], [ %start, %entry ]\n  %l = load i32, ptr %src, align 4\n  %cmp = icmp ne i32 %l, 0\n  %cmp.ext = zext i1 %cmp to i64\n  %cmp.trunc = trunc i64 %cmp.ext to i16\n  %gep.dst = getelementptr i16, ptr %dst, i64 %iv\n  store i16 %cmp.trunc, ptr %gep.dst, align 2\n  %red.next = mul i8 %red, 3\n  %iv.next = add i64 %iv, 1\n  %ec = icmp ult i64 %iv, 416\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret i8 %red.next\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence-chains-vplan.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -debug-only=loop-vectorize -disable-output -S %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test_chained_first_order_recurrences_4",
          "test_body": "define i32 @test_chained_first_order_recurrences_4(ptr %base, i64 %x) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %for.x = phi i64 [ %for.x.next, %loop ], [ 0, %entry ]\n  %for.y = phi i32 [ %for.x.prev, %loop ], [ 0, %entry ]\n  %iv.next = add i64 %iv, 1\n  %gep = getelementptr i64, ptr %base, i64 %iv\n  %for.x.prev = trunc i64 %for.x to i32\n  %for.y.i64 = sext i32 %for.y to i64\n  store i64 %for.y.i64, ptr %gep, align 4\n  %for.x.next = mul i64 %x, 2\n  %icmp = icmp ugt i64 %iv, 4096\n  br i1 %icmp, label %ret, label %loop\n\nret:                                              ; preds = %loop\n  ret i32 0\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/narrow-to-single-scalar.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -S %s",
        "opt -p loop-vectorize -force-vector-width=2 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "narrow_widen_store_user",
          "test_body": "define void @narrow_widen_store_user(i32 %x, ptr noalias %A, ptr noalias %B) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.A = getelementptr i32, ptr %A, i32 %iv\n  %gep.B = getelementptr i32, ptr %B, i32 %iv\n  %wide.add = add i32 %x, 1\n  %wide.mul = mul i32 %wide.add, 3\n  store i32 %wide.add, ptr %gep.A, align 4\n  store i32 %wide.mul, ptr %gep.B, align 4\n  %iv.next = add i32 %iv, 1\n  %ec = icmp ne i32 %iv.next, 1024\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/pr43166-fold-tail-by-masking.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -force-vector-width=4 -S"
      ],
      "tests": [
        {
          "test_name": "test2",
          "test_body": "define i64 @test2(i64 %y) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %cond.end, %entry\n  %i = phi i32 [ 0, %entry ], [ %inc, %cond.end ]\n  %cmp = icmp eq i64 %y, 0\n  br i1 %cmp, label %cond.end, label %cond.false\n\ncond.false:                                       ; preds = %for.body\n  br label %cond.end\n\ncond.end:                                         ; preds = %cond.false, %for.body\n  %cond = phi i64 [ 55, %cond.false ], [ 77, %for.body ]\n  %inc = add nuw nsw i32 %i, 1\n  %exitcond = icmp eq i32 %inc, 3\n  br i1 %exitcond, label %for.cond.cleanup, label %for.body\n\nfor.cond.cleanup:                                 ; preds = %cond.end\n  ret i64 %cond\n}\n"
        },
        {
          "test_name": "test3",
          "test_body": "define i32 @test3(i64 %y) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %cond.end, %entry\n  %i = phi i32 [ 0, %entry ], [ %inc, %cond.end ]\n  %cmp = icmp eq i64 %y, 0\n  br i1 %cmp, label %cond.end, label %cond.false\n\ncond.false:                                       ; preds = %for.body\n  br label %cond.end\n\ncond.end:                                         ; preds = %cond.false, %for.body\n  %cond = phi i32 [ 55, %cond.false ], [ %i, %for.body ]\n  %inc = add nuw nsw i32 %i, 1\n  %exitcond = icmp eq i32 %inc, 3\n  br i1 %exitcond, label %for.cond.cleanup, label %for.body\n\nfor.cond.cleanup:                                 ; preds = %cond.end\n  ret i32 %cond\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/pr55167-fold-tail-live-out.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=2 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define i32 @test(i32 %a, i1 %c.1, i1 %c.2) {\nbb:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %bb\n  %iv = phi i32 [ 6, %bb ], [ %iv.next, %loop.latch ]\n  %v.2 = phi i32 [ 35902, %bb ], [ %p.2, %loop.latch ]\n  br i1 %c.1, label %loop.latch, label %body.1\n\nbody.1:                                           ; preds = %loop.header\n  %v.2.add = add i32 %v.2, 10\n  br i1 %c.2, label %loop.latch, label %body.2\n\nbody.2:                                           ; preds = %body.1\n  %add.1 = add i32 %v.2.add, 20\n  %xor = xor i32 %a, 1\n  %add.2 = add i32 %add.1, %xor\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %body.2, %body.1, %loop.header\n  %p.1 = phi i32 [ %iv, %loop.header ], [ 9, %body.1 ], [ 9, %body.2 ]\n  %p.2 = phi i32 [ %v.2, %loop.header ], [ %v.2.add, %body.1 ], [ %add.2, %body.2 ]\n  %iv.next = add nuw nsw i32 %iv, 1\n  %ec = icmp ult i32 %iv, 181\n  br i1 %ec, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  %e.1 = phi i32 [ %p.1, %loop.latch ]\n  %e.2 = phi i32 [ %p.2, %loop.latch ]\n  %res = add i32 %e.1, %e.2\n  ret i32 %res\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/predicatedinst-loop-invariant.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -S %s"
      ],
      "tests": [
        {
          "test_name": "loop_invariant_srem",
          "test_body": "define void @loop_invariant_srem(ptr %p, i64 %a, i8 %b) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i8 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.next = add i8 %iv, 1\n  %cmp.slt = icmp slt i8 %iv, 2\n  %shl = shl i64 %a, 48\n  %ashr = ashr i64 %shl, 52\n  %trunc.i32 = trunc i64 %ashr to i32\n  br i1 %cmp.slt, label %cond.false, label %loop.latch\n\ncond.false:                                       ; preds = %loop.header\n  %zext = zext i8 %b to i32\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %cond.false, %loop.header\n  %cond = phi i32 [ %trunc.i32, %loop.header ], [ %zext, %cond.false ]\n  %shl.i32 = shl i32 %cond, 8\n  %trunc = trunc i32 %shl.i32 to i8\n  %rem = srem i8 %iv, %trunc\n  %gep.p.rem = getelementptr i32, ptr %p, i8 %rem\n  store i32 4, ptr %gep.p.rem, align 4\n  %ec = icmp eq i8 %iv, 8\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "loop_invariant_store",
          "test_body": "define void @loop_invariant_store(ptr %p, i64 %a, i8 %b) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.next = add i32 %iv, 1\n  %cmp.slt = icmp slt i32 %iv, 2\n  %shl = shl i64 %a, 48\n  %ashr = ashr i64 %shl, 52\n  %trunc.i32 = trunc i64 %ashr to i32\n  br i1 %cmp.slt, label %cond.false, label %loop.latch\n\ncond.false:                                       ; preds = %loop.header\n  %zext = zext i8 %b to i32\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %cond.false, %loop.header\n  %cond = phi i32 [ %trunc.i32, %loop.header ], [ %zext, %cond.false ]\n  %shl.i32 = shl i32 %cond, 8\n  %trunc = trunc i32 %shl.i32 to i8\n  store i8 %trunc, ptr %p, align 1\n  %exitcond = icmp slt i32 %iv, 8\n  br i1 %exitcond, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/reduction-inloop-uf4.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize,dce,instcombine -force-vector-interleave=4 -force-vector-width=4 -prefer-inloop-reductions -S"
      ],
      "tests": [
        {
          "test_name": "cond_rdx_pred",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\ndefine i32 @cond_rdx_pred(i32 %cond, ptr noalias %a, i64 %N) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %iv = phi i64 [ %inc, %for.inc ], [ 0, %entry ]\n  %sum = phi i32 [ %res, %for.inc ], [ 4, %entry ]\n  %cmp1 = icmp sgt i32 %cond, 7\n  br i1 %cmp1, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %arrayidx = getelementptr inbounds i32, ptr %a, i64 %iv\n  %load = load i32, ptr %arrayidx, align 4\n  %mul = mul nsw i32 %load, %sum\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %res = phi i32 [ %mul, %if.then ], [ %sum, %for.body ]\n  %inc = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %inc, %N\n  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !0\n\nfor.end:                                          ; preds = %for.inc\n  ret i32 %res\n}\n\n!0 = distinct !{!0, !1, !2}\n!1 = !{!\"llvm.loop.vectorize.predicate.enable\", i1 true}\n!2 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/trunc-shifts.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "test_ashr_const_shift_ops",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\ndefine void @test_ashr_const_shift_ops(ptr %dst, i32 %f) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i8 [ 0, %entry ], [ %iv.next, %loop ]\n  %l = ashr i32 %f, 18\n  %l.t = trunc i32 %l to i8\n  %iv.ext = zext i8 %iv to i64\n  %gep = getelementptr inbounds i8, ptr %dst, i64 %iv.ext\n  store i8 %l.t, ptr %gep, align 8\n  %iv.next = add i8 %iv, 1\n  %conv = zext i8 %iv.next to i32\n  %c = icmp ne i32 %conv, 100\n  br i1 %c, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "test_pr47927_lshr_const_shift_ops",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\ndefine void @test_pr47927_lshr_const_shift_ops(ptr %dst, i32 %f) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i8 [ 0, %entry ], [ %iv.next, %loop ]\n  %l = lshr i32 %f, 18\n  %l.t = trunc i32 %l to i8\n  %iv.ext = zext i8 %iv to i64\n  %gep = getelementptr inbounds i8, ptr %dst, i64 %iv.ext\n  store i8 %l.t, ptr %gep, align 8\n  %iv.next = add i8 %iv, 1\n  %conv = zext i8 %iv.next to i32\n  %c = icmp ne i32 %conv, 100\n  br i1 %c, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "test_shl_const_shift_ops",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\ndefine void @test_shl_const_shift_ops(ptr %dst, i32 %f) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i8 [ 0, %entry ], [ %iv.next, %loop ]\n  %l = shl i32 %f, 18\n  %l.t = trunc i32 %l to i8\n  %iv.ext = zext i8 %iv to i64\n  %gep = getelementptr inbounds i8, ptr %dst, i64 %iv.ext\n  store i8 %l.t, ptr %gep, align 8\n  %iv.next = add i8 %iv, 1\n  %conv = zext i8 %iv.next to i32\n  %c = icmp ne i32 %conv, 100\n  br i1 %c, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LV] Assert \"Expected at least one loop-variant operand\"",
    "body": "This IR:\n\n```\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64-unknown-linux-gnu\"\n\ndefine i16 @_Z4testsisjyjybtjjxbxtthiPjPbS_PA25_A25_yS_S3_(ptr %arr_8, i64 %indvars.iv, i1 %tobool204.not) #0 {\nentry:\n  br label %for.cond57.preheader.us\n\nfor.cond57.preheader.us:                          ; preds = %for.cond57.preheader.us, %entry\n  %indvars.iv696 = phi i64 [ %indvars.iv.next697, %for.cond57.preheader.us ], [ 0, %entry ]\n  %arrayidx207.us571 = getelementptr i32, ptr %arr_8, i64 %indvars.iv\n  %cond223.in.us572 = select i1 %tobool204.not, ptr null, ptr %arrayidx207.us571\n  %cond223.us573 = load i32, ptr %cond223.in.us572, align 4\n  %0 = trunc i32 %cond223.us573 to i16\n  %indvars.iv.next697 = add i64 %indvars.iv696, 1\n  %1 = icmp ult i64 %indvars.iv696, %indvars.iv\n  br i1 %1, label %for.cond57.preheader.us, label %for.body62.us559.split, !llvm.loop !0\n\nfor.body62.us559.split:                           ; preds = %for.cond57.preheader.us\n  ret i16 %0\n}\n\nattributes #0 = { \"target-cpu\"=\"grace\" }\n\n!0 = distinct !{!0, !1, !2, !3}\n!1 = !{!\"llvm.loop.mustprogress\"}\n!2 = !{!\"llvm.loop.vectorize.predicate.enable\", i1 true}\n!3 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n```\n\ntriggers this assert:\n\n```\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:2552: virtual void llvm::VPWidenGEPRecipe::execute(llvm::VPTransformState&): Assertion `any_of(operands(), [](VPValue *Op) { return !Op->isDefinedOutsideLoopRegions(); }) && \"Expected at least one loop-variant operand\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -S -passes=loop-vectorize <source>\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"<source>\"\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"_Z4testsisjyjybtjjxbxtthiPjPbS_PA25_A25_yS_S3_\"\n #0 0x000000000598ad38 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x598ad38)\n #1 0x0000000005987be4 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x00007c4e84e42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x00007c4e84e969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x00007c4e84e42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x00007c4e84e287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x00007c4e84e2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x00007c4e84e39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x000000000388fda1 (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x388fda1)\n #9 0x000000000382fae3 llvm::VPBasicBlock::executeRecipes(llvm::VPTransformState*, llvm::BasicBlock*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x382fae3)\n#10 0x0000000003846025 llvm::VPBasicBlock::execute(llvm::VPTransformState*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3846025)\n#11 0x000000000384b952 llvm::VPlan::execute(llvm::VPTransformState*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x384b952)\n#12 0x00000000036c1a93 llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoopVectorizer&, llvm::DominatorTree*, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36c1a93)\n```\n\nSee also: https://godbolt.org/z/hnc9Wjxe4\n\n",
    "author": "sjoerdmeijer",
    "labels": [
      "vectorizers",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "sjoerdmeijer",
        "body": "CC: @fhahn "
      },
      {
        "author": "fhahn",
        "body": "Should be fixed by https://github.com/llvm/llvm-project/pull/168246, plan to land it tomorrow"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}