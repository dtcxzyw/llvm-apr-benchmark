{
  "bug_id": "160250",
  "issue_url": "https://github.com/llvm/llvm-project/issues/160250",
  "bug_type": "crash",
  "base_commit": "73d9974c91413f5a6dbe6f76f4b73ad226b6276b",
  "knowledge_cutoff": "2025-09-23T07:31:32Z",
  "lit_test_dir": [
    "llvm/test/Transforms/DFAJumpThreading"
  ],
  "hints": {
    "fix_commit": "a05e004b285af92f9bcef12d5ab5537c36002c13",
    "components": [
      "DFAJumpThreading"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp": [
        [
          190,
          201
        ],
        [
          332,
          338
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp": [
        "unfold"
      ]
    }
  },
  "patch": "commit a05e004b285af92f9bcef12d5ab5537c36002c13\nAuthor: Hongyu Chen <xxs_chy@outlook.com>\nDate:   Wed Oct 1 22:06:08 2025 +0800\n\n    [DFAJumpThreading] Unfold select to the incoming block of phi user (#160987)\n    \n    Fixes #160250\n    We previously assumed the select to unfold is defined in the incoming\n    block of phi user, as `isValidSelectInst` filters other cases at the\n    initial stage. However, the selects not defined in the incoming block\n    may occur after unfolding the arms of the unfolded select.\n    This patch sinks the select into the incoming block of the phi user and\n    unfolds it at the incoming block.\n\ndiff --git a/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp b/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp\nindex 944b253e0f5e..e9a3e983bc1e 100644\n--- a/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp\n+++ b/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp\n@@ -190,12 +190,12 @@ void unfold(DomTreeUpdater *DTU, LoopInfo *LI, SelectInstToUnfold SIToUnfold,\n             std::vector<BasicBlock *> *NewBBs) {\n   SelectInst *SI = SIToUnfold.getInst();\n   PHINode *SIUse = SIToUnfold.getUse();\n-  BasicBlock *StartBlock = SI->getParent();\n+  assert(SI->hasOneUse());\n+  // The select may come indirectly, instead of from where it is defined.\n+  BasicBlock *StartBlock = SIUse->getIncomingBlock(*SI->use_begin());\n   BranchInst *StartBlockTerm =\n       dyn_cast<BranchInst>(StartBlock->getTerminator());\n-\n   assert(StartBlockTerm);\n-  assert(SI->hasOneUse());\n \n   if (StartBlockTerm->isUnconditional()) {\n     BasicBlock *EndBlock = StartBlock->getUniqueSuccessor();\n@@ -332,7 +332,7 @@ void unfold(DomTreeUpdater *DTU, LoopInfo *LI, SelectInstToUnfold SIToUnfold,\n   }\n \n   // Preserve loop info\n-  if (Loop *L = LI->getLoopFor(SI->getParent())) {\n+  if (Loop *L = LI->getLoopFor(StartBlock)) {\n     for (BasicBlock *NewBB : *NewBBs)\n       L->addBasicBlockToLoop(NewBB, *LI);\n   }\n@@ -533,6 +533,8 @@ private:\n       return false;\n \n     // Only fold the select coming from directly where it is defined.\n+    // TODO: We have dealt with the select coming indirectly now. This\n+    // constraint can be relaxed.\n     PHINode *PHIUser = dyn_cast<PHINode>(SIUse);\n     if (PHIUser && PHIUser->getIncomingBlock(*SI->use_begin()) != SIBB)\n       return false;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/DFAJumpThreading/dfa-jump-threading-transform.ll",
      "commands": [
        "opt -S -passes=dfa-jump-threading %s"
      ],
      "tests": [
        {
          "test_name": "pr106083_select_dead_uses",
          "test_body": "define void @pr106083_select_dead_uses(i1 %cmp1, i1 %not, ptr %p) {\nbb:\n  %spec.select = select i1 %cmp1, i32 0, i32 1\n  br label %.loopexit6\n\n.loopexit6:                                       ; preds = %select.unfold, %bb\n  br i1 %not, label %select.unfold, label %bb1\n\nbb1:                                              ; preds = %.loopexit6\n  %i = load i32, ptr %p, align 4\n  %not2 = icmp eq i32 0, 0\n  %spec.select7 = select i1 %not2, i32 %spec.select, i32 0\n  br label %select.unfold\n\nselect.unfold:                                    ; preds = %bb1, %.loopexit6\n  %_2 = phi i32 [ 0, %.loopexit6 ], [ %spec.select7, %bb1 ]\n  switch i32 %_2, label %bb2 [\n    i32 0, label %.preheader.preheader\n    i32 1, label %.loopexit6\n  ]\n\n.preheader.preheader:                             ; preds = %select.unfold\n  ret void\n\nbb2:                                              ; preds = %select.unfold\n  unreachable\n}\n"
        },
        {
          "test_name": "pr106083_invalidBBarg_fold",
          "test_body": "define void @pr106083_invalidBBarg_fold(i1 %cmp1, i1 %cmp2, i1 %not, ptr %d) {\nbb:\n  %sel = select i1 %cmp1, i32 0, i32 1\n  br label %BB1\n\nBB1:                                              ; preds = %BB1.backedge, %BB7, %bb\n  %i = phi i16 [ 0, %BB1.backedge ], [ 0, %bb ], [ 1, %BB7 ]\n  br i1 %not, label %BB7, label %BB2\n\nBB2:                                              ; preds = %BB1\n  store i16 0, ptr %d, align 2\n  %spec.select = select i1 %cmp2, i32 %sel, i32 0\n  br label %BB7\n\nBB7:                                              ; preds = %BB2, %BB1\n  %d.promoted4 = phi i16 [ 0, %BB1 ], [ 1, %BB2 ]\n  %_3 = phi i32 [ 0, %BB1 ], [ %spec.select, %BB2 ]\n  switch i32 %_3, label %BB1.backedge [\n    i32 0, label %BB1\n    i32 1, label %BB8\n  ]\n\nBB1.backedge:                                     ; preds = %BB7\n  br label %BB1\n\nBB8:                                              ; preds = %BB7\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/DFAJumpThreading/dfa-unfold-select.ll",
      "commands": [
        "opt -S -passes=dfa-jump-threading -dfa-early-exit-heuristic=false %s"
      ],
      "tests": [
        {
          "test_name": "pr160250",
          "test_body": "define i16 @pr160250() {\nentry:\n  %.5 = select i1 false, i32 0, i32 0\n  %.6 = select i1 false, i32 0, i32 0\n  br label %for.cond48\n\nfor.cond48:                                       ; preds = %for.cond48.backedge, %entry\n  br i1 false, label %cleanup87, label %if.else\n\nif.else:                                          ; preds = %for.cond48\n  %spec.select1 = select i1 false, i32 %.5, i32 0\n  %spec.select = select i1 false, i32 %.6, i32 %spec.select1\n  br label %cleanup87\n\ncleanup87:                                        ; preds = %if.else, %for.cond48\n  %cleanup.dest.slot.3 = phi i32 [ 0, %for.cond48 ], [ %spec.select, %if.else ]\n  switch i32 %cleanup.dest.slot.3, label %for.cond48.backedge [\n    i32 0, label %for.cond48.backedge\n    i32 1, label %for.cond48.backedge\n  ]\n\nfor.cond48.backedge:                              ; preds = %cleanup87, %cleanup87, %cleanup87\n  br label %for.cond48\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "dfa-jump-threading crashing with \"Assertion `Idx >= 0 && \"Invalid basic block argument to remove!\"' failed\"",
    "body": "llvm commit: 2ab02b6f561d\nReproduce with:\n```opt -passes=\"dfa-jump-threading\" bbi-110818.ll -o /dev/null```\nResult:\n```\nopt: ../include/llvm/IR/Instructions.h:2795: Value *llvm::PHINode::removeIncomingValue(const BasicBlock *, bool): Assertion `Idx >= 0 && \"Invalid basic block argument to remove!\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: build-all/bin/opt -passes=dfa-jump-threading bbi-110818.ll -o /dev/null\n1.\tRunning pass \"function(dfa-jump-threading)\" on module \"bbi-110818.ll\"\n2.\tRunning pass \"dfa-jump-threading\" on function \"func_2\"\n #0 0x000055a37c34f4a6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (build-all/bin/opt+0x4b714a6)\n #1 0x000055a37c34ca35 llvm::sys::RunSignalHandlers() (build-all/bin/opt+0x4b6ea35)\n #2 0x000055a37c350629 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007f3c662e2990 __restore_rt (/lib64/libpthread.so.0+0x12990)\n #4 0x00007f3c63c8252f raise (/lib64/libc.so.6+0x4e52f)\n #5 0x00007f3c63c55e65 abort (/lib64/libc.so.6+0x21e65)\n #6 0x00007f3c63c55d39 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d39)\n #7 0x00007f3c63c7ae86 (/lib64/libc.so.6+0x46e86)\n #8 0x000055a37dc07096 (anonymous namespace)::DFAJumpThreading::run(llvm::Function&) DFAJumpThreading.cpp:0:0\n #9 0x000055a37dc00b60 llvm::DFAJumpThreadingPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (build-all/bin/opt+0x6422b60)\n#10 0x000055a37d81b81d llvm::detail::PassModel<llvm::Function, llvm::DFAJumpThreadingPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) PassBuilderPipelines.cpp:0:0\n#11 0x000055a37c56c965 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (build-all/bin/opt+0x4d8e965)\n#12 0x000055a37d81bc5d llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) PassBuilderPipelines.cpp:0:0\n#13 0x000055a37c57126e llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (build-all/bin/opt+0x4d9326e)\n#14 0x000055a37d7aa6ad llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) NewPMDriver.cpp:0:0\n#15 0x000055a37c56b635 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (build-all/bin/opt+0x4d8d635)\n#16 0x000055a37d7a33f0 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (build-all/bin/opt+0x5fc53f0)\n#17 0x000055a37c2f0718 optMain (build-all/bin/opt+0x4b12718)\n#18 0x00007f3c63c6e7e5 __libc_start_main (/lib64/libc.so.6+0x3a7e5)\n#19 0x000055a37c2ee12e _start (build-all/bin/opt+0x4b1012e)\nAbort (core dumped)\n```\n\n[bbi-110818.ll.gz](https://github.com/user-attachments/files/22488497/bbi-110818.ll.gz)",
    "author": "mikaelholmen",
    "labels": [
      "crash",
      "llvm:transforms",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "mikaelholmen",
        "body": "This crash seems to be related to https://github.com/llvm/llvm-project/pull/96127 and the fix (https://github.com/llvm/llvm-project/pull/109511) for a crash I reported on that PR in https://github.com/llvm/llvm-project/pull/96127#issuecomment-2324800391"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}