{
  "bug_id": "162128",
  "issue_url": "https://github.com/llvm/llvm-project/issues/162128",
  "bug_type": "crash",
  "base_commit": "0df5fc7d825d2b279ecd283ca002834c223853ff",
  "knowledge_cutoff": "2025-10-06T17:50:29Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "70c1c8f8007746040e256186d1e23b65d7590e00",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp": [
        [
          763,
          768
        ],
        [
          770,
          778
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp": [
        "VPlanTransforms::addMinimumVectorEpilogueIterationCheck"
      ]
    }
  },
  "patch": "commit 70c1c8f8007746040e256186d1e23b65d7590e00\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Tue Oct 7 21:15:58 2025 +0100\n\n    [VPlan] Create SCEV expansion for epilogue check first.\n    \n    VPExpandSCEVRecipes must be at the beginning of the entry block.\n    addMinimumEpilogueIterationCheck currently creates VPInstructions to\n    compute the remaining iterations before potentially creating\n    VPExpandSCEVRecipes.\n    \n    Fix this by first creating any SCEV expansions if needed.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/162128.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp b/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\nindex c8212af9f8e0..b36298fcad74 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\n@@ -763,6 +763,8 @@ void VPlanTransforms::addMinimumVectorEpilogueIterationCheck(\n   // Add the minimum iteration check for the epilogue vector loop.\n   VPValue *TC = Plan.getOrAddLiveIn(TripCount);\n   VPBuilder Builder(cast<VPBasicBlock>(Plan.getEntry()));\n+  VPValue *VFxUF = Builder.createExpandSCEV(SE.getElementCount(\n+      TripCount->getType(), (EpilogueVF * EpilogueUF), SCEV::FlagNUW));\n   VPValue *Count = Builder.createNaryOp(\n       Instruction::Sub, {TC, Plan.getOrAddLiveIn(VectorTripCount)},\n       DebugLoc::getUnknown(), \"n.vec.remaining\");\n@@ -770,9 +772,6 @@ void VPlanTransforms::addMinimumVectorEpilogueIterationCheck(\n   // Generate code to check if the loop's trip count is less than VF * UF of\n   // the vector epilogue loop.\n   auto P = RequiresScalarEpilogue ? ICmpInst::ICMP_ULE : ICmpInst::ICMP_ULT;\n-  VPValue *VFxUF = Builder.createExpandSCEV(SE.getElementCount(\n-      TripCount->getType(), (EpilogueVF * EpilogueUF), SCEV::FlagNUW));\n-\n   auto *CheckMinIters = Builder.createICmp(\n       P, Count, VFxUF, DebugLoc::getUnknown(), \"min.epilog.iters.check\");\n   VPInstruction *Branch =\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/epilog-vectorization-scev-expansion.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -enable-epilogue-vectorization -epilogue-vectorization-force-VF=4 -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n@end = external global [128 x i8]\n\n; Test case for https://github.com/llvm/llvm-project/issues/162128.\ndefine void @test_epilogue_step_scev_expansion(ptr %dst) {\n;\nentry:\n  br label %loop\n\nloop:\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.dst = getelementptr i8, ptr %dst, i64 %iv\n  store i8 0, ptr %gep.dst, align 1\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, sub (i64 0, i64 ptrtoint (ptr getelementptr inbounds nuw (i8, ptr @end, i64 1) to i64))\n  br i1 %ec, label %exit, label %loop\n\nexit:\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion failure in VPlanTransforms.cpp",
    "body": "We're seeing an assertion failure trip when building Fuchsia w/ coverage instrumentation. \n\nHere is a reproducer \n[llvm-profdata-a2a90a.zip](https://github.com/user-attachments/files/22727832/llvm-profdata-a2a90a.zip)\n\nI'm working on reducing it, and @gulfemsavrun has started a bisect.\n\nThe toolchain we're qualifying is from Oct 2 (commit b147019f8b11cd491f331bd707f764786792665e).\n\n```console\nclang++: /usr/local/google/home/paulkirth/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:3917: static DenseMap<const SCEV *, Value *> llvm::VPlanTransforms::expandSCEVs(VPlan &, ScalarEvolution &): Assertion `none_of(*Entry, IsaPred<VPExpandSCEVRecipe>) && \"VPExpandSCEVRecipes must be at the beginning of the entry block, \" \"after any VPIRInstructions\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\nStack dump:\n0.      Program arguments: /usr/local/google/home/paulkirth/llvm-project/build/bin/clang++ -cc1 -triple x86_64-unknown-windows-msvc19.33.0 -O2 -emit-obj -massembler-fatal-warnings -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name llvm-profdata.cc -mrelocation-model pic -pic-level 2 -mframe-pointer=non-leaf -relaxed-aliasing -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -fms-volatile -ffreestanding -D_HAS_STATIC_RTTI=0 -target-cpu x86-64-v2 -mllvm -x86-branches-within-32B-boundaries -tune-cpu generic -gno-column-info -gcodeview -debug-info-kind=constructor -fdebug-compilation-dir=. -object-file-name=kernel.efi_x64-coverage\\\\obj\\\\src\\\\lib\\\\llvm-profdata\\\\libllvm-profdata.llvm-profdata.cc.o -mllvm -crash-diagnostics-dir=clang-crashreports -ffunction-sections -fdata-sections -fcoverage-compilation-dir=. -sys-header-deps -D _LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS -D _LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS=1 -D TOOLCHAIN_VERSION=mSdw4dJP68zDVUDZeMkK7B6_Qa4ra24Ty4wlu7xGETgC -D __Fuchsia_API_level__=4293918720 -D ZX_ASSERT_LEVEL=2 -D __PE_COFF__ -D WITH_FRAME_POINTERS=1 -D HAVE_LLVM_PROFDATA=1 -U _MSC_VER -U _MSC_FULL_VER -Wall -Wextra -Wconversion -Wextra-semi -Wimplicit-fallthrough -Wnewline-eof -Wstrict-prototypes -Wwrite-strings -Wno-sign-conversion -Wno-unused-parameter -Wnonportable-system-include-path -Wno-missing-field-initializers -Wno-extra-qualification -Wno-cast-function-type-mismatch -Wno-unknown-warning-option -Wno-missing-template-arg-list-after-template-kw -Wno-deprecated-pragma -Wno-nontrivial-memaccess -Wthread-safety -Wno-unknown-warning-option -Wno-thread-safety-reference-return -Werror -Wno-builtin-macro-redefined -Wformat=2 -Wmissing-declarations -Wvla -Wshadow -Wno-deprecated-this-capture -std=c++20 -fdeprecated-macro -fstack-size-section -ferror-limit 19 -ftemplate-backtrace-limit=0 -fvisibility=hidden -fvisibility-inlines-hidden -ftrivial-auto-var-init=pattern -fno-rtti -fno-use-cxa-atexit -fms-extensions -fms-compatibility -fms-compatibility-version=19.33 -fno-threadsafe-statics -fno-implicit-modules -fskip-odr-check-in-gmf -faligned-allocation -fnew-alignment=8 -fcolor-diagnostics -vectorize-loops -vectorize-slp -faddrsig -x c++ llvm-profdata-a2a90a.cpp\n1.      <eof> parser at end of file\n2.      Optimizer\n3.      Running pass \"function<eager-inv>(drop-unnecessary-assumes,float2int,lower-constant-intrinsics,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O2>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"llvm-profdata-a2a90a.cpp\"\n4.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"?MergeLiveData@LlvmProfdata@@QEAAXULiveData@1@@Z\"\n#0 0x00005634a0128b28 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /usr/local/google/home/paulkirth/llvm-project/llvm/lib/Support/Unix/Signals.inc:834:13\nllvm-profdata-a2a90a.sh: line 4: 3184705 Aborted                 (core dumped) \"$HOME/llvm-project/build/bin/clang++\" \"-cc1\" \"-triple\" \"x86_64-unknown-windows-msvc19.33.0\" \"-O2\" \"-emit-obj\" \"-massembler-fatal-warnings\" \"-disable-free\" \"-clear-ast-before-backend\" \"-disable-llvm-verifier\" \"-discard-value-names\" \"-main-file-name\" \"llvm-profdata.cc\" \"-mrelocation-model\" \"pic\" \"-pic-level\" \"2\" \"-mframe-pointer=non-leaf\" \"-relaxed-aliasing\" \"-fmath-errno\" \"-ffp-contract=on\" \"-fno-rounding-math\" \"-mconstructor-aliases\" \"-fms-volatile\" \"-ffreestanding\" \"-D_HAS_STATIC_RTTI=0\" \"-target-cpu\" \"x86-64-v2\" \"-mllvm\" \"-x86-branches-within-32B-boundaries\" \"-tune-cpu\" \"generic\" \"-gno-column-info\" \"-gcodeview\" \"-debug-info-kind=constructor\" \"-fdebug-compilation-dir=.\" \"-object-file-name=kernel.efi_x64-coverage\\\\obj\\\\src\\\\lib\\\\llvm-profdata\\\\libllvm-profdata.llvm-profdata.cc.o\" \"-mllvm\" \"-crash-diagnostics-dir=clang-crashreports\" \"-ffunction-sections\" \"-fdata-sections\" \"-fcoverage-compilation-dir=.\" \"-sys-header-deps\" \"-D\" \"_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS\" \"-D\" \"_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS=1\" \"-D\" \"TOOLCHAIN_VERSION=mSdw4dJP68zDVUDZeMkK7B6_Qa4ra24Ty4wlu7xGETgC\" \"-D\" \"__Fuchsia_API_level__=4293918720\" \"-D\" \"ZX_ASSERT_LEVEL=2\" \"-D\" \"__PE_COFF__\" \"-D\" \"WITH_FRAME_POINTERS=1\" \"-D\" \"HAVE_LLVM_PROFDATA=1\" \"-U\" \"_MSC_VER\" \"-U\" \"_MSC_FULL_VER\" \"-Wall\" \"-Wextra\" \"-Wconversion\" \"-Wextra-semi\" \"-Wimplicit-fallthrough\" \"-Wnewline-eof\" \"-Wstrict-prototypes\" \"-Wwrite-strings\" \"-Wno-sign-conversion\" \"-Wno-unused-parameter\" \"-Wnonportable-system-include-path\" \"-Wno-missing-field-initializers\" \"-Wno-extra-qualification\" \"-Wno-cast-function-type-mismatch\" \"-Wno-unknown-warning-option\" \"-Wno-missing-template-arg-list-after-template-kw\" \"-Wno-deprecated-pragma\" \"-Wno-nontrivial-memaccess\" \"-Wthread-safety\" \"-Wno-unknown-warning-option\" \"-Wno-thread-safety-reference-return\" \"-Werror\" \"-Wno-builtin-macro-redefined\" \"-Wformat=2\" \"-Wmissing-declarations\" \"-Wvla\" \"-Wshadow\" \"-Wno-deprecated-this-capture\" \"-std=c++20\" \"-fdeprecated-macro\" \"-fstack-size-section\" \"-ferror-limit\" \"19\" \"-ftemplate-backtrace-limit=0\" \"-fvisibility=hidden\" \"-fvisibility-inlines-hidden\" \"-ftrivial-auto-var-init=pattern\" \"-fno-rtti\" \"-fno-use-cxa-atexit\" \"-fms-extensions\" \"-fms-compatibility\" \"-fms-compatibility-version=19.33\" \"-fno-threadsafe-statics\" \"-fno-implicit-modules\" \"-fskip-odr-check-in-gmf\" \"-faligned-allocation\" \"-fnew-alignment=8\" \"-fcolor-diagnostics\" \"-vectorize-loops\" \"-vectorize-slp\" \"-faddrsig\" \"-x\" \"c++\" \"llvm-profdata-a2a90a.cpp\"\n```",
    "author": "ilovepi",
    "labels": [
      "vectorizers",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "ilovepi",
        "body": "bad.ll\n```llvm\n; *** IR Dump Before LoopVectorizePass on ?MergeLiveData@LlvmProfdata@@QEAAXULiveData@1@@Z ***\n; ModuleID = 'reduced.ll'\nsource_filename = \"reduced.ll\"\ntarget datalayout = \"e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-windows-msvc19.33.0\"\n\n@\"?CountersBegin_placeholder@?A0xE34CF3CB@@3PADA\" = external global [1 x i8]\n\n; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, inaccessiblemem: none)\ndefine noalias noundef ptr @\"?ProfCountersData@?A0xE34CF3CB@@YA?AV?$span@D$0?0@__ktl@std@@XZ\"() local_unnamed_addr #0 {\n  store i64 sub (i64 0, i64 ptrtoint (ptr getelementptr inbounds nuw (i8, ptr @\"?CountersBegin_placeholder@?A0xE34CF3CB@@3PADA\", i64 1) to i64)), ptr inttoptr (i64 8 to ptr), align 8\n  ret ptr null\n}\n\n; Function Attrs: nofree norecurse nosync nounwind memory(write, inaccessiblemem: none)\ndefine void @\"?MergeLiveData@LlvmProfdata@@QEAAXULiveData@1@@Z\"() local_unnamed_addr #1 {\n  store i64 sub (i64 0, i64 ptrtoint (ptr getelementptr inbounds nuw (i8, ptr @\"?CountersBegin_placeholder@?A0xE34CF3CB@@3PADA\", i64 1) to i64)), ptr inttoptr (i64 8 to ptr), align 8\n  %.not.i = icmp eq i64 sub (i64 0, i64 ptrtoint (ptr getelementptr inbounds nuw (i8, ptr @\"?CountersBegin_placeholder@?A0xE34CF3CB@@3PADA\", i64 1) to i64)), 0\n  br i1 %.not.i, label %\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit\", label %.lr.ph.i.preheader\n\n.lr.ph.i.preheader:                               ; preds = %0\n  br label %.lr.ph.i\n\n.lr.ph.i:                                         ; preds = %.lr.ph.i.preheader, %.lr.ph.i\n  %.01.i = phi i64 [ %2, %.lr.ph.i ], [ 0, %.lr.ph.i.preheader ]\n  %1 = getelementptr i8, ptr null, i64 %.01.i\n  store i8 poison, ptr %1, align 1\n  %2 = add nuw i64 %.01.i, 1\n  %exitcond.not.i = icmp eq i64 %2, sub (i64 0, i64 ptrtoint (ptr getelementptr inbounds nuw (i8, ptr @\"?CountersBegin_placeholder@?A0xE34CF3CB@@3PADA\", i64 1) to i64))\n  br i1 %exitcond.not.i, label %\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit.loopexit\", label %.lr.ph.i\n\n\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit.loopexit\": ; preds = %.lr.ph.i\n  br label %\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit\"\n\n\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit\": ; preds = %\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit.loopexit\", %0\n  ret void\n}\n\n; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none)\ndefine void @\"?MergeCounters@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@23@@Z\"() local_unnamed_addr #2 {\n  tail call void @\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z\"()\n  ret void\n}\n\n; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)\ndefine noalias noundef ptr @\"??$?0PEAD@?$span@D$0?0@__ktl@std@@QEAA@PEAD_K@Z\"(ptr writeonly captures(none) initializes((8, 16)) %0, i64 %1) local_unnamed_addr #3 {\n  %3 = getelementptr i8, ptr %0, i64 8\n  store i64 %1, ptr %3, align 8\n  ret ptr null\n}\n\n; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none)\ndefine void @\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z\"() local_unnamed_addr #4 {\n  %1 = load i64, ptr inttoptr (i64 8 to ptr), align 8\n  %.not = icmp eq i64 %1, 0\n  br i1 %.not, label %._crit_edge, label %.lr.ph\n\n._crit_edge:                                      ; preds = %.lr.ph, %0\n  ret void\n\n.lr.ph:                                           ; preds = %0, %.lr.ph\n  %.01 = phi i64 [ %3, %.lr.ph ], [ 0, %0 ]\n  %2 = getelementptr i8, ptr null, i64 %.01\n  store i8 poison, ptr %2, align 1\n  %3 = add nuw i64 %.01, 1\n  %exitcond.not = icmp eq i64 %3, %1\n  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph\n}\n\n; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)\ndefine i64 @\"?size@?$span@E$0?0@__ktl@std@@QEBA_KXZ\"() local_unnamed_addr #5 {\n  %1 = load i64, ptr inttoptr (i64 8 to ptr), align 8\n  ret i64 %1\n}\n\n; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)\ndefine noalias ptr @\"??A?$span@E$0?0@__ktl@std@@QEBAAEAE_K@Z\"(i64 %0) local_unnamed_addr #6 {\n  %2 = getelementptr i8, ptr null, i64 %0\n  ret ptr %2\n}\n\nattributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(write, inaccessiblemem: none) }\nattributes #1 = { nofree norecurse nosync nounwind memory(write, inaccessiblemem: none) \"no-builtins\" }\nattributes #2 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) }\nattributes #3 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }\nattributes #4 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) \"no-builtins\" }\nattributes #5 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }\nattributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }\n\n```\n\n`opt bad.ll -passes=\"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" -S`"
      },
      {
        "author": "ilovepi",
        "body": "got it down a bit more\n\n```llvm\n; RUN: opt %s -passes=\"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" -S\ntarget datalayout = \"e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-windows-msvc19.33.0\"\n\n@\"?CountersBegin_placeholder@?A0xE34CF3CB@@3PADA\" = external global [1 x i8]\n\ndefine void @\"?MergeLiveData@LlvmProfdata@@QEAAXULiveData@1@@Z\"() {\n.lr.ph.i.preheader:\n  br label %.lr.ph.i\n\n.lr.ph.i:                                         ; preds = %.lr.ph.i, %.lr.ph.i.preheader\n  %.01.i = phi i64 [ %1, %.lr.ph.i ], [ 0, %.lr.ph.i.preheader ]\n  %0 = getelementptr i8, ptr null, i64 %.01.i\n  store i8 0, ptr %0, align 1\n  %1 = add i64 %.01.i, 1\n  %exitcond.not.i = icmp eq i64 %.01.i, sub (i64 0, i64 ptrtoint (ptr getelementptr inbounds nuw (i8, ptr @\"?CountersBegin_placeholder@?A0xE34CF3CB@@3PADA\", i64 1) to i64))\n  br i1 %exitcond.not.i, label %\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit.loopexit\", label %.lr.ph.i\n\n\"??$MergeData@EUlogical_and@__ktl@std@@@?A0xE34CF3CB@@YAXV?$span@W4byte@std@@$0?0@__ktl@std@@V?$span@$$CBW4byte@std@@$0?0@12@@Z.exit.loopexit\": ; preds = %.lr.ph.i\n  ret void\n}\n```"
      },
      {
        "author": "ilovepi",
        "body": "```cpp\n// RUN: clang -cc1 -triple x86_64-unknown-windows-msvc19.33.0 -O2 -ffreestanding -std=c++20 -ftrivial-auto-var-init=pattern -fms-compatibility -vectorize-loops -emit-llvm %s\nnamespace std {\nenum byte;\ntemplate <bool> using __enable_if_t = int;\ntemplate <bool __v> struct integral_constant {\n  static const bool value = __v;\n};\ntemplate <bool _Val> using _BoolConstant = integral_constant<_Val>;\ntemplate <class _Tp>\nusing __libcpp_remove_reference_t = __remove_reference_t(_Tp);\ntemplate <class _Tp>\nusing remove_reference_t = __libcpp_remove_reference_t<_Tp>;\ntemplate <class _Tp, class _Up>\nusing _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;\ntemplate <class _Tp, class _Up>\nconcept __same_as_impl = _IsSame<_Tp, _Up>::value;\ntemplate <class _Tp, class _Up>\nconcept same_as = __same_as_impl<_Up, _Tp>;\ntemplate <bool, class _IfRes, class> using conditional_t = _IfRes;\ntemplate <class _Tp> using __remove_cvref_t = __remove_cvref(_Tp);\ntemplate <class _Tp> using remove_cvref_t = __remove_cvref_t<_Tp>;\ntemplate <class> class numeric_limits;\ntemplate <> struct numeric_limits<unsigned long long> {\n  static constexpr long max() { return 0; }\n};\nconstexpr size_t dynamic_extent = numeric_limits<size_t>::max();\ntemplate <typename, size_t = dynamic_extent> class span;\ntemplate <typename _Tp> struct span<_Tp> {\n  using size_type = size_t;\n  span subspan(size_type, size_type __count) { return {0, __count}; }\n  size_type size() { return __size_; }\n  size_type size_bytes() { return __size_; }\n  _Tp &operator[](size_type __idx) { return __data_[__idx]; }\n  _Tp *__data_;\n  size_type __size_;\n};\ntemplate <class, class _Rhs>\nconcept assignable_from = requires(_Rhs __rhs) { __rhs; };\ntemplate <class _Tp> constexpr bool is_object_v = assignable_from<_Tp, _Tp>;\ntemplate <template <class> class, class>\nintegral_constant<true> __sfinae_test_impl(int);\ntemplate <template <class> class _Templ, class... _Args>\nusing _IsValidExpansion = decltype(__sfinae_test_impl<_Templ, _Args...>(0));\ntemplate <class _Tp>\nusing __test_for_primary_template = __enable_if_t<_IsSame<_Tp, _Tp>::value>;\ntemplate <class _Tp>\nusing __is_primary_template =\n    _IsValidExpansion<__test_for_primary_template, _Tp>;\ntemplate <class> struct __cond_value_type;\ntemplate <class _Tp>\n  requires is_object_v<_Tp>\nstruct __cond_value_type<_Tp> {\n  using value_type = _Tp;\n};\ntemplate <class> struct indirectly_readable_traits;\ntemplate <class _Tp>\nstruct indirectly_readable_traits<_Tp *> : __cond_value_type<_Tp> {};\ntemplate <class _Tp>\nconcept __dereferenceable = requires(_Tp __t) { __t; };\ntemplate <__dereferenceable _Tp> using iter_reference_t = decltype(*_Tp());\ntemplate <class _Ip>\nusing iter_value_t =\n    conditional_t<__is_primary_template<int>::value,\n                  indirectly_readable_traits<_Ip>, int>::value_type;\ntemplate <class _Ip>\nconcept contiguous_iterator =\n    same_as<iter_value_t<_Ip>, remove_cvref_t<iter_reference_t<_Ip>>>;\ntemplate <contiguous_iterator _It, class _EndOrSize>\nspan(_It, _EndOrSize) -> span<remove_reference_t<iter_reference_t<_It>>>;\n} // namespace std\nstruct LiveData {\n  std::span<std::byte> bitmap;\n};\nnamespace std {\ntemplate <class> struct bit_or;\n}\nchar BitmapBegin, BitmapBegin_0, BitmapEnd;\nstd::span<char> ProfBitmapData() {\n  return std::span(&BitmapBegin_0, &BitmapEnd - &BitmapBegin);\n}\ntemplate <typename T, template <typename> class>\nvoid MergeData(std::span<std::byte> to) {\n  std::span to_data{reinterpret_cast<T *>(0), to.size_bytes()};\n  for (size_t i; i < to_data.size(); ++i)\n    to_data[i] = 0;\n}\ntemplate <typename T, template <typename> class Op, typename FromT>\nvoid MergeSelfData(std::span<std::byte> to, std::span<FromT> from, char *) {\n  MergeData<T, Op>(to.subspan(0, from.size_bytes()));\n}\nvoid MergeLiveData() {\n  LiveData data;\n  MergeSelfData<char, std::bit_or>(data.bitmap, ProfBitmapData(), \"\");\n}\n```\nIn case it helps, heres a reproducer from the frontend (e.g. incase there's a frontend change that caused bad IR to be emitted)"
      },
      {
        "author": "ilovepi",
        "body": "Also, this is still an issue at ToT  (8889377f5c867ddb07658f6286f4e58e64e9e30a from today)."
      },
      {
        "author": "ilovepi",
        "body": "Bisected to 2016af56525734a3ac80d7256434e49e561befc2, #157545, @fhahn can you take a look?"
      },
      {
        "author": "fhahn",
        "body": "Yep thanks for the heads up"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}