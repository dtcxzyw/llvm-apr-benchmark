{
  "bug_id": "76789",
  "issue_url": "https://github.com/llvm/llvm-project/issues/76789",
  "bug_type": "miscompilation",
  "base_commit": "55172b7005a6f972272f6d79f2b0d15063bc1b1c",
  "knowledge_cutoff": "2024-01-03T08:36:48Z",
  "lit_test_dir": [
    "llvm/test/Analysis/BasicAA"
  ],
  "hints": {
    "fix_commit": "5f57ad85a1a7c46eb43eee3c7d93b11d8fd7fcfa",
    "components": [
      "AliasAnalysis",
      "BasicAliasAnalysis"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/AliasAnalysis.cpp": [
        [
          883,
          888
        ]
      ],
      "llvm/lib/Analysis/BasicAliasAnalysis.cpp": [
        [
          215,
          221
        ],
        [
          228,
          233
        ],
        [
          1502,
          1512
        ],
        [
          1522,
          1532
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/AliasAnalysis.cpp": [
        "llvm::isEscapeSource",
        "llvm::isNotVisibleOnUnwind"
      ],
      "llvm/lib/Analysis/BasicAliasAnalysis.cpp": [
        "BasicAAResult::aliasCheck",
        "EarliestEscapeInfo::isNotCapturedBefore"
      ]
    }
  },
  "patch": "commit 5f57ad85a1a7c46eb43eee3c7d93b11d8fd7fcfa\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Wed Jan 17 09:31:00 2024 +0100\n\n    [BasicAA] Remove incorrect rule about constant pointers (#76815)\n    \n    BasicAA currently says that any Constant cannot alias an identified\n    local object. This is not correct if the local object escaped, as it's\n    possible to create a pointer to the escaped object using an inttoptr\n    constant expression base.\n    \n    To compensate for this, make sure that inttoptr constant expressions are\n    treated as escape sources, just like inttoptr instructions. This ensures\n    that the optimization can still be applied if the local object is\n    non-escaping. This is sufficient to still optimize the original\n    motivating case from c53e2ecf0296a55d3c33c19fb70a3aa7f81f2732.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/76789.\n\ndiff --git a/llvm/include/llvm/Analysis/AliasAnalysis.h b/llvm/include/llvm/Analysis/AliasAnalysis.h\nindex e1cfb025fb65..d6f732d35fd4 100644\n--- a/llvm/include/llvm/Analysis/AliasAnalysis.h\n+++ b/llvm/include/llvm/Analysis/AliasAnalysis.h\n@@ -154,6 +154,8 @@ struct CaptureInfo {\n \n   /// Check whether Object is not captured before instruction I. If OrAt is\n   /// true, captures by instruction I itself are also considered.\n+  ///\n+  /// If I is nullptr, then captures at any point will be considered.\n   virtual bool isNotCapturedBefore(const Value *Object, const Instruction *I,\n                                    bool OrAt) = 0;\n };\ndiff --git a/llvm/lib/Analysis/AliasAnalysis.cpp b/llvm/lib/Analysis/AliasAnalysis.cpp\nindex da18279ae9b9..6eaaad5f332e 100644\n--- a/llvm/lib/Analysis/AliasAnalysis.cpp\n+++ b/llvm/lib/Analysis/AliasAnalysis.cpp\n@@ -883,6 +883,11 @@ bool llvm::isEscapeSource(const Value *V) {\n   if (isa<IntToPtrInst>(V))\n     return true;\n \n+  // Same for inttoptr constant expressions.\n+  if (auto *CE = dyn_cast<ConstantExpr>(V))\n+    if (CE->getOpcode() == Instruction::IntToPtr)\n+      return true;\n+\n   return false;\n }\n \ndiff --git a/llvm/lib/Analysis/BasicAliasAnalysis.cpp b/llvm/lib/Analysis/BasicAliasAnalysis.cpp\nindex ab1ab106659e..3178e2d27816 100644\n--- a/llvm/lib/Analysis/BasicAliasAnalysis.cpp\n+++ b/llvm/lib/Analysis/BasicAliasAnalysis.cpp\n@@ -215,7 +215,7 @@ bool EarliestEscapeInfo::isNotCapturedBefore(const Value *Object,\n   auto Iter = EarliestEscapes.insert({Object, nullptr});\n   if (Iter.second) {\n     Instruction *EarliestCapture = FindEarliestCapture(\n-        Object, *const_cast<Function *>(I->getFunction()),\n+        Object, *const_cast<Function *>(DT.getRoot()->getParent()),\n         /*ReturnCaptures=*/false, /*StoreCaptures=*/true, DT);\n     if (EarliestCapture) {\n       auto Ins = Inst2Obj.insert({EarliestCapture, {}});\n@@ -228,6 +228,10 @@ bool EarliestEscapeInfo::isNotCapturedBefore(const Value *Object,\n   if (!Iter.first->second)\n     return true;\n \n+  // No context instruction means any use is capturing.\n+  if (!I)\n+    return false;\n+\n   if (I == Iter.first->second) {\n     if (OrAt)\n       return false;\n@@ -1502,11 +1506,6 @@ AliasResult BasicAAResult::aliasCheck(const Value *V1, LocationSize V1Size,\n     if (isIdentifiedObject(O1) && isIdentifiedObject(O2))\n       return AliasResult::NoAlias;\n \n-    // Constant pointers can't alias with non-const isIdentifiedObject objects.\n-    if ((isa<Constant>(O1) && isIdentifiedObject(O2) && !isa<Constant>(O2)) ||\n-        (isa<Constant>(O2) && isIdentifiedObject(O1) && !isa<Constant>(O1)))\n-      return AliasResult::NoAlias;\n-\n     // Function arguments can't alias with things that are known to be\n     // unambigously identified at the function level.\n     if ((isa<Argument>(O1) && isIdentifiedFunctionLocal(O2)) ||\n@@ -1522,11 +1521,11 @@ AliasResult BasicAAResult::aliasCheck(const Value *V1, LocationSize V1Size,\n     // temporary store the nocapture argument's value in a temporary memory\n     // location if that memory location doesn't escape. Or it may pass a\n     // nocapture value to other functions as long as they don't capture it.\n-    if (isEscapeSource(O1) &&\n-        AAQI.CI->isNotCapturedBefore(O2, cast<Instruction>(O1), /*OrAt*/ true))\n+    if (isEscapeSource(O1) && AAQI.CI->isNotCapturedBefore(\n+                                  O2, dyn_cast<Instruction>(O1), /*OrAt*/ true))\n       return AliasResult::NoAlias;\n-    if (isEscapeSource(O2) &&\n-        AAQI.CI->isNotCapturedBefore(O1, cast<Instruction>(O2), /*OrAt*/ true))\n+    if (isEscapeSource(O2) && AAQI.CI->isNotCapturedBefore(\n+                                  O1, dyn_cast<Instruction>(O2), /*OrAt*/ true))\n       return AliasResult::NoAlias;\n   }\n \n",
  "tests": [
    {
      "file": "llvm/test/Analysis/BasicAA/inttoptr_constexpr.ll",
      "commands": [
        "opt -passes=aa-eval -print-all-alias-modref-info -disable-output < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "inttoptr_alloca_noescape",
          "test_body": "define void @inttoptr_alloca_noescape(i64 %offset) {\n  %a = alloca i8, align 1\n  %gep = getelementptr i8, ptr inttoptr (i64 -1 to ptr), i64 %offset\n  %load = load i8, ptr %gep, align 1\n  store i8 1, ptr %a, align 1\n  ret void\n}\n"
        },
        {
          "test_name": "inttoptr_alloca",
          "test_body": "define void @inttoptr_alloca() {\n  %a = alloca i8, align 1\n  %a.int = ptrtoint ptr %a to i64\n  %a.int.1 = add i64 %a.int, 1\n  %gep = getelementptr i8, ptr inttoptr (i64 -1 to ptr), i64 %a.int.1\n  %load = load i8, ptr %gep, align 1\n  store i8 1, ptr %a, align 1\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Wrong code at -O1 on x86_64-linux_gnu since LLVM-13",
    "body": "Clang at -O1 produces the wrong code since LLVM-13.\r\n\r\nBisected to 8f3d16905d75b07a933d01dc29677fe5867c1b3e, which was committed by @efriedma-quic \r\n\r\nCompiler explorer: https://godbolt.org/z/35no4xxfK\r\n\r\n```console\r\n% cat a.c\r\nint printf(const char *, ...);\r\nchar a;\r\nshort b;\r\nstatic short *c = &b;\r\nstatic short **f = &c;\r\nint g;\r\nint h(char *j, long k) {\r\n  int d = 0;\r\n  char *e = j + k;\r\n  for (; j < e; j++)\r\n    d = (d << 4) + *j;\r\n  return d;\r\n}\r\nint l(char j, long k) {\r\n  int i = h(&j, k);\r\n  return i;\r\n}\r\nint m(void);\r\nvoid n() { m(); }\r\nint m() {\r\n  int o;\r\n  char p = b = 4;\r\n  for (;;) {\r\n    g = 0;\r\n    for (; g <= 4; g++) {\r\n      p = 0;\r\n      for (; p <= 5; p++)\r\n        o = l(1, **f - 3);\r\n      a = (6 || 0) & o;\r\n    }\r\n    break;\r\n  }\r\n  short ***s = &f, ***q = s;\r\n  return &s != &q;\r\n}\r\nint main() {\r\n  n();\r\n  printf(\"%d\\n\", a);\r\n}\r\n%\r\n% clang -O0 a.c && ./a.out\r\n1\r\n% clang -O1 a.c && ./a.out\r\n0\r\n%\r\n```",
    "author": "shao-hua-li",
    "labels": [
      "miscompilation",
      "llvm:analysis"
    ],
    "comments": [
      {
        "author": "nikic",
        "body": "This basically reduces to:\r\n```llvm\r\ndefine i8 @test() {\r\n  %a = alloca i8\r\n  store i8 42, ptr %a\r\n  %a.int = ptrtoint ptr %a to i64\r\n  %a.int.1 = add i64 %a.int, 1\r\n  %gep = getelementptr i8, ptr inttoptr (i64 -1 to ptr), i64 %a.int.1\r\n  %load1 = load i8, ptr %gep\r\n  store i8 1, ptr %a\r\n  %load2 = load i8, ptr %gep\r\n  %sub = sub i8 %load1, %load2\r\n  ret i8 %sub\r\n}\r\n```\r\n\r\n`-passes=gvn` optimizes this to 0. (It actually happens in LICM, but basically the same issue.)\r\n\r\nIt's probably due to this check: https://github.com/llvm/llvm-project/blob/54378a7c2fd7f0ed0a3ea7ef08bc24896700e2c5/llvm/lib/Analysis/BasicAliasAnalysis.cpp#L1507-L1510\r\n\r\nI'm not sure whether this is a miscompile or not. It depends on the precise semantics of provenance around ptrtoint/inttoptr. It would be a miscompile under exposing ptrtoint + angelic inttoptr.\r\n\r\n(I haven't checked where the inttoptr pattern comes from, possibly it shouldn't be produced in the first place.)"
      },
      {
        "author": "nikic",
        "body": "The inttoptr is introduced by InstCombine like this: https://llvm.godbolt.org/z/nYdKKo7Ez\r\n\r\nI'm inclined to say that the bug is in BasicAA. I believe our current \"model\" is to be conservative with inttoptr and assume it can access all escaped objects."
      }
    ]
  }
}