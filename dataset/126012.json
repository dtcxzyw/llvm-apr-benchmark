{
  "bug_id": "126012",
  "issue_url": "https://github.com/llvm/llvm-project/issues/126012",
  "bug_type": "miscompilation",
  "base_commit": "52a02b6d1e0c6b492495ff79a3a06ce93e6180b8",
  "knowledge_cutoff": "2025-02-06T05:45:23Z",
  "lit_test_dir": [
    "llvm/test/Transforms/IndVarSimplify"
  ],
  "hints": {
    "fix_commit": "7aed53eb1982113e825534f0f66d0a0e46e7a5ed",
    "components": [
      "ScalarEvolution"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/ScalarEvolution.cpp": [
        [
          12400,
          12405
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/ScalarEvolution.cpp": [
        "ScalarEvolution::isImpliedViaMerge"
      ]
    }
  },
  "patch": "commit 7aed53eb1982113e825534f0f66d0a0e46e7a5ed\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Mon Feb 10 10:07:21 2025 +0100\n\n    [ScalarEvolution] Handle addrec incoming value in isImpliedViaMerge() (#126236)\n    \n    The code already guards against values coming from a previous iteration\n    using properlyDominates(). However, addrecs are considered to properly\n    dominate the loop they are defined in.\n    \n    Handle this special case separately, by checking for expressions that\n    have computable loop evolution (this should cover cases like a zext of\n    an addrec as well).\n    \n    I considered changing the definition of properlyDominates() instead, but\n    decided against it. The current definition is useful in other context,\n    e.g. when deciding whether an expression is safe to expand in a given\n    block.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/126012.\n\ndiff --git a/llvm/lib/Analysis/ScalarEvolution.cpp b/llvm/lib/Analysis/ScalarEvolution.cpp\nindex f89887118d8d..46a5c44f4e41 100644\n--- a/llvm/lib/Analysis/ScalarEvolution.cpp\n+++ b/llvm/lib/Analysis/ScalarEvolution.cpp\n@@ -12400,6 +12400,12 @@ bool ScalarEvolution::isImpliedViaMerge(CmpPredicate Pred, const SCEV *LHS,\n       // iteration of a loop.\n       if (!properlyDominates(L, LBB))\n         return false;\n+      // Addrecs are considered to properly dominate their loop, so are missed\n+      // by the previous check. Discard any values that have computable\n+      // evolution in this loop.\n+      if (auto *Loop = LI.getLoopFor(LBB))\n+        if (hasComputableLoopEvolution(L, Loop))\n+          return false;\n       if (!ProvedEasily(L, RHS))\n         return false;\n     }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/IndVarSimplify/pr126012.ll",
      "commands": [
        "opt -S -passes=indvars < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define i32 @test() {\nentry:\n  br label %for.preheader\n\nfor.preheader:                                    ; preds = %for.inc, %entry\n  %indvar1 = phi i32 [ 0, %entry ], [ %phi, %for.inc ]\n  %indvar2 = phi i32 [ 1, %entry ], [ %indvar3, %for.inc ]\n  %indvar3 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]\n  %cond1 = icmp eq i32 %indvar3, 0\n  br i1 %cond1, label %for.inc, label %for.end\n\nfor.end:                                          ; preds = %for.preheader\n  %cmp = icmp sgt i32 %indvar2, 0\n  %ext = zext i1 %cmp to i32\n  br label %for.inc\n\nfor.inc:                                          ; preds = %for.end, %for.preheader\n  %phi = phi i32 [ %ext, %for.end ], [ 0, %for.preheader ]\n  %inc = add i32 %indvar3, 1\n  %exitcond = icmp eq i32 %indvar3, 2\n  br i1 %exitcond, label %for.exit, label %for.preheader\n\nfor.exit:                                         ; preds = %for.inc\n  ret i32 %indvar1\n}\n",
          "additional_args": "-src-unroll=4 -tgt-unroll=4"
        }
      ]
    }
  ],
  "issue": {
    "title": "[IndVarSimplify] Miscompilation at O2",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/UTnMBe\n```\n; bin/opt -passes=indvars reduced.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@.str = constant [4 x i8] c\"%d\\0A\\00\"\n\ndefine i32 @main() {\nentry:\n  br label %for.cond1.preheader.i.i\n\nfor.cond1.preheader.i.i:                          ; preds = %for.inc18.i.i, %entry\n  %.pre.i.i = phi i64 [ 0, %entry ], [ %1, %for.inc18.i.i ]\n  %j.sroa.0.043.i.i = phi i64 [ 1, %entry ], [ %storemerge42.i.i, %for.inc18.i.i ]\n  %storemerge42.i.i = phi i64 [ 0, %entry ], [ %inc22.i.i, %for.inc18.i.i ]\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i\n\nfor.end.i.i:                                      ; preds = %for.cond1.preheader.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0\n  %dec.348.i.i = add i64 %.pre.i.i, 1\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0\n  br label %for.inc18.i.i\n\nfor.inc18.i.i:                                    ; preds = %for.end.i.i, %for.cond1.preheader.i.i\n  %1 = phi i64 [ %spec.select.i.i, %for.end.i.i ], [ 0, %for.cond1.preheader.i.i ]\n  %inc22.i.i = add i64 %storemerge42.i.i, 1\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i\n\ng.exit:                                           ; preds = %for.inc18.i.i\n  %conv = trunc i64 %.pre.i.i to i32\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n  ret i32 0\n}\n\ndeclare i32 @printf(ptr, ...)\n```\nBefore:\n```\nEntering function main\n  br label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 0\n    phi i64 %j.sroa.0.043.i.i -> i64 1\n    phi i64 %storemerge42.i.i -> i64 0\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> T\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 0\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 1\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 0\n    phi i64 %j.sroa.0.043.i.i -> i64 0\n    phi i64 %storemerge42.i.i -> i64 1\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> F\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 1\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 0\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 0\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 2\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 0\n    phi i64 %j.sroa.0.043.i.i -> i64 1\n    phi i64 %storemerge42.i.i -> i64 2\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 1\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 1\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 1\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 3\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 1\n    phi i64 %j.sroa.0.043.i.i -> i64 2\n    phi i64 %storemerge42.i.i -> i64 3\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 2\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 2\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 2\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 4\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 2\n    phi i64 %j.sroa.0.043.i.i -> i64 3\n    phi i64 %storemerge42.i.i -> i64 4\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 3\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 3\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 3\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 5\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 3\n    phi i64 %j.sroa.0.043.i.i -> i64 4\n    phi i64 %storemerge42.i.i -> i64 5\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 4\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 4\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 4\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 6\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 4\n    phi i64 %j.sroa.0.043.i.i -> i64 5\n    phi i64 %storemerge42.i.i -> i64 6\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 5\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 5\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 5\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 7\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 5\n    phi i64 %j.sroa.0.043.i.i -> i64 6\n    phi i64 %storemerge42.i.i -> i64 7\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 6\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 6\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 6\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 8\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 6\n    phi i64 %j.sroa.0.043.i.i -> i64 7\n    phi i64 %storemerge42.i.i -> i64 8\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 7\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 7\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 7\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 9\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 7\n    phi i64 %j.sroa.0.043.i.i -> i64 8\n    phi i64 %storemerge42.i.i -> i64 9\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %0 = icmp sgt i64 %j.sroa.0.043.i.i, 0 -> T\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 8\n  %spec.select.i.i = select i1 %0, i64 %dec.348.i.i, i64 0 -> i64 8\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %1 -> i64 8\n  %inc22.i.i = add i64 %storemerge42.i.i, 1 -> i64 10\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> T\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %g.exit\n  %conv = trunc i64 %.pre.i.i to i32 -> i32 7\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n    Printf: 7\n   -> i32 2\n  ret i32 0\nExiting function main\n```\nAfter:\n```\n; ModuleID = 'reduced.ll'\nsource_filename = \"reduced.ll\"\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@.str = constant [4 x i8] c\"%d\\0A\\00\"\n\ndefine i32 @main() {\nentry:\n  br label %for.cond1.preheader.i.i\n\nfor.cond1.preheader.i.i:                          ; preds = %for.inc18.i.i, %entry\n  %.pre.i.i = phi i64 [ 0, %entry ], [ %0, %for.inc18.i.i ]\n  %storemerge42.i.i = phi i64 [ 0, %entry ], [ %inc22.i.i, %for.inc18.i.i ]\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i\n\nfor.end.i.i:                                      ; preds = %for.cond1.preheader.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0\n  br label %for.inc18.i.i\n\nfor.inc18.i.i:                                    ; preds = %for.end.i.i, %for.cond1.preheader.i.i\n  %0 = phi i64 [ %spec.select.i.i, %for.end.i.i ], [ 0, %for.cond1.preheader.i.i ]\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i\n\ng.exit:                                           ; preds = %for.inc18.i.i\n  %.pre.i.i.lcssa = phi i64 [ %.pre.i.i, %for.inc18.i.i ]\n  %conv = trunc i64 %.pre.i.i.lcssa to i32\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n  ret i32 0\n}\n\ndeclare i32 @printf(ptr, ...)\n```\n```\nEntering function main\n  br label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 0\n    phi i64 %storemerge42.i.i -> i64 0\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> T\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 0\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 1\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 0\n    phi i64 %storemerge42.i.i -> i64 1\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 1\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 1\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 1\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 2\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 1\n    phi i64 %storemerge42.i.i -> i64 2\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 2\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 2\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 2\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 3\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 2\n    phi i64 %storemerge42.i.i -> i64 3\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 3\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 3\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 3\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 4\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 3\n    phi i64 %storemerge42.i.i -> i64 4\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 4\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 4\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 4\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 5\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 4\n    phi i64 %storemerge42.i.i -> i64 5\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 5\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 5\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 5\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 6\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 5\n    phi i64 %storemerge42.i.i -> i64 6\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 6\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 6\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 6\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 7\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 6\n    phi i64 %storemerge42.i.i -> i64 7\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 7\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 7\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 7\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 8\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 7\n    phi i64 %storemerge42.i.i -> i64 8\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 8\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 8\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 8\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 9\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> F\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %for.cond1.preheader.i.i\n    phi i64 %.pre.i.i -> i64 8\n    phi i64 %storemerge42.i.i -> i64 9\n  %tobool.not.i.i = icmp eq i64 %storemerge42.i.i, 0 -> F\n  br i1 %tobool.not.i.i, label %for.inc18.i.i, label %for.end.i.i jump to %for.end.i.i\n  %dec.348.i.i = add i64 %.pre.i.i, 1 -> i64 9\n  %spec.select.i.i = select i1 true, i64 %dec.348.i.i, i64 0 -> i64 9\n  br label %for.inc18.i.i jump to %for.inc18.i.i\n    phi i64 %0 -> i64 9\n  %inc22.i.i = add nuw nsw i64 %storemerge42.i.i, 1 -> i64 10\n  %exitcond50.not.i.i = icmp eq i64 %storemerge42.i.i, 9 -> T\n  br i1 %exitcond50.not.i.i, label %g.exit, label %for.cond1.preheader.i.i jump to %g.exit\n    phi i64 %.pre.i.i.lcssa -> i64 8\n  %conv = trunc i64 %.pre.i.i.lcssa to i32 -> i32 8\n  %call1 = call i32 (ptr, ...) @printf(ptr @.str, i32 %conv)\n    Printf: 8\n   -> i32 2\n  ret i32 0\nExiting function main\n```\nllvm version: 52fc6ffcda0895c0c7b976ad1f5cb5a282b571d2",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:SCEV"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "Reduced reproducer: https://alive2.llvm.org/ce/z/_x96gs\n```\n; bin/opt -passes=indvars reduced.ll -S --debug\ndefine i32 @src() {\nentry:\n  br label %for.preheader\n\nfor.preheader:\n  %indvar1 = phi i32 [ 0, %entry ], [ %phi, %for.inc ]\n  %indvar2 = phi i32 [ 1, %entry ], [ %indvar3, %for.inc ]\n  %indvar3 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]\n  %cond1 = icmp eq i32 %indvar3, 0\n  br i1 %cond1, label %for.inc, label %for.end\n\nfor.end:\n  %cmp = icmp sgt i32 %indvar2, 0\n  %ext = zext i1 %cmp to i32\n  br label %for.inc\n\nfor.inc:\n  %phi = phi i32 [ %ext, %for.end ], [ 0, %for.preheader ]\n  %inc = add i32 %indvar3, 1\n  %exitcond = icmp eq i32 %indvar3, 2\n  br i1 %exitcond, label %for.exit, label %for.preheader\n\nfor.exit:\n  ret i32 %indvar1\n}\n\n```\n```\nINDVARS: Eliminated comparison:   %cmp = icmp sgt i32 %indvar2, 0\n\ndefine i32 @src() {\nentry:\n  br label %for.preheader\n\nfor.preheader:                                    ; preds = %for.inc, %entry\n  %indvar1 = phi i32 [ 0, %entry ], [ %phi, %for.inc ]\n  %indvar3 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]\n  %cond1 = icmp eq i32 %indvar3, 0\n  br i1 %cond1, label %for.inc, label %for.end\n\nfor.end:                                          ; preds = %for.preheader\n  %ext = zext i1 true to i32\n  br label %for.inc\n\nfor.inc:                                          ; preds = %for.end, %for.preheader\n  %phi = phi i32 [ %ext, %for.end ], [ 0, %for.preheader ]\n  %inc = add nuw nsw i32 %indvar3, 1\n  %exitcond = icmp eq i32 %indvar3, 2\n  br i1 %exitcond, label %for.exit, label %for.preheader\n\nfor.exit:                                         ; preds = %for.inc\n  %indvar1.lcssa = phi i32 [ %indvar1, %for.inc ]\n  ret i32 %indvar1.lcssa\n}\n```\n`ScalarEvolution::isImpliedViaMerge(sgt, %indvar2, 0, {0,+,1}<nuw><nsw><%for.preheader>(= %indvar3), 0)` wrongly returns true.\nI can't quite understand why `%indvar3` properly dominates `%for.preheader`: https://github.com/llvm/llvm-project/blob/26ecddb05d13c101ccd840a6710eb5f8b82de841/llvm/lib/Analysis/ScalarEvolution.cpp#L14131-L14141\n\n@nikic @fhahn Can you help fix this issue?\n\n\n"
      },
      {
        "author": "nikic",
        "body": "Related previous fix: https://reviews.llvm.org/D101829"
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "16370e02a715717dd585537f02eb3e3a3221637e"
}