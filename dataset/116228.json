{
  "bug_id": "116228",
  "issue_url": "https://github.com/llvm/llvm-project/issues/116228",
  "bug_type": "crash",
  "base_commit": "fbbea8929ffd2fae57a6013912455d566b884e12",
  "knowledge_cutoff": "2024-11-14T13:46:57Z",
  "lit_test_dir": [
    "llvm/test/Analysis/MemorySSA"
  ],
  "hints": {
    "fix_commit": "46e04f7fe5c0f01ba452489bb966bdf2d560a63d",
    "components": [
      "MemorySSAUpdater"
    ],
    "bug_location_lineno": {
      "llvm/include/llvm/Analysis/MemorySSAUpdater.h": [
        [
          260,
          282
        ]
      ],
      "llvm/lib/Analysis/MemorySSAUpdater.cpp": [
        [
          565,
          588
        ],
        [
          593,
          602
        ],
        [
          615,
          621
        ],
        [
          668,
          675
        ],
        [
          692,
          700
        ],
        [
          716,
          728
        ],
        [
          741,
          747
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/MemorySSAUpdater.cpp": [
        "MemorySSAUpdater::cloneUsesAndDefs",
        "MemorySSAUpdater::privateUpdateExitBlocksForClonedLoop",
        "MemorySSAUpdater::updateForClonedBlockIntoPred",
        "MemorySSAUpdater::updateForClonedLoop",
        "getNewDefiningAccessForClone",
        "onlySingleValue"
      ]
    }
  },
  "patch": "commit 46e04f7fe5c0f01ba452489bb966bdf2d560a63d\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Mon Dec 9 12:21:49 2024 +0100\n\n    [MemorySSA] Handle MemoryDef optimized away during cloning (#117883)\n    \n    When determining the replacement access during cloning, we currently\n    leave accesses for instructions that are not in the VMap alone. This is\n    correct if the instruction is not in VMap because it hasn't been cloned,\n    but not if it has been cloned and then removed. In that case, we should\n    walk up to the defining access, like in other simplification cases.\n    \n    To distinguish the two cases, pass in a callback that queries whether\n    the instruction is part of the cloned region.\n    \n    An alternative to this would be to delay removal of dead instructions in\n    SimpleLoopUnswitch until after MSSA cloning.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/116228.\n\ndiff --git a/llvm/include/llvm/Analysis/MemorySSAUpdater.h b/llvm/include/llvm/Analysis/MemorySSAUpdater.h\nindex 055feceefb05..b8e08f4b7842 100644\n--- a/llvm/include/llvm/Analysis/MemorySSAUpdater.h\n+++ b/llvm/include/llvm/Analysis/MemorySSAUpdater.h\n@@ -260,23 +260,32 @@ private:\n   MemoryAccess *tryRemoveTrivialPhi(MemoryPhi *Phi, RangeType &Operands);\n   void tryRemoveTrivialPhis(ArrayRef<WeakVH> UpdatedPHIs);\n   void fixupDefs(const SmallVectorImpl<WeakVH> &);\n-  // Clone all uses and defs from BB to NewBB given a 1:1 map of all\n-  // instructions and blocks cloned, and a map of MemoryPhi : Definition\n-  // (MemoryAccess Phi or Def). VMap maps old instructions to cloned\n-  // instructions and old blocks to cloned blocks. MPhiMap, is created in the\n-  // caller of this private method, and maps existing MemoryPhis to new\n-  // definitions that new MemoryAccesses must point to. These definitions may\n-  // not necessarily be MemoryPhis themselves, they may be MemoryDefs. As such,\n-  // the map is between MemoryPhis and MemoryAccesses, where the MemoryAccesses\n-  // may be MemoryPhis or MemoryDefs and not MemoryUses.\n-  // If CloneWasSimplified = true, the clone was exact. Otherwise, assume that\n-  // the clone involved simplifications that may have: (1) turned a MemoryUse\n-  // into an instruction that MemorySSA has no representation for, or (2) turned\n-  // a MemoryDef into a MemoryUse or an instruction that MemorySSA has no\n-  // representation for. No other cases are supported.\n+  /// Clone all uses and defs from BB to NewBB given a 1:1 map of all\n+  /// instructions and blocks cloned, and a map of MemoryPhi : Definition\n+  /// (MemoryAccess Phi or Def).\n+  ///\n+  /// \\param VMap Maps old instructions to cloned instructions and old blocks\n+  ///        to cloned blocks\n+  /// \\param MPhiMap, is created in the caller of this private method, and maps\n+  ///        existing MemoryPhis to new definitions that new MemoryAccesses\n+  ///        must point to. These definitions may not necessarily be MemoryPhis\n+  ///        themselves, they may be MemoryDefs. As such, the map is between\n+  ///        MemoryPhis and MemoryAccesses, where the MemoryAccesses may be\n+  ///        MemoryPhis or MemoryDefs and not MemoryUses.\n+  /// \\param IsInClonedRegion Determines whether a basic block was cloned.\n+  ///        References to accesses outside the cloned region will not be\n+  ///        remapped.\n+  /// \\param CloneWasSimplified If false, the clone was exact. Otherwise,\n+  ///        assume that the clone involved simplifications that may have:\n+  ///        (1) turned a MemoryUse into an instruction that MemorySSA has no\n+  ///        representation for, or (2) turned a MemoryDef into a MemoryUse or\n+  ///        an instruction that MemorySSA has no representation for. No other\n+  ///        cases are supported.\n   void cloneUsesAndDefs(BasicBlock *BB, BasicBlock *NewBB,\n                         const ValueToValueMapTy &VMap, PhiToDefMap &MPhiMap,\n+                        function_ref<bool(BasicBlock *)> IsInClonedRegion,\n                         bool CloneWasSimplified = false);\n+\n   template <typename Iter>\n   void privateUpdateExitBlocksForClonedLoop(ArrayRef<BasicBlock *> ExitBlocks,\n                                             Iter ValuesBegin, Iter ValuesEnd,\ndiff --git a/llvm/lib/Analysis/MemorySSAUpdater.cpp b/llvm/lib/Analysis/MemorySSAUpdater.cpp\nindex f672bd0e1e13..050b827388d3 100644\n--- a/llvm/lib/Analysis/MemorySSAUpdater.cpp\n+++ b/llvm/lib/Analysis/MemorySSAUpdater.cpp\n@@ -565,24 +565,26 @@ static MemoryAccess *onlySingleValue(MemoryPhi *MP) {\n   return MA;\n }\n \n-static MemoryAccess *getNewDefiningAccessForClone(MemoryAccess *MA,\n-                                                  const ValueToValueMapTy &VMap,\n-                                                  PhiToDefMap &MPhiMap,\n-                                                  MemorySSA *MSSA) {\n+static MemoryAccess *getNewDefiningAccessForClone(\n+    MemoryAccess *MA, const ValueToValueMapTy &VMap, PhiToDefMap &MPhiMap,\n+    MemorySSA *MSSA, function_ref<bool(BasicBlock *BB)> IsInClonedRegion) {\n   MemoryAccess *InsnDefining = MA;\n   if (MemoryDef *DefMUD = dyn_cast<MemoryDef>(InsnDefining)) {\n-    if (!MSSA->isLiveOnEntryDef(DefMUD)) {\n-      Instruction *DefMUDI = DefMUD->getMemoryInst();\n-      assert(DefMUDI && \"Found MemoryUseOrDef with no Instruction.\");\n-      if (Instruction *NewDefMUDI =\n-              cast_or_null<Instruction>(VMap.lookup(DefMUDI))) {\n-        InsnDefining = MSSA->getMemoryAccess(NewDefMUDI);\n-        if (!InsnDefining || isa<MemoryUse>(InsnDefining)) {\n-          // The clone was simplified, it's no longer a MemoryDef, look up.\n-          InsnDefining = getNewDefiningAccessForClone(\n-              DefMUD->getDefiningAccess(), VMap, MPhiMap, MSSA);\n-        }\n-      }\n+    if (MSSA->isLiveOnEntryDef(DefMUD))\n+      return DefMUD;\n+\n+    // If the MemoryDef is not part of the cloned region, leave it alone.\n+    Instruction *DefMUDI = DefMUD->getMemoryInst();\n+    assert(DefMUDI && \"Found MemoryUseOrDef with no Instruction.\");\n+    if (!IsInClonedRegion(DefMUDI->getParent()))\n+      return DefMUD;\n+\n+    auto *NewDefMUDI = cast_or_null<Instruction>(VMap.lookup(DefMUDI));\n+    InsnDefining = NewDefMUDI ? MSSA->getMemoryAccess(NewDefMUDI) : nullptr;\n+    if (!InsnDefining || isa<MemoryUse>(InsnDefining)) {\n+      // The clone was simplified, it's no longer a MemoryDef, look up.\n+      InsnDefining = getNewDefiningAccessForClone(\n+          DefMUD->getDefiningAccess(), VMap, MPhiMap, MSSA, IsInClonedRegion);\n     }\n   } else {\n     MemoryPhi *DefPhi = cast<MemoryPhi>(InsnDefining);\n@@ -593,10 +595,10 @@ static MemoryAccess *getNewDefiningAccessForClone(MemoryAccess *MA,\n   return InsnDefining;\n }\n \n-void MemorySSAUpdater::cloneUsesAndDefs(BasicBlock *BB, BasicBlock *NewBB,\n-                                        const ValueToValueMapTy &VMap,\n-                                        PhiToDefMap &MPhiMap,\n-                                        bool CloneWasSimplified) {\n+void MemorySSAUpdater::cloneUsesAndDefs(\n+    BasicBlock *BB, BasicBlock *NewBB, const ValueToValueMapTy &VMap,\n+    PhiToDefMap &MPhiMap, function_ref<bool(BasicBlock *)> IsInClonedRegion,\n+    bool CloneWasSimplified) {\n   const MemorySSA::AccessList *Acc = MSSA->getBlockAccesses(BB);\n   if (!Acc)\n     return;\n@@ -615,7 +617,7 @@ void MemorySSAUpdater::cloneUsesAndDefs(BasicBlock *BB, BasicBlock *NewBB,\n         MemoryAccess *NewUseOrDef = MSSA->createDefinedAccess(\n             NewInsn,\n             getNewDefiningAccessForClone(MUD->getDefiningAccess(), VMap,\n-                                         MPhiMap, MSSA),\n+                                         MPhiMap, MSSA, IsInClonedRegion),\n             /*Template=*/CloneWasSimplified ? nullptr : MUD,\n             /*CreationMustSucceed=*/false);\n         if (NewUseOrDef)\n@@ -668,8 +670,13 @@ void MemorySSAUpdater::updateForClonedLoop(const LoopBlocksRPO &LoopBlocks,\n                                            ArrayRef<BasicBlock *> ExitBlocks,\n                                            const ValueToValueMapTy &VMap,\n                                            bool IgnoreIncomingWithNoClones) {\n-  PhiToDefMap MPhiMap;\n+  SmallSetVector<BasicBlock *, 16> Blocks;\n+  for (BasicBlock *BB : concat<BasicBlock *const>(LoopBlocks, ExitBlocks))\n+    Blocks.insert(BB);\n \n+  auto IsInClonedRegion = [&](BasicBlock *BB) { return Blocks.contains(BB); };\n+\n+  PhiToDefMap MPhiMap;\n   auto FixPhiIncomingValues = [&](MemoryPhi *Phi, MemoryPhi *NewPhi) {\n     assert(Phi && NewPhi && \"Invalid Phi nodes.\");\n     BasicBlock *NewPhiBB = NewPhi->getBlock();\n@@ -692,9 +699,10 @@ void MemorySSAUpdater::updateForClonedLoop(const LoopBlocksRPO &LoopBlocks,\n         continue;\n \n       // Determine incoming value and add it as incoming from IncBB.\n-      NewPhi->addIncoming(\n-          getNewDefiningAccessForClone(IncomingAccess, VMap, MPhiMap, MSSA),\n-          IncBB);\n+      NewPhi->addIncoming(getNewDefiningAccessForClone(IncomingAccess, VMap,\n+                                                       MPhiMap, MSSA,\n+                                                       IsInClonedRegion),\n+                          IncBB);\n     }\n     if (auto *SingleAccess = onlySingleValue(NewPhi)) {\n       MPhiMap[Phi] = SingleAccess;\n@@ -716,13 +724,13 @@ void MemorySSAUpdater::updateForClonedLoop(const LoopBlocksRPO &LoopBlocks,\n       MPhiMap[MPhi] = NewPhi;\n     }\n     // Update Uses and Defs.\n-    cloneUsesAndDefs(BB, NewBlock, VMap, MPhiMap);\n+    cloneUsesAndDefs(BB, NewBlock, VMap, MPhiMap, IsInClonedRegion);\n   };\n \n-  for (auto *BB : llvm::concat<BasicBlock *const>(LoopBlocks, ExitBlocks))\n+  for (auto *BB : Blocks)\n     ProcessBlock(BB);\n \n-  for (auto *BB : llvm::concat<BasicBlock *const>(LoopBlocks, ExitBlocks))\n+  for (auto *BB : Blocks)\n     if (MemoryPhi *MPhi = MSSA->getMemoryAccess(BB))\n       if (MemoryAccess *NewPhi = MPhiMap.lookup(MPhi))\n         FixPhiIncomingValues(MPhi, cast<MemoryPhi>(NewPhi));\n@@ -741,7 +749,9 @@ void MemorySSAUpdater::updateForClonedBlockIntoPred(\n   PhiToDefMap MPhiMap;\n   if (MemoryPhi *MPhi = MSSA->getMemoryAccess(BB))\n     MPhiMap[MPhi] = MPhi->getIncomingValueForBlock(P1);\n-  cloneUsesAndDefs(BB, P1, VM, MPhiMap, /*CloneWasSimplified=*/true);\n+  cloneUsesAndDefs(\n+      BB, P1, VM, MPhiMap, [&](BasicBlock *CheckBB) { return BB == CheckBB; },\n+      /*CloneWasSimplified=*/true);\n }\n \n template <typename Iter>\n",
  "tests": [
    {
      "file": "llvm/test/Analysis/MemorySSA/loop-rotate-update.ll",
      "commands": [
        "opt -disable-output -passes=\"loop-mssa(loop-rotate),print<memoryssa>\" -verify-memoryssa < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n\n\n\ndefine void @test(ptr %p) {\nentry:\n  br label %loop\n\nloop:\n  store ptr null, ptr %p\n  %val1 = load ptr, ptr %p\n  %cmp = icmp eq ptr %val1, null\n  br i1 %cmp, label %exit, label %loop.latch\n\nloop.latch:\n  %val2 = load ptr, ptr %p\n  br label %loop\n\nexit:\n  ret void\n}"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/MemorySSA/pr116227.ll",
      "commands": [
        "opt -disable-output -passes=\"loop-mssa(simple-loop-unswitch<nontrivial>),print<memoryssa>\" -verify-memoryssa < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndeclare ptr @malloc() allockind(\"alloc,uninitialized\")\n\n\n\n\ndefine void @test(i1 %arg) {\nentry:\n  br label %for.body\n\nfor.body:\n  %call.i = call ptr @malloc()\n  %cmp.i = icmp ne ptr %call.i, null\n  %or.cond.i = select i1 %cmp.i, i1 %arg, i1 false\n  br i1 %or.cond.i, label %exit, label %for.body\n\nexit:\n  ret void\n}\n\n\n\n\n\ndefine void @test_extra_defs(ptr %p, i1 %arg) {\nentry:\n  store i8 1, ptr %p\n  br label %for.body\n\nfor.body:\n  store i8 2, ptr %p\n  %call.i = call ptr @malloc()\n  %cmp.i = icmp ne ptr %call.i, null\n  %or.cond.i = select i1 %cmp.i, i1 %arg, i1 false\n  br i1 %or.cond.i, label %exit, label %for.body\n\nexit:\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[clang] Crash at -O3: Assertion `MA->use_empty() && \"Trying to remove memory access that still has uses\"' failed",
    "body": "When I compiled the code with -O3, it crashed:\r\n\r\nBisected to https://github.com/llvm/llvm-project/commit/5a3e3675f6be3c49fb1a305202888cce4d916ba6, which was committed by @durin42 \r\n\r\nCompiler explorer: https://godbolt.org/z/3Wc1jdx6d\r\n\r\n```c\r\nstruct a {\r\n  struct a *b\r\n};\r\nint c, g, i;\r\nvoid *malloc();\r\nint d() {\r\n  struct a *e = malloc(c);\r\n  if (e == 0)\r\n    return 1;\r\n  for (int f = 0; f < c; f++)\r\n    e[f].b = 1 ? &e[1] : 0;\r\n}\r\nint h() {\r\n  for (; g; g++)\r\n    ;\r\n  return 0;\r\n}\r\nvoid j() {\r\n  for (;;)\r\n    for (; h() + i; i++)\r\n      d();\r\n}\r\nint main() {}\r\n```\r\nCrash is: \r\n\r\n```\r\nclang: /root/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:1840: void llvm::MemorySSA::removeFromLookups(llvm::MemoryAccess*): Assertion `MA->use_empty() && \"Trying to remove memory access that still has uses\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/clang -gdwarf-4 -g -o /app/output.s -mllvm --x86-asm-syntax=intel -fno-verbose-asm -S --gcc-toolchain=/opt/compiler-explorer/gcc-snapshot -fcolor-diagnostics -fno-crash-diagnostics -O3 -Wall -Wextra <source>\r\n1.\t<eof> parser at end of file\r\n2.\tOptimizer\r\n3.\tRunning pass \"require<globals-aa>,function(invalidate<aa>),require<profile-summary>,cgscc(devirt<4>(inline,function-attrs<skip-non-recursive-function-attrs>,argpromotion,openmp-opt-cgscc,function<eager-inv;no-rerun>(sroa<modify-cfg>,early-cse<memssa>,speculative-execution<only-if-divergent-target>,jump-threading,correlated-propagation,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,instcombine<max-iterations=1;no-verify-fixpoint>,aggressive-instcombine,libcalls-shrinkwrap,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,reassociate,constraint-elimination,loop-mssa(loop-instsimplify,loop-simplifycfg,licm<no-allowspeculation>,loop-rotate<header-duplication;no-prepare-for-lto>,licm<allowspeculation>,simple-loop-unswitch<nontrivial;trivial>),simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,instcombine<max-iterations=1;no-verify-fixpoint>,loop(loop-idiom,indvars,simple-loop-unswitch<nontrivial;trivial>,loop-deletion,loop-unroll-full),sroa<modify-cfg>,vector-combine,mldst-motion<no-split-footer-bb>,gvn<>,sccp,bdce,instcombine<max-iterations=1;no-verify-fixpoint>,jump-threading,correlated-propagation,adce,memcpyopt,dse,move-auto-init,loop-mssa(licm<allowspeculation>),coro-elide,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,instcombine<max-iterations=1;no-verify-fixpoint>),function-attrs,function(require<should-not-run-function-passes>),coro-split,coro-annotation-elide)),function(invalidate<should-not-run-function-passes>),cgscc(devirt<4>())\" on module \"<source>\"\r\n4.\tRunning pass \"cgscc(devirt<4>(inline,function-attrs<skip-non-recursive-function-attrs>,argpromotion,openmp-opt-cgscc,function<eager-inv;no-rerun>(sroa<modify-cfg>,early-cse<memssa>,speculative-execution<only-if-divergent-target>,jump-threading,correlated-propagation,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,instcombine<max-iterations=1;no-verify-fixpoint>,aggressive-instcombine,libcalls-shrinkwrap,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,reassociate,constraint-elimination,loop-mssa(loop-instsimplify,loop-simplifycfg,licm<no-allowspeculation>,loop-rotate<header-duplication;no-prepare-for-lto>,licm<allowspeculation>,simple-loop-unswitch<nontrivial;trivial>),simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,instcombine<max-iterations=1;no-verify-fixpoint>,loop(loop-idiom,indvars,simple-loop-unswitch<nontrivial;trivial>,loop-deletion,loop-unroll-full),sroa<modify-cfg>,vector-combine,mldst-motion<no-split-footer-bb>,gvn<>,sccp,bdce,instcombine<max-iterations=1;no-verify-fixpoint>,jump-threading,correlated-propagation,adce,memcpyopt,dse,move-auto-init,loop-mssa(licm<allowspeculation>),coro-elide,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,instcombine<max-iterations=1;no-verify-fixpoint>),function-attrs,function(require<should-not-run-function-passes>),coro-split,coro-annotation-elide))\" on module \"<source>\"\r\n5.\tRunning pass \"loop-mssa(loop-instsimplify,loop-simplifycfg,licm<no-allowspeculation>,loop-rotate<header-duplication;no-prepare-for-lto>,licm<allowspeculation>,simple-loop-unswitch<nontrivial;trivial>)\" on function \"j\"\r\n #0 0x0000000003bfb838 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3bfb838)\r\n #1 0x0000000003bf953c llvm::sys::CleanupOnSignal(unsigned long) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3bf953c)\r\n #2 0x0000000003b46b38 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0\r\n #3 0x00007afb46242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007afb462969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #5 0x00007afb46242476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #6 0x00007afb462287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #7 0x00007afb4622871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #8 0x00007afb46239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #9 0x0000000002bead0a llvm::MemorySSA::removeFromLookups(llvm::MemoryAccess*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2bead0a)\r\n#10 0x0000000002c03a6c llvm::MemorySSAUpdater::removeBlocks(llvm::SmallSetVector<llvm::BasicBlock*, 8u> const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2c03a6c)\r\n#11 0x00000000084e163a deleteDeadBlocksFromLoop(llvm::Loop&, llvm::SmallVectorImpl<llvm::BasicBlock*>&, llvm::DominatorTree&, llvm::LoopInfo&, llvm::MemorySSAUpdater*, llvm::ScalarEvolution*, llvm::LPMUpdater&) SimpleLoopUnswitch.cpp:0:0\r\n#12 0x00000000084ea50d unswitchNontrivialInvariants(llvm::Loop&, llvm::Instruction&, llvm::ArrayRef<llvm::Value*>, llvm::IVConditionInfo&, llvm::DominatorTree&, llvm::LoopInfo&, llvm::AssumptionCache&, llvm::ScalarEvolution*, llvm::MemorySSAUpdater*, llvm::LPMUpdater&, bool, bool) SimpleLoopUnswitch.cpp:0:0\r\n#13 0x00000000084ec9a8 unswitchBestCondition(llvm::Loop&, llvm::DominatorTree&, llvm::LoopInfo&, llvm::AssumptionCache&, llvm::AAResults&, llvm::TargetTransformInfo&, llvm::ScalarEvolution*, llvm::MemorySSAUpdater*, llvm::LPMUpdater&) SimpleLoopUnswitch.cpp:0:0\r\n#14 0x00000000084f0679 llvm::SimpleLoopUnswitchPass::run(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x84f0679)\r\n#15 0x000000000525730e llvm::detail::PassModel<llvm::Loop, llvm::SimpleLoopUnswitchPass, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::run(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x525730e)\r\n#16 0x0000000003a12986 std::optional<llvm::PreservedAnalyses> llvm::PassManager<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::runSinglePass<llvm::Loop, std::unique_ptr<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>, std::default_delete<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>>>>(llvm::Loop&, std::unique_ptr<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>, std::default_delete<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>>>&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&, llvm::PassInstrumentation&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3a12986)\r\n#17 0x0000000003a12b4e llvm::PassManager<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::runWithoutLoopNestPasses(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3a12b4e)\r\n#18 0x0000000003a13f04 llvm::PassManager<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::run(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3a13f04)\r\n#19 0x0000000003a14bfc llvm::FunctionToLoopPassAdaptor::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3a14bfc)\r\n#20 0x000000000112567e llvm::detail::PassModel<llvm::Function, llvm::FunctionToLoopPassAdaptor, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x112567e)\r\n#21 0x00000000035b06d8 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x35b06d8)\r\n#22 0x0000000001125c2e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x1125c2e)\r\n#23 0x0000000002ab3c12 llvm::CGSCCToFunctionPassAdaptor::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2ab3c12)\r\n#24 0x000000000112607e llvm::detail::PassModel<llvm::LazyCallGraph::SCC, llvm::CGSCCToFunctionPassAdaptor, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x112607e)\r\n#25 0x0000000002aaad52 llvm::PassManager<llvm::LazyCallGraph::SCC, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2aaad52)\r\n#26 0x00000000052560ce llvm::detail::PassModel<llvm::LazyCallGraph::SCC, llvm::PassManager<llvm::LazyCallGraph::SCC, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x52560ce)\r\n#27 0x0000000002ab0666 llvm::DevirtSCCRepeatedPass::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2ab0666)\r\n#28 0x00000000052560ee llvm::detail::PassModel<llvm::LazyCallGraph::SCC, llvm::DevirtSCCRepeatedPass, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x52560ee)\r\n#29 0x0000000002aae3f6 llvm::ModuleToPostOrderCGSCCPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2aae3f6)\r\n#30 0x00000000052560ae llvm::detail::PassModel<llvm::Module, llvm::ModuleToPostOrderCGSCCPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x52560ae)\r\n#31 0x00000000035aeb30 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x35aeb30)\r\n#32 0x0000000005476f75 llvm::ModuleInlinerWrapperPass::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x5476f75)\r\n#33 0x00000000050f42ce llvm::detail::PassModel<llvm::Module, llvm::ModuleInlinerWrapperPass, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x50f42ce)\r\n#34 0x00000000035aeb30 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x35aeb30)\r\n#35 0x0000000003ea671b (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&, clang::BackendConsumer*) BackendUtil.cpp:0:0\r\n#36 0x0000000003ea9f45 clang::EmitBackendOutput(clang::DiagnosticsEngine&, clang::HeaderSearchOptions const&, clang::CodeGenOptions const&, clang::TargetOptions const&, clang::LangOptions const&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>, clang::BackendConsumer*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3ea9f45)\r\n#37 0x0000000004575cfe clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4575cfe)\r\n#38 0x000000000673552c clang::ParseAST(clang::Sema&, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x673552c)\r\n#39 0x00000000045760e8 clang::CodeGenAction::ExecuteAction() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x45760e8)\r\n#40 0x00000000048312c9 clang::FrontendAction::Execute() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x48312c9)\r\n#41 0x00000000047b04be clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x47b04be)\r\n#42 0x000000000491c2ce clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x491c2ce)\r\n#43 0x0000000000ceb57f cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xceb57f)\r\n#44 0x0000000000ce323a ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\r\n#45 0x00000000045b92e9 void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()>(long) Job.cpp:0:0\r\n#46 0x0000000003b46fe4 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3b46fe4)\r\n#47 0x00000000045b98df clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const (.part.0) Job.cpp:0:0\r\n#48 0x000000000457fbcd clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x457fbcd)\r\n#49 0x0000000004580cbd clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4580cbd)\r\n#50 0x0000000004588075 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4588075)\r\n#51 0x0000000000ce8419 clang_main(int, char**, llvm::ToolContext const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xce8419)\r\n#52 0x0000000000bb4c14 main (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xbb4c14)\r\n#53 0x00007afb46229d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#54 0x00007afb46229e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#55 0x0000000000ce2cee _start (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xce2cee)\r\n```",
    "author": "cardigan1008",
    "labels": [
      "crash-on-valid",
      "llvm:analysis"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "Reduced reproducer: https://godbolt.org/z/bK3z9nGsa\r\n```\r\n; bin/opt  -passes=\"loop-mssa(licm,simple-loop-unswitch<nontrivial;trivial>)\" reduced.ll -S\r\n; ModuleID = 'reduced.bc'\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\n; Function Attrs: allockind(\"alloc,uninitialized\")\r\ndeclare ptr @malloc() #0\r\n\r\ndefine void @j(i1 %cmp2.i) {\r\nentry:\r\n  br label %for.cond\r\n\r\nfor.cond:                                         ; preds = %for.cond1.for.cond_crit_edge, %entry\r\n  br label %for.cond1\r\n\r\nfor.cond1:                                        ; preds = %for.body.i, %for.body, %for.cond\r\n  br i1 false, label %for.cond1.for.cond_crit_edge, label %for.body\r\n\r\nfor.cond1.for.cond_crit_edge:                     ; preds = %for.cond1\r\n  br label %for.cond\r\n\r\nfor.body:                                         ; preds = %for.cond1\r\n  %call.i = call ptr @malloc()\r\n  %cmp.i = icmp ne ptr %call.i, null\r\n  %or.cond.i = select i1 %cmp.i, i1 %cmp2.i, i1 false\r\n  br i1 %or.cond.i, label %for.body.i, label %for.cond1\r\n\r\nfor.body.i:                                       ; preds = %for.body\r\n  br label %for.cond1\r\n}\r\n\r\nattributes #0 = { allockind(\"alloc,uninitialized\") }\r\n```"
      },
      {
        "author": "nikic",
        "body": "Can reduce this to:\n\n```llvm\n; RUN: opt -S -passes=\"loop-mssa(simple-loop-unswitch<nontrivial>)\" -verify-memoryssa < %s\ndeclare ptr @malloc() allockind(\"alloc,uninitialized\")\n\ndefine void @test(i1 %arg) {\nentry:\n  br label %for.body\n\nfor.body:\n  %call.i = call ptr @malloc()\n  %cmp.i = icmp ne ptr %call.i, null\n  %or.cond.i = select i1 %cmp.i, i1 %arg, i1 false\n  br i1 %or.cond.i, label %exit, label %for.body\n\nexit:\n  ret void\n}\n```\n\n> opt: /home/npopov/repos/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:2068: void llvm::MemorySSA::verifyOrderingDominationAndDefUses(IterT, VerificationLevel) const [IterT = llvm::iterator_range<llvm::ilist_iterator<llvm::ilist_detail::node_options<llvm::BasicBlock, true, false, void, false, void>, false, false>>]: Assertion `dominates(MD, U) && \"Memory Def does not dominate it's uses\"' failed.\n"
      },
      {
        "author": "nikic",
        "body": "We go from:\n```llvm\nMemorySSA for function: test\ndefine void @test(i1 %arg) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n; 2 = MemoryPhi({entry,liveOnEntry},{for.body,1})\n; 1 = MemoryDef(2)\n  %call.i = call ptr @malloc()\n  %cmp.i = icmp ne ptr %call.i, null\n  %or.cond.i = select i1 %cmp.i, i1 %arg, i1 false\n  br i1 %or.cond.i, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  ret void\n}\n```\nTo:\n```llvm\nMemorySSA for function: test\ndefine void @test(i1 %arg) {\nentry:\n  %arg.fr = freeze i1 %arg\n  br i1 %arg.fr, label %entry.split, label %entry.split.us\n\nentry.split.us:                                   ; preds = %entry\n  br label %for.body.us\n\nfor.body.us:                                      ; preds = %for.body.us, %entry.split.us\n; 3 = MemoryPhi({entry.split.us,liveOnEntry},{for.body.us,1})\n  br label %for.body.us\n\nentry.split:                                      ; preds = %entry\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry.split\n; 2 = MemoryPhi({entry.split,liveOnEntry},{for.body,1})\n; 1 = MemoryDef(2)\n  %call.i = call ptr @malloc()\n  %cmp.i = icmp ne ptr %call.i, null\n  %or.cond.i = select i1 %cmp.i, i1 true, i1 false\n  br i1 %or.cond.i, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  ret void\n}\n```\n\nMemoryPhi 3 is broken.\n\nI think this is because we first delete the dead cloned instructions and then update MSSA and something gets confused in that case..."
      }
    ]
  },
  "verified": true
}