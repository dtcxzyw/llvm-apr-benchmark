{
  "bug_id": "161524",
  "issue_url": "https://github.com/llvm/llvm-project/issues/161524",
  "bug_type": "miscompilation",
  "base_commit": "42ab473f518c5f180455c674cbaba70a0b2634b7",
  "knowledge_cutoff": "2025-10-01T14:10:51Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "57a9f79336abebbdfffd52270bb615f7189758d2",
    "components": [
      "ValueTracking"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        [
          7651,
          7675
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        "isGuaranteedNotToBeUndefOrPoison"
      ]
    }
  },
  "patch": "commit 57a9f79336abebbdfffd52270bb615f7189758d2\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Thu Oct 2 01:11:51 2025 +0800\n\n    [ValueTracking] Take PHI's poison-generating flags into account (#161530)\n    \n    ninf/nnan in the phi node may produce poison values. They should be\n    considered in `isGuaranteedNotToBeUndefOrPoison`.\n    Closes https://github.com/llvm/llvm-project/issues/161524.\n\ndiff --git a/llvm/lib/Analysis/ValueTracking.cpp b/llvm/lib/Analysis/ValueTracking.cpp\nindex 6f11b250cf21..09a8fbea065a 100644\n--- a/llvm/lib/Analysis/ValueTracking.cpp\n+++ b/llvm/lib/Analysis/ValueTracking.cpp\n@@ -7651,25 +7651,26 @@ static bool isGuaranteedNotToBeUndefOrPoison(\n         return true;\n     }\n \n-    if (const auto *PN = dyn_cast<PHINode>(V)) {\n-      unsigned Num = PN->getNumIncomingValues();\n-      bool IsWellDefined = true;\n-      for (unsigned i = 0; i < Num; ++i) {\n-        if (PN == PN->getIncomingValue(i))\n-          continue;\n-        auto *TI = PN->getIncomingBlock(i)->getTerminator();\n-        if (!isGuaranteedNotToBeUndefOrPoison(PN->getIncomingValue(i), AC, TI,\n-                                              DT, Depth + 1, Kind)) {\n-          IsWellDefined = false;\n-          break;\n+    if (!::canCreateUndefOrPoison(Opr, Kind,\n+                                  /*ConsiderFlagsAndMetadata=*/true)) {\n+      if (const auto *PN = dyn_cast<PHINode>(V)) {\n+        unsigned Num = PN->getNumIncomingValues();\n+        bool IsWellDefined = true;\n+        for (unsigned i = 0; i < Num; ++i) {\n+          if (PN == PN->getIncomingValue(i))\n+            continue;\n+          auto *TI = PN->getIncomingBlock(i)->getTerminator();\n+          if (!isGuaranteedNotToBeUndefOrPoison(PN->getIncomingValue(i), AC, TI,\n+                                                DT, Depth + 1, Kind)) {\n+            IsWellDefined = false;\n+            break;\n+          }\n         }\n-      }\n-      if (IsWellDefined)\n+        if (IsWellDefined)\n+          return true;\n+      } else if (all_of(Opr->operands(), OpCheck))\n         return true;\n-    } else if (!::canCreateUndefOrPoison(Opr, Kind,\n-                                         /*ConsiderFlagsAndMetadata*/ true) &&\n-               all_of(Opr->operands(), OpCheck))\n-      return true;\n+    }\n   }\n \n   if (auto *I = dyn_cast<LoadInst>(V))\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/freeze-phi.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "pr161524",
          "test_body": "define float @pr161524(float noundef %arg) {\nentry:\n  %cond = tail call i1 @llvm.is.fpclass.f32(float %arg, i32 144)\n  br i1 %cond, label %if.then, label %if.exit\n\nif.then:                                          ; preds = %entry\n  %fadd = fadd float %arg, 1.000000e+00\n  br label %if.exit\n\nif.exit:                                          ; preds = %if.then, %entry\n  %ret = phi ninf float [ %fadd, %if.then ], [ %arg, %entry ]\n  %ret.fr = freeze float %ret\n  ret float %ret.fr\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i1 @llvm.is.fpclass.f32(float, i32 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] Freeze is incorrectly dropped",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/xyfr4N\n```\n; bin/opt -passes=instcombine test.ll -S\ndefine float @test(float %arg) {\nentry:\n  %cond = tail call i1 @llvm.is.fpclass.f32(float %arg, i32 144)\n  %0 = freeze i1 %cond\n  br i1 %0, label %if.then, label %if.exit\n\nif.then:                                          ; preds = %entry\n  %fadd = fadd float %arg, 1.0\n  br label %if.exit\n\nif.exit:                                          ; preds = %if.then, %entry\n  %ret = phi ninf float [ %fadd, %if.then ], [ %arg, %entry ]\n  %1 = freeze float %ret\n  ret float %1\n}\n```\n```\n=>\ndefine float @test(float %arg) {\nentry:\n  %arg.fr = freeze float %arg\n  %cond = is.fpclass float %arg.fr, i32 144\n  br i1 %cond, label %if.then, label %if.exit\n\nif.then:\n  %fadd = fadd float %arg.fr, 1.000000\n  br label %if.exit\n\nif.exit:\n  %ret = phi ninf float [ %fadd, %if.then ], [ %arg.fr, %entry ]\n  ret float %ret\n}\nTransformation doesn't verify!\n\nERROR: Target is more poisonous than source\n\nExample:\nfloat %arg = #xff800000 (-oo)\n\nSource:\ni1 %cond = #x0 (0)\ni1 %#0 = #x0 (0)\n  >> Jump to %if.exit\nfloat %ret = poison\nfloat %#1 = #x00000003 (0.000000000000?)\n\nTarget:\nfloat %arg.fr = #xff800000 (-oo)\ni1 %cond = #x0 (0)\n  >> Jump to %if.exit\nfloat %ret = poison\nSource value: #x00000003 (0.000000000000?)\nTarget value: poison\n```",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:analysis",
      "generated by fuzzer"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}