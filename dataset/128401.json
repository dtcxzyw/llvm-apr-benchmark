{
  "bug_id": "128401",
  "issue_url": "https://github.com/llvm/llvm-project/issues/128401",
  "bug_type": "crash",
  "base_commit": "22a5bb32b787443b70476cc1359709b6c888b591",
  "knowledge_cutoff": "2025-02-23T05:19:16Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "eb14d2a1d48fe76c5faed71a08547135a35ee742",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          13320,
          13328
        ],
        [
          13874,
          13888
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::isGatherShuffledEntry",
        "BoUpSLP::isGatherShuffledSingleRegisterEntry"
      ]
    }
  },
  "patch": "commit eb14d2a1d48fe76c5faed71a08547135a35ee742\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Mon Feb 24 06:02:56 2025 -0800\n\n    [SLP]Fix check for matched gather node, if it is a subvector node\n    \n    If the gather node is a subvector node, it may match the existing\n    vector/gather node in the graph, but still may require reordering. in\n    this case need to fully check its dependencies to prevent a compiler\n    crash.\n    \n    Fixes #128401\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex bf256d82ae17..5fc5fb10fad5 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -13320,9 +13320,16 @@ BoUpSLP::isGatherShuffledSingleRegisterEntry(\n   Entries.clear();\n   // TODO: currently checking only for Scalars in the tree entry, need to count\n   // reused elements too for better cost estimation.\n-  const EdgeInfo &TEUseEI = TE == VectorizableTree.front().get()\n-                                ? EdgeInfo(const_cast<TreeEntry *>(TE), 0)\n-                                : TE->UserTreeIndex;\n+  auto GetUserEntry = [&](const TreeEntry *TE) {\n+    while (TE->UserTreeIndex && TE->UserTreeIndex.EdgeIdx == UINT_MAX)\n+      TE = TE->UserTreeIndex.UserTE;\n+    if (TE == VectorizableTree.front().get())\n+      return EdgeInfo(const_cast<TreeEntry *>(TE), 0);\n+    return TE->UserTreeIndex;\n+  };\n+  const EdgeInfo TEUseEI = GetUserEntry(TE);\n+  if (!TEUseEI)\n+    return std::nullopt;\n   const Instruction *TEInsertPt = &getLastInstructionInBundle(TEUseEI.UserTE);\n   const BasicBlock *TEInsertBlock = nullptr;\n   // Main node of PHI entries keeps the correct order of operands/incoming\n@@ -13874,15 +13881,13 @@ BoUpSLP::isGatherShuffledEntry(\n   assert(VL.size() % NumParts == 0 &&\n          \"Number of scalars must be divisible by NumParts.\");\n   if (TE->UserTreeIndex && TE->UserTreeIndex.UserTE->isGather() &&\n-      TE->UserTreeIndex.EdgeIdx == UINT_MAX) {\n-    assert(\n-        (TE->Idx == 0 ||\n-         (TE->hasState() && TE->getOpcode() == Instruction::ExtractElement) ||\n-         isSplat(TE->Scalars) ||\n-         getSameValuesTreeEntry(TE->getMainOp(), TE->Scalars)) &&\n-        \"Expected splat or extractelements only node.\");\n+      TE->UserTreeIndex.EdgeIdx == UINT_MAX &&\n+      (TE->Idx == 0 ||\n+       (TE->hasState() && TE->getOpcode() == Instruction::ExtractElement) ||\n+       isSplat(TE->Scalars) ||\n+       (TE->hasState() &&\n+        getSameValuesTreeEntry(TE->getMainOp(), TE->Scalars))))\n     return {};\n-  }\n   unsigned SliceSize = getPartNumElems(VL.size(), NumParts);\n   SmallVector<std::optional<TTI::ShuffleKind>> Res;\n   for (unsigned Part : seq<unsigned>(NumParts)) {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/bv-matched-node-reorder.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n@g = global [8 x i8] zeroinitializer\n\ndefine i32 @main() {\n;\nentry:\n  %l2.i.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 5), align 1\n  %li.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 4), align 1\n  %l1.i.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 7), align 1\n  %l6.i.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 6), align 1\n  br i1 false, label %if.end151.1.i.i.1.i.i.i, label %end\n\npre:\n  br label %end\n\nend:\n  %0 = phi i8 [ 0, %pre ], [ %li.i.i.i, %entry ]\n  %1 = phi i8 [ 0, %pre ], [ %l2.i.i.i.i, %entry ]\n  %2 = phi i8 [ 0, %pre ], [ %l6.i.i.i.i, %entry ]\n  %3 = phi i8 [ 0, %pre ], [ %l1.i.i.i.i, %entry ]\n  %4 = phi i8 [ 0, %pre ], [ %l1.i.i.i.i, %entry ]\n  %5 = phi i8 [ 0, %pre ], [ %l6.i.i.i.i, %entry ]\n  %6 = phi i8 [ 0, %pre ], [ %l2.i.i.i.i, %entry ]\n  %7 = phi i8 [ 0, %pre ], [ %li.i.i.i, %entry ]\n  br label %if.end151.1.i.i.1.i.i.i\n\nif.end151.1.i.i.1.i.i.i:\n  %8 = phi i8 [ %li.i.i.i, %entry ], [ %7, %end ]\n  %9 = phi i8 [ %l2.i.i.i.i, %entry ], [ %6, %end ]\n  %10 = phi i8 [ %l6.i.i.i.i, %entry ], [ %5, %end ]\n  %11 = phi i8 [ %l1.i.i.i.i, %entry ], [ %4, %end ]\n  %12 = phi i8 [ %l1.i.i.i.i, %entry ], [ %3, %end ]\n  %13 = phi i8 [ 0, %entry ], [ %2, %end ]\n  %14 = phi i8 [ %l2.i.i.i.i, %entry ], [ %1, %end ]\n  %15 = phi i8 [ %li.i.i.i, %entry ], [ %0, %end ]\n  %16 = phi i8 [ 0, %entry ], [ %6, %end ]\n  %17 = phi i8 [ %l1.i.i.i.i, %entry ], [ %4, %end ]\n  %18 = phi i8 [ %l6.i.i.i.i, %entry ], [ %5, %end ]\n  %19 = phi i8 [ %l1.i.i.i.i, %entry ], [ %4, %end ]\n  %20 = phi i8 [ %l6.i.i.i.i, %entry ], [ %5, %end ]\n  %21 = phi i8 [ %l2.i.i.i.i, %entry ], [ %6, %end ]\n  %22 = phi i8 [ %li.i.i.i, %entry ], [ %7, %end ]\n  %tobool.not.i.1121.i.1.i.i.i = icmp ne i8 %18, 0\n  %c1.1.1117.i.1.i9.i.i = icmp eq i8 %17, 0\n  %c1.i.1.i.i.i = icmp eq i8 %16, 0\n  %c1.1.i.i.i.i = icmp eq i8 %12, 0\n  %cmp258.i.1.i.i.i.i = icmp eq i8 %13, 0\n  %c1.i.i.i.i = icmp eq i8 %14, 0\n  %cmp258.i.i.i.i.i = icmp eq i8 %15, 0\n  %c1.1.1.i.i.i.i = icmp eq i8 %11, 0\n  %cmp258.i.1.1.i.i.i.i = icmp eq i8 %10, 0\n  %c1.187.i.i.i.i = icmp eq i8 %9, 0\n  %cmp258.i.185.i.i.i.i = icmp eq i8 %8, 0\n  %c1.1.1117.i.i.i.i = icmp eq i8 %19, 0\n  %cmp258.i.1.1115.i.i.i.i = icmp eq i8 %20, 0\n  %c1.1113.i.i.i.i = icmp eq i8 %21, 0\n  %cmp258.i.1111.i.i.i.i = icmp eq i8 %22, 0\n  %c1.187.1.i.i.i.i = icmp eq i8 %16, 0\n  ret i32 0\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Assertion `\"Expected splat or extractelements only node.\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/9jx1xejoe\n```\n; bin/opt -passes=slp-vectorizer test.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@g = global [8 x i8] zeroinitializer\n\ndefine i32 @main() {\nentry:\n  %.promoted42.i.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 5), align 1\n  %.promoted.i.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 4), align 1\n  %.promoted51.i.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 7), align 1\n  %.promoted56.i.i.i.i = load i8, ptr getelementptr inbounds nuw (i8, ptr @g, i64 6), align 1\n  br i1 false, label %if.end151.1.i.i.1.i.i.i, label %if.end151.1.i.1.i.i.i.i\n\nfor.cond79.preheader.us.preheader.1.i.1.i.i.i.i:\n  br label %if.end151.1.i.1.i.i.i.i\n\nif.end151.1.i.1.i.i.i.i:\n  %0 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted.i.i.i.i, %entry ]\n  %1 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted42.i.i.i.i, %entry ]\n  %2 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted56.i.i.i.i, %entry ]\n  %3 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted51.i.i.i.i, %entry ]\n  %4 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted51.i.i.i.i, %entry ]\n  %5 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted56.i.i.i.i, %entry ]\n  %6 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted42.i.i.i.i, %entry ]\n  %7 = phi i8 [ 0, %for.cond79.preheader.us.preheader.1.i.1.i.i.i.i ], [ %.promoted.i.i.i.i, %entry ]\n  br label %if.end151.1.i.i.1.i.i.i\n\nif.end151.1.i.i.1.i.i.i:\n  %8 = phi i8 [ %.promoted.i.i.i.i, %entry ], [ %7, %if.end151.1.i.1.i.i.i.i ]\n  %9 = phi i8 [ %.promoted42.i.i.i.i, %entry ], [ %6, %if.end151.1.i.1.i.i.i.i ]\n  %10 = phi i8 [ %.promoted56.i.i.i.i, %entry ], [ %5, %if.end151.1.i.1.i.i.i.i ]\n  %11 = phi i8 [ %.promoted51.i.i.i.i, %entry ], [ %4, %if.end151.1.i.1.i.i.i.i ]\n  %12 = phi i8 [ %.promoted51.i.i.i.i, %entry ], [ %3, %if.end151.1.i.1.i.i.i.i ]\n  %13 = phi i8 [ 0, %entry ], [ %2, %if.end151.1.i.1.i.i.i.i ]\n  %14 = phi i8 [ %.promoted42.i.i.i.i, %entry ], [ %1, %if.end151.1.i.1.i.i.i.i ]\n  %15 = phi i8 [ %.promoted.i.i.i.i, %entry ], [ %0, %if.end151.1.i.1.i.i.i.i ]\n  %16 = phi i8 [ 0, %entry ], [ %6, %if.end151.1.i.1.i.i.i.i ]\n  %17 = phi i8 [ %.promoted51.i.i.i.i, %entry ], [ %4, %if.end151.1.i.1.i.i.i.i ]\n  %18 = phi i8 [ %.promoted56.i.i.i.i, %entry ], [ %5, %if.end151.1.i.1.i.i.i.i ]\n  %19 = phi i8 [ %.promoted51.i.i.i.i, %entry ], [ %4, %if.end151.1.i.1.i.i.i.i ]\n  %20 = phi i8 [ %.promoted56.i.i.i.i, %entry ], [ %5, %if.end151.1.i.1.i.i.i.i ]\n  %21 = phi i8 [ %.promoted42.i.i.i.i, %entry ], [ %6, %if.end151.1.i.1.i.i.i.i ]\n  %22 = phi i8 [ %.promoted.i.i.i.i, %entry ], [ %7, %if.end151.1.i.1.i.i.i.i ]\n  %tobool.not.i.1121.i.1.i.i.i = icmp ne i8 %18, 0\n  %cmp258.1.i.1.1117.i.1.i9.i.i = icmp eq i8 %17, 0\n  %cmp258.1.i.i.1.i.i.i = icmp eq i8 %16, 0\n  %cmp258.1.i.1.i.i.i.i = icmp eq i8 %12, 0\n  %cmp258.i.1.i.i.i.i = icmp eq i8 %13, 0\n  %cmp258.1.i.i.i.i.i = icmp eq i8 %14, 0\n  %cmp258.i.i.i.i.i = icmp eq i8 %15, 0\n  %cmp258.1.i.1.1.i.i.i.i = icmp eq i8 %11, 0\n  %cmp258.i.1.1.i.i.i.i = icmp eq i8 %10, 0\n  %cmp258.1.i.187.i.i.i.i = icmp eq i8 %9, 0\n  %cmp258.i.185.i.i.i.i = icmp eq i8 %8, 0\n  %cmp258.1.i.1.1117.i.i.i.i = icmp eq i8 %19, 0\n  %cmp258.i.1.1115.i.i.i.i = icmp eq i8 %20, 0\n  %cmp258.1.i.1113.i.i.i.i = icmp eq i8 %21, 0\n  %cmp258.i.1111.i.i.i.i = icmp eq i8 %22, 0\n  %cmp258.1.i.187.1.i.i.i.i = icmp eq i8 %16, 0\n  ret i32 0\n}\n```\n```\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13878: llvm::SmallVector<std::optional<llvm::TargetTransformInfo::ShuffleKind> > llvm::slpvectorizer::BoUpSLP::isGatherShuffledEntry(const llvm::slpvectorizer::BoUpSLP::TreeEntry*, llvm::ArrayRef<llvm::Value*>, llvm::SmallVectorImpl<int>&, llvm::SmallVectorImpl<llvm::SmallVector<const llvm::slpvectorizer::BoUpSLP::TreeEntry*> >&, unsigned int, bool): Assertion `(TE->Idx == 0 || (TE->hasState() && TE->getOpcode() == Instruction::ExtractElement) || isSplat(TE->Scalars) || getSameValuesTreeEntry(TE->getMainOp(), TE->Scalars)) && \"Expected splat or extractelements only node.\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=slp-vectorizer <source>\n1.\tRunning pass \"function(slp-vectorizer)\" on module \"<source>\"\n2.\tRunning pass \"slp-vectorizer\" on function \"main\"\n #0 0x0000000005447b18 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5447b18)\n #1 0x00000000054454d4 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x000072c4b8a42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x000072c4b8a969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x000072c4b8a42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x000072c4b8a287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x000072c4b8a2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x000072c4b8a39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x000000000447b405 llvm::slpvectorizer::BoUpSLP::isGatherShuffledEntry(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::SmallVectorImpl<int>&, llvm::SmallVectorImpl<llvm::SmallVector<llvm::slpvectorizer::BoUpSLP::TreeEntry const*, 6u>>&, unsigned int, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x447b405)\n #9 0x000000000447c786 llvm::InstructionCost llvm::slpvectorizer::BoUpSLP::processBuildVector<llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator, llvm::InstructionCost, llvm::TargetTransformInfo, llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP, llvm::SmallPtrSetImpl<llvm::Value*>>(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::Type*, llvm::TargetTransformInfo&, llvm::ArrayRef<llvm::Value*>&, llvm::slpvectorizer::BoUpSLP&, llvm::SmallPtrSetImpl<llvm::Value*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x447c786)\n#10 0x000000000447ec37 llvm::slpvectorizer::BoUpSLP::getEntryCost(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::SmallPtrSetImpl<llvm::Value*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x447ec37)\n#11 0x00000000044b3879 llvm::slpvectorizer::BoUpSLP::getTreeCost(llvm::ArrayRef<llvm::Value*>) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x44b3879)\n#12 0x00000000044bd45d llvm::SLPVectorizerPass::tryToVectorizeList(llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP&, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x44bd45d)\n#13 0x00000000044c1701 bool llvm::SLPVectorizerPass::vectorizeCmpInsts<std::reverse_iterator<llvm::CmpInst* const*>>(llvm::iterator_range<std::reverse_iterator<llvm::CmpInst* const*>>, llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x44c1701)\n#14 0x00000000044c1fab llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&)::'lambda3'(bool)::operator()(bool) const SLPVectorizer.cpp:0:0\n#15 0x00000000044c575f llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x44c575f)\n#16 0x00000000044cbef6 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (.part.0) SLPVectorizer.cpp:0:0\n#17 0x00000000044cca4b llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x44cca4b)\n#18 0x0000000003182e1e llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3182e1e)\n#19 0x00000000052431d0 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x52431d0)\n#20 0x0000000000e6e03e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe6e03e)\n#21 0x0000000005241aeb llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5241aeb)\n#22 0x0000000000e6d34e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe6d34e)\n#23 0x00000000052414f0 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x52414f0)\n#24 0x0000000000935a5a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x935a5a)\n#25 0x00000000009290cc optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9290cc)\n#26 0x000072c4b8a29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#27 0x000072c4b8a29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#28 0x00000000009209a5 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9209a5)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\nllvm version: dbd219aef4be56754c793589c60bd787b7de60c2\n",
    "author": "dtcxzyw",
    "labels": [
      "llvm:SLPVectorizer",
      "crash-on-valid",
      "generated by fuzzer"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "bisect": "894935cb5146fd2ac6334cc8b11e6d6e0e264fe6"
}