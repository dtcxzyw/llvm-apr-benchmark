{
  "bug_id": "128838",
  "issue_url": "https://github.com/llvm/llvm-project/issues/128838",
  "bug_type": "crash",
  "base_commit": "9c65e6ac115a7d8566c874537791125c3ace7c1a",
  "knowledge_cutoff": "2025-02-26T07:25:33Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "62994c3291239f3d11f958d002319b2bd6eddbc9",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          7691,
          7701
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          2180,
          2186
        ],
        [
          2189,
          2206
        ],
        [
          2210,
          2219
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.h": [
        [
          189,
          196
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationPlanner::executePlan"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::handleUncountableEarlyExit",
        "VPlanTransforms::materializeLiveInBroadcasts"
      ]
    }
  },
  "patch": "commit 62994c3291239f3d11f958d002319b2bd6eddbc9\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Wed Mar 12 22:03:18 2025 +0000\n\n    [VPlan] Also introduce explicit broadcasts for values from entry VPBB.\n    \n    Update and generalize materializeBroadcasts to also introduce explicit\n    broadcasts for VPValues defined in the Plans Entry block.\n    \n    This fixes a crash when trying to insert the broadcasts generated by\n    VPTransformState::get after the generating instruction, which isn't\n    possible after invoke instructions.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/128838.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex bab2c6efd403..02bacde3f60a 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -7691,11 +7691,11 @@ DenseMap<const SCEV *, Value *> LoopVectorizationPlanner::executePlan(\n       ((VectorizingEpilogue && ExpandedSCEVs) ||\n        (!VectorizingEpilogue && !ExpandedSCEVs)) &&\n       \"expanded SCEVs to reuse can only be used during epilogue vectorization\");\n-  VPlanTransforms::materializeLiveInBroadcasts(BestVPlan);\n   // TODO: Move to VPlan transform stage once the transition to the VPlan-based\n   // cost model is complete for better cost estimates.\n   VPlanTransforms::runPass(VPlanTransforms::unrollByUF, BestVPlan, BestUF,\n                            OrigLoop->getHeader()->getContext());\n+  VPlanTransforms::materializeBroadcasts(BestVPlan);\n   VPlanTransforms::optimizeForVFAndUF(BestVPlan, BestVF, BestUF, PSE);\n   VPlanTransforms::simplifyRecipes(BestVPlan, *Legal->getWidestInductionType());\n   VPlanTransforms::removeDeadRecipes(BestVPlan);\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex ecf52673480e..f23795f87d46 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -2180,7 +2180,7 @@ void VPlanTransforms::handleUncountableEarlyExit(\n   LatchExitingBranch->eraseFromParent();\n }\n \n-void VPlanTransforms::materializeLiveInBroadcasts(VPlan &Plan) {\n+void VPlanTransforms::materializeBroadcasts(VPlan &Plan) {\n   if (Plan.hasScalarVFOnly())\n     return;\n \n@@ -2189,18 +2189,25 @@ void VPlanTransforms::materializeLiveInBroadcasts(VPlan &Plan) {\n   VPDT.recalculate(Plan);\n #endif\n \n+  SmallVector<VPValue *> VPValues;\n+  append_range(VPValues, Plan.getLiveIns());\n+  for (VPRecipeBase &R : *Plan.getEntry())\n+    append_range(VPValues, R.definedValues());\n+\n   auto *VectorPreheader = Plan.getVectorPreheader();\n-  for (VPValue *LiveIn : Plan.getLiveIns()) {\n-    if (all_of(LiveIn->users(),\n-               [LiveIn](VPUser *U) { return U->usesScalars(LiveIn); }) ||\n-        !LiveIn->getLiveInIRValue() ||\n-        isa<Constant>(LiveIn->getLiveInIRValue()))\n+  for (VPValue *VPV : VPValues) {\n+    if (all_of(VPV->users(),\n+               [VPV](VPUser *U) { return U->usesScalars(VPV); }) ||\n+        (VPV->isLiveIn() &&\n+         (!VPV->getLiveInIRValue() || isa<Constant>(VPV->getLiveInIRValue()))))\n       continue;\n \n     // Add explicit broadcast at the insert point that dominates all users.\n     VPBasicBlock *HoistBlock = VectorPreheader;\n     VPBasicBlock::iterator HoistPoint = VectorPreheader->end();\n-    for (VPUser *User : LiveIn->users()) {\n+    for (VPUser *User : VPV->users()) {\n+      if (User->usesScalars(VPV))\n+        continue;\n       if (cast<VPRecipeBase>(User)->getParent() == VectorPreheader)\n         HoistPoint = HoistBlock->begin();\n       else\n@@ -2210,10 +2217,10 @@ void VPlanTransforms::materializeLiveInBroadcasts(VPlan &Plan) {\n     }\n \n     VPBuilder Builder(cast<VPBasicBlock>(HoistBlock), HoistPoint);\n-    auto *Broadcast = Builder.createNaryOp(VPInstruction::Broadcast, {LiveIn});\n-    LiveIn->replaceUsesWithIf(\n-        Broadcast, [LiveIn, Broadcast](VPUser &U, unsigned Idx) {\n-          return Broadcast != &U && !U.usesScalars(LiveIn);\n-        });\n+    auto *Broadcast = Builder.createNaryOp(VPInstruction::Broadcast, {VPV});\n+    VPV->replaceUsesWithIf(Broadcast,\n+                           [VPV, Broadcast](VPUser &U, unsigned Idx) {\n+                             return Broadcast != &U && !U.usesScalars(VPV);\n+                           });\n   }\n }\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.h b/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\nindex 8a9a81e00fe2..2ec07eea1ecc 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\n@@ -189,8 +189,8 @@ struct VPlanTransforms {\n   optimizeInductionExitUsers(VPlan &Plan,\n                              DenseMap<VPValue *, VPValue *> &EndValues);\n \n-  /// Add explicit broadcasts for live-ins used as vectors.\n-  static void materializeLiveInBroadcasts(VPlan &Plan);\n+  /// Add explicit broadcasts for live-ins and VPValues defined in \\p Plan's entry block if they are used as vectors.\n+  static void materializeBroadcasts(VPlan &Plan);\n };\n \n } // namespace llvm\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/illegal-type.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mattr=+v -force-vector-width=4 -scalable-vectorization=on -S 2>&1"
      ],
      "tests": [
        {
          "test_name": "uniform_store_i1",
          "test_body": "target triple = \"riscv64-linux-gnu\"\n\ndefine void @uniform_store_i1(ptr noalias %dst, ptr noalias %start, i64 %N) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %first.sroa = phi ptr [ %incdec.ptr, %for.body ], [ %start, %entry ]\n  %iv = phi i64 [ %iv.next, %for.body ], [ 0, %entry ]\n  %iv.next = add i64 %iv, 1\n  %incdec.ptr = getelementptr inbounds i64, ptr %first.sroa, i64 1\n  %cmp.not = icmp eq ptr %incdec.ptr, %start\n  store i1 %cmp.not, ptr %dst, align 1\n  %cmp = icmp ult i64 %iv, %N\n  br i1 %cmp, label %for.body, label %end, !llvm.loop !0\n\nend:                                              ; preds = %for.body\n  ret void\n}\n\n!0 = distinct !{!0, !1}\n!1 = !{!\"llvm.loop.vectorize.scalable.enable\", i1 true}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/epilog-vectorization-inductions.ll",
      "commands": [
        "opt -passes=loop-vectorize -mcpu=znver2 -S %s"
      ],
      "tests": [
        {
          "test_name": "test_induction_step_needs_expansion",
          "test_body": "target triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @test_induction_step_needs_expansion(ptr noalias %j, ptr %k, i64 %l, i16 %off) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %p.09 = phi i16 [ 0, %entry ], [ %add, %loop ]\n  %add = sub i16 %p.09, %off\n  %arrayidx3 = getelementptr inbounds i16, ptr %k, i64 %iv\n  store i16 %add, ptr %arrayidx3, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, %l\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/induction-step.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -S %s"
      ],
      "tests": [
        {
          "test_name": "wide_add_induction_step_live_in",
          "test_body": "target triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i16 @wide_add_induction_step_live_in(ptr %dst, i64 %N, i16 %off) {\nentry:\n  %o.1 = add i16 %off, 2\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.2 = phi i16 [ 0, %entry ], [ %add, %loop ]\n  %add = add i16 %iv.2, %o.1\n  %gep.dst = getelementptr inbounds i16, ptr %dst, i64 %iv\n  store i16 %add, ptr %gep.dst, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i16 %add\n}\n"
        },
        {
          "test_name": "wide_sub_induction_step_live_in",
          "test_body": "target triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i16 @wide_sub_induction_step_live_in(ptr %dst, i64 %N, i16 %off) {\nentry:\n  %o.1 = add i16 %off, 2\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.2 = phi i16 [ 0, %entry ], [ %sub, %loop ]\n  %sub = sub i16 %iv.2, %o.1\n  %gep.dst = getelementptr inbounds i16, ptr %dst, i64 %iv\n  store i16 %sub, ptr %gep.dst, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i16 %sub\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/expand-scev-after-invoke.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndeclare i32 @foo()\n\n; Test case for https://github.com/llvm/llvm-project/issues/128838. Make sure\n; we do not crash when expanding %step.\ndefine void @test(ptr %dst) personality ptr null {\n;\nentry:\n  %step = invoke i32 @foo()\n  to label %loop unwind label %lpad\n\nloop:\n  %iv.1 = phi i64 [ 0, %entry ], [ %add, %loop ]\n  %iv.2 = phi i32 [ 0, %entry ], [ %iv.2.next, %loop ]\n  %add = add i64 %iv.1, 1\n  %gep = getelementptr inbounds i32, ptr %dst, i64 %iv.1\n  store i32 %iv.2, ptr %gep, align 8\n  %iv.2.next = add i32 %iv.2, %step\n  %ec = icmp ult i64 %iv.1, 161\n  br i1 %ec, label %loop, label %exit\n\nexit:\n  ret void\n\nlpad:\n  %landingpad = landingpad { ptr, i32 }\n  cleanup\n  ret void\n}"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/float-induction.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize,dce,instcombine -force-vector-interleave=1 -force-vector-width=4 -S",
        "opt < %s -passes=loop-vectorize,dce,instcombine -force-vector-interleave=2 -force-vector-width=4 -S",
        "opt < %s -passes=loop-vectorize,dce,instcombine -force-vector-interleave=2 -force-vector-width=1 -S",
        "opt < %s -passes=loop-vectorize,dce,simplifycfg,instcombine,simplifycfg -force-vector-interleave=1 -force-vector-width=2 -simplifycfg-require-and-preserve-domtree=1 -keep-loops=false -S"
      ],
      "tests": [
        {
          "test_name": "fp_iv_loop1_fast_FMF",
          "test_body": "@fp_inc = external global float, align 4\n\ndefine void @fp_iv_loop1_fast_FMF(float %init, ptr noalias captures(none) %A, i32 %N) {\nentry:\n  %cmp4 = icmp sgt i32 %N, 0\n  br i1 %cmp4, label %for.body.lr.ph, label %for.end\n\nfor.body.lr.ph:                                   ; preds = %entry\n  %fpinc = load float, ptr @fp_inc, align 4\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.body.lr.ph\n  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]\n  %x.05 = phi float [ %init, %for.body.lr.ph ], [ %add, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv\n  store float %x.05, ptr %arrayidx, align 4\n  %add = fsub fast float %x.05, %fpinc\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, %N\n  br i1 %exitcond, label %for.end.loopexit, label %for.body\n\nfor.end.loopexit:                                 ; preds = %for.body\n  br label %for.end\n\nfor.end:                                          ; preds = %for.end.loopexit, %entry\n  ret void\n}\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 2, !\"Debug Info Version\", i32 3}\n"
        },
        {
          "test_name": "fp_iv_loop3",
          "test_body": "@fp_inc = external global float, align 4\n\ndefine void @fp_iv_loop3(float %init, ptr noalias captures(none) %A, ptr noalias captures(none) %B, ptr noalias captures(none) %C, i32 %N) {\nentry:\n  %cmp9 = icmp sgt i32 %N, 0\n  br i1 %cmp9, label %for.body.lr.ph, label %for.end\n\nfor.body.lr.ph:                                   ; preds = %entry\n  %0 = load float, ptr @fp_inc, align 4\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.body.lr.ph\n  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]\n  %y.012 = phi float [ 0x3FB99999A0000000, %for.body.lr.ph ], [ %conv1, %for.body ]\n  %x.011 = phi float [ %init, %for.body.lr.ph ], [ %add, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv\n  store float %x.011, ptr %arrayidx, align 4\n  %add = fadd fast float %x.011, %0\n  %conv1 = fadd fast float %y.012, -5.000000e-01\n  %add2 = fadd fast float %conv1, %add\n  %arrayidx4 = getelementptr inbounds float, ptr %B, i64 %indvars.iv\n  store float %add2, ptr %arrayidx4, align 4\n  %arrayidx6 = getelementptr inbounds float, ptr %C, i64 %indvars.iv\n  store float %conv1, ptr %arrayidx6, align 4\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, %N\n  br i1 %exitcond, label %for.end.loopexit, label %for.body\n\nfor.end.loopexit:                                 ; preds = %for.body\n  br label %for.end\n\nfor.end:                                          ; preds = %for.end.loopexit, %entry\n  ret void\n}\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 2, !\"Debug Info Version\", i32 3}\n"
        },
        {
          "test_name": "fp_iv_loop1_reassoc_FMF",
          "test_body": "@fp_inc = external global float, align 4\n\ndefine void @fp_iv_loop1_reassoc_FMF(float %init, ptr noalias captures(none) %A, i32 %N) {\nentry:\n  %cmp4 = icmp sgt i32 %N, 0\n  br i1 %cmp4, label %for.body.lr.ph, label %for.end\n\nfor.body.lr.ph:                                   ; preds = %entry\n  %fpinc = load float, ptr @fp_inc, align 4\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.body.lr.ph\n  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]\n  %x.05 = phi float [ %init, %for.body.lr.ph ], [ %add, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv\n  store float %x.05, ptr %arrayidx, align 4\n  %add = fsub reassoc float %x.05, %fpinc\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, %N\n  br i1 %exitcond, label %for.end.loopexit, label %for.body\n\nfor.end.loopexit:                                 ; preds = %for.body\n  br label %for.end\n\nfor.end:                                          ; preds = %for.end.loopexit, %entry\n  ret void\n}\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 2, !\"Debug Info Version\", i32 3}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/induction-step.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=8 -S"
      ],
      "tests": [
        {
          "test_name": "wide_add_induction_step_live_in",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @wide_add_induction_step_live_in(ptr %dst, i64 %N, i16 %off) {\nentry:\n  %o.1 = add i16 %off, 2\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.2 = phi i16 [ 0, %entry ], [ %add, %loop ]\n  %add = add i16 %iv.2, %o.1\n  %gep.dst = getelementptr inbounds i16, ptr %dst, i64 %iv\n  store i16 %add, ptr %gep.dst, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/induction.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize,instcombine -force-vector-interleave=1 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize,instcombine -force-vector-interleave=2 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize -force-vector-interleave=2 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize,instcombine -force-vector-interleave=2 -force-vector-width=4 -force-widen-divrem-via-safe-divisor=0 -enable-interleaved-mem-accesses -S"
      ],
      "tests": [
        {
          "test_name": "test_optimized_cast_induction_feeding_first_order_recurrence",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\ndefine void @test_optimized_cast_induction_feeding_first_order_recurrence(i64 %n, i32 %step, ptr %ptr) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %for = phi i32 [ 0, %entry ], [ %iv.2.conv, %loop ]\n  %iv.1 = phi i64 [ 0, %entry ], [ %iv.1.next, %loop ]\n  %iv.2 = phi i32 [ 0, %entry ], [ %iv.2.next, %loop ]\n  %iv.2.ext = shl i32 %iv.2, 24\n  %iv.2.conv = ashr exact i32 %iv.2.ext, 24\n  %gep = getelementptr inbounds i32, ptr %ptr, i64 %iv.1\n  store i32 %for, ptr %gep, align 4\n  %iv.2.next = add nsw i32 %iv.2.conv, %step\n  %iv.1.next = add nuw nsw i64 %iv.1, 1\n  %exitcond = icmp eq i64 %iv.1.next, %n\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion `!NodePtr->isKnownSentinel()' failed.",
    "body": "To reproduce run opt with the test below, -passes=loop-vectorize\n```\n; ModuleID = './reduced.ll'\nsource_filename = \"./reduced.ll\"\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @wombat() gc \"statepoint-example\" personality ptr null {\nbb:\n  %invoke = invoke i32 null(ptr addrspace(1) null, i32 0, i32 0, i32 0)\n          to label %bb1 unwind label %bb5\n\nbb1:                                              ; preds = %bb1, %bb\n  %phi = phi i64 [ %add, %bb1 ], [ 0, %bb ]\n  %phi2 = phi i32 [ %add3, %bb1 ], [ 0, %bb ]\n  %add = add i64 %phi, 1\n  %sitofp = sitofp i32 %phi2 to double\n  store double %sitofp, ptr addrspace(1) null, align 8\n  %add3 = add i32 %phi2, %invoke\n  %icmp = icmp ult i64 %phi, 161\n  br i1 %icmp, label %bb1, label %bb4\n\nbb4:                                              ; preds = %bb1\n  ret void\n\nbb5:                                              ; preds = %bb\n  %landingpad = landingpad { ptr, i32 }\n          cleanup\n  ret void\n}\n```\nReproducer: https://godbolt.org/z/3do96adnn\n\nStack dump:\n```\nopt: /root/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h:322: llvm::ilist_iterator_w_bits<OptionsT, IsReverse, IsConst>::reference llvm::ilist_iterator_w_bits<OptionsT, IsReverse, IsConst>::operator*() const [with OptionsT = llvm::ilist_detail::node_options<llvm::Instruction, true, false, void, true, llvm::BasicBlock>; bool IsReverse = false; bool IsConst = false; llvm::ilist_iterator_w_bits<OptionsT, IsReverse, IsConst>::reference = llvm::Instruction&]: Assertion `!NodePtr->isKnownSentinel()' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=loop-vectorize <source>\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"<source>\"\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"wombat\"\n #0 0x0000000005452b98 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5452b98)\n #1 0x0000000005450554 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x00007b16e6242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x00007b16e62969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x00007b16e6242476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x00007b16e62287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x00007b16e622871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x00007b16e6239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x00000000044f6c23 (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x44f6c23)\n #9 0x000000000450ebb3 llvm::VPTransformState::get(llvm::VPValue*, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x450ebb3)\n#10 0x0000000004543138 llvm::VPInstruction::generate(llvm::VPTransformState&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4543138)\n#11 0x0000000004544ba4 llvm::VPInstruction::execute(llvm::VPTransformState&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4544ba4)\n#12 0x00000000044f82e7 llvm::VPBasicBlock::executeRecipes(llvm::VPTransformState*, llvm::BasicBlock*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x44f82e7)\n#13 0x00000000045038f9 llvm::VPIRBasicBlock::execute(llvm::VPTransformState*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x45038f9)\n#14 0x0000000004510249 llvm::VPlan::execute(llvm::VPTransformState*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4510249)\n#15 0x00000000043cccce llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoopVectorizer&, llvm::DominatorTree*, bool, llvm::DenseMap<llvm::SCEV const*, llvm::Value*, llvm::DenseMapInfo<llvm::SCEV const*, void>, llvm::detail::DenseMapPair<llvm::SCEV const*, llvm::Value*>> const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x43cccce)\n#16 0x00000000043e15d8 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x43e15d8)\n#17 0x00000000043e2f49 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x43e2f49)\n#18 0x00000000043e35c3 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x43e35c3)\n#19 0x000000000318aaae llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x318aaae)\n#20 0x000000000524cd90 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x524cd90)\n#21 0x0000000000e6f54e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe6f54e)\n#22 0x000000000524b6ab llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x524b6ab)\n#23 0x0000000000e6e83e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe6e83e)\n#24 0x000000000524b0b0 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x524b0b0)\n#25 0x0000000000935a3a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x935a3a)\n#26 0x00000000009290ac optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9290ac)\n#27 0x00007b16e6229d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#28 0x00007b16e6229e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#29 0x0000000000920985 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x920985)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "TatyanaDoubts",
    "labels": [
      "vectorizers",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "looking "
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  },
  "bisect": "e258bca9505f35e0a22cb213a305eea9b76d11ea"
}