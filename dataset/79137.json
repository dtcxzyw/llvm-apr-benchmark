{
  "bug_id": "79137",
  "issue_url": "https://github.com/llvm/llvm-project/issues/79137",
  "bug_type": "miscompilation",
  "base_commit": "543cf08636f3a3bb55dddba2e8cad787601647ba",
  "knowledge_cutoff": "2024-01-23T13:37:52Z",
  "lit_test_dir": [
    "llvm/test/Transforms/PhaseOrdering",
    "llvm/test/Analysis/LoopAccessAnalysis"
  ],
  "hints": {
    "fix_commit": "cd7ea4ea657ea41b42fcbd0e6b33faa46608d18e",
    "components": [
      "LoopAccessAnalysis"
    ],
    "files": [
      "llvm/lib/Analysis/LoopAccessAnalysis.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/LoopAccessAnalysis.cpp": [
        [
          657,
          672
        ],
        [
          674,
          681
        ],
        [
          731,
          736
        ],
        [
          775,
          780
        ],
        [
          2283,
          2288
        ],
        [
          2326,
          2331
        ],
        [
          2407,
          2413
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/LoopAccessAnalysis.cpp": [
        "addStore",
        "addLoad",
        "LoopAccessInfo::analyzeLoop",
        "AccessAnalysis"
      ]
    }
  },
  "patch": "commit cd7ea4ea657ea41b42fcbd0e6b33faa46608d18e\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Wed Jan 24 11:20:16 2024 +0100\n\n    [LAA] Drop alias scope metadata that is not valid across iterations (#79161)\n    \n    LAA currently adds memory locations with their original AATags to AST.\n    However, scoped alias AATags may be valid only within one loop\n    iteration, while LAA reasons across iterations.\n    \n    Fix this by determining which alias scopes are defined inside the loop,\n    and drop AATags that reference these scopes.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/79137.\n\ndiff --git a/llvm/lib/Analysis/LoopAccessAnalysis.cpp b/llvm/lib/Analysis/LoopAccessAnalysis.cpp\nindex 7e67c9015282..dd6b88fee415 100644\n--- a/llvm/lib/Analysis/LoopAccessAnalysis.cpp\n+++ b/llvm/lib/Analysis/LoopAccessAnalysis.cpp\n@@ -657,16 +657,18 @@ public:\n \n   AccessAnalysis(Loop *TheLoop, AAResults *AA, LoopInfo *LI,\n                  MemoryDepChecker::DepCandidates &DA,\n-                 PredicatedScalarEvolution &PSE)\n-      : TheLoop(TheLoop), BAA(*AA), AST(BAA), LI(LI), DepCands(DA), PSE(PSE) {\n+                 PredicatedScalarEvolution &PSE,\n+                 SmallPtrSetImpl<MDNode *> &LoopAliasScopes)\n+      : TheLoop(TheLoop), BAA(*AA), AST(BAA), LI(LI), DepCands(DA), PSE(PSE),\n+        LoopAliasScopes(LoopAliasScopes) {\n     // We're analyzing dependences across loop iterations.\n     BAA.enableCrossIterationMode();\n   }\n \n   /// Register a load  and whether it is only read from.\n   void addLoad(MemoryLocation &Loc, Type *AccessTy, bool IsReadOnly) {\n-    Value *Ptr = const_cast<Value*>(Loc.Ptr);\n-    AST.add(Loc.getWithNewSize(LocationSize::beforeOrAfterPointer()));\n+    Value *Ptr = const_cast<Value *>(Loc.Ptr);\n+    AST.add(adjustLoc(Loc));\n     Accesses[MemAccessInfo(Ptr, false)].insert(AccessTy);\n     if (IsReadOnly)\n       ReadOnlyPtr.insert(Ptr);\n@@ -674,8 +676,8 @@ public:\n \n   /// Register a store.\n   void addStore(MemoryLocation &Loc, Type *AccessTy) {\n-    Value *Ptr = const_cast<Value*>(Loc.Ptr);\n-    AST.add(Loc.getWithNewSize(LocationSize::beforeOrAfterPointer()));\n+    Value *Ptr = const_cast<Value *>(Loc.Ptr);\n+    AST.add(adjustLoc(Loc));\n     Accesses[MemAccessInfo(Ptr, true)].insert(AccessTy);\n   }\n \n@@ -731,6 +733,32 @@ public:\n private:\n   typedef MapVector<MemAccessInfo, SmallSetVector<Type *, 1>> PtrAccessMap;\n \n+  /// Adjust the MemoryLocation so that it represents accesses to this\n+  /// location across all iterations, rather than a single one.\n+  MemoryLocation adjustLoc(MemoryLocation Loc) const {\n+    // The accessed location varies within the loop, but remains within the\n+    // underlying object.\n+    Loc.Size = LocationSize::beforeOrAfterPointer();\n+    Loc.AATags.Scope = adjustAliasScopeList(Loc.AATags.Scope);\n+    Loc.AATags.NoAlias = adjustAliasScopeList(Loc.AATags.NoAlias);\n+    return Loc;\n+  }\n+\n+  /// Drop alias scopes that are only valid within a single loop iteration.\n+  MDNode *adjustAliasScopeList(MDNode *ScopeList) const {\n+    if (!ScopeList)\n+      return nullptr;\n+\n+    // For the sake of simplicity, drop the whole scope list if any scope is\n+    // iteration-local.\n+    if (any_of(ScopeList->operands(), [&](Metadata *Scope) {\n+          return LoopAliasScopes.contains(cast<MDNode>(Scope));\n+        }))\n+      return nullptr;\n+\n+    return ScopeList;\n+  }\n+\n   /// Go over all memory access and check whether runtime pointer checks\n   /// are needed and build sets of dependency check candidates.\n   void processMemAccesses();\n@@ -775,6 +803,10 @@ private:\n   PredicatedScalarEvolution &PSE;\n \n   DenseMap<Value *, SmallVector<const Value *, 16>> UnderlyingObjects;\n+\n+  /// Alias scopes that are declared inside the loop, and as such not valid\n+  /// across iterations.\n+  SmallPtrSetImpl<MDNode *> &LoopAliasScopes;\n };\n \n } // end anonymous namespace\n@@ -2283,6 +2315,7 @@ void LoopAccessInfo::analyzeLoop(AAResults *AA, LoopInfo *LI,\n   // Holds the Load and Store instructions.\n   SmallVector<LoadInst *, 16> Loads;\n   SmallVector<StoreInst *, 16> Stores;\n+  SmallPtrSet<MDNode *, 8> LoopAliasScopes;\n \n   // Holds all the different accesses in the loop.\n   unsigned NumReads = 0;\n@@ -2326,6 +2359,11 @@ void LoopAccessInfo::analyzeLoop(AAResults *AA, LoopInfo *LI,\n       if (HasComplexMemInst)\n         continue;\n \n+      // Record alias scopes defined inside the loop.\n+      if (auto *Decl = dyn_cast<NoAliasScopeDeclInst>(&I))\n+        for (Metadata *Op : Decl->getScopeList()->operands())\n+          LoopAliasScopes.insert(cast<MDNode>(Op));\n+\n       // Many math library functions read the rounding mode. We will only\n       // vectorize a loop if it contains known function calls that don't set\n       // the flag. Therefore, it is safe to ignore this read from memory.\n@@ -2407,7 +2445,8 @@ void LoopAccessInfo::analyzeLoop(AAResults *AA, LoopInfo *LI,\n   }\n \n   MemoryDepChecker::DepCandidates DependentAccesses;\n-  AccessAnalysis Accesses(TheLoop, AA, LI, DependentAccesses, *PSE);\n+  AccessAnalysis Accesses(TheLoop, AA, LI, DependentAccesses, *PSE,\n+                          LoopAliasScopes);\n \n   // Holds the analyzed pointers. We don't want to call getUnderlyingObjects\n   // multiple times on the same object. If the ptr is accessed twice, once\n",
  "tests": [
    {
      "file": "llvm/test/Analysis/LoopAccessAnalysis/noalias-scope-decl.ll",
      "commands": [
        "opt -passes='print<access-info>' -disable-output 2>&1 < %s"
      ],
      "tests": [
        {
          "test_name": "test_scope_out_of_loop",
          "test_body": "define void @test_scope_out_of_loop(ptr %arg, i64 %num) {\nentry:\n  %icmp = icmp ult i64 %num, 2\n  br i1 %icmp, label %exit, label %preheader\n\npreheader:                                        ; preds = %entry\n  call void @llvm.experimental.noalias.scope.decl(metadata !0)\n  call void @llvm.experimental.noalias.scope.decl(metadata !3)\n  %arg.1 = getelementptr inbounds i8, ptr %arg, i64 1\n  %end = add i64 %num, -2\n  br label %loop\n\nloop:                                             ; preds = %loop, %preheader\n  %prev.ptr = phi ptr [ %cur.ptr, %loop ], [ %arg, %preheader ]\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %preheader ]\n  %cur.ptr = getelementptr inbounds i8, ptr %arg.1, i64 %iv\n  %load.prev = load i8, ptr %prev.ptr, align 1, !alias.scope !0, !noalias !3\n  %load.cur = load i8, ptr %cur.ptr, align 1, !alias.scope !3\n  %add = add i8 %load.cur, %load.prev\n  store i8 %add, ptr %cur.ptr, align 1, !alias.scope !3\n  %iv.next = add nuw i64 %iv, 1\n  %cmp = icmp eq i64 %iv, %end\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %entry\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)\ndeclare void @llvm.experimental.noalias.scope.decl(metadata) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }\n\n!0 = !{!1}\n!1 = distinct !{!1, !2}\n!2 = distinct !{!2}\n!3 = !{!4}\n!4 = distinct !{!4, !5}\n!5 = distinct !{!5}\n"
        },
        {
          "test_name": "test_scope_in_loop",
          "test_body": "define void @test_scope_in_loop(ptr %arg, i64 %num) {\nentry:\n  %icmp = icmp ult i64 %num, 2\n  br i1 %icmp, label %exit, label %preheader\n\npreheader:                                        ; preds = %entry\n  %arg.1 = getelementptr inbounds i8, ptr %arg, i64 1\n  %end = add i64 %num, -2\n  br label %loop\n\nloop:                                             ; preds = %loop, %preheader\n  %prev.ptr = phi ptr [ %cur.ptr, %loop ], [ %arg, %preheader ]\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %preheader ]\n  %cur.ptr = getelementptr inbounds i8, ptr %arg.1, i64 %iv\n  call void @llvm.experimental.noalias.scope.decl(metadata !0)\n  call void @llvm.experimental.noalias.scope.decl(metadata !3)\n  %load.prev = load i8, ptr %prev.ptr, align 1, !alias.scope !0, !noalias !3\n  %load.cur = load i8, ptr %cur.ptr, align 1, !alias.scope !3\n  %add = add i8 %load.cur, %load.prev\n  store i8 %add, ptr %cur.ptr, align 1, !alias.scope !3\n  %iv.next = add nuw i64 %iv, 1\n  %cmp = icmp eq i64 %iv, %end\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %entry\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)\ndeclare void @llvm.experimental.noalias.scope.decl(metadata) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }\n\n!0 = !{!1}\n!1 = distinct !{!1, !2}\n!2 = distinct !{!2}\n!3 = !{!4}\n!4 = distinct !{!4, !5}\n!5 = distinct !{!5}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/PhaseOrdering/X86/loop-vectorizer-noalias.ll",
      "commands": [
        "opt -S -O3 -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "accsum",
          "test_body": "declare hidden void @acc(ptr noalias noundef, ptr noalias noundef)\n\ndefine void @accsum(ptr noundef %vals, i64 noundef %num) #0 {\nentry:\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.inc, %entry\n  %i.0 = phi i64 [ 1, %entry ], [ %inc, %for.inc ]\n  %cmp = icmp ult i64 %i.0, %num\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.cond\n  br label %for.end\n\nfor.body:                                         ; preds = %for.cond\n  %arrayidx = getelementptr inbounds i8, ptr %vals, i64 %i.0\n  %sub = sub i64 %i.0, 1\n  %arrayidx1 = getelementptr inbounds i8, ptr %vals, i64 %sub\n  call void @acc(ptr noundef %arrayidx, ptr noundef %arrayidx1)\n  br label %for.inc\n\nfor.inc:                                          ; preds = %for.body\n  %inc = add i64 %i.0, 1\n  br label %for.cond\n\nfor.end:                                          ; preds = %for.cond.cleanup\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" }\n"
        },
        {
          "test_name": "acc",
          "test_body": "define hidden void @acc(ptr noalias noundef %val, ptr noalias noundef %prev) {\nentry:\n  %0 = load i8, ptr %prev, align 1\n  %conv = zext i8 %0 to i32\n  %1 = load i8, ptr %val, align 1\n  %conv1 = zext i8 %1 to i32\n  %add = add nsw i32 %conv1, %conv\n  %conv2 = trunc i32 %add to i8\n  store i8 %conv2, ptr %val, align 1\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize] Miscompile with iteration-local scoped alias metadata",
    "body": "C reproducer: https://clang.godbolt.org/z/f6rE4jvhM\r\n\r\nIR reproducer: https://llvm.godbolt.org/z/7anbPon8K\r\n\r\n```llvm\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine hidden void @test(ptr %arg, i64 %num) {\r\nentry:\r\n  %icmp = icmp ult i64 %num, 2\r\n  br i1 %icmp, label %exit, label %preheader\r\n\r\npreheader:\r\n  %arg.1 = getelementptr inbounds i8, ptr %arg, i64 1\r\n  %end = add i64 %num, -2\r\n  br label %loop\r\n\r\nloop:\r\n  %prev.ptr = phi ptr [ %cur.ptr, %loop ], [ %arg, %preheader ]\r\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %preheader ]\r\n  %cur.ptr = getelementptr inbounds i8, ptr %arg.1, i64 %iv\r\n  call void @llvm.experimental.noalias.scope.decl(metadata !0)\r\n  call void @llvm.experimental.noalias.scope.decl(metadata !3)\r\n  %load.prev = load i8, ptr %prev.ptr, align 1, !alias.scope !0, !noalias !3\r\n  %load.cur = load i8, ptr %cur.ptr, align 1, !alias.scope !3\r\n  %add = add i8 %load.cur, %load.prev\r\n  store i8 %add, ptr %cur.ptr, align 1, !alias.scope !3\r\n  %iv.next = add nuw i64 %iv, 1\r\n  %cmp = icmp eq i64 %iv, %end\r\n  br i1 %cmp, label %exit, label %loop\r\n\r\nexit:\r\n  ret void\r\n}\r\n\r\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)\r\ndeclare void @llvm.experimental.noalias.scope.decl(metadata) #0\r\n\r\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }\r\n\r\n!0 = !{!1}\r\n!1 = distinct !{!1, !2}\r\n!2 = distinct !{!2}\r\n!3 = !{!4}\r\n!4 = distinct !{!4, !5}\r\n!5 = distinct !{!5}\r\n```\r\n\r\nThe current and previous value are only noalias within the iteration (per the location of the `@llvm.experimental.noalias.scope.decl`), but the vectorization appears to assume that the underlying objects don't alias.",
    "author": "nikic",
    "labels": [
      "miscompilation",
      "release:backport",
      "llvm:analysis"
    ],
    "comments": [
      {
        "author": "nikic",
        "body": "Well, I guess the actual problem here is in LAA rather than LoopVectorize proper. Debug log:\r\n```\r\nLAA: Found a loop in test: loop\r\nLAA: Processing memory accesses...\r\n  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.\r\n  AliasSet[0x8e36e00, 1] must alias, No access Memory locations: (ptr %cur.ptr, unknown before-or-after)\r\n  AliasSet[0x8e372b0, 1] must alias, No access Memory locations: (ptr %prev.ptr, unknown before-or-after)\r\n\r\nLAA:   Accesses(3):\r\n\t  %cur.ptr = getelementptr inbounds i8, ptr %arg.1, i64 %iv (write)\r\n\t  %prev.ptr = phi ptr [ %cur.ptr, %loop ], [ %arg, %preheader ] (read-only)\r\n\t  %cur.ptr = getelementptr inbounds i8, ptr %arg.1, i64 %iv (read)\r\nUnderlying objects for pointer   %cur.ptr = getelementptr inbounds i8, ptr %arg.1, i64 %iv\r\n  ptr %arg\r\nUnderlying objects for pointer   %cur.ptr = getelementptr inbounds i8, ptr %arg.1, i64 %iv\r\n  ptr %arg\r\nUnderlying objects for pointer   %prev.ptr = phi ptr [ %cur.ptr, %loop ], [ %arg, %preheader ]\r\n  ptr %arg\r\nLAA: May be able to perform a memory runtime check if needed.\r\nLAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.\r\n```\r\n\r\nWhen constructing the AST we get the LocationSize to BeforeOrAfter, but we retain the AATags, which is generally not valid.\r\n\r\n@fhahn "
      },
      {
        "author": "github-actions[bot]",
        "body": "/pull-request llvm/llvm-project#79561"
      },
      {
        "author": "EugeneZelenko",
        "body": "@mjbedy: But pull request is still open."
      },
      {
        "author": "tstellar",
        "body": "PR has been created, we will track the status there."
      }
    ]
  }
}
