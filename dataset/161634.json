{
  "bug_id": "161634",
  "issue_url": "https://github.com/llvm/llvm-project/issues/161634",
  "bug_type": "miscompilation",
  "base_commit": "4cc0bae159e56dc02145f9154005dc1eb9ed1fd7",
  "knowledge_cutoff": "2025-10-02T07:36:01Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine",
    "llvm/test/Transforms/LoopVectorize",
    "llvm/test/Transforms/PhaseOrdering"
  ],
  "hints": {
    "fix_commit": "9e63b7ae4c6f6a06882ade921795c42108355c71",
    "components": [
      "InstCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        [
          544,
          551
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        "InstCombinerImpl::foldSelectIntoOp"
      ]
    }
  },
  "patch": "commit 9e63b7ae4c6f6a06882ade921795c42108355c71\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Sat Oct 11 10:04:55 2025 +0800\n\n    [InstCombine] Fix flag propagation in `foldSelectIntoOp` (#162003)\n    \n    Consider the following transform:\n    ```\n    C = binop float A, nnan OOp\n    D = select ninf, i1 cond, float C, float A\n    ->\n    E = select ninf, i1 cond, float OOp, float Identity\n    F = binop float A, E\n    ```\n    We cannot propagate ninf from the original select, because OOp may be\n    inf, and the flag only guarantees that FalseVal (op OOp) is never\n    infinity.\n    Examples: -inf + +inf = NaN, -inf - -inf = NaN, 0 * inf = NaN\n    Specifically, if the original select has both ninf and nnan, we can\n    safely propagate the flag.\n    \n    Alive2:\n    + fadd: https://alive2.llvm.org/ce/z/TWfktv\n    + fsub: https://alive2.llvm.org/ce/z/RAsjJb\n    + fmul: https://alive2.llvm.org/ce/z/8eg4ND\n    \n    Closes https://github.com/llvm/llvm-project/issues/161634.\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\nindex 8c8fc69e27ee..6b67b48a138b 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n@@ -544,8 +544,18 @@ Instruction *InstCombinerImpl::foldSelectIntoOp(SelectInst &SI, Value *TrueVal,\n \n     Value *NewSel = Builder.CreateSelect(SI.getCondition(), Swapped ? C : OOp,\n                                          Swapped ? OOp : C, \"\", &SI);\n-    if (isa<FPMathOperator>(&SI))\n-      cast<Instruction>(NewSel)->setFastMathFlags(FMF);\n+    if (isa<FPMathOperator>(&SI)) {\n+      FastMathFlags NewSelFMF = FMF;\n+      // We cannot propagate ninf from the original select, because OOp may be\n+      // inf and the flag only guarantees that FalseVal (op OOp) is never\n+      // infinity.\n+      // Examples: -inf + +inf = NaN, -inf - -inf = NaN, 0 * inf = NaN\n+      // Specifically, if the original select has both ninf and nnan, we can\n+      // safely propagate the flag.\n+      NewSelFMF.setNoInfs(TVI->hasNoInfs() ||\n+                          (NewSelFMF.noInfs() && NewSelFMF.noNaNs()));\n+      cast<Instruction>(NewSel)->setFastMathFlags(NewSelFMF);\n+    }\n     NewSel->takeName(TVI);\n     BinaryOperator *BO =\n         BinaryOperator::Create(TVI->getOpcode(), FalseVal, NewSel);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/fold-select-fmul-if-zero.ll",
      "commands": [
        "opt -S -passes=instcombine < %s",
        "opt -S -passes=instcombine -denormal-fp-math=preserve-sign < %s",
        "opt -S -passes=instcombine -denormal-fp-math=positive-zero < %s"
      ],
      "tests": [
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_nsz_nnan_fmul",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_nsz_nnan_fmul(float %x, float %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nnan nsz float %x, %y\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_select_known_never_negzero_negsub",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_select_known_never_negzero_negsub(float %x, float nofpclass(nzero nsub) %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nnan ninf float %x, %y\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_self_if_0_oeq_zero_f32",
          "test_body": "define float @fmul_by_self_if_0_oeq_zero_f32(float %x) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul float %x, %x\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_self_if_0_oeq_zero_f32_fmul_nnan_ninf_nsz",
          "test_body": "define float @fmul_by_self_if_0_oeq_zero_f32_fmul_nnan_ninf_nsz(float %x) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nnan ninf nsz float %x, %x\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_nsz_fmul",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_nsz_fmul(float %x, float %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nsz float %x, %y\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_nsz_commuted",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_nsz_commuted(float %x, float %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nnan ninf nsz float %y, %x\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_select_nsz_inverted",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_select_nsz_inverted(float %x, float %y) {\n  %x.is.not.zero = fcmp one float %x, 0.000000e+00\n  %scaled.x = fmul nnan ninf float %x, %y\n  %scaled.if.denormal = select nsz i1 %x.is.not.zero, float %x, float %scaled.x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_nnan_ninf_fmul",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_nnan_ninf_fmul(float %x, float %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nnan ninf float %x, %y\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_nsz_ninf_fmul",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_nsz_ninf_fmul(float %x, float %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul ninf nsz float %x, %y\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_select_known_never_negzero",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_select_known_never_negzero(float %x, float nofpclass(nzero) %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nnan ninf float %x, %y\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        },
        {
          "test_name": "fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_nsz",
          "test_body": "define float @fmul_by_var_if_0_oeq_zero_f32_fmul_nnan_ninf_nsz(float %x, float %y) {\n  %x.is.zero = fcmp oeq float %x, 0.000000e+00\n  %scaled.x = fmul nnan ninf nsz float %x, %y\n  %scaled.if.denormal = select nnan i1 %x.is.zero, float %scaled.x, float %x\n  ret float %scaled.if.denormal\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/InstCombine/select-binop-foldable-floating-point.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "select_fpclass_fadd_nnan_ninf",
          "test_body": "define float @select_fpclass_fadd_nnan_ninf(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select nnan ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fmul_swapped",
          "test_body": "define float @select_nnan_fmul_swapped(i1 %cond, float %A, float %B) {\n  %C = fmul float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_ninf2",
          "test_body": "define float @select_fpclass_fmul_ninf2(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd_ninf2",
          "test_body": "define float @select_fpclass_fadd_ninf2(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_ninf3",
          "test_body": "define float @select_fpclass_fmul_ninf3(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul ninf float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fsub",
          "test_body": "define float @select_nnan_fsub(i1 %cond, float %A, float %B) {\n  %C = fsub float %A, %B\n  %D = select nnan i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_ninf2",
          "test_body": "define float @select_fpclass_fsub_ninf2(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fdiv_swapped_fast_math",
          "test_body": "define float @select_nnan_fdiv_swapped_fast_math(i1 %cond, float %A, float %B) {\n  %C = fdiv fast float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fsub_swapped",
          "test_body": "define float @select_nnan_fsub_swapped(i1 %cond, float %A, float %B) {\n  %C = fsub float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd",
          "test_body": "define float @select_fpclass_fadd(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fmul_swapped_fast_math",
          "test_body": "define float @select_nnan_fmul_swapped_fast_math(i1 %cond, float %A, float %B) {\n  %C = fmul fast float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd_ninf1",
          "test_body": "define float @select_fpclass_fadd_ninf1(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd ninf float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_nsz_fsub_v4f32",
          "test_body": "define <4 x float> @select_nnan_nsz_fsub_v4f32(<4 x i1> %cond, <4 x float> %A, <4 x float> %B) {\n  %C = fsub <4 x float> %A, %B\n  %D = select nnan nsz <4 x i1> %cond, <4 x float> %C, <4 x float> %A\n  ret <4 x float> %D\n}\n"
        },
        {
          "test_name": "select_nnan_fsub_fast_math",
          "test_body": "define float @select_nnan_fsub_fast_math(i1 %cond, float %A, float %B) {\n  %C = fsub fast float %A, %B\n  %D = select nnan i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fadd_swapped",
          "test_body": "define float @select_nnan_fadd_swapped(i1 %cond, float %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fmul_fast_math",
          "test_body": "define float @select_nnan_fmul_fast_math(i1 %cond, float %A, float %B) {\n  %C = fmul fast float %A, %B\n  %D = select nnan i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd_ninf3",
          "test_body": "define float @select_fpclass_fadd_ninf3(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd ninf float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fdiv_fast_math",
          "test_body": "define float @select_nnan_fdiv_fast_math(i1 %cond, float %A, float %B) {\n  %C = fdiv fast float %A, %B\n  %D = select nnan i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fadd_fast_math",
          "test_body": "define float @select_nnan_fadd_fast_math(i1 %cond, float %A, float %B) {\n  %C = fadd fast float %A, %B\n  %D = select nnan i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fsub_swapped_fast_math",
          "test_body": "define float @select_nnan_fsub_swapped_fast_math(i1 %cond, float %A, float %B) {\n  %C = fsub fast float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_nnan_ninf",
          "test_body": "define float @select_fpclass_fsub_nnan_ninf(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub float %A, %B\n  %D = select nnan ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fadd",
          "test_body": "define float @select_nnan_fadd(i1 %cond, float %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select nnan i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_ninf1",
          "test_body": "define float @select_fpclass_fmul_ninf1(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul ninf float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_ninf1",
          "test_body": "define float @select_fpclass_fsub_ninf1(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub ninf float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_nnan_ninf",
          "test_body": "define float @select_fpclass_fmul_nnan_ninf(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul float %A, %B\n  %D = select nnan ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_ninf3",
          "test_body": "define float @select_fpclass_fsub_ninf3(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub ninf float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fadd_swapped_fast_math",
          "test_body": "define float @select_nnan_fadd_swapped_fast_math(i1 %cond, float %A, float %B) {\n  %C = fadd fast float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_nnan_fdiv_swapped",
          "test_body": "define float @select_nnan_fdiv_swapped(i1 %cond, float %A, float %B) {\n  %C = fdiv float %A, %B\n  %D = select nnan i1 %cond, float %A, float %C\n  ret float %D\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/ARM/mve-selectandorcost.ll",
      "commands": [
        "opt -passes=loop-vectorize,instcombine,simplifycfg < %s -S -o -",
        "opt -passes=loop-vectorize -debug-only=loop-vectorize -disable-output < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-arm-none-eabi\"\n\ndefine float @test(ptr readonly captures(none) %pA, ptr readonly captures(none) %pB, i32 %blockSize) #0 {\nentry:\n  %cmp.not16 = icmp eq i32 %blockSize, 0\n  br i1 %cmp.not16, label %while.end, label %while.body\n\nwhile.body:                                       ; preds = %if.end, %entry\n  %pA.addr.020 = phi ptr [ %incdec.ptr, %if.end ], [ %pA, %entry ]\n  %pB.addr.019 = phi ptr [ %incdec.ptr1, %if.end ], [ %pB, %entry ]\n  %blockSize.addr.018 = phi i32 [ %dec, %if.end ], [ %blockSize, %entry ]\n  %accum.017 = phi float [ %accum.1, %if.end ], [ 0.000000e+00, %entry ]\n  %incdec.ptr = getelementptr inbounds float, ptr %pA.addr.020, i32 1\n  %0 = load float, ptr %pA.addr.020, align 4\n  %incdec.ptr1 = getelementptr inbounds float, ptr %pB.addr.019, i32 1\n  %1 = load float, ptr %pB.addr.019, align 4\n  %cmp2 = fcmp fast une float %0, 0.000000e+00\n  %cmp3 = fcmp fast une float %1, 0.000000e+00\n  %or.cond = select i1 %cmp2, i1 true, i1 %cmp3\n  br i1 %or.cond, label %if.then, label %if.end\n\nif.then:                                          ; preds = %while.body\n  %2 = tail call fast float @llvm.fabs.f32(float %0)\n  %3 = tail call fast float @llvm.fabs.f32(float %1)\n  %add = fadd fast float %3, %2\n  %sub = fsub fast float %0, %1\n  %4 = tail call fast float @llvm.fabs.f32(float %sub)\n  %div = fdiv fast float %4, %add\n  %add4 = fadd fast float %div, %accum.017\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %while.body\n  %accum.1 = phi float [ %add4, %if.then ], [ %accum.017, %while.body ]\n  %dec = add i32 %blockSize.addr.018, -1\n  %cmp.not = icmp eq i32 %dec, 0\n  br i1 %cmp.not, label %while.end, label %while.body\n\nwhile.end:                                        ; preds = %if.end, %entry\n  %accum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %accum.1, %if.end ]\n  ret float %accum.0.lcssa\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.fabs.f32(float) #1\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\nattributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/PhaseOrdering/AArch64/predicated-reduction.ll",
      "commands": [
        "opt -passes=\"default<O3>\" -S < %s"
      ],
      "tests": [
        {
          "test_name": "monte_exp",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64\"\n\ndefine nofpclass(nan inf) double @monte_exp(i32 noundef %nblocks, i32 noundef %RAND_BLOCK_LENGTH, ptr noundef %samples, double noundef nofpclass(nan inf) %Y, double noundef nofpclass(nan inf) %Z) {\nentry:\n  %nblocks.addr = alloca i32, align 4\n  %RAND_BLOCK_LENGTH.addr = alloca i32, align 4\n  %samples.addr = alloca ptr, align 8\n  %Y.addr = alloca double, align 8\n  %Z.addr = alloca double, align 8\n  %i = alloca i32, align 4\n  %block = alloca i32, align 4\n  %rngVal = alloca double, align 8\n  %callValue = alloca double, align 8\n  %v0 = alloca double, align 8\n  %v1 = alloca double, align 8\n  store i32 %nblocks, ptr %nblocks.addr, align 4\n  store i32 %RAND_BLOCK_LENGTH, ptr %RAND_BLOCK_LENGTH.addr, align 4\n  store ptr %samples, ptr %samples.addr, align 8\n  store double %Y, ptr %Y.addr, align 8\n  store double %Z, ptr %Z.addr, align 8\n  call void @llvm.lifetime.start.p0(ptr %i)\n  call void @llvm.lifetime.start.p0(ptr %block)\n  call void @llvm.lifetime.start.p0(ptr %rngVal)\n  call void @llvm.lifetime.start.p0(ptr %callValue)\n  call void @llvm.lifetime.start.p0(ptr %v0)\n  store double 0.000000e+00, ptr %v0, align 8\n  call void @llvm.lifetime.start.p0(ptr %v1)\n  store double 0.000000e+00, ptr %v1, align 8\n  store i32 0, ptr %block, align 4\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.inc8, %entry\n  %0 = load i32, ptr %block, align 4\n  %1 = load i32, ptr %nblocks.addr, align 4\n  %cmp = icmp slt i32 %0, %1\n  br i1 %cmp, label %for.body, label %for.end10\n\nfor.body:                                         ; preds = %for.cond\n  %2 = load i32, ptr %RAND_BLOCK_LENGTH.addr, align 4\n  %3 = load ptr, ptr %samples.addr, align 8\n  call void @resample(i32 noundef %2, ptr noundef %3)\n  store i32 0, ptr %i, align 4\n  br label %for.cond1\n\nfor.cond1:                                        ; preds = %for.inc, %for.body\n  %4 = load i32, ptr %i, align 4\n  %5 = load i32, ptr %RAND_BLOCK_LENGTH.addr, align 4\n  %cmp2 = icmp slt i32 %4, %5\n  br i1 %cmp2, label %for.body3, label %for.end\n\nfor.body3:                                        ; preds = %for.cond1\n  %6 = load ptr, ptr %samples.addr, align 8\n  %7 = load i32, ptr %i, align 4\n  %idxprom = sext i32 %7 to i64\n  %arrayidx = getelementptr inbounds float, ptr %6, i64 %idxprom\n  %8 = load float, ptr %arrayidx, align 4\n  %conv = fpext float %8 to double\n  store double %conv, ptr %rngVal, align 8\n  %9 = load double, ptr %Y.addr, align 8\n  %10 = load double, ptr %rngVal, align 8\n  %11 = call fast double @llvm.exp2.f64(double %10)\n  %mul = fmul fast double %9, %11\n  %12 = load double, ptr %Z.addr, align 8\n  %sub = fsub fast double %mul, %12\n  store double %sub, ptr %callValue, align 8\n  %13 = load double, ptr %callValue, align 8\n  %cmp4 = fcmp fast ogt double %13, 0.000000e+00\n  br i1 %cmp4, label %if.then, label %if.end\n\nif.then:                                          ; preds = %for.body3\n  %14 = load double, ptr %callValue, align 8\n  %15 = load double, ptr %v0, align 8\n  %add = fadd fast double %15, %14\n  store double %add, ptr %v0, align 8\n  %16 = load double, ptr %callValue, align 8\n  %17 = load double, ptr %callValue, align 8\n  %mul6 = fmul fast double %16, %17\n  %18 = load double, ptr %v1, align 8\n  %add7 = fadd fast double %18, %mul6\n  store double %add7, ptr %v1, align 8\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %for.body3\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.end\n  %19 = load i32, ptr %i, align 4\n  %inc = add nsw i32 %19, 1\n  store i32 %inc, ptr %i, align 4\n  br label %for.cond1\n\nfor.end:                                          ; preds = %for.cond1\n  br label %for.inc8\n\nfor.inc8:                                         ; preds = %for.end\n  %20 = load i32, ptr %block, align 4\n  %inc9 = add nsw i32 %20, 1\n  store i32 %inc9, ptr %block, align 4\n  br label %for.cond\n\nfor.end10:                                        ; preds = %for.cond\n  %21 = load double, ptr %v0, align 8\n  %22 = load double, ptr %v1, align 8\n  %add11 = fadd fast double %21, %22\n  call void @llvm.lifetime.end.p0(ptr %v1)\n  call void @llvm.lifetime.end.p0(ptr %v0)\n  call void @llvm.lifetime.end.p0(ptr %callValue)\n  call void @llvm.lifetime.end.p0(ptr %rngVal)\n  call void @llvm.lifetime.end.p0(ptr %block)\n  call void @llvm.lifetime.end.p0(ptr %i)\n  ret double %add11\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p0(ptr captures(none)) #0\n\ndeclare void @resample(i32 noundef, ptr noundef)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare double @llvm.exp2.f64(double) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.end.p0(ptr captures(none)) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\nattributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "monte_simple",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64\"\n\ndefine nofpclass(nan inf) double @monte_simple(i32 noundef %nblocks, i32 noundef %RAND_BLOCK_LENGTH, ptr noundef %samples, double noundef nofpclass(nan inf) %Y, double noundef nofpclass(nan inf) %Z) {\nentry:\n  %nblocks.addr = alloca i32, align 4\n  %RAND_BLOCK_LENGTH.addr = alloca i32, align 4\n  %samples.addr = alloca ptr, align 8\n  %Y.addr = alloca double, align 8\n  %Z.addr = alloca double, align 8\n  %i = alloca i32, align 4\n  %block = alloca i32, align 4\n  %rngVal = alloca double, align 8\n  %callValue = alloca double, align 8\n  %v0 = alloca double, align 8\n  %v1 = alloca double, align 8\n  store i32 %nblocks, ptr %nblocks.addr, align 4\n  store i32 %RAND_BLOCK_LENGTH, ptr %RAND_BLOCK_LENGTH.addr, align 4\n  store ptr %samples, ptr %samples.addr, align 8\n  store double %Y, ptr %Y.addr, align 8\n  store double %Z, ptr %Z.addr, align 8\n  call void @llvm.lifetime.start.p0(ptr %i)\n  call void @llvm.lifetime.start.p0(ptr %block)\n  call void @llvm.lifetime.start.p0(ptr %rngVal)\n  call void @llvm.lifetime.start.p0(ptr %callValue)\n  call void @llvm.lifetime.start.p0(ptr %v0)\n  store double 0.000000e+00, ptr %v0, align 8\n  call void @llvm.lifetime.start.p0(ptr %v1)\n  store double 0.000000e+00, ptr %v1, align 8\n  store i32 0, ptr %i, align 4\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.inc, %entry\n  %0 = load i32, ptr %i, align 4\n  %1 = load i32, ptr %RAND_BLOCK_LENGTH.addr, align 4\n  %cmp = icmp slt i32 %0, %1\n  br i1 %cmp, label %for.body, label %for.end\n\nfor.body:                                         ; preds = %for.cond\n  %2 = load ptr, ptr %samples.addr, align 8\n  %3 = load i32, ptr %i, align 4\n  %idxprom = sext i32 %3 to i64\n  %arrayidx = getelementptr inbounds float, ptr %2, i64 %idxprom\n  %4 = load float, ptr %arrayidx, align 4\n  %conv = fpext float %4 to double\n  store double %conv, ptr %rngVal, align 8\n  %5 = load double, ptr %Y.addr, align 8\n  %6 = load double, ptr %rngVal, align 8\n  %mul = fmul fast double %5, %6\n  %7 = load double, ptr %Z.addr, align 8\n  %sub = fsub fast double %mul, %7\n  store double %sub, ptr %callValue, align 8\n  %8 = load double, ptr %callValue, align 8\n  %cmp1 = fcmp fast ogt double %8, 0.000000e+00\n  br i1 %cmp1, label %if.then, label %if.end\n\nif.then:                                          ; preds = %for.body\n  %9 = load double, ptr %callValue, align 8\n  %10 = load double, ptr %v0, align 8\n  %add = fadd fast double %10, %9\n  store double %add, ptr %v0, align 8\n  %11 = load double, ptr %callValue, align 8\n  %12 = load double, ptr %callValue, align 8\n  %mul3 = fmul fast double %11, %12\n  %13 = load double, ptr %v1, align 8\n  %add4 = fadd fast double %13, %mul3\n  store double %add4, ptr %v1, align 8\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %for.body\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.end\n  %14 = load i32, ptr %i, align 4\n  %inc = add nsw i32 %14, 1\n  store i32 %inc, ptr %i, align 4\n  br label %for.cond\n\nfor.end:                                          ; preds = %for.cond\n  %15 = load double, ptr %v0, align 8\n  %16 = load double, ptr %v1, align 8\n  %add5 = fadd fast double %15, %16\n  call void @llvm.lifetime.end.p0(ptr %v1)\n  call void @llvm.lifetime.end.p0(ptr %v0)\n  call void @llvm.lifetime.end.p0(ptr %callValue)\n  call void @llvm.lifetime.end.p0(ptr %rngVal)\n  call void @llvm.lifetime.end.p0(ptr %block)\n  call void @llvm.lifetime.end.p0(ptr %i)\n  ret double %add5\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p0(ptr captures(none)) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.end.p0(ptr captures(none)) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] ninf should not be preserved",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/GNeZKU\n```\n; bin/opt -passes=instcombine test.ll -S\ndefine float @select_fpclass_fadd(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n```\n```\n=>\ndefine float @select_fpclass_fadd(i1 %cond, float nofpclass(3) %A, float %B) {\n#0:\n  %C = select ninf i1 %cond, float %B, float -0.000000\n  %D = fadd float nofpclass(3) %A, %C\n  ret float %D\n}\nTransformation doesn't verify!\n\nERROR: Target is more poisonous than source\n\nExample:\ni1 %cond = #x1 (1)\nfloat nofpclass(3) %A = #xff800000 (-oo)\nfloat %B = #x7f800000 (+oo)\n\nSource:\nfloat %C = #xffc00000 (QNaN)\nfloat %D = #xffc00000 (QNaN)\n\nTarget:\nfloat %C = poison\nfloat %D = poison\nSource value: #xffc00000 (QNaN)\nTarget value: poison\n```",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:instcombine",
      "floating-point",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "https://github.com/llvm/llvm-project/blob/6ee362e1b5eb52421e0e700074c40ff9e7e0205e/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp#L545-L546"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}