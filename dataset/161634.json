{
  "bug_id": "161634",
  "issue_url": "https://github.com/llvm/llvm-project/issues/161634",
  "bug_type": "miscompilation",
  "base_commit": "4cc0bae159e56dc02145f9154005dc1eb9ed1fd7",
  "knowledge_cutoff": "2025-10-02T07:36:01Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine",
    "llvm/test/Transforms/LoopVectorize",
    "llvm/test/Transforms/PhaseOrdering"
  ],
  "hints": {
    "fix_commit": "9e63b7ae4c6f6a06882ade921795c42108355c71",
    "components": [
      "InstCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        [
          544,
          551
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        "InstCombinerImpl::foldSelectIntoOp"
      ]
    }
  },
  "patch": "commit 9e63b7ae4c6f6a06882ade921795c42108355c71\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Sat Oct 11 10:04:55 2025 +0800\n\n    [InstCombine] Fix flag propagation in `foldSelectIntoOp` (#162003)\n    \n    Consider the following transform:\n    ```\n    C = binop float A, nnan OOp\n    D = select ninf, i1 cond, float C, float A\n    ->\n    E = select ninf, i1 cond, float OOp, float Identity\n    F = binop float A, E\n    ```\n    We cannot propagate ninf from the original select, because OOp may be\n    inf, and the flag only guarantees that FalseVal (op OOp) is never\n    infinity.\n    Examples: -inf + +inf = NaN, -inf - -inf = NaN, 0 * inf = NaN\n    Specifically, if the original select has both ninf and nnan, we can\n    safely propagate the flag.\n    \n    Alive2:\n    + fadd: https://alive2.llvm.org/ce/z/TWfktv\n    + fsub: https://alive2.llvm.org/ce/z/RAsjJb\n    + fmul: https://alive2.llvm.org/ce/z/8eg4ND\n    \n    Closes https://github.com/llvm/llvm-project/issues/161634.\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\nindex 8c8fc69e27ee..6b67b48a138b 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n@@ -544,8 +544,18 @@ Instruction *InstCombinerImpl::foldSelectIntoOp(SelectInst &SI, Value *TrueVal,\n \n     Value *NewSel = Builder.CreateSelect(SI.getCondition(), Swapped ? C : OOp,\n                                          Swapped ? OOp : C, \"\", &SI);\n-    if (isa<FPMathOperator>(&SI))\n-      cast<Instruction>(NewSel)->setFastMathFlags(FMF);\n+    if (isa<FPMathOperator>(&SI)) {\n+      FastMathFlags NewSelFMF = FMF;\n+      // We cannot propagate ninf from the original select, because OOp may be\n+      // inf and the flag only guarantees that FalseVal (op OOp) is never\n+      // infinity.\n+      // Examples: -inf + +inf = NaN, -inf - -inf = NaN, 0 * inf = NaN\n+      // Specifically, if the original select has both ninf and nnan, we can\n+      // safely propagate the flag.\n+      NewSelFMF.setNoInfs(TVI->hasNoInfs() ||\n+                          (NewSelFMF.noInfs() && NewSelFMF.noNaNs()));\n+      cast<Instruction>(NewSel)->setFastMathFlags(NewSelFMF);\n+    }\n     NewSel->takeName(TVI);\n     BinaryOperator *BO =\n         BinaryOperator::Create(TVI->getOpcode(), FalseVal, NewSel);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/select-binop-foldable-floating-point.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "select_fpclass_fadd_nnan_ninf",
          "test_body": "define float @select_fpclass_fadd_nnan_ninf(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select nnan ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_ninf2",
          "test_body": "define float @select_fpclass_fmul_ninf2(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd_ninf2",
          "test_body": "define float @select_fpclass_fadd_ninf2(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_ninf3",
          "test_body": "define float @select_fpclass_fmul_ninf3(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul ninf float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_ninf2",
          "test_body": "define float @select_fpclass_fsub_ninf2(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd",
          "test_body": "define float @select_fpclass_fadd(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd_ninf1",
          "test_body": "define float @select_fpclass_fadd_ninf1(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd ninf float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fadd_ninf3",
          "test_body": "define float @select_fpclass_fadd_ninf3(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd ninf float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_nnan_ninf",
          "test_body": "define float @select_fpclass_fsub_nnan_ninf(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub float %A, %B\n  %D = select nnan ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_ninf1",
          "test_body": "define float @select_fpclass_fmul_ninf1(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul ninf float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_ninf1",
          "test_body": "define float @select_fpclass_fsub_ninf1(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub ninf float %A, %B\n  %D = select i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fmul_nnan_ninf",
          "test_body": "define float @select_fpclass_fmul_nnan_ninf(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fmul float %A, %B\n  %D = select nnan ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        },
        {
          "test_name": "select_fpclass_fsub_ninf3",
          "test_body": "define float @select_fpclass_fsub_ninf3(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fsub ninf float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] ninf should not be preserved",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/GNeZKU\n```\n; bin/opt -passes=instcombine test.ll -S\ndefine float @select_fpclass_fadd(i1 %cond, float nofpclass(nan) %A, float %B) {\n  %C = fadd float %A, %B\n  %D = select ninf i1 %cond, float %C, float %A\n  ret float %D\n}\n```\n```\n=>\ndefine float @select_fpclass_fadd(i1 %cond, float nofpclass(3) %A, float %B) {\n#0:\n  %C = select ninf i1 %cond, float %B, float -0.000000\n  %D = fadd float nofpclass(3) %A, %C\n  ret float %D\n}\nTransformation doesn't verify!\n\nERROR: Target is more poisonous than source\n\nExample:\ni1 %cond = #x1 (1)\nfloat nofpclass(3) %A = #xff800000 (-oo)\nfloat %B = #x7f800000 (+oo)\n\nSource:\nfloat %C = #xffc00000 (QNaN)\nfloat %D = #xffc00000 (QNaN)\n\nTarget:\nfloat %C = poison\nfloat %D = poison\nSource value: #xffc00000 (QNaN)\nTarget value: poison\n```",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:instcombine",
      "floating-point",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "https://github.com/llvm/llvm-project/blob/6ee362e1b5eb52421e0e700074c40ff9e7e0205e/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp#L545-L546"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}