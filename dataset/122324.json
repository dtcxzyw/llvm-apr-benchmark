{
  "bug_id": "122324",
  "issue_url": "https://github.com/llvm/llvm-project/issues/122324",
  "bug_type": "miscompilation",
  "base_commit": "26aa20a3dd82e2ff5855bee04b22b35f6b1f026f",
  "knowledge_cutoff": "2025-01-09T17:54:50Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "5ff36748cfeee1d02da6512ad578e4014724f67e",
    "components": [
      "SLPVectorizer"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          10973,
          10979
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "addMask",
        "swap",
        "gather",
        "empty",
        "size"
      ]
    }
  },
  "patch": "commit 5ff36748cfeee1d02da6512ad578e4014724f67e\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Thu Jan 9 10:39:38 2025 -0800\n\n    [SLP]Fix mask processing for reused gathered scalars\n    \n    Need to sync the mask between cost and actual emission to avoid bugs in\n    mask calculation\n    \n    Fixes #122324\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 36fed8937aec..48ed612c11b3 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -10973,7 +10973,19 @@ public:\n       }\n     }\n \n-    ::addMask(CommonMask, ExtMask, /*ExtendingManyInputs=*/true);\n+    if (!ExtMask.empty()) {\n+      if (CommonMask.empty()) {\n+        CommonMask.assign(ExtMask.begin(), ExtMask.end());\n+      } else {\n+        SmallVector<int> NewMask(ExtMask.size(), PoisonMaskElem);\n+        for (int I = 0, Sz = ExtMask.size(); I < Sz; ++I) {\n+          if (ExtMask[I] == PoisonMaskElem)\n+            continue;\n+          NewMask[I] = CommonMask[ExtMask[I]];\n+        }\n+        CommonMask.swap(NewMask);\n+      }\n+    }\n     if (CommonMask.empty()) {\n       assert(InVectors.size() == 1 && \"Expected only one vector with no mask\");\n       return Cost;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/shuffle-mask-emission.ll",
      "commands": [
        "opt -S -passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define i1 @test() {\nentry:\n  %h.promoted118.i.fr = freeze i32 1\n  %invariant.op.i51 = add i32 %h.promoted118.i.fr, 0\n  %conv25.i = xor i32 0, 0\n  %add.i.i = add i32 %conv25.i, %h.promoted118.i.fr\n  %sext.i.mask = and i32 %add.i.i, 0\n  %cmp27.i = icmp eq i32 %sext.i.mask, 1\n  %0 = or i1 %cmp27.i, false\n  %conv25.i.1 = add i32 0, 0\n  %add.i.i.1 = add i32 %conv25.i.1, %h.promoted118.i.fr\n  %sext.i.1.mask = and i32 %add.i.i.1, 1\n  %cmp27.i.1 = icmp eq i32 %sext.i.1.mask, 0\n  %conv25.1.i.1 = xor i32 0, 0\n  %add.i.1.i.1 = add i32 %conv25.1.i.1, %h.promoted118.i.fr\n  %sext.1.i.1.mask = and i32 %add.i.1.i.1, 1\n  %cmp27.1.i.1 = icmp eq i32 %sext.1.i.1.mask, 0\n  %add.i.2.reass.i.1 = add i32 %invariant.op.i51, %conv25.i.1\n  %sext.2.i.1.mask = and i32 %add.i.2.reass.i.1, 1\n  %cmp27.2.i.1 = icmp eq i32 %sext.2.i.1.mask, 0\n  %1 = or i1 %cmp27.1.i.1, %cmp27.2.i.1\n  %2 = or i1 %cmp27.i.1, %1\n  %3 = or i1 %0, %2\n  ret i1 %3\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Miscompilation",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/KF8JBo\nThis issue was originally reported on LoongArch.\n\n```\n; bin/opt -passes=slp-vectorizer test.ll -S\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i1 @src() {\nentry:\n  %h.promoted118.i.fr = freeze i32 1\n  %invariant.op.i51 = add i32 %h.promoted118.i.fr, 0\n  %conv25.i = xor i32 0, 0\n  %add.i.i = add i32 %conv25.i, %h.promoted118.i.fr\n  %sext.i.mask = and i32 %add.i.i, 0\n  %cmp27.i = icmp eq i32 %sext.i.mask, 1\n  %0 = or i1 %cmp27.i, false\n  %conv25.i.1 = add i32 0, 0\n  %add.i.i.1 = add i32 %conv25.i.1, %h.promoted118.i.fr\n  %sext.i.1.mask = and i32 %add.i.i.1, 1\n  %cmp27.i.1 = icmp eq i32 %sext.i.1.mask, 0\n  %conv25.1.i.1 = xor i32 0, 0\n  %add.i.1.i.1 = add i32 %conv25.1.i.1, %h.promoted118.i.fr\n  %sext.1.i.1.mask = and i32 %add.i.1.i.1, 1\n  %cmp27.1.i.1 = icmp eq i32 %sext.1.i.1.mask, 0\n  %add.i.2.reass.i.1 = add i32 %invariant.op.i51, %conv25.i.1\n  %sext.2.i.1.mask = and i32 %add.i.2.reass.i.1, 1\n  %cmp27.2.i.1 = icmp eq i32 %sext.2.i.1.mask, 0\n  %1 = or i1 %cmp27.1.i.1, %cmp27.2.i.1\n  %2 = or i1 %cmp27.i.1, %1\n  %3 = or i1 %0, %2\n  ret i1 %3\n}\n```\n```\n\n----------------------------------------\ndefine i1 @src() {\nentry:\n  %h.promoted118.i.fr = freeze i32 1\n  %invariant.op.i51 = add i32 %h.promoted118.i.fr, 0\n  %conv25.i = xor i32 0, 0\n  %add.i.i = add i32 %conv25.i, %h.promoted118.i.fr\n  %sext.i.mask = and i32 %add.i.i, 0\n  %cmp27.i = icmp eq i32 %sext.i.mask, 1\n  %#0 = or i1 %cmp27.i, 0\n  %conv25.i.1 = add i32 0, 0\n  %add.i.i.1 = add i32 %conv25.i.1, %h.promoted118.i.fr\n  %sext.i.1.mask = and i32 %add.i.i.1, 1\n  %cmp27.i.1 = icmp eq i32 %sext.i.1.mask, 0\n  %conv25.1.i.1 = xor i32 0, 0\n  %add.i.1.i.1 = add i32 %conv25.1.i.1, %h.promoted118.i.fr\n  %sext.1.i.1.mask = and i32 %add.i.1.i.1, 1\n  %cmp27.1.i.1 = icmp eq i32 %sext.1.i.1.mask, 0\n  %add.i.2.reass.i.1 = add i32 %invariant.op.i51, %conv25.i.1\n  %sext.2.i.1.mask = and i32 %add.i.2.reass.i.1, 1\n  %cmp27.2.i.1 = icmp eq i32 %sext.2.i.1.mask, 0\n  %#1 = or i1 %cmp27.1.i.1, %cmp27.2.i.1\n  %#2 = or i1 %cmp27.i.1, %#1\n  %#3 = or i1 %#0, %#2\n  ret i1 %#3\n}\n=>\ndefine i1 @src() {\nentry:\n  %h.promoted118.i.fr = freeze i32 1\n  %#0 = insertelement <4 x i32> { 0, 0, poison, 0 }, i32 %h.promoted118.i.fr, i32 2\n  %#1 = xor <4 x i32> { 0, 0, 0, 0 }, %#0\n  %#2 = add <4 x i32> { 0, 0, 0, 0 }, %#0\n  %#3 = shufflevector <4 x i32> %#1, <4 x i32> %#2, 0, 1, 6, 7\n  %#6 = shufflevector <4 x i32> %#0, <4 x i32> %#3, 0, 7\n  %#7 = shufflevector <2 x i32> %#6, <2 x i32> poison, 0, 0, 1, 0\n  %#8 = add <4 x i32> %#3, %#7\n  %#9 = and <4 x i32> %#8, { 0, 1, 1, 1 }\n  %#10 = icmp eq <4 x i32> %#9, { 1, 0, 0, 0 }\n  %#11 = reduce_or <4 x i1> %#10\n  %op.rdx = or i1 %#11, 0\n  ret i1 %op.rdx\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nExample:\n\nSource:\ni32 %h.promoted118.i.fr = #x00000001 (1)\ni32 %invariant.op.i51 = #x00000001 (1)\ni32 %conv25.i = #x00000000 (0)\ni32 %add.i.i = #x00000001 (1)\ni32 %sext.i.mask = #x00000000 (0)\ni1 %cmp27.i = #x0 (0)\ni1 %#0 = #x0 (0)\ni32 %conv25.i.1 = #x00000000 (0)\ni32 %add.i.i.1 = #x00000001 (1)\ni32 %sext.i.1.mask = #x00000001 (1)\ni1 %cmp27.i.1 = #x0 (0)\ni32 %conv25.1.i.1 = #x00000000 (0)\ni32 %add.i.1.i.1 = #x00000001 (1)\ni32 %sext.1.i.1.mask = #x00000001 (1)\ni1 %cmp27.1.i.1 = #x0 (0)\ni32 %add.i.2.reass.i.1 = #x00000001 (1)\ni32 %sext.2.i.1.mask = #x00000001 (1)\ni1 %cmp27.2.i.1 = #x0 (0)\ni1 %#1 = #x0 (0)\ni1 %#2 = #x0 (0)\ni1 %#3 = #x0 (0)\n\nTarget:\ni32 %h.promoted118.i.fr = #x00000001 (1)\n<4 x i32> %#0 = < #x00000000 (0), #x00000000 (0), #x00000001 (1), #x00000000 (0) >\n<4 x i32> %#1 = < #x00000000 (0), #x00000000 (0), #x00000001 (1), #x00000000 (0) >\n<4 x i32> %#2 = < #x00000000 (0), #x00000000 (0), #x00000001 (1), #x00000000 (0) >\n<4 x i32> %#3 = < #x00000000 (0), #x00000000 (0), #x00000001 (1), #x00000000 (0) >\n<2 x i32> %#6 = < #x00000000 (0), #x00000000 (0) >\n<4 x i32> %#7 = < #x00000000 (0), #x00000000 (0), #x00000000 (0), #x00000000 (0) >\n<4 x i32> %#8 = < #x00000000 (0), #x00000000 (0), #x00000001 (1), #x00000000 (0) >\n<4 x i32> %#9 = < #x00000000 (0), #x00000000 (0), #x00000001 (1), #x00000000 (0) >\n<4 x i1> %#10 = < #x0 (0), #x1 (1), #x0 (0), #x1 (1) >\ni1 %#11 = #x1 (1)\ni1 %op.rdx = #x1 (1)\nSource value: #x0 (0)\nTarget value: #x1 (1)\n\nSummary:\n  0 correct transformations\n  1 incorrect transformations\n  0 failed-to-prove transformations\n  0 Alive2 errors\n```\nllvm version: d80bdf7261e7d785b98f827eeed950b2147f70e6\n",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:SLPVectorizer"
    ],
    "comments": []
  }
}
