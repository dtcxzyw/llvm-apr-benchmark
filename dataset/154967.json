{
  "bug_id": "154967",
  "issue_url": "https://github.com/llvm/llvm-project/issues/154967",
  "bug_type": "miscompilation",
  "base_commit": "3cbbc075be6bbcfc9c7d8ff6d069403be28ad242",
  "knowledge_cutoff": "2025-08-22T15:11:23Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "c950a729749fc32a9431643d3d149bd833e01451",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          8634,
          8641
        ],
        [
          8926,
          8932
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp": [
        [
          538,
          545
        ],
        [
          559,
          566
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          919,
          926
        ],
        [
          1029,
          1034
        ],
        [
          1040,
          1047
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          2983,
          2991
        ],
        [
          3038,
          3050
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.h": [
        [
          70,
          77
        ],
        [
          207,
          214
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationPlanner::tryToBuildVPlanWithVPRecipes"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp": [
        "VPlanTransforms::handleEarlyExits"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPInstruction::computeCost",
        "VPInstruction::generate"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::convertToConcreteRecipes",
        "VPlanTransforms::handleUncountableEarlyExit"
      ]
    }
  },
  "patch": "commit c950a729749fc32a9431643d3d149bd833e01451\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Mon Aug 25 21:42:14 2025 +0100\n\n    [VPlan] Support scalar VF for ExtractLane and FirstActiveLane.\n    \n    Extend ExtractLane and FirstActiveLane to support scalable VFs. This\n    allows correct handling when interleaving with VF = 1.\n    \n    Alive2 proofs:\n     - Fixed codegen with this patch: https://alive2.llvm.org/ce/z/8Y5_Vc\n       (verifies as correct)\n     - Original codegen: https://alive2.llvm.org/ce/z/twdg3X (doesn't\n       verify)\n    \n    Fixes https://github.com/llvm/llvm-project/issues/154967.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex a0f306c12754..cc99386a4e66 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -8634,8 +8634,7 @@ VPlanPtr LoopVectorizationPlanner::tryToBuildVPlanWithVPRecipes(\n             return !CM.requiresScalarEpilogue(VF.isVector());\n           },\n           Range);\n-  VPlanTransforms::handleEarlyExits(*Plan, Legal->hasUncountableEarlyExit(),\n-                                    Range);\n+  VPlanTransforms::handleEarlyExits(*Plan, Legal->hasUncountableEarlyExit());\n   VPlanTransforms::addMiddleCheck(*Plan, RequiresScalarEpilogueCheck,\n                                   CM.foldTailByMasking());\n \n@@ -8926,7 +8925,7 @@ VPlanPtr LoopVectorizationPlanner::tryToBuildVPlan(VFRange &Range) {\n       OrigLoop, *LI, Legal->getWidestInductionType(),\n       getDebugLocFromInstOrOperands(Legal->getPrimaryInduction()), PSE);\n   VPlanTransforms::handleEarlyExits(*Plan,\n-                                    /*HasUncountableExit*/ false, Range);\n+                                    /*HasUncountableExit*/ false);\n   VPlanTransforms::addMiddleCheck(*Plan, /*RequiresScalarEpilogue*/ true,\n                                   /*TailFolded*/ false);\n \ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp b/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\nindex 80b48de57b40..4a8b4b8d0484 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanConstruction.cpp\n@@ -538,8 +538,7 @@ VPlanTransforms::buildVPlan0(Loop *TheLoop, LoopInfo &LI, Type *InductionTy,\n }\n \n void VPlanTransforms::handleEarlyExits(VPlan &Plan,\n-                                       bool HasUncountableEarlyExit,\n-                                       VFRange &Range) {\n+                                       bool HasUncountableEarlyExit) {\n   auto *MiddleVPBB = cast<VPBasicBlock>(\n       Plan.getScalarHeader()->getSinglePredecessor()->getPredecessors()[0]);\n   auto *LatchVPBB = cast<VPBasicBlock>(MiddleVPBB->getSinglePredecessor());\n@@ -559,8 +558,7 @@ void VPlanTransforms::handleEarlyExits(VPlan &Plan,\n         assert(!HandledUncountableEarlyExit &&\n                \"can handle exactly one uncountable early exit\");\n         handleUncountableEarlyExit(cast<VPBasicBlock>(Pred), EB, Plan,\n-                                   cast<VPBasicBlock>(HeaderVPB), LatchVPBB,\n-                                   Range);\n+                                   cast<VPBasicBlock>(HeaderVPB), LatchVPBB);\n         HandledUncountableEarlyExit = true;\n       } else {\n         for (VPRecipeBase &R : EB->phis())\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 2f3ee1ff61d2..f804846f82cc 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -919,8 +919,15 @@ Value *VPInstruction::generate(VPTransformState &State) {\n     unsigned LastOpIdx = getNumOperands() - 1;\n     Value *Res = nullptr;\n     for (int Idx = LastOpIdx; Idx >= 0; --Idx) {\n-      Value *TrailingZeros = Builder.CreateCountTrailingZeroElems(\n-          Builder.getInt64Ty(), State.get(getOperand(Idx)), true, Name);\n+      Value *TrailingZeros =\n+          State.VF.isScalar()\n+              ? Builder.CreateZExt(\n+                    Builder.CreateICmpEQ(State.get(getOperand(Idx)),\n+                                         Builder.getFalse()),\n+                    Builder.getInt64Ty())\n+              : Builder.CreateCountTrailingZeroElems(Builder.getInt64Ty(),\n+                                                     State.get(getOperand(Idx)),\n+                                                     true, Name);\n       Value *Current = Builder.CreateAdd(\n           Builder.CreateMul(RuntimeVF, Builder.getInt64(Idx)), TrailingZeros);\n       if (Res) {\n@@ -1029,6 +1036,12 @@ InstructionCost VPInstruction::computeCost(ElementCount VF,\n   switch (getOpcode()) {\n   case Instruction::ExtractElement:\n   case VPInstruction::ExtractLane: {\n+    if (VF.isScalar()) {\n+      // ExtractLane with VF=1 takes care of handling extracting across multiple\n+      // parts.\n+      return 0;\n+    }\n+\n     // Add on the cost of extracting the element.\n     auto *VecTy = toVectorTy(Ctx.Types.inferScalarType(getOperand(0)), VF);\n     return Ctx.TTI.getVectorInstrCost(Instruction::ExtractElement, VecTy,\n@@ -1040,8 +1053,13 @@ InstructionCost VPInstruction::computeCost(ElementCount VF,\n         Instruction::Or, cast<VectorType>(VecTy), std::nullopt, Ctx.CostKind);\n   }\n   case VPInstruction::FirstActiveLane: {\n+    Type *ScalarTy = Ctx.Types.inferScalarType(getOperand(0));\n+    if (VF.isScalar())\n+      return Ctx.TTI.getCmpSelInstrCost(Instruction::ICmp, ScalarTy,\n+                                        CmpInst::makeCmpResultType(ScalarTy),\n+                                        CmpInst::ICMP_EQ, Ctx.CostKind);\n     // Calculate the cost of determining the lane index.\n-    auto *PredTy = toVectorTy(Ctx.Types.inferScalarType(getOperand(0)), VF);\n+    auto *PredTy = toVectorTy(ScalarTy, VF);\n     IntrinsicCostAttributes Attrs(Intrinsic::experimental_cttz_elts,\n                                   Type::getInt64Ty(Ctx.LLVMCtx),\n                                   {PredTy, Type::getInt1Ty(Ctx.LLVMCtx)});\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex e0bf241c73fd..56175e7f1814 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -2983,9 +2983,11 @@ void VPlanTransforms::convertToConcreteRecipes(VPlan &Plan) {\n     R->eraseFromParent();\n }\n \n-void VPlanTransforms::handleUncountableEarlyExit(\n-    VPBasicBlock *EarlyExitingVPBB, VPBasicBlock *EarlyExitVPBB, VPlan &Plan,\n-    VPBasicBlock *HeaderVPBB, VPBasicBlock *LatchVPBB, VFRange &Range) {\n+void VPlanTransforms::handleUncountableEarlyExit(VPBasicBlock *EarlyExitingVPBB,\n+                                                 VPBasicBlock *EarlyExitVPBB,\n+                                                 VPlan &Plan,\n+                                                 VPBasicBlock *HeaderVPBB,\n+                                                 VPBasicBlock *LatchVPBB) {\n   VPBlockBase *MiddleVPBB = LatchVPBB->getSuccessors()[0];\n   if (!EarlyExitVPBB->getSinglePredecessor() &&\n       EarlyExitVPBB->getPredecessors()[1] == MiddleVPBB) {\n@@ -3038,13 +3040,7 @@ void VPlanTransforms::handleUncountableEarlyExit(\n     }\n \n     VPValue *IncomingFromEarlyExit = ExitIRI->getOperand(EarlyExitIdx);\n-    auto IsVector = [](ElementCount VF) { return VF.isVector(); };\n-    // When the VFs are vectors, need to add `extract` to get the incoming value\n-    // from early exit. When the range contains scalar VF, limit the range to\n-    // scalar VF to prevent mis-compilation for the range containing both scalar\n-    // and vector VFs.\n-    if (!IncomingFromEarlyExit->isLiveIn() &&\n-        LoopVectorizationPlanner::getDecisionAndClampRange(IsVector, Range)) {\n+    if (!IncomingFromEarlyExit->isLiveIn()) {\n       // Update the incoming value from the early exit.\n       VPValue *FirstActiveLane = EarlyExitB.createNaryOp(\n           VPInstruction::FirstActiveLane, {CondToEarlyExit}, nullptr,\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.h b/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\nindex 700b94621d5f..0b7769642214 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\n@@ -70,8 +70,8 @@ struct VPlanTransforms {\n               PredicatedScalarEvolution &PSE);\n \n   /// Update \\p Plan to account for all early exits.\n-  LLVM_ABI_FOR_TEST static void\n-  handleEarlyExits(VPlan &Plan, bool HasUncountableExit, VFRange &Range);\n+  LLVM_ABI_FOR_TEST static void handleEarlyExits(VPlan &Plan,\n+                                                 bool HasUncountableExit);\n \n   /// If a check is needed to guard executing the scalar epilogue loop, it will\n   /// be added to the middle block.\n@@ -207,8 +207,7 @@ struct VPlanTransforms {\n   static void handleUncountableEarlyExit(VPBasicBlock *EarlyExitingVPBB,\n                                          VPBasicBlock *EarlyExitVPBB,\n                                          VPlan &Plan, VPBasicBlock *HeaderVPBB,\n-                                         VPBasicBlock *LatchVPBB,\n-                                         VFRange &Range);\n+                                         VPBasicBlock *LatchVPBB);\n \n   /// Replace loop regions with explicit CFG.\n   static void dissolveLoopRegions(VPlan &Plan);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/single-early-exit-interleave-only.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=1 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "iv_used_in_exit_with_math",
          "test_body": "define i8 @iv_used_in_exit_with_math(i8 noundef %g) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i8 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %s = shl nuw i8 1, %iv\n  %a = and i8 %s, %g\n  %c = icmp eq i8 %a, 0\n  br i1 %c, label %loop.latch, label %return\n\nloop.latch:                                       ; preds = %loop.header\n  %iv.next = add nuw nsw i8 %iv, 1\n  %ec = icmp eq i8 %iv.next, 4\n  br i1 %ec, label %return, label %loop.header\n\nreturn:                                           ; preds = %loop.latch, %loop.header\n  %res.iv1 = phi i8 [ 32, %loop.latch ], [ %iv, %loop.header ]\n  %res.iv2 = phi i8 [ 0, %loop.latch ], [ %iv, %loop.header ]\n  %res = add i8 %res.iv1, %res.iv2\n  ret i8 %res\n}\n",
          "additional_args": "-src-unroll=32 -tgt-unroll=32"
        }
      ]
    }
  ],
  "issue": {
    "title": "wrong code at -O{s,2} with \"-mllvm -force-vector-width=1 -mllvm -force-vector-interleave=2\" on x86_64-linux-gnu",
    "body": "Compiler Explorer: https://godbolt.org/z/eEqc4oeET\n\nNote:\n- works: 20.1.0 and earlier\n- fails: trunk, only at -O{s,2}\n- perhaps related: https://github.com/llvm/llvm-project/issues/153946 \n\n```\n[516] % clangtk -v\nclang version 22.0.0git (https://github.com/llvm/llvm-project.git fc6299065794d05bcab8f6bb9628441b3d071131)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /local/home/suz/suz-local/software/local/clang-trunk/bin\nBuild config: +assertions\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12\nSelected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12\nCandidate multilib: .;@m64\nSelected multilib: .;@m64\nFound CUDA installation: /usr/local/cuda, version 12.1\n[517] % \n[517] % clangtk -O2 small.c; ./a.out\n[518] % \n[518] % clangtk -O2 -mllvm -force-vector-width=1 -mllvm -force-vector-interleave=2 small.c\n[519] % ./a.out\nAborted\n[520] % cat small.c\nint a, b;\nint f(int g) {\n  a = 0;\n  for (; a < 32; a++)\n    if (g >> a & 1)\n      return a;\n  return 0;\n}\nint main() {\n  if (f(b-2) != 1)\n    __builtin_abort();\n  return 0;\n}\n```",
    "author": "zhendongsu",
    "labels": [
      "miscompilation",
      "vectorizers"
    ],
    "comments": [
      {
        "author": "MacDue",
        "body": "This seems to be an issue with early-exit vectorization not handling a return value depending on the induction variable correctly. It looks like it just passes through the vectorized induction `vp<%4>`:\n\n```\n<x1> vector loop: {\n  vector.body:\n    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%index.next>\n    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>, vp<%0>\n    CLONE ir<%0> = shl nuw ir<1>, vp<%4>\n    CLONE ir<%1> = and ir<%0>, ir<%g>\n    CLONE ir<%tobool.not> = icmp eq ir<%1>, ir<0>\n    EMIT vp<%index.next> = add nuw vp<%3>, vp<%1>\n    EMIT vp<%5> = not ir<%tobool.not>\n    EMIT vp<%6> = any-of vp<%5>\n    EMIT vp<%7> = icmp eq vp<%index.next>, vp<%2>\n    EMIT vp<%8> = or vp<%6>, vp<%7>\n    EMIT branch-on-cond vp<%8>\n  No successors\n}\nSuccessor(s): middle.split\n\nmiddle.split:\n  EMIT branch-on-cond vp<%6>\nSuccessor(s): vector.early.exit, middle.block\n\nmiddle.block:\n  EMIT vp<%cmp.n> = icmp eq ir<32>, vp<%2>\n  EMIT branch-on-cond vp<%cmp.n>\nSuccessor(s): ir-bb<return>, scalar.ph\n\nvector.early.exit:\nSuccessor(s): ir-bb<return>\n\nir-bb<return>:\n  IR   %storemerge.lcssa = phi i32 [ 32, %for.inc ], [ %storemerge2, %for.body ] (extra operands: ir<32> from middle.block, vp<%4> from vector.early.exit)\n  IR   %retval.0 = phi i32 [ 0, %for.inc ], [ %storemerge2, %for.body ] (extra operands: ir<0> from middle.block, vp<%4> from vector.early.exit)\n  IR   store i32 %storemerge.lcssa, ptr @a, align 4, !tbaa !7\nNo successors\n```\n"
      },
      {
        "author": "fhahn",
        "body": "Don't think this is related to https://github.com/llvm/llvm-project/issues/153946, it is specific to VF = 1. Will look into a fix"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  },
  "verified": true
}