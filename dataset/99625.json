{
  "bug_id": "99625",
  "issue_url": "https://github.com/llvm/llvm-project/issues/99625",
  "bug_type": "crash",
  "base_commit": "098bd842a7e50853fa231f8b73c24ec5006fe063",
  "knowledge_cutoff": "2024-07-19T10:17:11Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "008df3cf85e9bb1532c079bfd7a7a00e90e0a3c6",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          3914,
          3932
        ],
        [
          9516,
          9521
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::collectLoopUniforms",
        "VPReplicateRecipe::execute"
      ]
    }
  },
  "patch": "commit 008df3cf85e9bb1532c079bfd7a7a00e90e0a3c6\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Fri Jul 19 12:02:25 2024 +0100\n\n    [LV] Check isPredInst instead of isScalarWithPred in uniform analysis. (#98892)\n    \n    Any instruction marked as uniform will result in a uniform\n    VPReplicateRecipe. If it requires predication, it will be placed in a\n    replicate region, even if isScalarWithPredication returns false.\n    \n    Check isPredicatedInst instead of isScalarWithPredication to avoid\n    generating uniform VPReplicateRecipes placed inside a replicate region.\n    This fixes an assertion when using scalable VFs.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/80416.\n    Fixes https://github.com/llvm/llvm-project/issues/94328.\n    Fixes https://github.com/llvm/llvm-project/issues/99625.\n    \n    PR: https://github.com/llvm/llvm-project/pull/98892\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex fbca4cdcbcfc..cceed75aa50b 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -3914,19 +3914,19 @@ void LoopVectorizationCostModel::collectLoopUniforms(ElementCount VF) {\n   SetVector<Instruction *> Worklist;\n \n   // Add uniform instructions demanding lane 0 to the worklist. Instructions\n-  // that are scalar with predication must not be considered uniform after\n+  // that require predication must not be considered uniform after\n   // vectorization, because that would create an erroneous replicating region\n   // where only a single instance out of VF should be formed.\n-  // TODO: optimize such seldom cases if found important, see PR40816.\n   auto addToWorklistIfAllowed = [&](Instruction *I) -> void {\n     if (isOutOfScope(I)) {\n       LLVM_DEBUG(dbgs() << \"LV: Found not uniform due to scope: \"\n                         << *I << \"\\n\");\n       return;\n     }\n-    if (isScalarWithPredication(I, VF)) {\n-      LLVM_DEBUG(dbgs() << \"LV: Found not uniform being ScalarWithPredication: \"\n-                        << *I << \"\\n\");\n+    if (isPredicatedInst(I)) {\n+      LLVM_DEBUG(\n+          dbgs() << \"LV: Found not uniform due to requiring predication: \" << *I\n+                 << \"\\n\");\n       return;\n     }\n     LLVM_DEBUG(dbgs() << \"LV: Found uniform instruction: \" << *I << \"\\n\");\n@@ -9516,6 +9516,8 @@ void VPInterleaveRecipe::execute(VPTransformState &State) {\n void VPReplicateRecipe::execute(VPTransformState &State) {\n   Instruction *UI = getUnderlyingInstr();\n   if (State.Instance) { // Generate a single instance.\n+    assert((State.VF.isScalar() || !isUniform()) &&\n+           \"uniform recipe shouldn't be predicated\");\n     assert(!State.VF.isScalable() && \"Can't scalarize a scalable vector\");\n     State.ILV->scalarizeInstruction(UI, this, *State.Instance, State);\n     // Insert scalar instance packing it into a vector.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/divs-with-scalable-vfs.ll",
      "commands": [
        "opt -p loop-vectorize -mtriple aarch64 -mcpu=neoverse-v1 -S %s"
      ],
      "tests": [
        {
          "test_name": "sdiv_feeding_gep_predicated",
          "test_body": "define void @sdiv_feeding_gep_predicated(ptr %dst, i32 %x, i64 %M, i64 %conv6, i64 %N) {\nentry:\n  %conv61 = zext i32 %x to i64\n  br label %loop\n\nloop:                                             ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %c = icmp ule i64 %iv, %M\n  br i1 %c, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop\n  %div18 = sdiv i64 %M, %conv6\n  %conv20 = trunc i64 %div18 to i32\n  %mul30 = mul i64 %div18, %conv61\n  %sub31 = sub i64 %iv, %mul30\n  %conv34 = trunc i64 %sub31 to i32\n  %mul35 = mul i32 %x, %conv20\n  %add36 = add i32 %mul35, %conv34\n  %idxprom = sext i32 %add36 to i64\n  %gep = getelementptr double, ptr %dst, i64 %idxprom\n  store double 0.000000e+00, ptr %gep, align 8\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "sdiv_feeding_gep",
          "test_body": "define void @sdiv_feeding_gep(ptr %dst, i32 %x, i64 %M, i64 %conv6, i64 %N) {\nentry:\n  %conv61 = zext i32 %x to i64\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %div18 = sdiv i64 %M, %conv6\n  %conv20 = trunc i64 %div18 to i32\n  %mul30 = mul i64 %div18, %conv61\n  %sub31 = sub i64 %iv, %mul30\n  %conv34 = trunc i64 %sub31 to i32\n  %mul35 = mul i32 %x, %conv20\n  %add36 = add i32 %mul35, %conv34\n  %idxprom = sext i32 %add36 to i64\n  %gep = getelementptr double, ptr %dst, i64 %idxprom\n  store double 0.000000e+00, ptr %gep, align 8\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "udiv_urem_feeding_gep",
          "test_body": "define void @udiv_urem_feeding_gep(i64 %x, ptr %dst, i64 %N) {\nentry:\n  %mul.1.i = mul i64 %x, %x\n  %mul.2.i = mul i64 %mul.1.i, %x\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %div.i = udiv i64 %iv, %mul.2.i\n  %rem.i = urem i64 %iv, %mul.2.i\n  %div.1.i = udiv i64 %rem.i, %mul.1.i\n  %rem.1.i = urem i64 %rem.i, %mul.1.i\n  %div.2.i = udiv i64 %rem.1.i, %x\n  %rem.2.i = urem i64 %rem.1.i, %x\n  %mul.i = mul i64 %x, %div.i\n  %add.i = add i64 %mul.i, %div.1.i\n  %mul.1.i9 = mul i64 %add.i, %x\n  %add.1.i = add i64 %mul.1.i9, %div.2.i\n  %mul.2.i11 = mul i64 %add.1.i, %x\n  %add.2.i = add i64 %mul.2.i11, %rem.2.i\n  %sext.i = shl i64 %add.2.i, 32\n  %conv6.i = ashr i64 %sext.i, 32\n  %gep = getelementptr i64, ptr %dst, i64 %conv6.i\n  store i64 %div.i, ptr %gep, align 4\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv, %N\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/consecutive-ptr-uniforms.ll",
      "commands": [
        "opt < %s -aa-pipeline=basic-aa -passes=loop-vectorize,instcombine -S -debug-only=loop-vectorize -disable-output -print-after=instcombine 2>&1",
        "opt < %s -passes=loop-vectorize -force-vector-width=2 -S"
      ],
      "tests": [
        {
          "test_name": "PR31671",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n%data = type { [32000 x float], [3 x i32], [4 x i8], [32000 x float] }\n\ndefine void @PR31671(float %x, ptr %d) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ %i.next, %for.body ], [ 0, %entry ]\n  %tmp0 = getelementptr inbounds %data, ptr %d, i64 0, i32 3, i64 %i\n  %tmp1 = load float, ptr %tmp0, align 4\n  %tmp2 = fmul float %x, %tmp1\n  %tmp3 = getelementptr inbounds %data, ptr %d, i64 0, i32 0, i64 %i\n  %tmp4 = load float, ptr %tmp3, align 4\n  %tmp5 = fadd float %tmp4, %tmp2\n  store float %tmp5, ptr %tmp3, align 4\n  %i.next = add nuw nsw i64 %i, 5\n  %cond = icmp slt i64 %i.next, 32000\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"knl\" }\n"
        },
        {
          "test_name": "PR40816",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@a = external hidden constant [3 x i32], align 1\n@b = external global i32, align 1\n\ndefine void @PR40816() #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]\n  store i32 %0, ptr @b, align 1\n  %arrayidx1 = getelementptr inbounds [3 x i32], ptr @a, i32 0, i32 %0\n  %1 = load i32, ptr %arrayidx1, align 1\n  %cmp2 = icmp eq i32 %1, 0\n  %inc = add nuw nsw i32 %0, 1\n  br i1 %cmp2, label %return, label %for.body\n\nreturn:                                           ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"core2\" }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion fail \"Should not predicate a uniform recipe\"",
    "body": "[RomBlocks-4aa6a4.cpp.gz](https://github.com/user-attachments/files/16310648/RomBlocks-4aa6a4.cpp.gz)\r\n[RomBlocks-4aa6a4.sh.gz](https://github.com/user-attachments/files/16310650/RomBlocks-4aa6a4.sh.gz)\r\n\r\nclang++: /home/dcb40b/llvm/trunk/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:8583: llvm::VPReplicateRecipe* llvm::VPRecipeBuilder::handleReplication(llvm::Instruction*, llvm::VFRange&): Assertion `(Range.Start.isScalar() || !IsUniform || !IsPredicated || (Range.Start.isScalable() && isa<IntrinsicInst>(I))) && \"Should not predicate a uniform recipe\"' failed.\r\n",
    "author": "dcb314",
    "labels": [
      "vectorizers",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "Taking a look now"
      },
      {
        "author": "fhahn",
        "body": "This one should also be fixed by https://github.com/llvm/llvm-project/pull/98892"
      }
    ]
  }
}