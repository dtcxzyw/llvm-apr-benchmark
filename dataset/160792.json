{
  "bug_id": "160792",
  "issue_url": "https://github.com/llvm/llvm-project/issues/160792",
  "bug_type": "crash",
  "base_commit": "ca55c07337d59aa65a19284f7b1307d16b2b0a44",
  "knowledge_cutoff": "2025-09-25T23:12:56Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "ae7b15f2e29cea642ca847a4f0ae91d2d793f6ad",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlan.cpp": [
        [
          1777,
          1782
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          3174,
          3179
        ],
        [
          3221,
          3229
        ],
        [
          3274,
          3282
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlan.cpp": [
        "VPCostContext::getScalarizationOverhead"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPReplicateRecipe::computeCost"
      ]
    }
  },
  "patch": "commit ae7b15f2e29cea642ca847a4f0ae91d2d793f6ad\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Sat Oct 11 19:01:27 2025 +0100\n\n    [VPlan] Return invalid for scalable VF in VPReplicateRecipe::computeCost\n    \n    Replication is currently not supported for scalable VFs. Make sure\n    VPReplicateRecipe::computeCost returns an invalid cost early, for\n    scalable VFs if the recipe is not a single-scalar.\n    \n    Note that this moves the existing invalid-costs.ll out of the AArch64\n    subdirectory, as it does not use a target triple.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/160792.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlan.cpp b/llvm/lib/Transforms/Vectorize/VPlan.cpp\nindex 2555ebe2ad89..1fea068bfafd 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlan.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlan.cpp\n@@ -1777,6 +1777,9 @@ InstructionCost VPCostContext::getScalarizationOverhead(\n   if (VF.isScalar())\n     return 0;\n \n+  assert(!VF.isScalable() &&\n+         \"Scalarization overhead not supported for scalable vectors\");\n+\n   InstructionCost ScalarizationCost = 0;\n   // Compute the cost of scalarizing the result if needed.\n   if (!ResultTy->isVoidTy()) {\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 600ff8ac33fe..8e9167729278 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -3174,6 +3174,9 @@ InstructionCost VPReplicateRecipe::computeCost(ElementCount VF,\n   // transform, avoid computing their cost multiple times for now.\n   Ctx.SkipCostComputation.insert(UI);\n \n+  if (VF.isScalable() && !isSingleScalar())\n+    return InstructionCost::getInvalid();\n+\n   switch (UI->getOpcode()) {\n   case Instruction::GetElementPtr:\n     // We mark this instruction as zero-cost because the cost of GEPs in\n@@ -3221,9 +3224,6 @@ InstructionCost VPReplicateRecipe::computeCost(ElementCount VF,\n       return ScalarCallCost;\n     }\n \n-    if (VF.isScalable())\n-      return InstructionCost::getInvalid();\n-\n     return ScalarCallCost * VF.getFixedValue() +\n            Ctx.getScalarizationOverhead(ResultTy, ArgOps, VF);\n   }\n@@ -3274,9 +3274,6 @@ InstructionCost VPReplicateRecipe::computeCost(ElementCount VF,\n   }\n   case Instruction::Load:\n   case Instruction::Store: {\n-    if (VF.isScalable() && !isSingleScalar())\n-      return InstructionCost::getInvalid();\n-\n     // TODO: See getMemInstScalarizationCost for how to handle replicating and\n     // predicated cases.\n     const VPRegionBlock *ParentRegion = getParent()->getParent();\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/invalid-costs.ll",
      "commands": [
        "opt -passes=\"loop-vectorize\" -pass-remarks-output=%t.yaml -S %s"
      ],
      "tests": [
        {
          "test_name": "replicate_sdiv_conditional",
          "test_body": "target triple = \"arm64-apple-macosx\"\n\ndefine void @replicate_sdiv_conditional(ptr noalias %a, ptr noalias %b, ptr noalias %c) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %gep.c = getelementptr inbounds i32, ptr %c, i64 %iv\n  %val.c = load i32, ptr %gep.c, align 4\n  %cmp = icmp slt i32 %val.c, 0\n  br i1 %cmp, label %if.then, label %loop.latch\n\nif.then:                                          ; preds = %loop.header\n  %gep.b = getelementptr inbounds i32, ptr %b, i64 %iv\n  %val.b = load i32, ptr %gep.b, align 4\n  %sext = sext i32 %val.b to i64\n  %shr = ashr i32 %val.b, 1\n  %add = add i32 %shr, %val.c\n  %conv = sext i32 %add to i64\n  %div = sdiv i64 %conv, %sext\n  %trunc = trunc i64 %div to i32\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %if.then, %loop.header\n  %result = phi i32 [ %trunc, %if.then ], [ %val.c, %loop.header ]\n  %gep.a = getelementptr inbounds i32, ptr %a, i64 %iv\n  store i32 %result, ptr %gep.a, align 4\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exit = icmp eq i64 %iv.next, 64\n  br i1 %exit, label %for.end, label %loop.header\n\nfor.end:                                          ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"neoverse-512tvb\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/invalid-costs.ll",
      "commands": [
        "opt -passes=\"loop-vectorize\" -pass-remarks-output=%t.yaml -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n; REMARKS: the cost-model indicates that vectorization is not beneficial\n\n; Test for https://github.com/llvm/llvm-project/issues/116375.\ndefine void @test_i24_load_for(ptr noalias %src, ptr %dst) {\n;\nentry:\n  br label %loop\n\nloop:\n  %iv = phi i16 [ 0, %entry ], [ %iv.next, %loop ]\n  %for = phi i24 [ 0, %entry ], [ %for.next, %loop ]\n  %iv.next = add i16 %iv, 1\n  %gep.src = getelementptr inbounds i24, ptr %src, i16 %iv\n  %for.next = load i24, ptr %gep.src, align 1\n  %gep.dst = getelementptr inbounds i24, ptr %dst, i16 %iv\n  store i24 %for, ptr %gep.dst\n  %ec = icmp eq i16 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop\n\nexit:\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion \"Request for a fixed element count on a scalable object\" failed, vectorizer crashing with -Rpass=loop-vectorize",
    "body": "Ran into a crash recently with the vectorizer while trying to build something. Note that this crash only happens if -Rpass=loop-vectorize is enabled.\n\nReproducer: https://godbolt.org/z/Ms47v6Eea\nNote: using the x86 trunk for the assertions build since there doesn't seem to one for armv8-a.\n\nCan't seem to reproduce it while giving the resulting IR into llc to produce assembly.\n\nSeems to be associated with commit 1858532c48cf5d93aa82966110fe1cada6ab6ba8  (tag: @fhahn ).\n\nSource C code used to produce the issue:\n\n```\nvoid foo(int *a, int *b, int *c) {\n  int i;\n  int temp;\n  int *ptr = a;\n\n  long qval;\n\n  for (i = 0; i < 64; i++) {\n    qval = b[i];\n    temp = c[i];\n    if (temp < 0) {\n      temp += qval >> 1;\n      temp /= qval;\n    }\n    ptr[i] = temp;\n  }\n}\n\nint main(int argc, char **argv) {\n  int a[] = {5, 3, 4, 5, 6, 7, 6};\n  int b[] = {0, 1, 2, 3, 4, 5, 6};\n  int c[] = {1, 2, 3, 4, 5, 6, 7};\n  foo(a, b, c);\n  return 0;\n}\n```\n`clang -march=armv8-a+sve -O3 -Rpass=loop-vectorize test.c -o test.s`",
    "author": "namikukr-qc",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  }
}