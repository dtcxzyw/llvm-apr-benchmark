{
  "bug_id": "162925",
  "issue_url": "https://github.com/llvm/llvm-project/issues/162925",
  "bug_type": "crash",
  "base_commit": "d72cd24ac43861b885dbcac395f2cc53246d6042",
  "knowledge_cutoff": "2025-10-10T21:27:13Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "8f168376c11d45834a59da9d61b2d850f2342f32",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          5291,
          5309
        ],
        [
          5312,
          5344
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "areAllOperandsReplacedByCopyableData",
        "getScheduleCopyableData"
      ]
    }
  },
  "patch": "commit 8f168376c11d45834a59da9d61b2d850f2342f32\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Sun Oct 12 10:11:56 2025 -0700\n\n    [SLP]Support non-ordered copyable argument in non-commutative instructions\n    \n    If the non-commutative user has several same operands and at least one\n    of them (but not the first) is copyable, need to consider this\n    opportunity when calculating the number of dependencies. Otherwise, the\n    schedule bundle might be not scheduled correctly and cause a compiler\n    crash\n    \n    Fixes #162925\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 2388375b8c2b..96f05fc82f29 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -5291,19 +5291,19 @@ private:\n         // data.\n         for (TreeEntry *TE : Entries) {\n           // Check if the user is commutative.\n-          // The commutatives are handled later, as their oeprands can be\n+          // The commutatives are handled later, as their operands can be\n           // reordered.\n           // Same applies even for non-commutative cmps, because we can invert\n           // their predicate potentially and, thus, reorder the operands.\n           bool IsCommutativeUser =\n               ::isCommutative(User) ||\n               ::isCommutative(TE->getMatchingMainOpOrAltOp(User), User);\n-          EdgeInfo EI(TE, U.getOperandNo());\n           if (!IsCommutativeUser && !isa<CmpInst>(User)) {\n             unsigned &OpCnt =\n                 OrderedEntriesCount.try_emplace(TE, 0).first->getSecond();\n+            EdgeInfo EI(TE, U.getOperandNo());\n             if (!getScheduleCopyableData(EI, Op) && OpCnt < NumOps)\n-              return false;\n+              continue;\n             // Found copyable operand - continue.\n             ++OpCnt;\n             continue;\n@@ -5312,33 +5312,38 @@ private:\n                 .first->getSecond();\n         }\n       }\n-      // Check the commutative/cmp entries.\n-      if (!PotentiallyReorderedEntriesCount.empty()) {\n-        for (auto &P : PotentiallyReorderedEntriesCount) {\n-          auto *It = find(P.first->Scalars, User);\n-          assert(It != P.first->Scalars.end() &&\n-                 \"User is not in the tree entry\");\n-          int Lane = std::distance(P.first->Scalars.begin(), It);\n-          assert(Lane >= 0 && \"Lane is not found\");\n-          if (isa<StoreInst>(User) && !P.first->ReorderIndices.empty())\n-            Lane = P.first->ReorderIndices[Lane];\n-          assert(Lane < static_cast<int>(P.first->Scalars.size()) &&\n-                 \"Couldn't find extract lane\");\n-          SmallVector<unsigned> OpIndices;\n-          for (unsigned OpIdx :\n-               seq<unsigned>(::getNumberOfPotentiallyCommutativeOps(\n-                   P.first->getMainOp()))) {\n-            if (P.first->getOperand(OpIdx)[Lane] == Op &&\n-                getScheduleCopyableData(EdgeInfo(P.first, OpIdx), Op))\n-              --P.getSecond();\n-          }\n-        }\n-        return all_of(PotentiallyReorderedEntriesCount,\n+      if (PotentiallyReorderedEntriesCount.empty())\n+        return all_of(OrderedEntriesCount,\n                       [&](const std::pair<const TreeEntry *, unsigned> &P) {\n-                        return P.second == NumOps - 1;\n+                        return P.second == NumOps;\n                       });\n-      }\n-      return true;\n+      // Check the commutative/cmp entries.\n+      for (auto &P : PotentiallyReorderedEntriesCount) {\n+        auto *It = find(P.first->Scalars, User);\n+        assert(It != P.first->Scalars.end() && \"User is not in the tree entry\");\n+        int Lane = std::distance(P.first->Scalars.begin(), It);\n+        assert(Lane >= 0 && \"Lane is not found\");\n+        if (isa<StoreInst>(User) && !P.first->ReorderIndices.empty())\n+          Lane = P.first->ReorderIndices[Lane];\n+        assert(Lane < static_cast<int>(P.first->Scalars.size()) &&\n+               \"Couldn't find extract lane\");\n+        SmallVector<unsigned> OpIndices;\n+        for (unsigned OpIdx :\n+             seq<unsigned>(::getNumberOfPotentiallyCommutativeOps(\n+                 P.first->getMainOp()))) {\n+          if (P.first->getOperand(OpIdx)[Lane] == Op &&\n+              getScheduleCopyableData(EdgeInfo(P.first, OpIdx), Op))\n+            --P.getSecond();\n+        }\n+      }\n+      return all_of(PotentiallyReorderedEntriesCount,\n+                    [&](const std::pair<const TreeEntry *, unsigned> &P) {\n+                      return P.second == NumOps - 1;\n+                    }) &&\n+             all_of(OrderedEntriesCount,\n+                    [&](const std::pair<const TreeEntry *, unsigned> &P) {\n+                      return P.second == NumOps;\n+                    });\n     }\n \n     SmallVector<ScheduleCopyableData *>\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/RISCV/non-commutative-second-arg-only-copyable.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -slp-threshold=-9999 -mtriple=riscv64-unknown-linux-gnu -mattr=+v < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine i32 @main(ptr %q, ptr %a, i8 %.pre) {\n;\nentry:\n  %.pre1 = load i8, ptr %q, align 1\n  %conv11.i = sext i8 %.pre to i32\n  %shl18.i = shl i32 %conv11.i, %conv11.i\n  %conv19.i = trunc i32 %shl18.i to i16\n  store i16 %conv19.i, ptr %a, align 2\n  %0 = sext i8 %.pre1 to i32\n  %1 = add i32 %0, 1\n  %shl18.i.1 = shl i32 1, %1\n  %conv19.i.1 = trunc i32 %shl18.i.1 to i16\n  %arrayidx21.i.1 = getelementptr i8, ptr %a, i64 2\n  store i16 %conv19.i.1, ptr %arrayidx21.i.1, align 2\n  ret i32 0\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[RISC-V][SLPVectorizer] Assertion `all_of(Bundles, [](const ScheduleBundle *Bundle) { return Bundle->isScheduled(); }) && \"must be scheduled at this point\"' failed.",
    "body": "Testcase:\n```llvm ir\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine i32 @main(ptr %q, ptr %a) #0 {\nentry:\n  %.pre = load i8, ptr %q, align 1\n  br label %for.body.i\n\nfor.body.i:                                       ; preds = %for.body.i, %entry\n  %conv34.i = phi i64 [ 0, %entry ], [ %conv.i, %for.body.i ]\n  %v.033.i = phi i32 [ 0, %entry ], [ %add.i, %for.body.i ]\n  %conv11.i = sext i8 %.pre to i32\n  %sub.sink.i = add i32 %v.033.i, %conv11.i\n  %shl18.i = shl i32 %conv11.i, %sub.sink.i\n  %conv19.i = trunc i32 %shl18.i to i16\n  %arrayidx21.i = getelementptr i16, ptr %a, i64 %conv34.i\n  store i16 %conv19.i, ptr %arrayidx21.i, align 2\n  %add.i = add i32 %v.033.i, 1\n  %conv.i = zext i32 %add.i to i64\n  %cmp.i = icmp ult i32 %v.033.i, 12\n  br i1 %cmp.i, label %for.body.i, label %c.exit\n\nc.exit:                                           ; preds = %for.body.i\n  ret i32 0\n}\n\nattributes #0 = { \"target-features\"=\"+v\" }\n\n```\n\nCommands/backtrace:\n```\n$ /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt \"-passes=lto<O3>\" reduced.ll\nWARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\nopt: /scratch/ewlu/daily-upstream-build/llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21677: void llvm::slpvectorizer::BoUpSLP::scheduleBlock(const llvm::slpvectorizer::BoUpSLP&, BlockScheduling*): Assertion `all_of(Bundles, [](const ScheduleBundle *Bundle) { return Bundle->isScheduled(); }) && \"must be scheduled at this point\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.      Program arguments: /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt -passes=lto<O3> reduced.ll\n1.      Running pass \"function<eager-inv>(loop-mssa(licm<allowspeculation>),gvn<>,memcpyopt,dse,move-auto-init,mldst-motion<no-split-footer-bb>,loop(indvars,loop-deletion,loop-unroll-full),loop-distribute,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-unroll<O3>,transform-warning,sroa<preserve-cfg>,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-arithmetic;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,sccp,instcombine<max-iterations=1;no-verify-fixpoint>,bdce,slp-vectorizer,vector-combine,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,jump-threading)\" on module \"reduced.ll\"\n2.      Running pass \"slp-vectorizer\" on function \"main\"\n #0 0x00005c95dc04ae60 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x35fae60)\n #1 0x00005c95dc047b7a SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x00007f5611645330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #3 0x00007f561169eb2c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\n #4 0x00007f561169eb2c __pthread_kill_internal ./nptl/pthread_kill.c:78:10\n #5 0x00007f561169eb2c pthread_kill ./nptl/pthread_kill.c:89:10\n #6 0x00007f561164527e raise ./signal/../sysdeps/posix/raise.c:27:6\n #7 0x00007f56116288ff abort ./stdlib/abort.c:81:7\n #8 0x00007f561162881b _nl_load_domain ./intl/loadmsgcat.c:1177:9\n #9 0x00007f561163b517 (/lib/x86_64-linux-gnu/libc.so.6+0x3b517)\n#10 0x00005c95d9c04287 llvm::slpvectorizer::BoUpSLP::scheduleBlock(llvm::slpvectorizer::BoUpSLP const&, llvm::slpvectorizer::BoUpSLP::BlockScheduling*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11b4287)\n#11 0x00005c95d9c174f3 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::SmallDenseSet<llvm::Value*, 4u, llvm::DenseMapInfo<llvm::Value*, void>> const&, llvm::Instruction*, llvm::ArrayRef<std::tuple<llvm::Value*, unsigned int, bool>>) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11c74f3)\n#12 0x00005c95d9c1bc72 llvm::slpvectorizer::BoUpSLP::vectorizeTree() (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11cbc72)\n#13 0x00005c95d9c3a404 llvm::SLPVectorizerPass::vectorizeStoreChain(llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP&, unsigned int, unsigned int, unsigned int&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11ea404)\n#14 0x00005c95d9c3d303 llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&)::'lambda'(std::map<long, unsigned int, std::less<long>, std::allocator<std::pair<long const, unsigned int>>> const&)::operator()(std::map<long, unsigned int, std::less<long>, std::allocator<std::pair<long const, unsigned int>>> const&) const SLPVectorizer.cpp:0:0\n#15 0x00005c95d9c3df00 llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11edf00)\n#16 0x00005c95d9c3f4df llvm::SLPVectorizerPass::vectorizeStoreChains(llvm::slpvectorizer::BoUpSLP&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11ef4df)\n#17 0x00005c95d9c41343 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11f1343)\n#18 0x00005c95d9c42021 llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11f2021)\n#19 0x00005c95d931e563 llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x8ce563)\n#20 0x00005c95dbe189e3 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x33c89e3)\n#21 0x00005c95d93203b3 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x8d03b3)\n#22 0x00005c95dbe174a7 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x33c74a7)\n#23 0x00005c95d8f958d3 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x5458d3)\n#24 0x00005c95dbe16da3 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x33c6da3)\n#25 0x00005c95d8fa0af6 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x550af6)\n#26 0x00005c95d8f93a7a optMain (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x543a7a)\n#27 0x00007f561162a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#28 0x00007f561162a28b call_init ./csu/../csu/libc-start.c:128:20\n#29 0x00007f561162a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#30 0x00005c95d8f89e15 _start (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x539e15)\nAborted\n```\n\nGodbolt: https://godbolt.org/z/76oWGdEzh\n\nFound via fuzzer (C program before reduction)",
    "author": "ewlu",
    "labels": [
      "llvm:SLPVectorizer",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true
}