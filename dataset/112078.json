{
  "bug_id": "112078",
  "issue_url": "https://github.com/llvm/llvm-project/issues/112078",
  "bug_type": "miscompilation",
  "base_commit": "39aae575744de7ae77e755142e0746a5b473b3ed",
  "knowledge_cutoff": "2024-10-12T04:08:35Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "9edc454ee601e04500529c98b753d3bd8f427d01",
    "components": [
      "InstCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp": [
        [
          935,
          943
        ],
        [
          945,
          955
        ],
        [
          3362,
          3370
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp": [
        "InstCombinerImpl::foldAndOrOfICmps",
        "foldIsPowerOf2OrZero"
      ]
    }
  },
  "patch": "commit 9edc454ee601e04500529c98b753d3bd8f427d01\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Mon Oct 14 20:52:55 2024 +0800\n\n    [InstCombine] Drop range attributes in `foldIsPowerOf2OrZero` (#112178)\n    \n    Closes https://github.com/llvm/llvm-project/issues/112078.\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp b/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\nindex 453071f3f982..64bee4ab974e 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n@@ -935,9 +935,11 @@ static Value *foldSignedTruncationCheck(ICmpInst *ICmp0, ICmpInst *ICmp1,\n \n /// Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and\n /// fold (icmp ne ctpop(X) 1) & (icmp ne X 0) into (icmp ugt ctpop(X) 1).\n-/// Also used for logical and/or, must be poison safe.\n+/// Also used for logical and/or, must be poison safe if range attributes are\n+/// dropped.\n static Value *foldIsPowerOf2OrZero(ICmpInst *Cmp0, ICmpInst *Cmp1, bool IsAnd,\n-                                   InstCombiner::BuilderTy &Builder) {\n+                                   InstCombiner::BuilderTy &Builder,\n+                                   InstCombinerImpl &IC) {\n   CmpInst::Predicate Pred0, Pred1;\n   Value *X;\n   if (!match(Cmp0, m_ICmp(Pred0, m_Intrinsic<Intrinsic::ctpop>(m_Value(X)),\n@@ -945,11 +947,19 @@ static Value *foldIsPowerOf2OrZero(ICmpInst *Cmp0, ICmpInst *Cmp1, bool IsAnd,\n       !match(Cmp1, m_ICmp(Pred1, m_Specific(X), m_ZeroInt())))\n     return nullptr;\n \n-  Value *CtPop = Cmp0->getOperand(0);\n-  if (IsAnd && Pred0 == ICmpInst::ICMP_NE && Pred1 == ICmpInst::ICMP_NE)\n+  auto *CtPop = cast<Instruction>(Cmp0->getOperand(0));\n+  if (IsAnd && Pred0 == ICmpInst::ICMP_NE && Pred1 == ICmpInst::ICMP_NE) {\n+    // Drop range attributes and re-infer them in the next iteration.\n+    CtPop->dropPoisonGeneratingAnnotations();\n+    IC.addToWorklist(CtPop);\n     return Builder.CreateICmpUGT(CtPop, ConstantInt::get(CtPop->getType(), 1));\n-  if (!IsAnd && Pred0 == ICmpInst::ICMP_EQ && Pred1 == ICmpInst::ICMP_EQ)\n+  }\n+  if (!IsAnd && Pred0 == ICmpInst::ICMP_EQ && Pred1 == ICmpInst::ICMP_EQ) {\n+    // Drop range attributes and re-infer them in the next iteration.\n+    CtPop->dropPoisonGeneratingAnnotations();\n+    IC.addToWorklist(CtPop);\n     return Builder.CreateICmpULT(CtPop, ConstantInt::get(CtPop->getType(), 2));\n+  }\n \n   return nullptr;\n }\n@@ -3362,9 +3372,9 @@ Value *InstCombinerImpl::foldAndOrOfICmps(ICmpInst *LHS, ICmpInst *RHS,\n                                              /*IsLogical*/ false, Builder, Q))\n     return V;\n \n-  if (Value *V = foldIsPowerOf2OrZero(LHS, RHS, IsAnd, Builder))\n+  if (Value *V = foldIsPowerOf2OrZero(LHS, RHS, IsAnd, Builder, *this))\n     return V;\n-  if (Value *V = foldIsPowerOf2OrZero(RHS, LHS, IsAnd, Builder))\n+  if (Value *V = foldIsPowerOf2OrZero(RHS, LHS, IsAnd, Builder, *this))\n     return V;\n \n   // TODO: One of these directions is fine with logical and/or, the other could\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/ispow2.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "is_pow2or0_decrement_op",
          "test_body": "define i1 @is_pow2or0_decrement_op(i8 %x) {\n  %dec = add i8 %x, -1\n  %and = and i8 %dec, %x\n  %cmp = icmp eq i8 %and, 0\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "is_pow2_negate_op_vec",
          "test_body": "define <2 x i1> @is_pow2_negate_op_vec(<2 x i32> %x) {\n  %neg = sub <2 x i32> zeroinitializer, %x\n  %and = and <2 x i32> %neg, %x\n  %cmp = icmp eq <2 x i32> %and, %x\n  %notzero = icmp ne <2 x i32> %x, zeroinitializer\n  %r = and <2 x i1> %cmp, %notzero\n  ret <2 x i1> %r\n}\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_cmp_op1_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_cmp_op1_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 3\n  %notzero = icmp ne i32 %x, 0\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_negate_op",
          "test_body": "define i1 @is_pow2_negate_op(i32 %x) {\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  %cmp = icmp eq i32 %and, %x\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "not_pow2_nz_known_bits",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @not_pow2_nz_known_bits(i32 %xin) {\n  %x = or i32 %xin, 1\n  %cnt = call i32 @llvm.ctpop.i32(i32 %x)\n  %r = icmp ne i32 %cnt, 1\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_nz_known_bits",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_nz_known_bits(i32 %xin) {\n  %x = or i32 %xin, 64\n  %cnt = call i32 @llvm.ctpop.i32(i32 %x)\n  %r = icmp eq i32 %cnt, 1\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_power2_or_zero_with_range",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_power2_or_zero_with_range(i32 %x) {\n  %ctpop = call range(i32 1, 33) i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %ctpop, 1\n  %notzero = icmp eq i32 %x, 0\n  %res = select i1 %notzero, i1 true, i1 %cmp\n  ret i1 %res\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_is_p2_or_z",
          "test_body": "define i1 @blsmsk_is_p2_or_z(i32 %xx, i32 %yy) {\n  %x = or i32 %xx, %yy\n  %xm1 = add i32 %x, -1\n  %y = xor i32 %x, %xm1\n  %r = icmp uge i32 %x, %y\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_commute_vec",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @isnot_pow2nor0_ctpop_commute_vec(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp ne <2 x i8> %t0, splat (i8 1)\n  %notzero = icmp ne <2 x i8> %x, zeroinitializer\n  %r = and <2 x i1> %notzero, %cmp\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_wrong_pred1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop_wrong_pred1(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 1\n  %iszero = icmp eq i32 %x, 0\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_non_zero_ne_1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #1\n\ndefine i1 @is_pow2_non_zero_ne_1(i32 %x) {\n  %notzero = icmp ne i32 %x, 0\n  call void @llvm.assume(i1 %notzero)\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 1\n  ret i1 %cmp\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "blsmsk_is_p2_or_z_fail",
          "test_body": "define i1 @blsmsk_is_p2_or_z_fail(i32 %xx, i32 %yy) {\n  %x = or i32 %xx, %yy\n  %xm1 = add i32 %x, -1\n  %y = xor i32 %x, %xm1\n  %r = icmp ugt i32 %x, %y\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "blsmsk_is_p2_or_z_uge_xy_fail",
          "test_body": "define i1 @blsmsk_is_p2_or_z_uge_xy_fail(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp uge i8 %x, %y\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_logical_extra_uses",
          "test_body": "declare void @use(i32)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @is_pow2or0_ctpop_logical_extra_uses(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  call void @use(i32 %t0)\n  %cmp = icmp eq i32 %t0, 1\n  call void @use_i1(i1 %cmp)\n  %iszero = icmp eq i32 %x, 0\n  call void @use_i1(i1 %iszero)\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_commute_vec",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @isnot_pow2_ctpop_commute_vec(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp ugt <2 x i8> %t0, splat (i8 1)\n  %iszero = icmp eq <2 x i8> %x, zeroinitializer\n  %r = or <2 x i1> %cmp, %iszero\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_fail_wrong_add",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z_fail_wrong_add(i32 %x, i32 %z) {\n  %xm1 = add i32 %z, -1\n  %y = xor i32 %x, %xm1\n  %r = icmp ult i32 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_pred2",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_pred2(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  %cmp2 = icmp sgt i32 %x, 0\n  %r = and i1 %cmp2, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_swap_cmp",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop_swap_cmp(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 1\n  %iszero = icmp eq i32 %x, 0\n  %r = or i1 %cmp, %iszero\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_commute_vec_wrong_pred3",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @is_pow2or0_ctpop_commute_vec_wrong_pred3(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp eq <2 x i8> %t0, splat (i8 1)\n  %iszero = icmp eq <2 x i8> %x, zeroinitializer\n  %r = and <2 x i1> %cmp, %iszero\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_decrement_op_logical",
          "test_body": "define i1 @is_pow2_decrement_op_logical(i8 %x) {\n  %dec = add i8 %x, -1\n  %and = and i8 %dec, %x\n  %cmp = icmp eq i8 %and, 0\n  %notzero = icmp ne i8 %x, 0\n  %r = select i1 %cmp, i1 %notzero, i1 false\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2or0_negate_op_vec",
          "test_body": "define <2 x i1> @isnot_pow2or0_negate_op_vec(<2 x i32> %x) {\n  %neg = sub <2 x i32> zeroinitializer, %x\n  %and = and <2 x i32> %neg, %x\n  %cmp = icmp ne <2 x i32> %and, %x\n  ret <2 x i1> %cmp\n}\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_commute_vec",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @is_pow2or0_ctpop_commute_vec(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp eq <2 x i8> %t0, splat (i8 1)\n  %iszero = icmp eq <2 x i8> %x, zeroinitializer\n  %r = or <2 x i1> %iszero, %cmp\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_negate_op_logical",
          "test_body": "define i1 @is_pow2_negate_op_logical(i32 %x) {\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  %cmp = icmp eq i32 %and, %x\n  %notzero = icmp ne i32 %x, 0\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 1\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_ult_xy_fail",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z_ult_xy_fail(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp ult i8 %x, %y\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2nor0_wrong_pred3_ctpop_commute_vec",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @isnot_pow2nor0_wrong_pred3_ctpop_commute_vec(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp ne <2 x i8> %t0, splat (i8 1)\n  %notzero = icmp ne <2 x i8> %x, zeroinitializer\n  %r = or <2 x i1> %cmp, %notzero\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_negate_op_vec",
          "test_body": "define <2 x i1> @is_pow2or0_negate_op_vec(<2 x i32> %x) {\n  %neg = sub <2 x i32> zeroinitializer, %x\n  %and = and <2 x i32> %neg, %x\n  %cmp = icmp eq <2 x i32> %and, %x\n  ret <2 x i1> %cmp\n}\n"
        },
        {
          "test_name": "isnot_pow2or0_negate_op",
          "test_body": "define i1 @isnot_pow2or0_negate_op(i32 %x) {\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  %cmp = icmp ne i32 %and, %x\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "not_pow2_or_z_known_bits_fail_wrong_cmp",
          "test_body": "define <2 x i1> @not_pow2_or_z_known_bits_fail_wrong_cmp(<2 x i32> %xin) {\n  %x = or <2 x i32> %xin, splat (i32 64)\n  %cnt = call <2 x i32> @llvm.ctpop.v2i32(<2 x i32> %x)\n  %r = icmp ugt <2 x i32> %cnt, splat (i32 2)\n  ret <2 x i1> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i32> @llvm.ctpop.v2i32(<2 x i32>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_cmp_op2",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_cmp_op2(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  %notzero = icmp ne i32 %x, 1\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  %notzero = icmp ne i32 %x, 0\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_decrement_op_logical",
          "test_body": "define i1 @isnot_pow2_decrement_op_logical(i8 %x) {\n  %dec = add i8 %x, -1\n  %and = and i8 %dec, %x\n  %cmp = icmp ne i8 %and, 0\n  %iszero = icmp eq i8 %x, 0\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2_negate_op_logical",
          "test_body": "define i1 @isnot_pow2_negate_op_logical(i32 %x) {\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  %cmp = icmp ne i32 %and, %x\n  %iszero = icmp eq i32 %x, 0\n  %r = select i1 %cmp, i1 true, i1 %iszero\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_ctpop",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 1\n  %iszero = icmp eq i32 %x, 0\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_is_p2_or_z_uge_yx",
          "test_body": "define i1 @blsmsk_is_p2_or_z_uge_yx(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp uge i8 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "has_single_bit_inv",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @has_single_bit_inv(i32 %x) {\nentry:\n  %cmp1 = icmp eq i32 %x, 0\n  %popcnt = call range(i32 1, 33) i32 @llvm.ctpop.i32(i32 %x)\n  %cmp2 = icmp ugt i32 %popcnt, 1\n  %sel = select i1 %cmp1, i1 true, i1 %cmp2\n  ret i1 %sel\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_negate_op",
          "test_body": "define i1 @is_pow2or0_negate_op(i32 %x) {\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  %cmp = icmp eq i32 %and, %x\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_ugt_yx_fail",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z_ugt_yx_fail(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp ugt i8 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_fail",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z_fail(i32 %x) {\n  %xm1 = add i32 %x, -1\n  %y = xor i32 %x, %xm1\n  %r = icmp ule i32 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2_decrement_op_vec",
          "test_body": "define <2 x i1> @is_pow2_decrement_op_vec(<2 x i8> %x) {\n  %dec = add <2 x i8> %x, splat (i8 -1)\n  %and = and <2 x i8> %dec, %x\n  %cmp = icmp eq <2 x i8> %and, zeroinitializer\n  %notzero = icmp ne <2 x i8> %x, zeroinitializer\n  %r = and <2 x i1> %notzero, %cmp\n  ret <2 x i1> %r\n}\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_extra_uses",
          "test_body": "declare void @use(i32)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @isnot_pow2nor0_ctpop_extra_uses(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  call void @use(i32 %t0)\n  %cmp = icmp ne i32 %t0, 1\n  call void @use_i1(i1 %cmp)\n  %notzero = icmp ne i32 %x, 0\n  call void @use_i1(i1 %notzero)\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_wrong_pred1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop_wrong_pred1(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 1\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  %iszero = icmp eq i32 %x, 0\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_fail_multiuse",
          "test_body": "declare void @use.i32(i32)\n\ndefine i1 @blsmsk_isnt_p2_or_z_fail_multiuse(i32 %x) {\n  %xm1 = add i32 %x, -1\n  %y = xor i32 %x, %xm1\n  call void @use.i32(i32 %y)\n  %r = icmp ult i32 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_wrong_pred2_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop_wrong_pred2_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 1\n  %iszero = icmp ne i32 %x, 0\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_extra_uses",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @is_pow2_ctpop_extra_uses(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  call void @use_i1(i1 %cmp)\n  %notzero = icmp ne i32 %x, 0\n  call void @use_i1(i1 %notzero)\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_ult_yx",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z_ult_yx(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp ult i8 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_wrong_cmp_op1_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop_wrong_cmp_op1_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 3\n  %iszero = icmp eq i32 %x, 0\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_fail_bad_xor",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z_fail_bad_xor(i32 %x, i32 %z) {\n  %xm1 = add i32 %x, -1\n  %y = xor i32 %z, %xm1\n  %r = icmp ult i32 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_negate_op_extra_use2",
          "test_body": "declare void @use(i32)\n\ndefine i1 @is_pow2or0_negate_op_extra_use2(i32 %x) {\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  call void @use(i32 %and)\n  %cmp = icmp eq i32 %and, %x\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "isnot_pow2_negate_op",
          "test_body": "define i1 @isnot_pow2_negate_op(i32 %x) {\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  %cmp = icmp ne i32 %and, %x\n  %iszero = icmp eq i32 %x, 0\n  %r = or i1 %cmp, %iszero\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_negate_op_extra_use1",
          "test_body": "declare void @use(i32)\n\ndefine i1 @is_pow2or0_negate_op_extra_use1(i32 %x) {\n  %neg = sub i32 0, %x\n  call void @use(i32 %neg)\n  %and = and i32 %neg, %x\n  %cmp = icmp eq i32 %and, %x\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_wrong_cmp_op1_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop_wrong_cmp_op1_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 2\n  %iszero = icmp eq i32 %x, 0\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_wrong_cmp_op2_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop_wrong_cmp_op2_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  %iszero = icmp eq i32 %x, 1\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_cmp_op1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_cmp_op1(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 3\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_commute_vec_wrong_cmp_op1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @is_pow2or0_ctpop_commute_vec_wrong_cmp_op1(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp eq <2 x i8> %t0, <i8 -1, i8 1>\n  %iszero = icmp eq <2 x i8> %x, zeroinitializer\n  %r = or <2 x i1> %cmp, %iszero\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_wrong_pred2_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop_wrong_pred2_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  %cmp2 = icmp slt i32 %x, 0\n  %r = select i1 %cmp2, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_extra_uses_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @is_pow2_ctpop_extra_uses_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  call void @use_i1(i1 %cmp)\n  %notzero = icmp ne i32 %x, 0\n  call void @use_i1(i1 %notzero)\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2or0_negate_op_commute3",
          "test_body": "define i1 @isnot_pow2or0_negate_op_commute3(i32 %p) {\n  %x = urem i32 42, %p\n  %neg = sub i32 0, %x\n  %and = and i32 %x, %neg\n  %cmp = icmp ne i32 %x, %and\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_cmp_op2_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_cmp_op2_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  %notzero = icmp ne i32 %x, 1\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_non_zero_eq_1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #1\n\ndefine i1 @is_pow2_non_zero_eq_1(i32 %x) {\n  %notzero = icmp ne i32 %x, 0\n  call void @llvm.assume(i1 %notzero)\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 1\n  ret i1 %cmp\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_logical_extra_uses",
          "test_body": "declare void @use(i32)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @isnot_pow2nor0_ctpop_logical_extra_uses(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  call void @use(i32 %t0)\n  %cmp = icmp ne i32 %t0, 1\n  call void @use_i1(i1 %cmp)\n  %notzero = icmp ne i32 %x, 0\n  call void @use_i1(i1 %notzero)\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_wrong_pred2",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop_wrong_pred2(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 1\n  %iszero = icmp ne i32 %x, 0\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_wrong_cmp_op2",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop_wrong_cmp_op2(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  %iszero = icmp eq i32 %x, 1\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_pred1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_pred1(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 2\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_extra_uses_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @isnot_pow2_ctpop_extra_uses_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  call void @use_i1(i1 %cmp)\n  %iszero = icmp eq i32 %x, 0\n  call void @use_i1(i1 %iszero)\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_extra_uses",
          "test_body": "declare void @use(i32)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @is_pow2or0_ctpop_extra_uses(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  call void @use(i32 %t0)\n  %cmp = icmp eq i32 %t0, 1\n  call void @use_i1(i1 %cmp)\n  %iszero = icmp eq i32 %x, 0\n  call void @use_i1(i1 %iszero)\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_non_zero_ult_2",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #1\n\ndefine i1 @is_pow2_non_zero_ult_2(i32 %x) {\n  %notzero = icmp ne i32 %x, 0\n  call void @llvm.assume(i1 %notzero)\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  ret i1 %cmp\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_commute_vec",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @is_pow2_ctpop_commute_vec(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp ult <2 x i8> %t0, splat (i8 2)\n  %notzero = icmp ne <2 x i8> %x, zeroinitializer\n  %r = and <2 x i1> %cmp, %notzero\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_decrement_op",
          "test_body": "define i1 @isnot_pow2_decrement_op(i8 %x) {\n  %dec = add i8 %x, -1\n  %and = and i8 %dec, %x\n  %cmp = icmp ne i8 %and, 0\n  %iszero = icmp eq i8 %x, 0\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_wrong_cmp_op1_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop_wrong_cmp_op1_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 5\n  %notzero = icmp ne i32 %x, 0\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_pred1_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_pred1_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 2\n  %notzero = icmp ne i32 %x, 0\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2or0_decrement_op_vec",
          "test_body": "define <2 x i1> @isnot_pow2or0_decrement_op_vec(<2 x i8> %x) {\n  %dec = add <2 x i8> %x, splat (i8 -1)\n  %and = and <2 x i8> %dec, %x\n  %cmp = icmp ne <2 x i8> %and, zeroinitializer\n  ret <2 x i1> %cmp\n}\n"
        },
        {
          "test_name": "is_pow2_ctpop_wrong_pred2_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop_wrong_pred2_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  %cmp2 = icmp sgt i32 %x, 0\n  %r = select i1 %cmp2, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z_ugt_xy",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z_ugt_xy(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp ugt i8 %x, %y\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_commute_vec_wrong_cmp_op1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>) #0\n\ndefine <2 x i1> @isnot_pow2nor0_ctpop_commute_vec_wrong_cmp_op1(<2 x i8> %x) {\n  %t0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %x)\n  %cmp = icmp ne <2 x i8> %t0, <i8 0, i8 -1>\n  %notzero = icmp ne <2 x i8> %x, zeroinitializer\n  %r = and <2 x i1> %cmp, %notzero\n  ret <2 x i1> %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_wrong_pred2_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop_wrong_pred2_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 1\n  %notzero = icmp eq i32 %x, 0\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_negate_op_commute1",
          "test_body": "define i1 @is_pow2or0_negate_op_commute1(i32 %p) {\n  %x = srem i32 42, %p\n  %neg = sub i32 0, %x\n  %and = and i32 %x, %neg\n  %cmp = icmp eq i32 %and, %x\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "is_pow2_or_z_known_bits",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_or_z_known_bits(i32 %xin) {\n  %x = or i32 %xin, -2147483648\n  %cnt = call i32 @llvm.ctpop.i32(i32 %x)\n  %r = icmp ult i32 %cnt, 2\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2or0_decrement_op_vec",
          "test_body": "define <2 x i1> @is_pow2or0_decrement_op_vec(<2 x i8> %x) {\n  %dec = add <2 x i8> %x, splat (i8 -1)\n  %and = and <2 x i8> %dec, %x\n  %cmp = icmp eq <2 x i8> %and, zeroinitializer\n  ret <2 x i1> %cmp\n}\n"
        },
        {
          "test_name": "is_pow2_decrement_op",
          "test_body": "define i1 @is_pow2_decrement_op(i8 %x) {\n  %dec = add i8 %x, -1\n  %and = and i8 %dec, %x\n  %cmp = icmp eq i8 %and, 0\n  %notzero = icmp ne i8 %x, 0\n  %r = and i1 %cmp, %notzero\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_wrong_pred2",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop_wrong_pred2(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  %cmp2 = icmp slt i32 %x, 0\n  %r = or i1 %cmp2, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  %iszero = icmp eq i32 %x, 0\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2or0_negate_op_commute2",
          "test_body": "define i1 @isnot_pow2or0_negate_op_commute2(i32 %p) {\n  %x = urem i32 42, %p\n  %neg = sub i32 0, %x\n  %and = and i32 %neg, %x\n  %cmp = icmp ne i32 %x, %and\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "blsmsk_is_p2_or_z_fail_bad_cmp",
          "test_body": "define i1 @blsmsk_is_p2_or_z_fail_bad_cmp(i32 %x, i32 %z) {\n  %xm1 = add i32 %x, -1\n  %y = xor i32 %x, %xm1\n  %r = icmp uge i32 %y, %z\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2_decrement_op_vec",
          "test_body": "define <2 x i1> @isnot_pow2_decrement_op_vec(<2 x i8> %x) {\n  %dec = add <2 x i8> %x, splat (i8 -1)\n  %and = and <2 x i8> %dec, %x\n  %cmp = icmp ne <2 x i8> %and, zeroinitializer\n  %iszero = icmp eq <2 x i8> %x, zeroinitializer\n  %r = or <2 x i1> %cmp, %iszero\n  ret <2 x i1> %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_wrong_cmp_op1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop_wrong_cmp_op1(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 2\n  %iszero = icmp eq i32 %x, 0\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_is_p2_or_z_ule_yx_fail",
          "test_body": "define i1 @blsmsk_is_p2_or_z_ule_yx_fail(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp ule i8 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "not_pow2_or_z_known_bits",
          "test_body": "define <2 x i1> @not_pow2_or_z_known_bits(<2 x i32> %xin) {\n  %x = or <2 x i32> %xin, splat (i32 64)\n  %cnt = call <2 x i32> @llvm.ctpop.v2i32(<2 x i32> %x)\n  %r = icmp ugt <2 x i32> %cnt, splat (i32 1)\n  ret <2 x i1> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i32> @llvm.ctpop.v2i32(<2 x i32>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_negate_op_vec",
          "test_body": "define <2 x i1> @isnot_pow2_negate_op_vec(<2 x i32> %x) {\n  %neg = sub <2 x i32> zeroinitializer, %x\n  %and = and <2 x i32> %neg, %x\n  %cmp = icmp ne <2 x i32> %and, %x\n  %iszero = icmp eq <2 x i32> %x, zeroinitializer\n  %r = or <2 x i1> %iszero, %cmp\n  ret <2 x i1> %r\n}\n"
        },
        {
          "test_name": "is_pow2or0_ctpop_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2or0_ctpop_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 1\n  %iszero = icmp eq i32 %x, 0\n  %r = select i1 %iszero, i1 true, i1 %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_extra_uses",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use_i1(i1)\n\ndefine i1 @isnot_pow2_ctpop_extra_uses(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  call void @use_i1(i1 %cmp)\n  %iszero = icmp eq i32 %x, 0\n  call void @use_i1(i1 %iszero)\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_power2_or_zero_inv_with_range",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_power2_or_zero_inv_with_range(i32 %x) {\n  %ctpop = call range(i32 1, 33) i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %ctpop, 1\n  %notzero = icmp ne i32 %x, 0\n  %res = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %res\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_wrong_pred2",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop_wrong_pred2(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp eq i32 %t0, 1\n  %notzero = icmp eq i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "has_single_bit",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @has_single_bit(i32 %x) {\nentry:\n  %cmp1 = icmp ne i32 %x, 0\n  %popcnt = call range(i32 1, 33) i32 @llvm.ctpop.i32(i32 %x)\n  %cmp2 = icmp ult i32 %popcnt, 2\n  %sel = select i1 %cmp1, i1 %cmp2, i1 false\n  ret i1 %sel\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_fail_pr63327",
          "test_body": "define i1 @is_pow2_fail_pr63327(i32 %x) {\n  %nx = sub i32 0, %x\n  %x_and_nx = and i32 %x, %nx\n  %r = icmp sge i32 %x_and_nx, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2_ctpop",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @is_pow2_ctpop(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ult i32 %t0, 2\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "is_pow2_nz_known_bits_fail_multiuse",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndeclare void @use.i32(i32)\n\ndefine i1 @is_pow2_nz_known_bits_fail_multiuse(i32 %xin) {\n  %x = or i32 %xin, 64\n  %cnt = call i32 @llvm.ctpop.i32(i32 %x)\n  call void @use.i32(i32 %cnt)\n  %r = icmp eq i32 %cnt, 1\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_isnt_p2_or_z",
          "test_body": "define i1 @blsmsk_isnt_p2_or_z(i32 %x) {\n  %xm1 = add i32 %x, -1\n  %y = xor i32 %x, %xm1\n  %r = icmp ult i32 %y, %x\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "isnot_pow2or0_decrement_op",
          "test_body": "define i1 @isnot_pow2or0_decrement_op(i8 %x) {\n  %dec = add i8 %x, -1\n  %and = and i8 %dec, %x\n  %cmp = icmp ne i8 %and, 0\n  ret i1 %cmp\n}\n"
        },
        {
          "test_name": "not_pow2_nz_known_bits_fail_not_p2_test",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @not_pow2_nz_known_bits_fail_not_p2_test(i32 %xin) {\n  %x = or i32 %xin, 1\n  %cnt = call i32 @llvm.ctpop.i32(i32 %x)\n  %r = icmp ne i32 %cnt, 2\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2_ctpop_wrong_cmp_op1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2_ctpop_wrong_cmp_op1(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 2\n  %iszero = icmp eq i32 %x, 0\n  %r = or i1 %iszero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "blsmsk_is_p2_or_z_ule_xy",
          "test_body": "define i1 @blsmsk_is_p2_or_z_ule_xy(i8 %xx, i8 %yy) {\n  %x = or i8 %xx, %yy\n  %xm1 = add i8 %x, -1\n  %y = xor i8 %x, %xm1\n  %r = icmp ule i8 %x, %y\n  ret i1 %r\n}\n"
        },
        {
          "test_name": "is_pow2_non_zero_ugt_1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #1\n\ndefine i1 @is_pow2_non_zero_ugt_1(i32 %x) {\n  %notzero = icmp ne i32 %x, 0\n  call void @llvm.assume(i1 %notzero)\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ugt i32 %t0, 1\n  ret i1 %cmp\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_swap_cmp",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop_swap_cmp(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 1\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %cmp, %notzero\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_logical",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop_logical(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 1\n  %notzero = icmp ne i32 %x, 0\n  %r = select i1 %notzero, i1 %cmp, i1 false\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "isnot_pow2nor0_ctpop_wrong_cmp_op1",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctpop.i32(i32) #0\n\ndefine i1 @isnot_pow2nor0_ctpop_wrong_cmp_op1(i32 %x) {\n  %t0 = tail call i32 @llvm.ctpop.i32(i32 %x)\n  %cmp = icmp ne i32 %t0, 4\n  %notzero = icmp ne i32 %x, 0\n  %r = and i1 %notzero, %cmp\n  ret i1 %r\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] `range` attribute should be dropped in `foldIsPowerOf2OrZero`",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/u62KKP (Please use latest alive2 with https://github.com/AliveToolkit/alive2/pull/1097)\r\n```\r\ndefine i1 @src(i32 %x) {\r\n  %t0 = tail call range(i32 1, 33) i32 @llvm.ctpop.i32(i32 %x)\r\n  %cmp = icmp ne i32 %t0, 1\r\n  %notzero = icmp ne i32 %x, 0\r\n  %r = select i1 %notzero, i1 %cmp, i1 false\r\n  ret i1 %r\r\n}\r\n\r\ndefine i1 @tgt(i32 %x) {\r\n  %t0 = tail call range(i32 1, 33) i32 @llvm.ctpop.i32(i32 %x)\r\n  %r = icmp ugt i32 %t0, 1\r\n  ret i1 %r\r\n}\r\n```\r\n```\r\n----------------------------------------\r\ndefine i1 @src(i32 %x) {\r\n#0:\r\n  %t0 = ctpop i32 %x\r\n  %#range_0_%t0 = !range i32 %t0, i32 1, i32 33\r\n  %cmp = icmp ne i32 %#range_0_%t0, 1\r\n  %notzero = icmp ne i32 %x, 0\r\n  %r = select i1 %notzero, i1 %cmp, i1 0\r\n  ret i1 %r\r\n}\r\n=>\r\ndefine i1 @tgt(i32 %x) {\r\n#0:\r\n  %t0 = ctpop i32 %x\r\n  %#range_0_%t0 = !range i32 %t0, i32 1, i32 33\r\n  %r = icmp ugt i32 %#range_0_%t0, 1\r\n  ret i1 %r\r\n}\r\nTransformation doesn't verify!\r\n\r\nERROR: Target is more poisonous than source\r\n\r\nExample:\r\ni32 %x = #x00000000 (0)\r\n\r\nSource:\r\ni32 %t0 = #x00000000 (0)\r\ni32 %#range_0_%t0 = poison\r\ni1 %cmp = poison\r\ni1 %notzero = #x0 (0)\r\ni1 %r = #x0 (0)\r\n\r\nTarget:\r\ni32 %t0 = #x00000000 (0)\r\ni32 %#range_0_%t0 = poison\r\ni1 %r = poison\r\nSource value: #x0 (0)\r\nTarget value: poison\r\n```",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "llvm:instcombine"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  }
}