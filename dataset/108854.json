{
  "bug_id": "108854",
  "issue_url": "https://github.com/llvm/llvm-project/issues/108854",
  "bug_type": "miscompilation",
  "base_commit": "752e10379c2ffb4f6eebf490f1fab7eb769dfbf6",
  "knowledge_cutoff": "2024-09-16T16:43:14Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SimplifyCFG"
  ],
  "hints": {
    "fix_commit": "30cdf1e959d2e4dee1c871ff37470dcdb7e8d099",
    "components": [
      "SimplifyCFG"
    ],
    "files": [
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp": [
        [
          398,
          406
        ],
        [
          421,
          432
        ],
        [
          461,
          467
        ],
        [
          480,
          487
        ],
        [
          3140,
          3146
        ],
        [
          3651,
          3657
        ],
        [
          3741,
          3750
        ],
        [
          8116,
          8122
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp": [
        "SimplifyCFGOpt::simplifyOnce",
        "SimplifyCFGOpt::speculativelyExecuteBB",
        "computeSpeculationCost",
        "dominatesMergePoint",
        "foldTwoEntryPHINode"
      ]
    }
  },
  "patch": "commit 30cdf1e959d2e4dee1c871ff37470dcdb7e8d099\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Thu Sep 19 10:19:15 2024 +0200\n\n    [SimplifyCFG] Pass context instruction to isSafeToSpeculativelyExecute() (#109132)\n    \n    Pass speculation target and assumption cache to\n    isSafeToSpeculativelyExecute() calls.\n    \n    This allows speculating based on dereferenceable/align assumptions, but\n    the primary motivation here is to avoid regressions from planned changes\n    to fix https://github.com/llvm/llvm-project/issues/108854.\n\ndiff --git a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\nindex 09461e65e2dc..69c4475a494c 100644\n--- a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\n+++ b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\n@@ -398,9 +398,6 @@ static void addPredecessorToBlock(BasicBlock *Succ, BasicBlock *NewPred,\n /// expensive.\n static InstructionCost computeSpeculationCost(const User *I,\n                                               const TargetTransformInfo &TTI) {\n-  assert((!isa<Instruction>(I) ||\n-          isSafeToSpeculativelyExecute(cast<Instruction>(I))) &&\n-         \"Instruction is not safe to speculatively execute!\");\n   return TTI.getInstructionCost(I, TargetTransformInfo::TCK_SizeAndLatency);\n }\n \n@@ -421,12 +418,11 @@ static InstructionCost computeSpeculationCost(const User *I,\n /// After this function returns, Cost is increased by the cost of\n /// V plus its non-dominating operands.  If that cost is greater than\n /// Budget, false is returned and Cost is undefined.\n-static bool dominatesMergePoint(Value *V, BasicBlock *BB,\n+static bool dominatesMergePoint(Value *V, BasicBlock *BB, Instruction *InsertPt,\n                                 SmallPtrSetImpl<Instruction *> &AggressiveInsts,\n-                                InstructionCost &Cost,\n-                                InstructionCost Budget,\n+                                InstructionCost &Cost, InstructionCost Budget,\n                                 const TargetTransformInfo &TTI,\n-                                unsigned Depth = 0) {\n+                                AssumptionCache *AC, unsigned Depth = 0) {\n   // It is possible to hit a zero-cost cycle (phi/gep instructions for example),\n   // so limit the recursion depth.\n   // TODO: While this recursion limit does prevent pathological behavior, it\n@@ -461,7 +457,7 @@ static bool dominatesMergePoint(Value *V, BasicBlock *BB,\n   // Okay, it looks like the instruction IS in the \"condition\".  Check to\n   // see if it's a cheap instruction to unconditionally compute, and if it\n   // only uses stuff defined outside of the condition.  If so, hoist it out.\n-  if (!isSafeToSpeculativelyExecute(I))\n+  if (!isSafeToSpeculativelyExecute(I, InsertPt, AC))\n     return false;\n \n   Cost += computeSpeculationCost(I, TTI);\n@@ -480,8 +476,8 @@ static bool dominatesMergePoint(Value *V, BasicBlock *BB,\n   // Okay, we can only really hoist these out if their operands do\n   // not take us over the cost threshold.\n   for (Use &Op : I->operands())\n-    if (!dominatesMergePoint(Op, BB, AggressiveInsts, Cost, Budget, TTI,\n-                             Depth + 1))\n+    if (!dominatesMergePoint(Op, BB, InsertPt, AggressiveInsts, Cost, Budget,\n+                             TTI, AC, Depth + 1))\n       return false;\n   // Okay, it's safe to do this!  Remember this instruction.\n   AggressiveInsts.insert(I);\n@@ -3140,7 +3136,8 @@ bool SimplifyCFGOpt::speculativelyExecuteBB(BranchInst *BI,\n       return false;\n \n     // Don't hoist the instruction if it's unsafe or expensive.\n-    if (!IsSafeCheapLoadStore && !isSafeToSpeculativelyExecute(&I) &&\n+    if (!IsSafeCheapLoadStore &&\n+        !isSafeToSpeculativelyExecute(&I, BI, Options.AC) &&\n         !(HoistCondStores && !SpeculatedStoreValue &&\n           (SpeculatedStoreValue =\n                isSafeToSpeculateStore(&I, BB, ThenBB, EndBB))))\n@@ -3651,7 +3648,8 @@ static bool foldCondBranchOnValueKnownInPredecessor(BranchInst *BI,\n /// Given a BB that starts with the specified two-entry PHI node,\n /// see if we can eliminate it.\n static bool foldTwoEntryPHINode(PHINode *PN, const TargetTransformInfo &TTI,\n-                                DomTreeUpdater *DTU, const DataLayout &DL,\n+                                DomTreeUpdater *DTU, AssumptionCache *AC,\n+                                const DataLayout &DL,\n                                 bool SpeculateUnpredictables) {\n   // Ok, this is a two entry PHI node.  Check to see if this is a simple \"if\n   // statement\", which has a very simple dominance structure.  Basically, we\n@@ -3741,10 +3739,10 @@ static bool foldTwoEntryPHINode(PHINode *PN, const TargetTransformInfo &TTI,\n       continue;\n     }\n \n-    if (!dominatesMergePoint(PN->getIncomingValue(0), BB, AggressiveInsts,\n-                             Cost, Budget, TTI) ||\n-        !dominatesMergePoint(PN->getIncomingValue(1), BB, AggressiveInsts,\n-                             Cost, Budget, TTI))\n+    if (!dominatesMergePoint(PN->getIncomingValue(0), BB, DomBI,\n+                             AggressiveInsts, Cost, Budget, TTI, AC) ||\n+        !dominatesMergePoint(PN->getIncomingValue(1), BB, DomBI,\n+                             AggressiveInsts, Cost, Budget, TTI, AC))\n       return Changed;\n   }\n \n@@ -8116,7 +8114,7 @@ bool SimplifyCFGOpt::simplifyOnce(BasicBlock *BB) {\n     // eliminate it, do so now.\n     if (auto *PN = dyn_cast<PHINode>(BB->begin()))\n       if (PN->getNumIncomingValues() == 2)\n-        if (foldTwoEntryPHINode(PN, TTI, DTU, DL,\n+        if (foldTwoEntryPHINode(PN, TTI, DTU, Options.AC, DL,\n                                 Options.SpeculateUnpredictables))\n           return true;\n   }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SimplifyCFG/speculate-derefable-load.ll",
      "commands": [
        "opt -S -passes=simplifycfg < %s"
      ],
      "tests": [
        {
          "test_name": "align_deref_align",
          "test_body": "define i64 @align_deref_align(i1 %c, ptr %p) {\nentry:\n  call void @llvm.assume(i1 true) [ \"dereferenceable\"(ptr %p, i64 8), \"align\"(ptr %p, i64 8) ]\n  br i1 %c, label %if, label %exit\n\nif:                                               ; preds = %entry\n  %v = load i64, ptr %p, align 8\n  br label %exit\n\nexit:                                             ; preds = %if, %entry\n  %res = phi i64 [ %v, %if ], [ 0, %entry ]\n  ret i64 %res\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "deref_hoist",
          "test_body": "define i64 @deref_hoist(i1 %c, ptr align 8 dereferenceable(8) %p1) {\nentry:\n  %p2 = load ptr, ptr %p1, align 8, !dereferenceable !0, !align !0\n  br i1 %c, label %if, label %exit\n\nif:                                               ; preds = %entry\n  %v = load i64, ptr %p2, align 8\n  br label %exit\n\nexit:                                             ; preds = %if, %entry\n  %res = phi i64 [ %v, %if ], [ 0, %entry ]\n  ret i64 %res\n}\n\n!0 = !{i64 8}\n"
        },
        {
          "test_name": "assume_deref_align_not_dominating",
          "test_body": "define i64 @assume_deref_align_not_dominating(i1 %c, ptr %p) {\nentry:\n  br i1 %c, label %if, label %exit\n\nif:                                               ; preds = %entry\n  %v = load i64, ptr %p, align 8\n  br label %exit\n\nexit:                                             ; preds = %if, %entry\n  %res = phi i64 [ %v, %if ], [ 0, %entry ]\n  call void @llvm.assume(i1 true) [ \"dereferenceable\"(ptr %p, i64 8), \"align\"(ptr %p, i64 8) ]\n  ret i64 %res\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "deref_hoist2",
          "test_body": "define i64 @deref_hoist2(i1 %c1, i32 %x, ptr align 8 dereferenceable(8) %p1) {\nentry:\n  %p2 = load ptr, ptr %p1, align 8, !dereferenceable !0, !align !0\n  br i1 %c1, label %if1, label %exit\n\nif1:                                              ; preds = %entry\n  %c2 = icmp ugt i32 %x, 10\n  br i1 %c2, label %if2, label %exit\n\nif2:                                              ; preds = %if1\n  %v = load i64, ptr %p2, align 8\n  br label %exit\n\nexit:                                             ; preds = %if2, %if1, %entry\n  %res = phi i64 [ %v, %if2 ], [ 1, %if1 ], [ 0, %entry ]\n  ret i64 %res\n}\n\n!0 = !{i64 8}\n"
        },
        {
          "test_name": "deref_no_hoist2",
          "test_body": "define i64 @deref_no_hoist2(i1 %c1, i32 %x, ptr align 8 dereferenceable(8) %p1) {\nentry:\n  br i1 %c1, label %if1, label %exit\n\nif1:                                              ; preds = %entry\n  %c2 = icmp ugt i32 %x, 10\n  br i1 %c2, label %if2, label %exit\n\nif2:                                              ; preds = %if1\n  %p2 = load ptr, ptr %p1, align 8, !dereferenceable !0, !align !0\n  %v = load i64, ptr %p2, align 8\n  br label %exit\n\nexit:                                             ; preds = %if2, %if1, %entry\n  %res = phi i64 [ %v, %if2 ], [ 1, %if1 ], [ 0, %entry ]\n  ret i64 %res\n}\n\n!0 = !{i64 8}\n"
        },
        {
          "test_name": "assume_deref_align2",
          "test_body": "define i64 @assume_deref_align2(i1 %c1, i32 %x, ptr %p) {\nentry:\n  call void @llvm.assume(i1 true) [ \"dereferenceable\"(ptr %p, i64 8), \"align\"(ptr %p, i64 8) ]\n  br i1 %c1, label %if1, label %exit\n\nif1:                                              ; preds = %entry\n  %c2 = icmp ugt i32 %x, 10\n  br i1 %c2, label %if2, label %exit\n\nif2:                                              ; preds = %if1\n  %v = load i64, ptr %p, align 8\n  br label %exit\n\nexit:                                             ; preds = %if2, %if1, %entry\n  %res = phi i64 [ %v, %if2 ], [ 1, %if1 ], [ 0, %entry ]\n  ret i64 %res\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "deref_no_hoist",
          "test_body": "define i64 @deref_no_hoist(i1 %c, ptr align 8 dereferenceable(8) %p1) {\nentry:\n  br i1 %c, label %if, label %exit\n\nif:                                               ; preds = %entry\n  %p2 = load ptr, ptr %p1, align 8, !dereferenceable !0, !align !0\n  %v = load i64, ptr %p2, align 8\n  br label %exit\n\nexit:                                             ; preds = %if, %entry\n  %res = phi i64 [ %v, %if ], [ 0, %entry ]\n  ret i64 %res\n}\n\n!0 = !{i64 8}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "isSafeToSpeculativelyExecute seems not safe to use from SimplifyCFG",
    "body": "The `llvm::isSafeToSpeculativelyExecute` function seems to be only safe to use when not speculating the result of moving instructions, since it may consider attributes that will get discarded during moving it later (e.g. dereferenceable). However, it can be seen that `SimplifyCFG:: dominatesMergePoint` tries to use it exactly in that way. Otherwise, like seen in the small snippet below, that can allow violating the semantics of attributes of the IR which, won't be valid after speculating is done (which is expected to discard those attributes).\r\n\r\nThe invalid speculation appears to happen here: https://github.com/llvm/llvm-project/blob/b592917eec407a01ef07334af5aafe6c8922c80a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp#L461-L465\r\n\r\nThis can be observed by running `opt -passes=simplifycfg this.ll` and observing that it returns IR with only basic block, which violates the semantics of `%4` being a conditional load in the original IR specification (%3 is not dereferencable after hoisting for `foldTwoEntryPHINode`):\r\n\r\n```llvm\r\ndefine i64 @julia_collect_81(i1 %0, ptr nonnull align 8 dereferenceable(8) %1) {\r\ntop:\r\n  br i1 %0, label %L82, label %L85\r\n\r\nL82:\r\n  %2 = load ptr, ptr %1, align 8, !dereferenceable !1, !align !1\r\n  %3 = load i64, ptr %2, align 8\r\n  br label %L85\r\n\r\nL85:\r\n  %4 = phi i64 [ %3, %L82 ], [ 0, %top ]\r\n  ret i64 %4\r\n}\r\n\r\n!0 = !{}\r\n!1 = !{i64 8}\r\n```\r\n\r\nWhat seems the best course of action to fix this pass mis-speculation? I think LICM and LoopRotationUtils and SpeculativeExecution may share same issue ~~but SpeculativeExecution has a private `AllPrecedingUsesFromBlockHoisted` check that it appears to have been using to avoid this issue (present since that pass was introduced in 154eb5aa1d9c829715d13c9a047d4498be4d2e2a)~~",
    "author": "vtjnash",
    "labels": [
      "miscompilation",
      "julialang",
      "llvm:analysis"
    ],
    "comments": [
      {
        "author": "nikic",
        "body": "For reference, the result of the transform is:\r\n```llvm\r\ndefine i64 @julia_collect_81(i1 %0, ptr nonnull align 8 dereferenceable(8) %1) {\r\n  %2 = load ptr, ptr %1, align 8, !align !0\r\n  %3 = load i64, ptr %2, align 8\r\n  %4 = select i1 %0, i64 %3, i64 0\r\n  ret i64 %4\r\n}\r\n\r\n!0 = !{i64 8}\r\n```\r\nWhich is correct. The poison generating `!align` attribute was preserved, while the UB generating `!dereferenceable` attribute was dropped.\r\n\r\nI was not able to parse what problem this issue is trying to report beyond that."
      },
      {
        "author": "nikic",
        "body": "Okay, now I get what this is about. It's not about the first load with the metadata, it's about the fact that the second load also gets speculated, based on the metadata the first load has before it gets dropped."
      },
      {
        "author": "nikic",
        "body": "I think the clean way to fix this would be to make use of `CxtI`. We should only make use of `!dereferenceable` information that dominates the location we're speculating to. If we're checking multiple instructions before speculating, then the necessary dominance relationship will not be there. If CxtI is nullptr we should assume an arbitrary speculation target and never use the information.\r\n\r\nMay be a bit trickier than that in practice because a) I don't think we pass CxtI in most cases right now and b) the `!dereferenceable` handling is inside getPointerDereferenceableBytes() so we probably need yet another Can flag?"
      },
      {
        "author": "vtjnash",
        "body": "Thanks! I see now that LICM had introduced the code for handling this case (f8a0db50b25ce696ae0644e75188c3d2f2465f5d) so it just needed the updates you made to pass it through. Although it still looks like LoopRotationUtils and SpeculativeExecution don't pass any CtxI argument either, but they also look like they could speculate on the result of moving a chunk of instructions?"
      },
      {
        "author": "nikic",
        "body": "@vtjnash Not passing a context instruction will use conservatively correct behavior (that is, will never use !dereferenceable metadata). Passing it would only improve results, it's not needed for correctness."
      }
    ]
  }
}