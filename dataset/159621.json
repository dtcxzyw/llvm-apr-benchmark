{
  "bug_id": "159621",
  "issue_url": "https://github.com/llvm/llvm-project/issues/159621",
  "bug_type": "crash",
  "base_commit": "2b5e29efd97c1e704e7678e53afe81bbb4745ea5",
  "knowledge_cutoff": "2025-09-18T18:15:16Z",
  "lit_test_dir": [
    "llvm/test/Transforms/PGOProfile"
  ],
  "hints": {
    "fix_commit": "a00450944d2a91aba302954556c1c23ae049dfc7",
    "components": [
      "Instrumentation"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp": [
        [
          1591,
          1597
        ],
        [
          1599,
          1604
        ],
        [
          1693,
          1706
        ],
        [
          1719,
          1724
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp": [
        "CHR::transformScopes",
        "insertTrivialPHIs"
      ]
    }
  },
  "patch": "commit a00450944d2a91aba302954556c1c23ae049dfc7\nAuthor: Aiden Grossman <aidengrossman@google.com>\nDate:   Mon Sep 22 13:57:59 2025 -0700\n\n    [ControlHeightReduction] Drop lifetime annotations where necessary (#159686)\n    \n    ControlHeightReduction will duplicate some blocks and insert phi nodes\n    in exit blocks of regions that it operates on for any live values. This\n    includes allocas. Having a lifetime annotation refer to a phi node was\n    made illegal in 92c55a315eab455d5fed2625fe0f61f88cb25499, which causes\n    the verifier to fail after CHR.\n    \n    There are some cases where we might not need to drop lifetime\n    annotations (usually because we do not need the phi to begin with), but\n    drop all annotations for now to be conservative.\n    \n    Fixes #159621.\n\ndiff --git a/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp b/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp\nindex c14bbecf0d4e..6f6245020ae5 100644\n--- a/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp\n+++ b/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp\n@@ -1591,7 +1591,16 @@ static void insertTrivialPHIs(CHRScope *Scope,\n         }\n         TrivialPHIs.insert(PN);\n         CHR_DEBUG(dbgs() << \"Insert phi \" << *PN << \"\\n\");\n+        bool FoundLifetimeAnnotation = false;\n         for (Instruction *UI : Users) {\n+          // If we found a lifetime annotation, remove it, but set a flag\n+          // to ensure that we remove all other lifetime annotations attached\n+          // to the alloca.\n+          if (UI->isLifetimeStartOrEnd()) {\n+            UI->eraseFromParent();\n+            FoundLifetimeAnnotation = true;\n+            continue;\n+          }\n           for (unsigned J = 0, NumOps = UI->getNumOperands(); J < NumOps; ++J) {\n             if (UI->getOperand(J) == &I) {\n               UI->setOperand(J, PN);\n@@ -1599,6 +1608,14 @@ static void insertTrivialPHIs(CHRScope *Scope,\n           }\n           CHR_DEBUG(dbgs() << \"Updated user \" << *UI << \"\\n\");\n         }\n+        // Erase any leftover lifetime annotations for a dynamic alloca.\n+        if (FoundLifetimeAnnotation) {\n+          for (User *U : make_early_inc_range(I.users())) {\n+            if (auto *UI = dyn_cast<Instruction>(U))\n+              if (UI->isLifetimeStartOrEnd())\n+                UI->eraseFromParent();\n+          }\n+        }\n       }\n     }\n   }\n@@ -1693,14 +1710,12 @@ void CHR::transformScopes(CHRScope *Scope, DenseSet<PHINode *> &TrivialPHIs) {\n   BasicBlock *ExitBlock = LastRegion->getExit();\n   std::optional<uint64_t> ProfileCount = BFI.getBlockProfileCount(EntryBlock);\n \n-  if (ExitBlock) {\n-    // Insert a trivial phi at the exit block (where the CHR hot path and the\n-    // cold path merges) for a value that's defined in the scope but used\n-    // outside it (meaning it's alive at the exit block). We will add the\n-    // incoming values for the CHR cold paths to it below. Without this, we'd\n-    // miss updating phi's for such values unless there happens to already be a\n-    // phi for that value there.\n-    insertTrivialPHIs(Scope, EntryBlock, ExitBlock, TrivialPHIs);\n+  SmallVector<AllocaInst *> StaticAllocas;\n+  for (Instruction &I : *EntryBlock) {\n+    if (auto *AI = dyn_cast<AllocaInst>(&I)) {\n+      if (AI->isStaticAlloca())\n+        StaticAllocas.push_back(AI);\n+    }\n   }\n \n   // Split the entry block of the first region. The new block becomes the new\n@@ -1719,6 +1734,20 @@ void CHR::transformScopes(CHRScope *Scope, DenseSet<PHINode *> &TrivialPHIs) {\n   FirstRegion->replaceEntryRecursive(NewEntryBlock);\n   BasicBlock *PreEntryBlock = EntryBlock;\n \n+  // Move static allocas into the pre-entry block so they stay static.\n+  for (AllocaInst *AI : StaticAllocas)\n+    AI->moveBefore(EntryBlock->getTerminator()->getIterator());\n+\n+  if (ExitBlock) {\n+    // Insert a trivial phi at the exit block (where the CHR hot path and the\n+    // cold path merges) for a value that's defined in the scope but used\n+    // outside it (meaning it's alive at the exit block). We will add the\n+    // incoming values for the CHR cold paths to it below. Without this, we'd\n+    // miss updating phi's for such values unless there happens to already be a\n+    // phi for that value there.\n+    insertTrivialPHIs(Scope, EntryBlock, ExitBlock, TrivialPHIs);\n+  }\n+\n   ValueToValueMapTy VMap;\n   // Clone the blocks in the scope (excluding the PreEntryBlock) to split into a\n   // hot path (originals) and a cold path (clones) and update the PHIs at the\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/PGOProfile/chr-lifetimes.ll",
      "commands": [
        "opt < %s -passes='require<profile-summary>,chr' -S"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndeclare void @foo()\ndeclare void @bar()\ndeclare void @baz(i64)\n\n; Test that when we have a static alloca in an entry block that will get split,\n; the alloca remains static and we preserve its lifetime annotations.\ndefine void @test_chr_with_lifetimes(ptr %i) !prof !14 {\n;\nentry:\n  %1 = load i32, ptr %i\n  %2 = icmp eq i32 %1, 0\n  %3 = select i1 %2, i64 4, i64 0, !prof !15\n  %test = alloca i32, align 8\n  call void @baz(i64 %3)\n  br i1 %2, label %bb1, label %bb0, !prof !15\n\nbb0:\n  call void @foo()\n  br label %bb1\n\nbb1:\n  call void @llvm.lifetime.start.p0(ptr %test)\n  store ptr %test, ptr %i, align 8\n  br label %bb2\n\nbb2:\n  %4 = phi ptr [ %5, %bb2 ], [ null, %bb1 ]\n  %5 = getelementptr i8, ptr %4, i64 24\n  %6 = icmp eq ptr %4, %i\n  br i1 %6, label %bb3, label %bb2\n\nbb3:\n  ret void\n}\n\n; Test that we remove lifetime markers that would otherwise refer to phi\n; nodes given the dynamic allocas they referred to have been duplicated.\ndefine void @test_chr_dynamic_alloca(ptr %i) !prof !14 {\n;\nentry:\n  %test1 = load i32, ptr %i\n  %test2 = icmp eq i32 %test1, 5\n  br i1 %test2, label %bb4, label %bb3\n\nbb4:\n  %1 = load i32, ptr %i\n  %2 = icmp eq i32 %1, 0\n  %3 = select i1 %2, i64 4, i64 0, !prof !15\n  %test = alloca i32, align 8\n  call void @baz(i64 %3)\n  br i1 %2, label %bb1, label %bb0, !prof !15\n\nbb0:\n  call void @foo()\n  call void @llvm.lifetime.start.p0(ptr %test)\n  store ptr %test, ptr %i, align 8\n  br label %bb1\n\nbb1:\n  call void @bar()\n  call void @llvm.lifetime.start.p0(ptr %test)\n  store ptr %test, ptr %i, align 8\n  br label %bb2\n\nbb2:\n  %4 = phi ptr [ %5, %bb2 ], [ null, %bb1 ]\n  %5 = getelementptr i8, ptr %4, i64 24\n  %test5 = load ptr, ptr %test\n  call void @llvm.lifetime.end.p0(ptr %test)\n  %6 = icmp eq ptr %4, %test5\n  br i1 %6, label %bb3, label %bb2\n\nbb3:\n  ret void\n}\n\n\n!llvm.module.flags = !{!0}\n!0 = !{i32 1, !\"ProfileSummary\", !1}\n!1 = !{!2, !3, !4, !5, !6, !7, !8, !9}\n!2 = !{!\"ProfileFormat\", !\"InstrProf\"}\n!3 = !{!\"TotalCount\", i64 10000}\n!4 = !{!\"MaxCount\", i64 10}\n!5 = !{!\"MaxInternalCount\", i64 1}\n!6 = !{!\"MaxFunctionCount\", i64 1000}\n!7 = !{!\"NumCounts\", i64 3}\n!8 = !{!\"NumFunctions\", i64 3}\n!9 = !{!\"DetailedSummary\", !10}\n!10 = !{!11, !12, !13}\n!11 = !{i32 10000, i64 100, i32 1}\n!12 = !{i32 999000, i64 100, i32 1}\n!13 = !{i32 999999, i64 1, i32 2}\n\n!14 = !{!\"function_entry_count\", i64 100}\n!15 = !{!\"branch_weights\", i32 0, i32 1}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[ControlHeightReductionPass] Creates invalid IR in ThinLTO Backend on AArch64 when building clang with ThinLTO+IRPGO",
    "body": "https://gist.github.com/boomanaiden154/7f1400804c879e25a012d7907f3922c9 is the IR.\n\nRunning `opt -mtriple=aarch64-unknown-linux-gnu -passes=\"default<O3>\" <file path> -disable-output` will reproduce the issue. The file comes from compiling clang on Aarch64 when using the BOLT caches. More details on the failure are in https://github.com/llvm/llvm-project/pull/159367.",
    "author": "boomanaiden154",
    "labels": [
      "crash",
      "LTO",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "boomanaiden154",
        "body": "Working on minimizing this currently."
      },
      {
        "author": "boomanaiden154",
        "body": "https://gist.github.com/boomanaiden154/3ae4fd0efc2cefa4d006fe1a4caec509 is the crash log."
      },
      {
        "author": "boomanaiden154",
        "body": "Reduced IR:\n```llvm\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64-unknown-linux-gnu\"\n\n%\"class.llvm::SmallVector.136\" = type { %\"class.llvm::SmallVectorImpl.76\", %\"struct.llvm::SmallVectorStorage.137\" }\n%\"class.llvm::SmallVectorImpl.76\" = type { %\"class.llvm::SmallVectorTemplateBase.77\" }\n%\"class.llvm::SmallVectorTemplateBase.77\" = type { %\"class.llvm::SmallVectorTemplateCommon.78\" }\n%\"class.llvm::SmallVectorTemplateCommon.78\" = type { %\"class.llvm::SmallVectorBase\" }\n%\"class.llvm::SmallVectorBase\" = type { ptr, i32, i32 }\n%\"struct.llvm::SmallVectorStorage.137\" = type { [256 x i8] }\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p0(ptr captures(none)) #0\n\ndefine i1 @_ZN4llvm23MemoryDependenceResults27getNonLocalPointerDepFromBBEPNS_11InstructionERKNS_12PHITransAddrERKNS_14MemoryLocationEbPNS_10BasicBlockERNS_15SmallVectorImplINS_17NonLocalDepResultEEERNS_13SmallDenseMapISA_PNS_5ValueELj16ENS_12DenseMapInfoISA_vEENS_6detail12DenseMapPairISA_SH_EEEEbb(ptr %this, ptr %QueryInst, i1 %isLoad, i1 %cmp.i.i.not.i.i) !prof !29 {\nentry:\n  %Worklist1 = alloca %\"class.llvm::SmallVector.136\", align 8\n  %shl.i.i.i = select i1 %isLoad, i64 4, i64 0, !prof !30\n  br i1 %cmp.i.i.not.i.i, label %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit, label %if.end.i.i, !prof !31\n\nif.end.i.i:                                       ; preds = %entry\n  call void @llvm.assume(i1 %isLoad)\n  br label %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit\n\n_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit: ; preds = %if.end.i.i, %entry\n  store i64 %shl.i.i.i, ptr %QueryInst, align 8\n  call void @llvm.lifetime.start.p0(ptr %Worklist1)\n  store ptr %Worklist1, ptr %this, align 8\n  br label %for.body.i.i.i.i1401\n\nfor.cond.preheader.i.i.i:                         ; preds = %for.body.i.i.i.i1401\n  ret i1 false\n\nfor.body.i.i.i.i1401:                             ; preds = %for.body.i.i.i.i1401, %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit\n  %__begin0.0.i34.i.i.i = phi ptr [ %incdec.ptr.i.i.i.i1402, %for.body.i.i.i.i1401 ], [ null, %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit ]\n  %incdec.ptr.i.i.i.i1402 = getelementptr i8, ptr %__begin0.0.i34.i.i.i, i64 24\n  %cmp.not.i.i.i.i1403 = icmp eq ptr %__begin0.0.i34.i.i.i, %this\n  br i1 %cmp.not.i.i.i.i1403, label %for.cond.preheader.i.i.i, label %for.body.i.i.i.i1401\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #1\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 1, !\"ProfileSummary\", !1}\n!1 = !{!2, !3, !4, !5, !6, !7, !8, !9, !10, !11}\n!2 = !{!\"ProfileFormat\", !\"InstrProf\"}\n!3 = !{!\"TotalCount\", i64 51888332104}\n!4 = !{!\"MaxCount\", i64 367187222}\n!5 = !{!\"MaxInternalCount\", i64 367187222}\n!6 = !{!\"MaxFunctionCount\", i64 281208867}\n!7 = !{!\"NumCounts\", i64 1698950}\n!8 = !{!\"NumFunctions\", i64 164155}\n!9 = !{!\"IsPartialProfile\", i64 0}\n!10 = !{!\"PartialProfileRatio\", double 0.000000e+00}\n!11 = !{!\"DetailedSummary\", !12}\n!12 = !{!13, !14, !15, !16, !17, !18, !19, !20, !21, !22, !23, !24, !25, !26, !27, !28}\n!13 = !{i32 10000, i64 281208867, i32 2}\n!14 = !{i32 100000, i64 88528372, i32 35}\n!15 = !{i32 200000, i64 38263822, i32 128}\n!16 = !{i32 300000, i64 20879095, i32 314}\n!17 = !{i32 400000, i64 12121080, i32 643}\n!18 = !{i32 500000, i64 6627144, i32 1239}\n!19 = !{i32 600000, i64 3697961, i32 2312}\n!20 = !{i32 700000, i64 2031812, i32 4214}\n!21 = !{i32 800000, i64 988368, i32 7927}\n!22 = !{i32 900000, i64 365146, i32 16522}\n!23 = !{i32 950000, i64 149448, i32 27512}\n!24 = !{i32 990000, i64 25291, i32 58500}\n!25 = !{i32 999000, i64 2484, i32 108076}\n!26 = !{i32 999900, i64 238, i32 156548}\n!27 = !{i32 999990, i64 44, i32 191314}\n!28 = !{i32 999999, i64 6, i32 216289}\n!29 = !{!\"function_entry_count\", i64 193405}\n!30 = !{!\"branch_weights\", i32 193405, i32 0}\n!31 = !{!\"branch_weights\", i32 0, i32 193405}\n```\n\nIt seems like this might be an issue with an earlier pass. It's just a verify call in LoopVectorizer that's tripping, and at the crash site we have the following IR:\n```llvm\n_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit: ; preds = %if.end.i.i.nonchr, %entry.split.nonchr, %if.end.i.i, %entry.split\n  %5 = phi i64 [ %shl.i.i.i, %if.end.i.i ], [ %shl.i.i.i, %entry.split ], [ %shl.i.i.i.nonchr, %if.end.i.i.nonchr ], [ %shl.i.i.i.nonchr, %entry.split.nonchr ]\n  %6 = phi ptr [ %Worklist1, %if.end.i.i ], [ %Worklist1, %entry.split ], [ %Worklist1, %if.end.i.i.nonchr ], [ %Worklist1, %entry.split.nonchr ]\n  store i64 %5, ptr %QueryInst, align 8\n  call void @llvm.lifetime.start.p0(ptr nonnull %6)\n  store ptr %6, ptr %this, align 8\n  br label %for.body.i.i.i.i1401\n```\nThe lifetime start annotation pointing at a phi node is not legal."
      },
      {
        "author": "fhahn",
        "body": "The input to LV is already invalid, `-verify-each` points to ControlHeightReductionPass or earlier\n\nhttps://llvm.godbolt.org/z/bdMMq6q5E"
      },
      {
        "author": "fhahn",
        "body": "Just extracting the IR before CHR doesn't seem to reproduce it, so possibly it gets broken earlier"
      },
      {
        "author": "boomanaiden154",
        "body": "Yeah, just saw that `ControlHeightReduction` is what introduces the invalid construct (from `-print-after-all`). Sorry for the noise about the loop vectorizer.\n\n> Just extracting the IR before CHR doesn't seem to reproduce it, so possibly it gets broken earlier\n\nJust ran into that too."
      },
      {
        "author": "boomanaiden154",
        "body": "Running just `chr` in opt doesn't work, because `chr` expects a cached profile summary analysis to be available. Taking the following IR from directly before CHR in the pipeline:\n```llvm\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64-unknown-linux-gnu\"\n\n%\"class.llvm::SmallVector.136\" = type { %\"class.llvm::SmallVectorImpl.76\", %\"struct.llvm::SmallVectorStorage.137\" }\n%\"class.llvm::SmallVectorImpl.76\" = type { %\"class.llvm::SmallVectorTemplateBase.77\" }\n%\"class.llvm::SmallVectorTemplateBase.77\" = type { %\"class.llvm::SmallVectorTemplateCommon.78\" }\n%\"class.llvm::SmallVectorTemplateCommon.78\" = type { %\"class.llvm::SmallVectorBase\" }\n%\"class.llvm::SmallVectorBase\" = type { ptr, i32, i32 }\n%\"struct.llvm::SmallVectorStorage.137\" = type { [256 x i8] }\n\n; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p0(ptr captures(none)) #0\n\n; Function Attrs: nofree norecurse nosync nounwind memory(argmem: write, inaccessiblemem: write)\ndefine noundef i1 @_ZN4llvm23MemoryDependenceResults27getNonLocalPointerDepFromBBEPNS_11InstructionERKNS_12PHITransAddrERKNS_14MemoryLocationEbPNS_10BasicBlockERNS_15SmallVectorImplINS_17NonLocalDepResultEEERNS_13SmallDenseMapISA_PNS_5ValueELj16ENS_12DenseMapInfoISA_vEENS_6detail12DenseMapPairISA_SH_EEEEbb(ptr writeonly captures(address) initializes((0, 8)) %this, ptr writeonly captures(none) initializes((0, 8)) %QueryInst, i1 %isLoad, i1 %cmp.i.i.not.i.i) local_unnamed_addr #1 !prof !29 {\nentry:\n  %Worklist1 = alloca %\"class.llvm::SmallVector.136\", align 8\n  %shl.i.i.i = select i1 %isLoad, i64 4, i64 0, !prof !30\n  br i1 %cmp.i.i.not.i.i, label %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit, label %if.end.i.i, !prof !31\n\nif.end.i.i:                                       ; preds = %entry\n  tail call void @llvm.assume(i1 %isLoad)\n  br label %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit\n\n_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit: ; preds = %if.end.i.i, %entry\n  store i64 %shl.i.i.i, ptr %QueryInst, align 8\n  call void @llvm.lifetime.start.p0(ptr nonnull %Worklist1)\n  store ptr %Worklist1, ptr %this, align 8\n  br label %for.body.i.i.i.i1401\n\nfor.cond.preheader.i.i.i:                         ; preds = %for.body.i.i.i.i1401\n  ret i1 false\n\nfor.body.i.i.i.i1401:                             ; preds = %for.body.i.i.i.i1401, %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit\n  %__begin0.0.i34.i.i.i = phi ptr [ %incdec.ptr.i.i.i.i1402, %for.body.i.i.i.i1401 ], [ null, %_ZNSt6vectorIN4llvm16NonLocalDepEntryESaIS1_EEC2ERKS3_.exit ]\n  %incdec.ptr.i.i.i.i1402 = getelementptr i8, ptr %__begin0.0.i34.i.i.i, i64 24\n  %cmp.not.i.i.i.i1403 = icmp eq ptr %__begin0.0.i34.i.i.i, %this\n  br i1 %cmp.not.i.i.i.i1403, label %for.cond.preheader.i.i.i, label %for.body.i.i.i.i1401\n}\n\n; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\nattributes #1 = { nofree norecurse nosync nounwind memory(argmem: write, inaccessiblemem: write) }\nattributes #2 = { mustprogress nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 1, !\"ProfileSummary\", !1}\n!1 = !{!2, !3, !4, !5, !6, !7, !8, !9, !10, !11}\n!2 = !{!\"ProfileFormat\", !\"InstrProf\"}\n!3 = !{!\"TotalCount\", i64 51888332104}\n!4 = !{!\"MaxCount\", i64 367187222}\n!5 = !{!\"MaxInternalCount\", i64 367187222}\n!6 = !{!\"MaxFunctionCount\", i64 281208867}\n!7 = !{!\"NumCounts\", i64 1698950}\n!8 = !{!\"NumFunctions\", i64 164155}\n!9 = !{!\"IsPartialProfile\", i64 0}\n!10 = !{!\"PartialProfileRatio\", double 0.000000e+00}\n!11 = !{!\"DetailedSummary\", !12}\n!12 = !{!13, !14, !15, !16, !17, !18, !19, !20, !21, !22, !23, !24, !25, !26, !27, !28}\n!13 = !{i32 10000, i64 281208867, i32 2}\n!14 = !{i32 100000, i64 88528372, i32 35}\n!15 = !{i32 200000, i64 38263822, i32 128}\n!16 = !{i32 300000, i64 20879095, i32 314}\n!17 = !{i32 400000, i64 12121080, i32 643}\n!18 = !{i32 500000, i64 6627144, i32 1239}\n!19 = !{i32 600000, i64 3697961, i32 2312}\n!20 = !{i32 700000, i64 2031812, i32 4214}\n!21 = !{i32 800000, i64 988368, i32 7927}\n!22 = !{i32 900000, i64 365146, i32 16522}\n!23 = !{i32 950000, i64 149448, i32 27512}\n!24 = !{i32 990000, i64 25291, i32 58500}\n!25 = !{i32 999000, i64 2484, i32 108076}\n!26 = !{i32 999900, i64 238, i32 156548}\n!27 = !{i32 999990, i64 44, i32 191314}\n!28 = !{i32 999999, i64 6, i32 216289}\n!29 = !{!\"function_entry_count\", i64 193405}\n!30 = !{!\"branch_weights\", i32 193405, i32 0}\n!31 = !{!\"branch_weights\", i32 0, i32 193405}\n```\n\nAnd then running the following opt invocation:\n```\nopt - -passes=\"require<profile-summary>,chr\" -disable-output\n```\nsuccessfully reproduces the crash. Running that on the original IR rather than the IR right before CHR also reproduces the crash, so I don't think it's something earlier producing invalid IR.\n\nIt looks like this was caught by 92c55a315eab455d5fed2625fe0f61f88cb25499.\n\n"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true
}