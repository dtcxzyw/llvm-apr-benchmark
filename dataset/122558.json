{
  "bug_id": "122558",
  "issue_url": "https://github.com/llvm/llvm-project/issues/122558",
  "bug_type": "crash",
  "base_commit": "25f28ddd69ed2453726c0934ba6feea8ae6f10f8",
  "knowledge_cutoff": "2025-01-11T00:36:48Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "1de3dc7d23dd6b856efad3a3a04f2396328726d7",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          4052,
          4058
        ],
        [
          4064,
          4069
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::computeMaxVF"
      ]
    }
  },
  "patch": "commit 1de3dc7d23dd6b856efad3a3a04f2396328726d7\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Tue Jan 14 22:07:38 2025 +0000\n\n    [LV] Bail out early if BTC+1 wraps.\n    \n    Currently we fail to detect the case where BTC + 1 wraps, i.e. the\n    vector trip count is 0, In those cases, the minimum iteration count\n    check will fail, and the vector code will never be executed.\n    \n    Explicitly check for this condition in computeMaxVF and avoid trying to\n    vectorize alltogether.\n    \n    Note that a number of tests needed to be updated, because the vector\n    loop would never be executed given the input IR.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/122558.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 744faef19243..fe2fb5e9faae 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -4052,7 +4052,8 @@ LoopVectorizationCostModel::computeMaxVF(ElementCount UserVF, unsigned UserIC) {\n     return FixedScalableVFPair::getNone();\n   }\n \n-  unsigned TC = PSE.getSE()->getSmallConstantTripCount(TheLoop);\n+  ScalarEvolution *SE = PSE.getSE();\n+  unsigned TC = SE->getSmallConstantTripCount(TheLoop);\n   unsigned MaxTC = PSE.getSmallConstantMaxTripCount();\n   LLVM_DEBUG(dbgs() << \"LV: Found trip count: \" << TC << '\\n');\n   if (TC != MaxTC)\n@@ -4064,6 +4065,22 @@ LoopVectorizationCostModel::computeMaxVF(ElementCount UserVF, unsigned UserIC) {\n     return FixedScalableVFPair::getNone();\n   }\n \n+  // If BTC matches the widest induction type and is -1 then the trip count\n+  // computation will wrap to 0 and the vector trip count will be 0. Do not try\n+  // to vectorize.\n+  const SCEV *BTC = SE->getBackedgeTakenCount(TheLoop);\n+  if (!isa<SCEVCouldNotCompute>(BTC) &&\n+      BTC->getType()->getScalarSizeInBits() >=\n+          Legal->getWidestInductionType()->getScalarSizeInBits() &&\n+      SE->isKnownPredicate(CmpInst::ICMP_EQ, BTC,\n+                           SE->getMinusOne(BTC->getType()))) {\n+    reportVectorizationFailure(\n+        \"Trip count computation wrapped\",\n+        \"backedge-taken count is -1, loop trip count wrapped to 0\",\n+        \"TripCountWrapped\", ORE, TheLoop);\n+    return FixedScalableVFPair::getNone();\n+  }\n+\n   switch (ScalarEpilogueStatus) {\n   case CM_ScalarEpilogueAllowed:\n     return computeFeasibleMaxVF(MaxTC, UserVF, false);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-dot-product-epilogue.ll",
      "commands": [
        "opt -mattr=+dotprod -passes=loop-vectorize -force-vector-interleave=1 -S < %s"
      ],
      "tests": [
        {
          "test_name": "dotp",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @dotp(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-dot-product-mixed.ll",
      "commands": [
        "opt -passes=loop-vectorize -enable-epilogue-vectorization=false -mattr=+i8mm,+dotprod -S < %s",
        "opt -passes=loop-vectorize -enable-epilogue-vectorization=false -mattr=+dotprod -S < %s"
      ],
      "tests": [
        {
          "test_name": "dotp_z_s",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @dotp_z_s(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = sext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "dotp_s_z",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @dotp_s_z(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = sext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-dot-product-neon.ll",
      "commands": [
        "opt -passes=loop-vectorize -enable-epilogue-vectorization=false -mattr=+neon,+dotprod -force-vector-interleave=1 -S < %s",
        "opt -passes=loop-vectorize -enable-epilogue-vectorization=false -mattr=+neon,+dotprod -S < %s",
        "opt -passes=loop-vectorize -enable-epilogue-vectorization=false -mattr=+neon,+dotprod -force-vector-interleave=1 -vectorizer-maximize-bandwidth -S < %s"
      ],
      "tests": [
        {
          "test_name": "dotp_unrolled",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @dotp_unrolled(i32 %num_out, i64 %num_in, ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum3 = phi i32 [ 0, %entry ], [ %add.a3, %for.body ]\n  %accum2 = phi i32 [ 0, %entry ], [ %add.a2, %for.body ]\n  %accum1 = phi i32 [ 0, %entry ], [ %add.a1, %for.body ]\n  %accum0 = phi i32 [ 0, %entry ], [ %add.a0, %for.body ]\n  %gep.a0 = getelementptr inbounds i8, ptr %a, i64 %iv\n  %gep.b0 = getelementptr inbounds i8, ptr %b, i64 %iv\n  %offset.1 = or disjoint i64 %iv, 1\n  %gep.a1 = getelementptr inbounds i8, ptr %a, i64 %offset.1\n  %gep.b1 = getelementptr inbounds i8, ptr %b, i64 %offset.1\n  %offset.2 = or disjoint i64 %iv, 2\n  %gep.a2 = getelementptr inbounds i8, ptr %a, i64 %offset.2\n  %gep.b2 = getelementptr inbounds i8, ptr %b, i64 %offset.2\n  %offset.3 = or disjoint i64 %iv, 3\n  %gep.a3 = getelementptr inbounds i8, ptr %a, i64 %offset.3\n  %gep.b3 = getelementptr inbounds i8, ptr %b, i64 %offset.3\n  %load.a0 = load i8, ptr %gep.a0, align 1\n  %ext.a0 = sext i8 %load.a0 to i32\n  %load.b0 = load i8, ptr %gep.b0, align 1\n  %ext.b0 = sext i8 %load.b0 to i32\n  %mul.a0 = mul nsw i32 %ext.b0, %ext.a0\n  %add.a0 = add nsw i32 %mul.a0, %accum0\n  %load.a1 = load i8, ptr %gep.a1, align 1\n  %ext.a1 = sext i8 %load.a1 to i32\n  %load.b1 = load i8, ptr %gep.b1, align 1\n  %ext.b1 = sext i8 %load.b1 to i32\n  %mul.a1 = mul nsw i32 %ext.a1, %ext.b1\n  %add.a1 = add nsw i32 %mul.a1, %accum1\n  %load.a2 = load i8, ptr %gep.a2, align 1\n  %ext.a2 = sext i8 %load.a2 to i32\n  %load.b2 = load i8, ptr %gep.b2, align 1\n  %ext.b2 = sext i8 %load.b2 to i32\n  %mul.a2 = mul nsw i32 %ext.a2, %ext.b2\n  %add.a2 = add nsw i32 %mul.a2, %accum2\n  %load.a3 = load i8, ptr %gep.a3, align 1\n  %ext.a3 = sext i8 %load.a3 to i32\n  %load.b3 = load i8, ptr %gep.b3, align 1\n  %ext.b3 = sext i8 %load.b3 to i32\n  %mul.a3 = mul nsw i32 %ext.a3, %ext.b3\n  %add.a3 = add nsw i32 %mul.a3, %accum3\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, %num_in\n  br i1 %exitcond.not, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  %result0 = add nsw i32 %add.a0, %add.a1\n  %result1 = add nsw i32 %add.a2, %add.a3\n  %result = add nsw i32 %result0, %result1\n  ret i32 %result\n}\n"
        },
        {
          "test_name": "dotp",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @dotp(ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n"
        },
        {
          "test_name": "not_dotp_predicated_pragma",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @not_dotp_predicated_pragma(i64 %N, ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr inbounds i8, ptr %b, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = sext i8 %load.a to i32\n  %gep.a2 = getelementptr inbounds i8, ptr %a, i64 %iv\n  %load.b = load i8, ptr %gep.a2, align 1\n  %ext.b = sext i8 %load.b to i32\n  %mul = mul nsw i32 %ext.b, %ext.a\n  %add = add nsw i32 %mul, %accum\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, %N\n  br i1 %exitcond.not, label %exit, label %for.body, !llvm.loop !0\n\nexit:                                             ; preds = %for.body\n  ret i32 %add\n}\n\n!0 = distinct !{!0, !1, !2, !3}\n!1 = !{!\"llvm.loop.mustprogress\"}\n!2 = !{!\"llvm.loop.vectorize.predicate.enable\", i1 true}\n!3 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n"
        },
        {
          "test_name": "not_dotp_not_loop_carried",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @not_dotp_not_loop_carried(ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %mul, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n"
        },
        {
          "test_name": "not_dotp_different_types",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @not_dotp_different_types(ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i16, ptr %gep.b, align 2\n  %ext.b = zext i16 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n"
        },
        {
          "test_name": "not_dotp_not_phi",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @not_dotp_not_phi(ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %ext.b\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n"
        },
        {
          "test_name": "not_dotp_extend_user",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @not_dotp_extend_user(ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  %result = add i32 %add, %ext.b\n  ret i32 %result\n}\n"
        },
        {
          "test_name": "not_dotp_predicated",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @not_dotp_predicated(i64 %N, ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr inbounds i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = sext i8 %load.a to i32\n  %gep.b = getelementptr inbounds i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = sext i8 %load.b to i32\n  %mul = mul nsw i32 %ext.b, %ext.a\n  %add = add nsw i32 %mul, %accum\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, %N\n  br i1 %exitcond.not, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  ret i32 %add\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-dot-product.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-interleave=1 -enable-epilogue-vectorization=false -S < %s",
        "opt -passes=loop-vectorize -enable-epilogue-vectorization=false -S < %s",
        "opt -passes=loop-vectorize -force-vector-interleave=1 -vectorizer-maximize-bandwidth -enable-epilogue-vectorization=false -S < %s"
      ],
      "tests": [
        {
          "test_name": "not_dotp_not_phi2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine void @not_dotp_not_phi2(ptr %matrix, i32 %n) #0 {\nentry:\n  %cmp = icmp sgt i32 %n, 0\n  br i1 %cmp, label %for.preheader, label %exit\n\nfor.preheader:                                    ; preds = %entry\n  %load.a = load i8, ptr null, align 1\n  %load.a1 = load i8, ptr inttoptr (i64 1 to ptr), align 1\n  %a.ext = sext i8 %load.a to i32\n  %a.ext1 = sext i8 %load.a1 to i32\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.preheader\n  %iv = phi i32 [ %iv.next, %for.body ], [ 0, %for.preheader ]\n  %ptr = phi ptr [ %scevgep, %for.body ], [ %matrix, %for.preheader ]\n  %accum = phi i32 [ %add.1, %for.body ], [ 0, %for.preheader ]\n  %gep.b = getelementptr i8, ptr %ptr, i64 1\n  %gep.b1 = getelementptr i8, ptr %ptr, i64 2\n  %load.b = load i8, ptr %gep.b, align 1\n  %b.ext = sext i8 %load.b to i32\n  %mul = mul nsw i32 %a.ext, %b.ext\n  %add = add i32 %mul, %accum\n  %load.b1 = load i8, ptr %gep.b1, align 1\n  %b.ext1 = sext i8 %load.b1 to i32\n  %mul.1 = mul nsw i32 %a.ext1, %b.ext1\n  %add.1 = add i32 %mul.1, %add\n  %scevgep = getelementptr i8, ptr %ptr, i64 16\n  %iv.next = add nuw nsw i32 %iv, 1\n  %exitcond.not = icmp eq i32 %iv.next, %n\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  %add.1.lcssa = phi i32 [ %add.1, %for.body ]\n  %add.float = sitofp i32 %add.1.lcssa to float\n  br label %exit\n\nexit:                                             ; preds = %for.exit, %entry\n  %result = phi float [ 0.000000e+00, %entry ], [ %add.float, %for.exit ]\n  store float %result, ptr %matrix, align 4\n  ret void\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_ext_outside_plan2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i64 @not_dotp_ext_outside_plan2(ptr %a, i16 %b, i64 %n) #0 {\nentry:\n  %cmp = icmp eq i64 %n, 0\n  br i1 %cmp, label %exit, label %for.ph\n\nfor.ph:                                           ; preds = %entry\n  %ext.b = zext i16 %b to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.ph\n  %iv = phi i64 [ 0, %for.ph ], [ %iv.next, %for.body ]\n  %accum = phi i64 [ 0, %for.ph ], [ %add, %for.body ]\n  %gep.a = getelementptr inbounds nuw i16, ptr %a, i64 %iv\n  %load.a = load i16, ptr %gep.a, align 2\n  %ext.a = zext i16 %load.a to i64\n  %mul = mul nuw nsw i64 %ext.b, %ext.a\n  %add = add i64 %mul, %accum\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp.1 = icmp eq i64 %iv.next, %n\n  br i1 %cmp.1, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body, %entry\n  %result = phi i64 [ 0, %entry ], [ %add, %for.body ]\n  ret i64 %result\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "dotp_unrolled",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @dotp_unrolled(i32 %num_out, i64 %num_in, ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum3 = phi i32 [ 0, %entry ], [ %add.a3, %for.body ]\n  %accum2 = phi i32 [ 0, %entry ], [ %add.a2, %for.body ]\n  %accum1 = phi i32 [ 0, %entry ], [ %add.a1, %for.body ]\n  %accum0 = phi i32 [ 0, %entry ], [ %add.a0, %for.body ]\n  %gep.a0 = getelementptr inbounds i8, ptr %a, i64 %iv\n  %gep.b0 = getelementptr inbounds i8, ptr %b, i64 %iv\n  %offset.1 = or disjoint i64 %iv, 1\n  %gep.a1 = getelementptr inbounds i8, ptr %a, i64 %offset.1\n  %gep.b1 = getelementptr inbounds i8, ptr %b, i64 %offset.1\n  %offset.2 = or disjoint i64 %iv, 2\n  %gep.a2 = getelementptr inbounds i8, ptr %a, i64 %offset.2\n  %gep.b2 = getelementptr inbounds i8, ptr %b, i64 %offset.2\n  %offset.3 = or disjoint i64 %iv, 3\n  %gep.a3 = getelementptr inbounds i8, ptr %a, i64 %offset.3\n  %gep.b3 = getelementptr inbounds i8, ptr %b, i64 %offset.3\n  %load.a0 = load i8, ptr %gep.a0, align 1\n  %ext.a0 = sext i8 %load.a0 to i32\n  %load.b0 = load i8, ptr %gep.b0, align 1\n  %ext.b0 = sext i8 %load.b0 to i32\n  %mul.a0 = mul nsw i32 %ext.b0, %ext.a0\n  %add.a0 = add nsw i32 %mul.a0, %accum0\n  %load.a1 = load i8, ptr %gep.a1, align 1\n  %ext.a1 = sext i8 %load.a1 to i32\n  %load.b1 = load i8, ptr %gep.b1, align 1\n  %ext.b1 = sext i8 %load.b1 to i32\n  %mul.a1 = mul nsw i32 %ext.a1, %ext.b1\n  %add.a1 = add nsw i32 %mul.a1, %accum1\n  %load.a2 = load i8, ptr %gep.a2, align 1\n  %ext.a2 = sext i8 %load.a2 to i32\n  %load.b2 = load i8, ptr %gep.b2, align 1\n  %ext.b2 = sext i8 %load.b2 to i32\n  %mul.a2 = mul nsw i32 %ext.a2, %ext.b2\n  %add.a2 = add nsw i32 %mul.a2, %accum2\n  %load.a3 = load i8, ptr %gep.a3, align 1\n  %ext.a3 = sext i8 %load.a3 to i32\n  %load.b3 = load i8, ptr %gep.b3, align 1\n  %ext.b3 = sext i8 %load.b3 to i32\n  %mul.a3 = mul nsw i32 %ext.a3, %ext.b3\n  %add.a3 = add nsw i32 %mul.a3, %accum3\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, %num_in\n  br i1 %exitcond.not, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  %result0 = add nsw i32 %add.a0, %add.a1\n  %result1 = add nsw i32 %add.a2, %add.a3\n  %result = add nsw i32 %result0, %result1\n  ret i32 %result\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "dotp",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @dotp(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_predicated_pragma",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @not_dotp_predicated_pragma(i64 %N, ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr inbounds i8, ptr %b, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = sext i8 %load.a to i32\n  %gep.a2 = getelementptr inbounds i8, ptr %a, i64 %iv\n  %load.b = load i8, ptr %gep.a2, align 1\n  %ext.b = sext i8 %load.b to i32\n  %mul = mul nsw i32 %ext.b, %ext.a\n  %add = add nsw i32 %mul, %accum\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, %N\n  br i1 %exitcond.not, label %exit, label %for.body, !llvm.loop !0\n\nexit:                                             ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n\n!0 = distinct !{!0, !1, !2, !3}\n!1 = !{!\"llvm.loop.mustprogress\"}\n!2 = !{!\"llvm.loop.vectorize.predicate.enable\", i1 true}\n!3 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n"
        },
        {
          "test_name": "dotp_cost_disagreement",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i64 @dotp_cost_disagreement(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i.iv = phi i64 [ 0, %entry ], [ %i.iv.next, %for.body ]\n  %sum = phi i64 [ 0, %entry ], [ %add, %for.body ]\n  %arrayidx = getelementptr inbounds nuw i8, ptr %a, i64 %i.iv\n  %0 = load i8, ptr %arrayidx, align 1\n  %conv = zext i8 %0 to i64\n  %i.iv.next = add nuw nsw i64 %i.iv, 1\n  %arrayidx2 = getelementptr inbounds nuw i8, ptr %b, i64 %i.iv.next\n  %1 = load i8, ptr %arrayidx2, align 1\n  %conv3 = zext i8 %1 to i64\n  %mul = mul nuw nsw i64 %conv3, %conv\n  %add = add i64 %sum, %mul\n  %exitcond.not = icmp eq i64 %i.iv.next, 16\n  br i1 %exitcond.not, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  ret i64 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_not_loop_carried",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @not_dotp_not_loop_carried(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %mul, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_different_types",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @not_dotp_different_types(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i16, ptr %gep.b, align 2\n  %ext.b = zext i16 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_not_phi",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @not_dotp_not_phi(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %ext.b\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_extend_user",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @not_dotp_extend_user(ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  %result = add i32 %add, %ext.b\n  ret i32 %result\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_ext_outside_plan",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i64 @not_dotp_ext_outside_plan(ptr %a, i16 %b, i64 %n) #0 {\nentry:\n  %cmp = icmp eq i64 %n, 0\n  br i1 %cmp, label %exit, label %for.ph\n\nfor.ph:                                           ; preds = %entry\n  %ext.b = zext i16 %b to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.ph\n  %iv = phi i64 [ 0, %for.ph ], [ %iv.next, %for.body ]\n  %accum = phi i64 [ 0, %for.ph ], [ %add, %for.body ]\n  %gep.a = getelementptr inbounds nuw i16, ptr %a, i64 %iv\n  %load.a = load i16, ptr %gep.a, align 2\n  %ext.a = zext i16 %load.a to i64\n  %mul = mul nuw nsw i64 %ext.a, %ext.b\n  %add = add i64 %mul, %accum\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp.1 = icmp eq i64 %iv.next, %n\n  br i1 %cmp.1, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body, %entry\n  %result = phi i64 [ 0, %entry ], [ %add, %for.body ]\n  ret i64 %result\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        },
        {
          "test_name": "not_dotp_predicated",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\n; Function Attrs: vscale_range(1,16)\ndefine i32 @not_dotp_predicated(i64 %N, ptr %a, ptr %b) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr inbounds i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = sext i8 %load.a to i32\n  %gep.b = getelementptr inbounds i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = sext i8 %load.b to i32\n  %mul = mul nsw i32 %ext.b, %ext.a\n  %add = add nsw i32 %mul, %accum\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, %N\n  br i1 %exitcond.not, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  ret i32 %add\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/partial-reduce-no-dotprod.ll",
      "commands": [
        "opt -passes=loop-vectorize -enable-epilogue-vectorization=false -mattr=+neon -S < %s"
      ],
      "tests": [
        {
          "test_name": "not_dotp",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @not_dotp(ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1000\n  br i1 %exitcond.not, label %for.exit, label %for.body\n\nfor.exit:                                         ; preds = %for.body\n  ret i32 %add\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/store-costs-sve.ll",
      "commands": [
        "opt -p loop-vectorize -S %s",
        "opt -p loop-vectorize -prefer-predicate-over-epilogue=predicate-else-scalar-epilogue -S %s"
      ],
      "tests": [
        {
          "test_name": "trunc_store",
          "test_body": "target datalayout = \"e-m:o-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"arm64-apple-macosx14.0.0\"\n\n; Function Attrs: vscale_range(1,16)\ndefine void @trunc_store(ptr %dst, ptr %src, i16 %x) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %x.ext = zext i16 %x to i64\n  %l = load i64, ptr %src, align 8\n  %and = and i64 %l, %x.ext\n  %trunc = trunc i64 %and to i8\n  %gep = getelementptr i8, ptr %dst, i64 %iv\n  store i8 %trunc, ptr %gep, align 1\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { vscale_range(1,16) \"target-features\"=\"+sve\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/vplan-printing.ll",
      "commands": [
        "opt -mattr=+neon,+dotprod -passes=loop-vectorize -debug-only=loop-vectorize -force-vector-interleave=1 -disable-output %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "print_partial_reduction",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-none-unknown-elf\"\n\ndefine i32 @print_partial_reduction(ptr %a, ptr %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %accum = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %gep.a = getelementptr i8, ptr %a, i64 %iv\n  %load.a = load i8, ptr %gep.a, align 1\n  %ext.a = zext i8 %load.a to i32\n  %gep.b = getelementptr i8, ptr %b, i64 %iv\n  %load.b = load i8, ptr %gep.b, align 1\n  %ext.b = zext i8 %load.b to i32\n  %mul = mul i32 %ext.b, %ext.a\n  %add = add i32 %mul, %accum\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %exit, label %for.body\n\nexit:                                             ; preds = %for.body\n  ret i32 %add\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/Hexagon/maximum-vf-crash.ll",
      "commands": [
        "opt -mtriple=hexagon -hexagon-autohvx -passes=loop-vectorize -S < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "f",
          "test_body": "target datalayout = \"e-m:e-p:32:32:32-a:0-n16:32-i64:64:64-i32:32:32-i16:16:16-i1:8:8-f32:32:32-f64:64:64-v32:32:32-v64:64:64-v512:512:512-v1024:1024:1024-v2048:2048:2048\"\n\n; Function Attrs: optsize\ndefine i32 @f(ptr %src) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %g.016 = phi i32 [ 0, %entry ], [ %g.1.lcssa, %loop ]\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %0 = load i8, ptr %src, align 1\n  %g.1.lcssa = add i32 %g.016, 1\n  %iv.next = add nsw i32 %iv, 1\n  %exitcond = icmp eq i32 %iv.next, 1000\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i32 %g.1.lcssa\n}\n\nattributes #0 = { optsize \"target-features\"=\"+hvx-length128b\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-constant-known-via-scev.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "second_lshr_operand_zero_via_scev",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i64 @second_lshr_operand_zero_via_scev() {\nentry:\n  %ext.0 = sext i8 0 to i32\n  br label %loops\n\nloops:                                            ; preds = %loops, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loops ]\n  %red = phi i64 [ 0, %entry ], [ %red.next, %loops ]\n  %c = icmp eq i64 %iv, 0\n  %and = and i64 %iv, 0\n  %0 = trunc i64 %iv to i32\n  %shr = lshr i32 %0, %ext.0\n  %conv.1 = zext i32 %shr to i64\n  %red.next.v = select i1 %c, i64 %and, i64 %conv.1\n  %red.next = or i64 %red.next.v, %red\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loops\n\nexit:                                             ; preds = %loops\n  %res = phi i64 [ %red.next, %loops ]\n  ret i64 %res\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-model.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7-avx -S"
      ],
      "tests": [
        {
          "test_name": "narrowed_reduction",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i32 @narrowed_reduction(ptr %a, i1 %cmp) #0 {\nentry:\n  %conv = zext i1 %cmp to i32\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 1, %entry ], [ %inc, %loop ]\n  %or13 = phi i32 [ 0, %entry ], [ %or, %loop ]\n  %and = and i32 %or13, 1\n  %or = or i32 %and, %conv\n  %inc = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 16\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i32 %or\n}\n\nattributes #0 = { \"target-cpu\"=\"penryn\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/drop-poison-generating-flags.ll",
      "commands": [
        "opt %s -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S"
      ],
      "tests": [
        {
          "test_name": "drop_zext_nneg",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc-linux-gnu\"\n\n; Function Attrs: noinline nounwind uwtable\ndefine void @drop_zext_nneg(ptr noalias %p, ptr noalias %p1) #0 {\nentry:\n  br label %body\n\nbody:                                             ; preds = %else, %entry\n  %iv = phi i64 [ %next, %else ], [ 0, %entry ]\n  %0 = trunc i64 %iv to i32\n  %c = icmp eq i32 %0, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %body\n  %zext = zext nneg i32 %0 to i64\n  %idx1 = getelementptr double, ptr %p, i64 %zext\n  %idx2 = getelementptr double, ptr %p, i64 %zext\n  %1 = load double, ptr %idx2, align 8\n  br label %else\n\nelse:                                             ; preds = %then, %body\n  %phi = phi double [ %1, %then ], [ 0.000000e+00, %body ]\n  store double %phi, ptr %p1, align 8\n  %next = add i64 %iv, 1\n  %cmp = icmp eq i64 %next, 1024\n  br i1 %cmp, label %exit, label %body\n\nexit:                                             ; preds = %else\n  ret void\n}\n\nattributes #0 = { noinline nounwind uwtable \"target-features\"=\"+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/interleave-cost.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "test_free_instructions_feeding_geps_for_interleave_groups",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @test_free_instructions_feeding_geps_for_interleave_groups(ptr noalias %p.invar, ptr noalias %dst.1, ptr noalias %dst.2) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %l.0 = load float, ptr %p.invar, align 4\n  %iv.mul = shl i64 %iv, 2\n  %gep.dst.19 = getelementptr float, ptr %dst.1, i64 %iv.mul\n  store float %l.0, ptr %gep.dst.19, align 4\n  %l.1 = load float, ptr %p.invar, align 4\n  %add.1 = or disjoint i64 %iv.mul, 1\n  %gep.dst.119 = getelementptr float, ptr %dst.1, i64 %add.1\n  store float %l.1, ptr %gep.dst.119, align 4\n  %add.2 = or disjoint i64 %iv.mul, 2\n  %gep.dst.129 = getelementptr float, ptr %dst.1, i64 %add.2\n  store float 0.000000e+00, ptr %gep.dst.129, align 4\n  %add.3 = or disjoint i64 %iv.mul, 3\n  %gep.dst.140 = getelementptr float, ptr %dst.1, i64 %add.3\n  store float 0.000000e+00, ptr %gep.dst.140, align 4\n  %l.2 = load float, ptr %p.invar, align 4\n  %gep.dst.247 = getelementptr float, ptr %dst.2, i64 %iv.mul\n  store float %l.2, ptr %gep.dst.247, align 4\n  %gep.dst.255 = getelementptr float, ptr %dst.2, i64 %add.1\n  store float 0.000000e+00, ptr %gep.dst.255, align 4\n  %gep.dst.265 = getelementptr float, ptr %dst.2, i64 %add.2\n  store float 0.000000e+00, ptr %gep.dst.265, align 4\n  %gep.dst.276 = getelementptr float, ptr %dst.2, i64 %add.3\n  store float 0.000000e+00, ptr %gep.dst.276, align 4\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, 1024\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/replicate-uniform-call.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "smax_call_uniform",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @smax_call_uniform(ptr %dst, i64 %x) {\nentry:\n  %c = icmp ult i8 -68, -69\n  %mul = mul nuw nsw i64 %x, 0\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %c, label %loop.latch, label %else\n\nelse:                                             ; preds = %loop.header\n  %rem = urem i64 %mul, %x\n  %smax = tail call i64 @llvm.smax.i64(i64 %rem, i64 0)\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %loop.header\n  %p = phi i64 [ 1, %loop.header ], [ %smax, %else ]\n  %add = add i64 %p, 1\n  %gep = getelementptr i64, ptr %dst, i64 %add\n  store i64 0, ptr %gep, align 8\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, 1024\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i64 @llvm.smax.i64(i64, i64) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/epilog-vectorization-vector-trip-count-zero.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=2 -epilogue-vectorization-force-VF=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "vector_trip_count_0_as_btc_is_all_1",
          "test_body": "target datalayout = \"E-m:e-i1:8:16-i8:8:16-i64:64-f128:64-v128:64-a:8:16-n32:64\"\n\ndefine void @vector_trip_count_0_as_btc_is_all_1(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.next = add i32 %iv, -1\n  %gep = getelementptr inbounds i32, ptr %dst, i32 %iv\n  store i32 %iv.next, ptr %gep, align 4\n  %ec = icmp eq i32 %iv.next, 0\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence-chains.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "test_resinking_required",
          "test_body": "define double @test_resinking_required(ptr %p, ptr noalias %a, ptr noalias %b) {\nEntry:\n  br label %Loop\n\nLoop:                                             ; preds = %Loop, %Entry\n  %for.1 = phi double [ %l1, %Loop ], [ 0.000000e+00, %Entry ]\n  %for.2 = phi double [ %l2, %Loop ], [ 0.000000e+00, %Entry ]\n  %for.3 = phi double [ %for.2, %Loop ], [ 0.000000e+00, %Entry ]\n  %iv = phi i64 [ %iv.next, %Loop ], [ 0, %Entry ]\n  %USE_2_FORS = fdiv double %for.3, %for.1\n  %div = fdiv double 0.000000e+00, %for.1\n  %l1 = load double, ptr %a, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %l2 = load double, ptr %b, align 8\n  store double %div, ptr %p, align 8\n  %cond = icmp eq i64 %iv.next, 1000\n  br i1 %cond, label %End, label %Loop\n\nEnd:                                              ; preds = %Loop\n  %res.1 = fadd double %for.1, %for.2\n  %res.2 = fadd double %res.1, %for.3\n  ret double %res.2\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/if-pred-stores.ll",
      "commands": [
        "opt -S -vectorize-num-stores-pred=1 -force-vector-width=1 -force-vector-interleave=2 -passes=loop-vectorize,simplifycfg -verify-loop-info -simplifycfg-require-and-preserve-domtree=1 < %s",
        "opt -S -vectorize-num-stores-pred=1 -force-vector-width=1 -force-vector-interleave=2 -passes=loop-vectorize -verify-loop-info < %s",
        "opt -S -vectorize-num-stores-pred=1 -force-vector-width=2 -force-vector-interleave=1 -passes=loop-vectorize,simplifycfg -verify-loop-info -simplifycfg-require-and-preserve-domtree=1 < %s"
      ],
      "tests": [
        {
          "test_name": "minimal_bit_widths_with_aliasing_store",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @minimal_bit_widths_with_aliasing_store(i1 %c, ptr %ptr) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %tmp0 = phi i64 [ %tmp6, %for.inc ], [ 0, %entry ]\n  %tmp1 = phi i64 [ %tmp7, %for.inc ], [ 1000, %entry ]\n  %tmp2 = getelementptr i8, ptr %ptr, i64 %tmp0\n  %tmp3 = load i8, ptr %tmp2, align 1\n  store i8 0, ptr %tmp2, align 1\n  br i1 %c, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %tmp4 = zext i8 %tmp3 to i32\n  %tmp5 = trunc i32 %tmp4 to i8\n  store i8 %tmp5, ptr %tmp2, align 1\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %tmp6 = add nuw nsw i64 %tmp0, 1\n  %tmp7 = add i64 %tmp1, -1\n  %tmp8 = icmp eq i64 %tmp7, 0\n  br i1 %tmp8, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.inc\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/induction.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize,instcombine -force-vector-interleave=1 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize,instcombine -force-vector-interleave=2 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize -force-vector-interleave=2 -force-vector-width=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize,instcombine -force-vector-interleave=2 -force-vector-width=4 -force-widen-divrem-via-safe-divisor=0 -enable-interleaved-mem-accesses -S"
      ],
      "tests": [
        {
          "test_name": "max_i32_backedgetaken",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\ndefine i32 @max_i32_backedgetaken() {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %a.0 = phi i32 [ 1, %entry ], [ %a.0.and, %loop ]\n  %b.0 = phi i32 [ 0, %entry ], [ %b.next, %loop ]\n  %a.0.and = and i32 %a.0, 4\n  %b.next = add i32 %b.0, -1\n  %ec = icmp eq i32 %b.next, 0\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i32 %a.0.and\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/interleave-and-scalarize-only.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=1 -force-vector-interleave=2 -debug -disable-output %s 2>&1",
        "opt -passes=loop-vectorize -force-vector-width=1 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "scalarize_ptrtoint",
          "test_body": "define void @scalarize_ptrtoint(ptr %src, ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep = getelementptr ptr, ptr %src, i64 %iv\n  %l = load ptr, ptr %gep, align 8\n  %cast = ptrtoint ptr %l to i64\n  %add = add i64 %cast, 10\n  %cast.2 = inttoptr i64 %add to ptr\n  store ptr %cast.2, ptr %dst, align 8\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, 1024\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/is_fpclass.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -force-vector-width=2 -S"
      ],
      "tests": [
        {
          "test_name": "d",
          "test_body": "define void @d() {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %i = phi i64 [ 0, %entry ], [ %i7, %loop ]\n  %i3 = load float, ptr null, align 4\n  %i4 = getelementptr float, ptr @d, i64 %i\n  %i5 = tail call i1 @llvm.is.fpclass.f32(float %i3, i32 0)\n  %i6 = select i1 %i5, float 0.000000e+00, float 0.000000e+00\n  store float %i6, ptr %i4, align 4\n  %i7 = add i64 %i, 1\n  %i8 = icmp eq i64 %i7, 128\n  br i1 %i8, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i1 @llvm.is.fpclass.f32(float, i32 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/optimal-epilog-vectorization.ll",
      "commands": [
        "opt -passes='loop-vectorize' -force-vector-width=4 -enable-epilogue-vectorization -epilogue-vectorization-force-VF=4 -S %s",
        "opt -passes='loop-vectorize' -enable-epilogue-vectorization -epilogue-vectorization-force-VF=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "multiple_ivs_wide",
          "test_body": "target datalayout = \"e-m:e-i64:64-n32:64-v128:128:128\"\n\ndefine void @multiple_ivs_wide(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.2 = phi i32 [ -64, %entry ], [ %iv.2.next, %loop ]\n  %iv.next = add i32 %iv, 2\n  %iv.2.next = add i32 %iv.2, 2\n  %gep = getelementptr inbounds i32, ptr %dst, i32 %iv\n  store i32 %iv.2.next, ptr %gep, align 4\n  %ec = icmp eq i32 %iv.next, 128\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/runtime-checks-hoist.ll",
      "commands": [
        "opt < %s -passes='loop-vectorize' -force-vector-interleave=1 -S -force-vector-width=4 -debug-only=loop-accesses,loop-vectorize,loop-utils"
      ],
      "tests": [
        {
          "test_name": "stride_check_known_via_loop_guard",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @stride_check_known_via_loop_guard(ptr %C, ptr %A, i32 %Acols) {\nentry:\n  %pre.c = icmp ugt i32 %Acols, 0\n  br i1 %pre.c, label %exit, label %outer.header\n\nouter.header:                                     ; preds = %outer.latch, %entry\n  %outer.iv = phi i32 [ 0, %entry ], [ %outer.iv.next, %outer.latch ]\n  %mul.us = mul i32 %outer.iv, %Acols\n  %arrayidx.us = getelementptr double, ptr %A, i32 %mul.us\n  br label %inner\n\ninner:                                            ; preds = %inner, %outer.header\n  %inner.iv = phi i32 [ 0, %outer.header ], [ %inner.iv.next, %inner ]\n  %gep.C = getelementptr inbounds double, ptr %C, i32 %inner.iv\n  %l = load double, ptr %arrayidx.us, align 8\n  store double %l, ptr %gep.C, align 8\n  %inner.iv.next = add i32 %inner.iv, 1\n  %inner.c = icmp eq i32 %inner.iv.next, 1000\n  br i1 %inner.c, label %outer.latch, label %inner\n\nouter.latch:                                      ; preds = %inner\n  %outer.iv.next = add i32 %outer.iv, 1\n  %outer.c = icmp ult i32 %outer.iv, 128\n  br i1 %outer.c, label %exit, label %outer.header\n\nexit:                                             ; preds = %outer.latch, %entry\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/scev-predicate-reasoning.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -lv-strided-pointer-ivs=true -S %s"
      ],
      "tests": [
        {
          "test_name": "step_direction_unknown",
          "test_body": "define void @step_direction_unknown(i32 %arg, ptr %dst) {\nentry:\n  %add = add i32 %arg, 1\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %phi = phi i64 [ 0, %entry ], [ %add2, %loop ]\n  %trunc = trunc i64 %phi to i32\n  %mul = mul i32 %add, %trunc\n  %zext = zext i32 %mul to i64\n  %getelementptr = getelementptr double, ptr %dst, i64 %zext\n  store double 0.000000e+00, ptr %getelementptr, align 8\n  %add2 = add i64 %phi, 1\n  %icmp = icmp eq i64 %add2, 1024\n  br i1 %icmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "integer_induction_wraps_scev_predicate_known",
          "test_body": "define void @integer_induction_wraps_scev_predicate_known(i32 %x, ptr %call, ptr %start) {\nentry:\n  %mul = shl i32 %x, 1\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.cond, %entry\n  %iv = phi i32 [ 30, %entry ], [ %inc, %for.cond ]\n  %p.0 = phi ptr [ %start, %entry ], [ %add.ptr, %for.cond ]\n  %add.ptr = getelementptr i8, ptr %p.0, i32 %mul\n  %arrayidx = getelementptr ptr, ptr %call, i32 %iv\n  store ptr %p.0, ptr %arrayidx, align 4\n  %inc = add i32 %iv, 1\n  %tobool.not = icmp eq i32 %iv, 1024\n  br i1 %tobool.not, label %for.end, label %for.cond\n\nfor.end:                                          ; preds = %for.cond\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/vplan-sink-scalars-and-merge-vf1.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-interleave=2 -force-vector-width=1 -debug -disable-output %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "sink_with_sideeffects",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\ndefine void @sink_with_sideeffects(i1 %c, ptr %ptr) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %tmp0 = phi i64 [ %tmp6, %for.inc ], [ 0, %entry ]\n  %tmp1 = phi i64 [ %tmp7, %for.inc ], [ 1024, %entry ]\n  %tmp2 = getelementptr i8, ptr %ptr, i64 %tmp0\n  %tmp3 = load i8, ptr %tmp2, align 1\n  store i8 0, ptr %tmp2, align 1\n  %tmp4 = zext i8 %tmp3 to i32\n  %tmp5 = trunc i32 %tmp4 to i8\n  br i1 %c, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  store i8 %tmp5, ptr %tmp2, align 1\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %tmp6 = add nuw nsw i64 %tmp0, 1\n  %tmp7 = add i64 %tmp1, -1\n  %tmp8 = icmp eq i64 %tmp7, 0\n  br i1 %tmp8, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.inc\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorizer]  Assertion `EPResumeVal && \"must have a resume value for the canonical IV\"' failed.",
    "body": "clang -Wno-incompatible-pointer-types -O3 -march=z13 -S -c crash19.i -o a.out -w -mllvm -disable-licm-promotion -mllvm -epilogue-vectorization-force-VF=2 \n\n[crash19.tar.gz](https://github.com/user-attachments/files/18383534/crash19.tar.gz)\n\n#9 0x000002aa3ff5e440 preparePlanForEpilogueVectorLoop\n#12 0x000002aa3ffa098a llvm::LoopVectorizePass::run\n\n@bmahjour \n@fhahn ",
    "author": "JonPsson1",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "@JonPsson1 Was the test case fuzzer generated? Just curious, because it had a loop with unsigned max as iteration count."
      },
      {
        "author": "JonPsson1",
        "body": "> [@JonPsson1](https://github.com/JonPsson1) Was the test case fuzzer generated? Just curious, because it had a loop with unsigned max as iteration count.\n\nNo, it was a CSmith test case."
      },
      {
        "author": "fhahn",
        "body": "@JonPsson1 Could you check if it fixes the full reproducer? If not, it would be great if you could share the full reproducer?"
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}