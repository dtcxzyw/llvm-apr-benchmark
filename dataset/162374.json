{
  "bug_id": "162374",
  "issue_url": "https://github.com/llvm/llvm-project/issues/162374",
  "bug_type": "crash",
  "base_commit": "ab71b7793a0480f820c62c0bbc69e6c8e7434c2a",
  "knowledge_cutoff": "2025-10-07T21:25:00Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "4bf5ab4f9d483c6cefbbd8d04774cea5571dce45",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h": [
        [
          322,
          328
        ]
      ],
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          8774,
          8786
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          1026,
          1031
        ],
        [
          1041,
          1058
        ],
        [
          1098,
          1104
        ],
        [
          2206,
          2225
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h": [
        "createScalarIVSteps",
        "createWidenCast"
      ],
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationPlanner::adjustRecipesForReductions"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::truncateToMinimalBitwidths",
        "simplifyRecipe"
      ]
    }
  },
  "patch": "commit 4bf5ab4f9d483c6cefbbd8d04774cea5571dce45\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Sun Oct 12 14:00:22 2025 +0100\n\n    [VPlan] Set flags when constructing truncs using VPWidenCastRecipe.\n    \n    VPWidenCastRecipes with Trunc opcodes where missing the correct OpType\n    for IR flags. Update createWidenCast to set the correct flags for\n    truncs, and use it consistenly.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/162374.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h b/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h\nindex 456fa4c85853..7651ba16b35c 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h\n@@ -322,7 +322,11 @@ public:\n \n   VPWidenCastRecipe *createWidenCast(Instruction::CastOps Opcode, VPValue *Op,\n                                      Type *ResultTy) {\n-    return tryInsertInstruction(new VPWidenCastRecipe(Opcode, Op, ResultTy));\n+    VPIRFlags Flags;\n+    if (Opcode == Instruction::Trunc)\n+      Flags = VPIRFlags::TruncFlagsTy(false, false);\n+    return tryInsertInstruction(\n+        new VPWidenCastRecipe(Opcode, Op, ResultTy, Flags));\n   }\n \n   VPScalarIVStepsRecipe *\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 50136a8ecae5..b96d29e63546 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -8774,13 +8774,19 @@ void LoopVectorizationPlanner::adjustRecipesForReductions(\n       assert(!RecurrenceDescriptor::isMinMaxRecurrenceKind(RecurrenceKind) &&\n              \"Unexpected truncated min-max recurrence!\");\n       Type *RdxTy = RdxDesc.getRecurrenceType();\n-      auto *Trunc =\n-          new VPWidenCastRecipe(Instruction::Trunc, NewExitingVPV, RdxTy);\n+      VPWidenCastRecipe *Trunc;\n       Instruction::CastOps ExtendOpc =\n           RdxDesc.isSigned() ? Instruction::SExt : Instruction::ZExt;\n-      auto *Extnd = new VPWidenCastRecipe(ExtendOpc, Trunc, PhiTy);\n-      Trunc->insertAfter(NewExitingVPV->getDefiningRecipe());\n-      Extnd->insertAfter(Trunc);\n+      VPWidenCastRecipe *Extnd;\n+      {\n+        VPBuilder::InsertPointGuard Guard(Builder);\n+        Builder.setInsertPoint(\n+            NewExitingVPV->getDefiningRecipe()->getParent(),\n+            std::next(NewExitingVPV->getDefiningRecipe()->getIterator()));\n+        Trunc =\n+            Builder.createWidenCast(Instruction::Trunc, NewExitingVPV, RdxTy);\n+        Extnd = Builder.createWidenCast(ExtendOpc, Trunc, PhiTy);\n+      }\n       if (PhiR->getOperand(1) == NewExitingVPV)\n         PhiR->setOperand(1, Extnd->getVPSingleValue());\n \ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex 7563cd719b19..9bb88205009c 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -1026,6 +1026,7 @@ static void simplifyRecipe(VPRecipeBase &R, VPTypeAnalysis &TypeInfo) {\n       PredPHI->replaceAllUsesWith(Op);\n   }\n \n+  VPBuilder Builder(Def);\n   VPValue *A;\n   if (match(Def, m_Trunc(m_ZExtOrSExt(m_VPValue(A))))) {\n     Type *TruncTy = TypeInfo.inferScalarType(Def);\n@@ -1041,18 +1042,16 @@ static void simplifyRecipe(VPRecipeBase &R, VPTypeAnalysis &TypeInfo) {\n         unsigned ExtOpcode = match(R.getOperand(0), m_SExt(m_VPValue()))\n                                  ? Instruction::SExt\n                                  : Instruction::ZExt;\n-        auto *VPC =\n-            new VPWidenCastRecipe(Instruction::CastOps(ExtOpcode), A, TruncTy);\n+        auto *Ext = Builder.createWidenCast(Instruction::CastOps(ExtOpcode), A,\n+                                            TruncTy);\n         if (auto *UnderlyingExt = R.getOperand(0)->getUnderlyingValue()) {\n           // UnderlyingExt has distinct return type, used to retain legacy cost.\n-          VPC->setUnderlyingValue(UnderlyingExt);\n+          Ext->setUnderlyingValue(UnderlyingExt);\n         }\n-        VPC->insertBefore(&R);\n-        Def->replaceAllUsesWith(VPC);\n+        Def->replaceAllUsesWith(Ext);\n       } else if (ATy->getScalarSizeInBits() > TruncTy->getScalarSizeInBits()) {\n-        auto *VPC = new VPWidenCastRecipe(Instruction::Trunc, A, TruncTy);\n-        VPC->insertBefore(&R);\n-        Def->replaceAllUsesWith(VPC);\n+        auto *Trunc = Builder.createWidenCast(Instruction::Trunc, A, TruncTy);\n+        Def->replaceAllUsesWith(Trunc);\n       }\n     }\n #ifndef NDEBUG\n@@ -1098,7 +1097,6 @@ static void simplifyRecipe(VPRecipeBase &R, VPTypeAnalysis &TypeInfo) {\n     return Def->replaceAllUsesWith(Def->getOperand(1));\n \n   // (x && y) || (x && z) -> x && (y || z)\n-  VPBuilder Builder(Def);\n   if (match(Def, m_c_BinaryOr(m_LogicalAnd(m_VPValue(X), m_VPValue(Y)),\n                               m_LogicalAnd(m_Deferred(X), m_VPValue(Z)))) &&\n       // Simplify only if one of the operands has one use to avoid creating an\n@@ -2206,20 +2204,20 @@ void VPlanTransforms::truncateToMinimalBitwidths(\n           continue;\n         assert(OpSizeInBits > NewResSizeInBits && \"nothing to truncate\");\n         auto [ProcessedIter, IterIsEmpty] = ProcessedTruncs.try_emplace(Op);\n-        VPWidenCastRecipe *NewOp =\n-            IterIsEmpty\n-                ? new VPWidenCastRecipe(Instruction::Trunc, Op, NewResTy,\n-                                        VPIRFlags::TruncFlagsTy(false, false))\n-                : ProcessedIter->second;\n-        R.setOperand(Idx, NewOp);\n-        if (!IterIsEmpty)\n+        if (!IterIsEmpty) {\n+          R.setOperand(Idx, ProcessedIter->second);\n           continue;\n-        ProcessedIter->second = NewOp;\n-        if (!Op->isLiveIn()) {\n-          NewOp->insertBefore(&R);\n-        } else {\n-          PH->appendRecipe(NewOp);\n         }\n+\n+        VPBuilder Builder;\n+        if (Op->isLiveIn())\n+          Builder.setInsertPoint(PH);\n+        else\n+          Builder.setInsertPoint(&R);\n+        VPWidenCastRecipe *NewOp =\n+            Builder.createWidenCast(Instruction::Trunc, Op, NewResTy);\n+        ProcessedIter->second = NewOp;\n+        R.setOperand(Idx, NewOp);\n       }\n \n     }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/truncate-to-minimal-bitwidth-evl-crash.ll",
      "commands": [
        "opt -passes=loop-vectorize -prefer-predicate-over-epilogue=predicate-else-scalar-epilogue -mtriple=riscv64 -mattr=+v -S %s"
      ],
      "tests": [
        {
          "test_name": "truncate_i16_to_i8_cse",
          "test_body": "define void @truncate_i16_to_i8_cse(ptr noalias %src, ptr noalias %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %count = phi i32 [ 0, %entry ], [ %count.next, %loop ]\n  %val = load i16, ptr %src, align 2\n  %val.zext = zext i16 %val to i64\n  %val.trunc.zext = trunc i64 %val.zext to i8\n  store i8 %val.trunc.zext, ptr null, align 1\n  %val.trunc = trunc i16 %val to i8\n  store i8 %val.trunc, ptr %dst, align 1\n  %count.next = add i32 %count, 1\n  %exitcond = icmp eq i32 %count.next, 0\n  %iv.next = add i64 %iv, 1\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize] Assertion `OpType == Other.OpType && \"OpType must match\"' failed.",
    "body": "Testcase:\n```llvm ir\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @init(ptr %arrayidx2.i, ptr %arrayidx13.i) #0 {\nentry:\n  br label %for.body.i\n\nfor.body.i:                                       ; preds = %for.body.i, %entry\n  %indvars.iv.i1 = phi i64 [ 0, %entry ], [ %indvars.iv.next.i, %for.body.i ]\n  %n.023.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]\n  %0 = load i16, ptr %arrayidx2.i, align 2\n  %conv3.i = zext i16 %0 to i64\n  %conv4.i = trunc i64 %conv3.i to i8\n  store i8 %conv4.i, ptr null, align 1\n  %conv11.i = trunc i16 %0 to i8\n  store i8 %conv11.i, ptr %arrayidx13.i, align 1\n  %inc.i = add i32 %n.023.i, 1\n  %tobool.not.i = icmp eq i32 %inc.i, 0\n  %indvars.iv.next.i = add i64 %indvars.iv.i1, 1\n  br i1 %tobool.not.i, label %c.exit.loopexit, label %for.body.i\n\nc.exit.loopexit:                                  ; preds = %for.body.i\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+v\" }\n```\n\nCommands/backtrace:\n```\n$ /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt --passes=loop-vectorize reduced.ll\nWARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\nopt: /scratch/ewlu/daily-upstream-build/llvm/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:404: void llvm::VPIRFlags::intersectFlags(const llvm::VPIRFlags&): Assertion `OpType == Other.OpType && \"OpType must match\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.      Program arguments: /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt --passes=loop-vectorize reduced.ll\n1.      Running pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"reduced.ll\"\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"init\"\n #0 0x00005c399f7f0072 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x342a072)\n #1 0x00005c399f7ecd6f llvm::sys::RunSignalHandlers() (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x3426d6f)\n #2 0x00005c399f7ecebc SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007e76d1245330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x00007e76d129eb2c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\n #5 0x00007e76d129eb2c __pthread_kill_internal ./nptl/pthread_kill.c:78:10\n #6 0x00007e76d129eb2c pthread_kill ./nptl/pthread_kill.c:89:10\n #7 0x00007e76d124527e raise ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007e76d12288ff abort ./stdlib/abort.c:81:7\n #9 0x00007e76d122881b _nl_load_domain ./intl/loadmsgcat.c:1177:9\n#10 0x00007e76d123b517 (/lib/x86_64-linux-gnu/libc.so.6+0x3b517)\n#11 0x00005c399d5a1cbc (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11dbcbc)\n#12 0x00005c399d5f4f66 llvm::VPlanTransforms::cse(llvm::VPlan&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x122ef66)\n#13 0x00005c399d3d02ef llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoopVectorizer&, llvm::DominatorTree*, bool) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x100a2ef)\n#14 0x00005c399d3edb79 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x1027b79)\n#15 0x00005c399d3f00e1 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x102a0e1)\n#16 0x00005c399d3f06f6 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x102a6f6)\n#17 0x00005c399cc79fd5 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x8b3fd5)\n#18 0x00005c399f5c5cf5 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x31ffcf5)\n#19 0x00005c399cc7c805 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x8b6805)\n#20 0x00005c399f5c43f1 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x31fe3f1)\n#21 0x00005c399c905fb5 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x53ffb5)\n#22 0x00005c399f5c4bdd llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x31febdd)\n#23 0x00005c399c911eeb llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x54beeb)\n#24 0x00005c399c90418d optMain (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x53e18d)\n#25 0x00007e76d122a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#26 0x00007e76d122a28b call_init ./csu/../csu/libc-start.c:128:20\n#27 0x00007e76d122a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#28 0x00005c399c8fa0b5 _start (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x5340b5)\nAborted\n```\n\nGodbolt: https://godbolt.org/z/ns6hTYcbK\n\nFound via fuzzer (C program before reduction).",
    "author": "ewlu",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  },
  "verified": true,
  "bisect": "c3e76b27709f93c9e945caa29dae596b581289e2"
}