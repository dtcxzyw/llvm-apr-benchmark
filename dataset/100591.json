{
  "bug_id": "100591",
  "issue_url": "https://github.com/llvm/llvm-project/issues/100591",
  "bug_type": "crash",
  "base_commit": "71801707e33c235656b172fa7dfb8662473a95c2",
  "knowledge_cutoff": "2024-07-25T16:31:43Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "e9e3a183d6d8d8729223b7131aa57fd9f02f0440",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          6730,
          6738
        ],
        [
          6765,
          6770
        ],
        [
          6789,
          6796
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::collectValuesToIgnore"
      ]
    }
  },
  "patch": "commit e9e3a183d6d8d8729223b7131aa57fd9f02f0440\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Sun Aug 18 12:51:17 2024 +0100\n\n    [LV] Don't cost branches and conditions to empty blocks.\n    \n    Update the legacy cost model skip branches with successors blocks\n    that are empty or only contain dead instructions, together with their\n    conditions. Such branches and conditions won't result in any\n    generated code and will be cleaned up by VPlan transforms.\n    \n    This fixes a difference between the legacy and VPlan-based cost model.\n    \n    When running LV in its usual pipeline position, such dead blocks should\n    already have been cleaned up, but they might be generated manually or by\n    fuzzers.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/100591.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 27e99694aafd..55c0ba3dd8f9 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -6730,9 +6730,12 @@ void LoopVectorizationCostModel::collectValuesToIgnore() {\n     return RequiresScalarEpilogue &&\n            !TheLoop->contains(cast<Instruction>(U)->getParent());\n   };\n+\n+  LoopBlocksDFS DFS(TheLoop);\n+  DFS.perform(LI);\n   MapVector<Value *, SmallVector<Value *>> DeadInvariantStoreOps;\n-  for (BasicBlock *BB : TheLoop->blocks())\n-    for (Instruction &I : *BB) {\n+  for (BasicBlock *BB : reverse(make_range(DFS.beginRPO(), DFS.endRPO())))\n+    for (Instruction &I : reverse(*BB)) {\n       // Find all stores to invariant variables. Since they are going to sink\n       // outside the loop we do not need calculate cost for them.\n       StoreInst *SI;\n@@ -6765,6 +6768,13 @@ void LoopVectorizationCostModel::collectValuesToIgnore() {\n         Value *PointerOp = getLoadStorePointerOperand(&I);\n         DeadInterleavePointerOps.push_back(PointerOp);\n       }\n+\n+      // Queue branches for analysis. They are dead, if their successors only\n+      // contain dead instructions.\n+      if (auto *Br = dyn_cast<BranchInst>(&I)) {\n+        if (Br->isConditional())\n+          DeadOps.push_back(&I);\n+      }\n     }\n \n   // Mark ops feeding interleave group members as free, if they are only used\n@@ -6789,8 +6799,36 @@ void LoopVectorizationCostModel::collectValuesToIgnore() {\n   // Mark ops that would be trivially dead and are only used by ignored\n   // instructions as free.\n   BasicBlock *Header = TheLoop->getHeader();\n+\n+  // Returns true if the block contains only dead instructions. Such blocks will\n+  // be removed by VPlan-to-VPlan transforms and won't be considered by the\n+  // VPlan-based cost model, so skip them in the legacy cost-model as well.\n+  auto IsEmptyBlock = [this](BasicBlock *BB) {\n+    return all_of(*BB, [this](Instruction &I) {\n+      return ValuesToIgnore.contains(&I) || VecValuesToIgnore.contains(&I) ||\n+             (isa<BranchInst>(&I) && !cast<BranchInst>(&I)->isConditional());\n+    });\n+  };\n   for (unsigned I = 0; I != DeadOps.size(); ++I) {\n     auto *Op = dyn_cast<Instruction>(DeadOps[I]);\n+\n+    // Check if the branch should be considered dead.\n+    if (auto *Br = dyn_cast_or_null<BranchInst>(Op)) {\n+      BasicBlock *ThenBB = Br->getSuccessor(0);\n+      BasicBlock *ElseBB = Br->getSuccessor(1);\n+      bool ThenEmpty = IsEmptyBlock(ThenBB);\n+      bool ElseEmpty = IsEmptyBlock(ElseBB);\n+      if ((ThenEmpty && ElseEmpty) ||\n+          (ThenEmpty && ThenBB->getSingleSuccessor() == ElseBB &&\n+           ElseBB->phis().empty()) ||\n+          (ElseEmpty && ElseBB->getSingleSuccessor() == ThenBB &&\n+           ThenBB->phis().empty())) {\n+        VecValuesToIgnore.insert(Br);\n+        DeadOps.push_back(Br->getCondition());\n+      }\n+      continue;\n+    }\n+\n     // Skip any op that shouldn't be considered dead.\n     if (!Op || !TheLoop->contains(Op) ||\n         (isa<PHINode>(Op) && Op->getParent() == Header) ||\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/blocks-with-dead-instructions.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "block_with_dead_inst_1",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @block_with_dead_inst_1(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  %dead.gep = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %0 = icmp eq i64 %iv.next, %N\n  br i1 %0, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "multiple_blocks_with_dead_insts_4",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_insts_4(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  br label %then.1\n\nthen.1:                                           ; preds = %then\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %then.1\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "empty_block_with_phi_1",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @empty_block_with_phi_1(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i32 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i32 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %p = phi i16 [ %l, %loop.header ], [ 99, %then ]\n  store i16 %p, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 1\n  %0 = icmp eq i64 %iv.next, %N\n  br i1 %0, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "multiple_blocks_with_dead_insts_3",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_insts_3(ptr %src) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 0, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %then\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "multiple_blocks_with_dead_inst_multiple_successors_5",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_inst_multiple_successors_5(ptr %src) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  br label %then.1\n\nthen.1:                                           ; preds = %then\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %loop.header\n  br label %else.2\n\nelse.2:                                           ; preds = %else\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else.2, %then.1\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "multiple_blocks_with_dead_inst_multiple_successors_6",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @multiple_blocks_with_dead_inst_multiple_successors_6(ptr %src, i1 %ic, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %then, label %else\n\nthen:                                             ; preds = %loop.header\n  br i1 %ic, label %then.1, label %else\n\nthen.1:                                           ; preds = %then\n  %dead.gep.1 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nelse:                                             ; preds = %then, %loop.header\n  br label %else.2\n\nelse.2:                                           ; preds = %else\n  %dead.gep.2 = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else.2, %then.1\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, %N\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "empty_block_with_phi_2",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @empty_block_with_phi_2(ptr %src, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i32 [ 1, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i32 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %loop.latch, label %else\n\nelse:                                             ; preds = %loop.header\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %loop.header\n  %p = phi i16 [ %l, %loop.header ], [ 99, %else ]\n  store i16 %p, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 1\n  %0 = icmp eq i64 %iv.next, %N\n  br i1 %0, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "block_with_dead_inst_2",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @block_with_dead_inst_2(ptr %src) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %xor1315 = phi i16 [ 0, %entry ], [ %xor, %loop.latch ]\n  %xor = xor i16 0, 0\n  %gep = getelementptr i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep, align 2\n  %c = icmp eq i16 %l, 0\n  br i1 %c, label %loop.latch, label %else\n\nelse:                                             ; preds = %loop.header\n  %dead.gep = getelementptr i64, ptr %src, i64 %iv\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %loop.header\n  store i16 %xor, ptr %gep, align 2\n  %iv.next = add nsw i64 %iv, 3\n  %ec = icmp eq i64 %iv.next, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[VPlan] Assertion `VF.Width == Width && \"VPlan cost model and legacy cost model disagreed\"' failed.",
    "body": "Tested using 51d4980a133db12888207698e39c469cb7055cac\r\n\r\nTestcase:\r\n```llvm ir\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine void @f() #0 {\r\nentry:\r\n  br label %for.body\r\n\r\nfor.cond.cleanup:                                 ; preds = %cond.end7\r\n  ret void\r\n\r\nfor.body:                                         ; preds = %cond.end7, %entry\r\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %cond.end7 ]\r\n  %xor1315 = phi i32 [ 0, %entry ], [ %xor, %cond.end7 ]\r\n  %xor = xor i32 0, 0\r\n  %arrayidx = getelementptr [1 x i16], ptr null, i64 0, i64 %indvars.iv\r\n  %0 = load i16, ptr %arrayidx, align 2\r\n  %tobool1.not = icmp eq i16 %0, 0\r\n  br i1 %tobool1.not, label %cond.false, label %cond.end7\r\n\r\ncond.false:                                       ; preds = %for.body\r\n  %arrayidx3 = getelementptr [1 x i64], ptr null, i64 0, i64 %indvars.iv\r\n  br label %cond.end7\r\n\r\ncond.end7:                                        ; preds = %cond.false, %for.body\r\n  %indvars.iv.next = add nsw i64 %indvars.iv, 3\r\n  %1 = icmp eq i64 %indvars.iv.next, 0\r\n  br i1 %1, label %for.cond.cleanup, label %for.body\r\n}\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+a,+c,+d,+f,+m,+relax,+v,+zicsr,+zifencei,+zmmul,+zve32f,+zve32x,+zve64d,+zve64f,+zve64x,+zvl128b,+zvl32b,+zvl64b,-b,-e,-experimental-smmpm,-experimental-smnpm,-experimental-ssnpm,-experimental-sspm,-experimental-ssqosid,-experimental-supm,-experimental-zacas,-experimental-zalasr,-experimental-zicfilp,-experimental-zicfiss,-h,-shcounterenw,-shgatpa,-shtvala,-shvsatpa,-shvstvala,-shvstvecd,-smaia,-smcdeleg,-smcsrind,-smepmp,-smstateen,-ssaia,-ssccfg,-ssccptr,-sscofpmf,-sscounterenw,-sscsrind,-ssstateen,-ssstrict,-sstc,-sstvala,-sstvecd,-ssu64xl,-svade,-svadu,-svbare,-svinval,-svnapot,-svpbmt,-xcvalu,-xcvbi,-xcvbitmanip,-xcvelw,-xcvmac,-xcvmem,-xcvsimd,-xsfcease,-xsfvcp,-xsfvfnrclipxfqf,-xsfvfwmaccqqq,-xsfvqmaccdod,-xsfvqmaccqoq,-xsifivecdiscarddlone,-xsifivecflushdlone,-xtheadba,-xtheadbb,-xtheadbs,-xtheadcmo,-xtheadcondmov,-xtheadfmemidx,-xtheadmac,-xtheadmemidx,-xtheadmempair,-xtheadsync,-xtheadvdot,-xventanacondops,-xwchc,-za128rs,-za64rs,-zaamo,-zabha,-zalrsc,-zama16b,-zawrs,-zba,-zbb,-zbc,-zbkb,-zbkc,-zbkx,-zbs,-zca,-zcb,-zcd,-zce,-zcf,-zcmop,-zcmp,-zcmt,-zdinx,-zfa,-zfbfmin,-zfh,-zfhmin,-zfinx,-zhinx,-zhinxmin,-zic64b,-zicbom,-zicbop,-zicboz,-ziccamoa,-ziccif,-zicclsm,-ziccrse,-zicntr,-zicond,-zihintntl,-zihintpause,-zihpm,-zimop,-zk,-zkn,-zknd,-zkne,-zknh,-zkr,-zks,-zksed,-zksh,-zkt,-ztso,-zvbb,-zvbc,-zvfbfmin,-zvfbfwma,-zvfh,-zvfhmin,-zvkb,-zvkg,-zvkn,-zvknc,-zvkned,-zvkng,-zvknha,-zvknhb,-zvks,-zvksc,-zvksed,-zvksg,-zvksh,-zvkt,-zvl1024b,-zvl16384b,-zvl2048b,-zvl256b,-zvl32768b,-zvl4096b,-zvl512b,-zvl65536b,-zvl8192b\" }\r\n```\r\n\r\nBacktrace:\r\n```\r\n> /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes loop-vectorize reduced.ll -S\r\nopt: /scratch/tc-testing/tc-compiler-fuzz-trunk/llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10123: bool llvm::LoopVectorizePass::processLoop(llvm::Loop*): Assertion `VF.Width == Width && \"VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes loop-vectorize reduced.ll -S\r\n1.      Running pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"reduced.ll\"\r\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"f\"\r\n #0 0x00005e0a0dd8f3b0 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2f1f3b0)\r\n #1 0x00005e0a0dd8c7cf llvm::sys::RunSignalHandlers() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2f1c7cf)\r\n #2 0x00005e0a0dd8c925 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x000073a243a42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x000073a243a969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x000073a243a969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x000073a243a969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x000073a243a42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x000073a243a287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x000073a243a2871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x000073a243a39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x00005e0a0cdaadd8 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1f3add8)\r\n#12 0x00005e0a0cdad991 llvm::LoopVectorizePass::runImpl(llvm::Function&, llvm::ScalarEvolution&, llvm::LoopInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::BlockFrequencyInfo*, llvm::TargetLibraryInfo*, llvm::DemandedBits&, llvm::AssumptionCache&, llvm::LoopAccessInfoManager&, llvm::OptimizationRemarkEmitter&, llvm::ProfileSummaryInfo*) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1f3d991)\r\n#13 0x00005e0a0cdae110 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1f3e110)\r\n#14 0x00005e0a0bc1fda6 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xdafda6)\r\n#15 0x00005e0a0dba750e llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2d3750e)\r\n#16 0x00005e0a0bc22f36 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xdb2f36)\r\n#17 0x00005e0a0dba629b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2d3629b)\r\n#18 0x00005e0a0bc1f286 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xdaf286)\r\n#19 0x00005e0a0dba43ed llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2d343ed)\r\n#20 0x00005e0a0b4686b6 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x5f86b6)\r\n#21 0x00005e0a0b45a2f1 optMain (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x5ea2f1)\r\n#22 0x000073a243a29d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#23 0x000073a243a29e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#24 0x000073a243a29e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#25 0x00005e0a0b450185 _start (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x5e0185)\r\nzsh: IOT instruction (core dumped)  /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt\r\n```\r\n\r\nGodbolt: https://godbolt.org/z/TnYreKbqn\r\n\r\n@fhahn \r\n\r\nFound via fuzzer.",
    "author": "patrick-rivos",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "Another case with dead instructions that get simplified by VPlan-DCE :/"
      },
      {
        "author": "patrick-rivos",
        "body": "Just to add a bit of context here: I'm hitting this assertion >300 times a day so I've allowlisted it in the fuzzer I run. There are likely other interesting cases where this assertion triggers but I don't have the bandwidth to deduplicate this failure to pull out those cases. :-("
      },
      {
        "author": "preames",
        "body": "> Just to add a bit of context here: I'm hitting this assertion >300 times a day so I've allowlisted it in the fuzzer I run. There are likely other interesting cases where this assertion triggers but I don't have the bandwidth to deduplicate this failure to pull out those cases. :-(\r\n\r\n@fhahn This assertion is triggering in a large number of fuzzer runs, and we have some reason to believe there are other failures be masked by this one.  (We have at least one instance of this found so far by accident.)  This needs to be either fixed or reverted so that tree is green.  "
      },
      {
        "author": "fhahn",
        "body": "Will look into a fix now that I'm back. The crash should not reproduce with `opt -passes='instcombine,simplifycfg,loop-vectorize'` for all instances of the same underlying issue."
      },
      {
        "author": "nikic",
        "body": "@fhahn I feel like at this point this assertion is doing a lot more harm than good. It's very fragile, and doesn't seem to help in finding any genuine bugs, just incidental differences in simplification power."
      },
      {
        "author": "artagnon",
        "body": "I was also looking into this bug briefly, but couldn't quite figure out why we didn't choose to rip out the legacy costing."
      },
      {
        "author": "sjoerdmeijer",
        "body": "If e9e3a183d6d8d8729223b7131aa57fd9f02f0440 was supposed to fix this, then I can confirm I am still seeing this assert. \r\n\r\nIf this is indeed something else or new, then I agree with @nikic that this assert is too fragile."
      },
      {
        "author": "fhahn",
        "body": "The assertion originally surfaced real differences that needed fixing; the fuzzer-generated issues over the last weeks mostly were due to unsimplified input, which is very difficult to completely match without actually iteratively simplifying. Seeing the recent https://github.com/llvm/llvm-project/issues/104714 with a C reproducer it was a bit surprising that dead loads (and subsequent dead blocks/conditions) survive until LoopVectorize in the default pipeline.\r\n\r\nThere will be a number of code changes over the next few weeks/months which may introduce unintended divergences the assert is supposed to catch. For that reason it would be beneficial to keep the assert.\r\n\r\nIdeally we would only check if no extra simplifications have been applied on the selected VPlan, which should be possible to check once #103033 lands.\r\n\r\nWe could also guard it with an option, similar to InstCombine's fix point iteration assertion, which can also trigger asserts by default on valid IR input.\r\n\r\n> If [e9e3a18](https://github.com/llvm/llvm-project/commit/e9e3a183d6d8d8729223b7131aa57fd9f02f0440) was supposed to fix this, then I can confirm I am still seeing this assert.\r\n> \r\n\r\nCould you share the reproducer somewhere? Would be good to check if this is due to the simplification issue mentioned above or a genuine divergence"
      },
      {
        "author": "sjoerdmeijer",
        "body": "> Could you share the reproducer somewhere? Would be good to check if this is due to the simplification issue mentioned above or a genuine divergence\r\n\r\nThis runs in the same assert with `opt -S -passes=loop-vectorize`: \r\n\r\n```\r\ntarget datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\r\ntarget triple = \"aarch64-unknown-linux-gnu\"\r\n\r\ndefine void @foo() #0 {\r\nentry:\r\n  br label %for.body315.us.us\r\n\r\nfor.body315.us.us:                                ; preds = %cond.end388.us.us, %entry\r\n  %indvars.iv10421 = phi i64 [ %indvars.iv.next1043, %cond.end388.us.us ], [ 0, %entry ]\r\n  br i1 false, label %cond.end388.us.us, label %cond.true380.us.us\r\n\r\ncond.true380.us.us:                               ; preds = %for.body315.us.us\r\n  %0 = load i32, ptr null, align 4\r\n  br label %cond.end388.us.us\r\n\r\ncond.end388.us.us:                                ; preds = %cond.true380.us.us, %for.body315.us.us\r\n  %indvars.iv.next1043 = add i64 %indvars.iv10421, 1\r\n  %cmp313.us.us = icmp slt i64 %indvars.iv10421, 1\r\n  br i1 %cmp313.us.us, label %for.body315.us.us, label %for.cond311.for.cond.cleanup314_crit_edge.loopexit, !llvm.loop !0\r\n\r\nfor.cond311.for.cond.cleanup314_crit_edge.loopexit: ; preds = %cond.end388.us.us\r\n  ret void\r\n}\r\n\r\nattributes #0 = { \"target-cpu\"=\"neoverse-v2\" }\r\n\r\n!0 = distinct !{!0, !1, !2, !3}\r\n!1 = !{!\"llvm.loop.mustprogress\"}\r\n!2 = !{!\"llvm.loop.vectorize.predicate.enable\", i1 true}\r\n!3 = !{!\"llvm.loop.vectorize.enable\", i1 true}\r\n```"
      }
    ]
  }
}
