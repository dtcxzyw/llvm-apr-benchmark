{
  "bug_id": "106909",
  "issue_url": "https://github.com/llvm/llvm-project/issues/106909",
  "bug_type": "miscompilation",
  "base_commit": "803ab280901588bdb92c52f8ea241caaa3926d8f",
  "knowledge_cutoff": "2024-09-01T13:21:47Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "6e68fa921bb7bf5ceb0b5036bb7d71399d5c7906",
    "components": [
      "SLPVectorizer"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          6584,
          6589
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "TreeEntry",
        "isAltShuffle",
        "BoUpSLP::getScalarsVectorizationState"
      ]
    }
  },
  "patch": "commit 6e68fa921bb7bf5ceb0b5036bb7d71399d5c7906\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Sun Sep 1 07:10:09 2024 -0700\n\n    [SLP]Fix PR106909: add a check for unsafe FP operations.\n    \n    NEON has non-IEEE compliant denormal flushing and the compiler should\n    check if it safe to vectorize instructions for NEON in non-fast math\n    mode.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/106909\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 993fd6ab1b0b..58137cd6f543 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -6584,6 +6584,13 @@ BoUpSLP::TreeEntry::EntryState BoUpSLP::getScalarsVectorizationState(\n     OrdersType &CurrentOrder, SmallVectorImpl<Value *> &PointerOps) const {\n   assert(S.MainOp && \"Expected instructions with same/alternate opcodes only.\");\n \n+  if (S.MainOp->getType()->isFloatingPointTy() &&\n+      TTI->isFPVectorizationPotentiallyUnsafe() && any_of(VL, [](Value *V) {\n+        auto *I = dyn_cast<Instruction>(V);\n+        return I && (I->isBinaryOp() || isa<CallInst>(I)) && !I->isFast();\n+      }))\n+    return TreeEntry::NeedToGather;\n+\n   unsigned ShuffleOrOp =\n       S.isAltShuffle() ? (unsigned)Instruction::ShuffleVector : S.getOpcode();\n   auto *VL0 = cast<Instruction>(S.OpValue);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/ARM/invalid-fp-operations.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=arm-- -mattr=+neon < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define void @test(ptr %a, ptr %b, ptr %r) {\n  %v.a.0 = load float, ptr %a, align 4\n  %a.1 = getelementptr i8, ptr %a, i64 4\n  %v.a.1 = load float, ptr %a.1, align 4\n  %a.2 = getelementptr i8, ptr %a, i64 8\n  %v.a.2 = load float, ptr %a.2, align 4\n  %a.3 = getelementptr i8, ptr %a, i64 12\n  %v.a.3 = load float, ptr %a.3, align 4\n  %v.b.0 = load float, ptr %b, align 4\n  %b.1 = getelementptr i8, ptr %b, i64 4\n  %v.b.1 = load float, ptr %b.1, align 4\n  %b.2 = getelementptr i8, ptr %b, i64 8\n  %v.b.2 = load float, ptr %b.2, align 4\n  %b.3 = getelementptr i8, ptr %b, i64 12\n  %v.b.3 = load float, ptr %b.3, align 4\n  %v.r.0 = fadd float %v.a.0, %v.b.0\n  %v.r.1 = fadd float %v.a.1, %v.b.1\n  %v.r.2 = fadd float %v.a.2, %v.b.2\n  %v.r.3 = fadd float %v.a.3, %v.b.3\n  store float %v.r.0, ptr %r, align 4\n  %r.1 = getelementptr i8, ptr %r, i64 4\n  store float %v.r.1, ptr %r.1, align 4\n  %r.2 = getelementptr i8, ptr %r, i64 8\n  store float %v.r.2, ptr %r.2, align 4\n  %r.3 = getelementptr i8, ptr %r, i64 12\n  store float %v.r.3, ptr %r.3, align 4\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "SLPVectorizer does not respect isFPVectorizationPotentiallyUnsafe()",
    "body": "SLPVectorizer currently incorrectly vectorizes FP instructions using ARM NEON (https://llvm.godbolt.org/z/c9866Yv13), which has non-IEEE compliant denormal flushing (https://github.com/llvm/llvm-project/issues/16648).\r\n\r\nThere is a isFPVectorizationPotentiallyUnsafe() TTI hook for this, which is checked by LoopVectorize, but not SLPVectorizer.\r\n\r\n(Technically at fault here is the ARM backend for using NEON instructions for vector floating point ops, but LLVM currently handles this by preventing their implicit formation.)",
    "author": "nikic",
    "labels": [
      "miscompilation",
      "llvm:SLPVectorizer"
    ],
    "comments": [
      {
        "author": "alexey-bataev",
        "body": "I cannot find where LoopVectorizer uses isFPVectorizationPotentiallyUnsafe. Could you point exact line of code? Searching through the LLVM code base provides only declarations of the function, but I cannot find a single reference"
      },
      {
        "author": "nikic",
        "body": "Sure, the call is here: https://github.com/llvm/llvm-project/blob/84ed3c29e8583bdd704d0e2f7e7c3d1162c6181c/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L9878\r\n\r\nSee also the related code in https://github.com/llvm/llvm-project/blob/84ed3c29e8583bdd704d0e2f7e7c3d1162c6181c/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp#L1001-L1004"
      }
    ]
  }
}