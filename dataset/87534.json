{
  "bug_id": "87534",
  "issue_url": "https://github.com/llvm/llvm-project/issues/87534",
  "bug_type": "miscompilation",
  "base_commit": "c1d00510ab5e7f5052efb1e678173e3a97302e61",
  "knowledge_cutoff": "2024-04-03T18:08:14Z",
  "lit_test_dir": [
    "llvm/test/Transforms/Inline"
  ],
  "hints": {
    "fix_commit": "a61f9fe31750cee65c726fb51f1b14e31e177258",
    "components": [
      "CloneFunction"
    ],
    "files": [
      "llvm/lib/Transforms/Utils/CloneFunction.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/CloneFunction.cpp": [
        [
          14,
          19
        ],
        [
          540,
          557
        ],
        [
          823,
          874
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/CloneFunction.cpp": [
        "PruningFunctionCloner::CloneBlock",
        "llvm::CloneAndPruneIntoFromInst"
      ]
    }
  },
  "patch": "commit a61f9fe31750cee65c726fb51f1b14e31e177258\nAuthor: Antonio Frighetto <me@antoniofrighetto.com>\nDate:   Mon Apr 8 08:57:38 2024 +0200\n\n    [Inline][Cloning] Defer simplification after phi-nodes resolution\n    \n    A logic issue arose when inlining via `CloneAndPruneFunctionInto`,\n    which, besides cloning, performs instruction simplification as well.\n    By the time a new cloned instruction is being simplified, phi-nodes\n    are not remapped yet as the whole CFG needs to be processed first.\n    As `VMap` state at this stage is incomplete, `threadCmpOverPHI` and\n    variants could lead to unsound optimizations. This issue has been\n    addressed by performing basic constant folding while cloning, and\n    postponing instruction simplification once phi-nodes are revisited.\n    \n    Fixes: https://github.com/llvm/llvm-project/issues/87534.\n\ndiff --git a/llvm/lib/Transforms/Utils/CloneFunction.cpp b/llvm/lib/Transforms/Utils/CloneFunction.cpp\nindex 3eac726994ae..42e648484416 100644\n--- a/llvm/lib/Transforms/Utils/CloneFunction.cpp\n+++ b/llvm/lib/Transforms/Utils/CloneFunction.cpp\n@@ -14,6 +14,7 @@\n \n #include \"llvm/ADT/SetVector.h\"\n #include \"llvm/ADT/SmallVector.h\"\n+#include \"llvm/Analysis/ConstantFolding.h\"\n #include \"llvm/Analysis/DomTreeUpdater.h\"\n #include \"llvm/Analysis/InstructionSimplify.h\"\n #include \"llvm/Analysis/LoopInfo.h\"\n@@ -540,18 +541,13 @@ void PruningFunctionCloner::CloneBlock(\n       RemapInstruction(NewInst, VMap,\n                        ModuleLevelChanges ? RF_None : RF_NoModuleLevelChanges);\n \n-      // If we can simplify this instruction to some other value, simply add\n-      // a mapping to that value rather than inserting a new instruction into\n-      // the basic block.\n-      if (Value *V =\n-              simplifyInstruction(NewInst, BB->getModule()->getDataLayout())) {\n-        // On the off-chance that this simplifies to an instruction in the old\n-        // function, map it back into the new function.\n-        if (NewFunc != OldFunc)\n-          if (Value *MappedV = VMap.lookup(V))\n-            V = MappedV;\n-\n-        if (!NewInst->mayHaveSideEffects()) {\n+      // Eagerly constant fold the newly cloned instruction. If successful, add\n+      // a mapping to the new value. Non-constant operands may be incomplete at\n+      // this stage, thus instruction simplification is performed after\n+      // processing phi-nodes.\n+      if (Value *V = ConstantFoldInstruction(\n+              NewInst, BB->getModule()->getDataLayout())) {\n+        if (isInstructionTriviallyDead(NewInst)) {\n           VMap[&*II] = V;\n           NewInst->eraseFromParent();\n           continue;\n@@ -823,52 +819,34 @@ void llvm::CloneAndPruneIntoFromInst(Function *NewFunc, const Function *OldFunc,\n     }\n   }\n \n-  // Make a second pass over the PHINodes now that all of them have been\n-  // remapped into the new function, simplifying the PHINode and performing any\n-  // recursive simplifications exposed. This will transparently update the\n-  // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce\n-  // two PHINodes, the iteration over the old PHIs remains valid, and the\n-  // mapping will just map us to the new node (which may not even be a PHI\n-  // node).\n+  // As phi-nodes have been now remapped, allow incremental simplification of\n+  // newly-cloned instructions.\n   const DataLayout &DL = NewFunc->getParent()->getDataLayout();\n-  SmallSetVector<const Value *, 8> Worklist;\n-  for (unsigned Idx = 0, Size = PHIToResolve.size(); Idx != Size; ++Idx)\n-    if (isa<PHINode>(VMap[PHIToResolve[Idx]]))\n-      Worklist.insert(PHIToResolve[Idx]);\n-\n-  // Note that we must test the size on each iteration, the worklist can grow.\n-  for (unsigned Idx = 0; Idx != Worklist.size(); ++Idx) {\n-    const Value *OrigV = Worklist[Idx];\n-    auto *I = dyn_cast_or_null<Instruction>(VMap.lookup(OrigV));\n-    if (!I)\n-      continue;\n-\n-    // Skip over non-intrinsic callsites, we don't want to remove any nodes from\n-    // the CGSCC.\n-    CallBase *CB = dyn_cast<CallBase>(I);\n-    if (CB && CB->getCalledFunction() &&\n-        !CB->getCalledFunction()->isIntrinsic())\n-      continue;\n-\n-    // See if this instruction simplifies.\n-    Value *SimpleV = simplifyInstruction(I, DL);\n-    if (!SimpleV)\n-      continue;\n-\n-    // Stash away all the uses of the old instruction so we can check them for\n-    // recursive simplifications after a RAUW. This is cheaper than checking all\n-    // uses of To on the recursive step in most cases.\n-    for (const User *U : OrigV->users())\n-      Worklist.insert(cast<Instruction>(U));\n-\n-    // Replace the instruction with its simplified value.\n-    I->replaceAllUsesWith(SimpleV);\n-\n-    // If the original instruction had no side effects, remove it.\n-    if (isInstructionTriviallyDead(I))\n-      I->eraseFromParent();\n-    else\n-      VMap[OrigV] = I;\n+  for (const auto &BB : *OldFunc) {\n+    for (const auto &I : BB) {\n+      auto *NewI = dyn_cast_or_null<Instruction>(VMap.lookup(&I));\n+      if (!NewI)\n+        continue;\n+\n+      // Skip over non-intrinsic callsites, we don't want to remove any nodes\n+      // from the CGSCC.\n+      CallBase *CB = dyn_cast<CallBase>(NewI);\n+      if (CB && CB->getCalledFunction() &&\n+          !CB->getCalledFunction()->isIntrinsic())\n+        continue;\n+\n+      if (Value *V = simplifyInstruction(NewI, DL)) {\n+        NewI->replaceAllUsesWith(V);\n+\n+        if (isInstructionTriviallyDead(NewI)) {\n+          NewI->eraseFromParent();\n+        } else {\n+          // Did not erase it? Restore the new instruction into VMap previously\n+          // dropped by `ValueIsRAUWd`.\n+          VMap[&I] = NewI;\n+        }\n+      }\n+    }\n   }\n \n   // Remap debug intrinsic operands now that all values have been mapped.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/Inline/inline-deferred-instsimplify.ll",
      "commands": [
        "opt < %s -passes=inline -S",
        "opt < %s -passes='cgscc(inline)' -S"
      ],
      "tests": [
        {
          "test_name": "main",
          "test_body": "%struct.a = type { i32, i32, i32, i32, i32 }\n\n@g_var = external global %struct.a, align 8\n\ndeclare void @callee(ptr noundef byval(%struct.a) align 8)\n\ndefine i32 @main() {\n  call void @callee(ptr noundef byval(%struct.a) align 8 @g_var)\n  ret i32 0\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/Inline/prof-update-sample-alwaysinline.ll",
      "commands": [
        "opt < %s -passes=always-inline -S"
      ],
      "tests": [
        {
          "test_name": "caller",
          "test_body": "; Function Attrs: alwaysinline\ndeclare void @callee(i32) #0\n\ndefine void @caller() {\n  call void @callee(i32 15), !prof !14\n  ret void\n}\n\nattributes #0 = { alwaysinline }\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 1, !\"ProfileSummary\", !1}\n!1 = !{!2, !3, !4, !5, !6, !7, !8, !9}\n!2 = !{!\"ProfileFormat\", !\"SampleProfile\"}\n!3 = !{!\"TotalCount\", i64 10000}\n!4 = !{!\"MaxCount\", i64 10}\n!5 = !{!\"MaxInternalCount\", i64 1}\n!6 = !{!\"MaxFunctionCount\", i64 2000}\n!7 = !{!\"NumCounts\", i64 2}\n!8 = !{!\"NumFunctions\", i64 2}\n!9 = !{!\"DetailedSummary\", !10}\n!10 = !{!11, !12, !13}\n!11 = !{i32 10000, i64 100, i32 1}\n!12 = !{i32 999000, i64 100, i32 1}\n!13 = !{i32 999999, i64 1, i32 2}\n!14 = !{!\"branch_weights\", i32 400}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/Inline/prof-update-sample.ll",
      "commands": [
        "opt < %s -passes='require<profile-summary>,cgscc(inline)' -S"
      ],
      "tests": [
        {
          "test_name": "caller",
          "test_body": "declare void @callee(i32)\n\ndefine void @caller() {\n  call void @callee(i32 15), !prof !14\n  ret void\n}\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 1, !\"ProfileSummary\", !1}\n!1 = !{!2, !3, !4, !5, !6, !7, !8, !9}\n!2 = !{!\"ProfileFormat\", !\"SampleProfile\"}\n!3 = !{!\"TotalCount\", i64 10000}\n!4 = !{!\"MaxCount\", i64 10}\n!5 = !{!\"MaxInternalCount\", i64 1}\n!6 = !{!\"MaxFunctionCount\", i64 2000}\n!7 = !{!\"NumCounts\", i64 2}\n!8 = !{!\"NumFunctions\", i64 2}\n!9 = !{!\"DetailedSummary\", !10}\n!10 = !{!11, !12, !13}\n!11 = !{i32 10000, i64 100, i32 1}\n!12 = !{i32 999000, i64 100, i32 1}\n!13 = !{i32 999999, i64 1, i32 2}\n!14 = !{!\"branch_weights\", i32 400}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "wrong code at -O1 on x86_64-linux-gnu",
    "body": "It appears to be a regression from 14.0.0, and affects 15.* and later. \r\n\r\nCompiler Explorer: https://godbolt.org/z/57cnEr81r\r\n\r\n```\r\n[546] % clangtk -v\r\nclang version 19.0.0git (https://github.com/llvm/llvm-project.git 07a566793b2f94d0de6b95b7e6d1146b0d7ffe49)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /local/suz-local/software/local/clang-trunk/bin\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/10\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/9\r\nSelected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11\r\nCandidate multilib: .;@m64\r\nSelected multilib: .;@m64\r\n[547] % \r\n[547] % clangtk -O1 small.c\r\n[548] % ./a.out\r\nAborted\r\n[549] % cat small.c\r\nstruct a {\r\n  int b;\r\n  int c;\r\n  int d;\r\n  int e;\r\n  int f;\r\n} g, h = {1,0,0,0,0}, *i;\r\nvoid j(struct a k) {\r\n  struct a *l = &g;\r\n  if (k.b)\r\n    l = i = &k;\r\n  if (l != &k)\r\n    __builtin_abort();\r\n}\r\nint main() {\r\n  j(h);\r\n  return 0;\r\n}\r\n```",
    "author": "zhendongsu",
    "labels": [
      "miscompilation",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "antoniofrighetto",
        "body": "Looks like a wrong optimization performed by InstSimplify while attempting to inline `j` into `main` \ud83e\udd14"
      },
      {
        "author": "dtcxzyw",
        "body": "Reduced test case: https://godbolt.org/z/racWKbrbr\r\n```\r\n%struct.a = type { i32, i32 }\r\n\r\n@h = dso_local global %struct.a { i32 1, i32 0 }, align 8\r\n\r\ndefine i1 @callee(ptr byval(%struct.a) align 8 %k) {\r\n  %cmp = icmp eq ptr @h, %k\r\n  ret i1 %cmp\r\n}\r\n\r\ndefine i1 @caller() {\r\n  %ret = call i1 @callee(ptr byval(%struct.a) align 8 @h)\r\n  ret i1 %ret\r\n}\r\n```\r\n\r\nI am not sure if it is an UB. cc @shafik @frederick-vs-ja \r\n"
      },
      {
        "author": "antoniofrighetto",
        "body": "I believe that accessing the pointer (`i`) when the object it points to gets out of scope is UB, which doesn't happen in the original snippet. I think there may be still a logic bug while instructions get simplified during inlining. This is how the basic blocks are laid out during `CloneBlock`:\r\n```llvm\r\n1:                                                ; No predecessors!\r\n  %2 = load i32, ptr %h, align 8\r\n  %.not.i = icmp eq i32 %2, 0\r\n  br i1 %.not, label %4, label %3\r\n\r\n3:                                                ; No predecessors!\r\n  store ptr %h, ptr @i, align 8\r\n  br label %4\r\n\r\n4:                                                ; No predecessors!\r\n  %.0.i = phi ptr [ %0, %3 ], [ @g, %1 ]\r\n  %5 = icmp eq ptr %.0.i, %h\r\n  br i1 %.not1, label %6, label %5\r\n  ```\r\n`%0` has been remapped to `%h` everywhere but in the phi-node, as per:\r\nhttps://github.com/llvm/llvm-project/blob/ffd08c7759000f55332f1657a1fab64a7adc03fd/llvm/lib/Transforms/Utils/CloneFunction.cpp#L536-L541\r\n\r\nThe idiosyncrasy stems from the fact that `%5 = icmp eq ptr %.0.i, %h` is (correctly) simplified to `i1 false`, except that it shouldn't since `%0` was not remapped in the PN."
      },
      {
        "author": "jdoerfert",
        "body": "@antoniofrighetto described the problem already.\r\n\r\nFunnily, 7 years ago this popped up for the first time:\r\nhttps://github.com/llvm/llvm-project/commit/9282f1aecef7b2190c2430e190342558958f4f8f\r\n\r\nBasically, we reason about / simplify instructions based on partially state data.\r\nThis cannot work.\r\nThe commit above was just a stop gap as it identified some situations when it went wrong (namely we ended up with a simplified instructions from another function).\r\nFollowing the same logic, you could prevent the folder to come up with constants, but then it's questionable why we have it in the first place.\r\n\r\nAlternatives include:\r\n1) Remove the simplification, doing it at this stage, with half-broken IR, is simply not a good idea.\r\n2) Move the simplification later, after the control flow and PHIs have been remapped.\r\n3) Somehow make SimplifyInst stop at/before PHI nodes.\r\n\r\nI would measure the impact of 1) first, that seems the cleanest solution.\r\nYou can prototype 3) fairly easily, but it's a whack-a-mole situation waiting to happen again (IMHO).\r\n2) Is reasonable and maybe not as intrusive after all, haven't looked at it in much detail.\r\n\r\n"
      }
    ]
  }
}