{
  "bug_id": "119665",
  "issue_url": "https://github.com/llvm/llvm-project/issues/119665",
  "bug_type": "crash",
  "base_commit": "7ae78a6cdb6ce9ad1534ed10519649fb3d47aca9",
  "knowledge_cutoff": "2024-12-12T07:13:14Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "3706dfef660097f24fb5efbac0d7f14b424492ed",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          2937,
          2946
        ],
        [
          2950,
          2955
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "InnerLoopVectorizer::fixVectorizedLoop"
      ]
    }
  },
  "patch": "commit 3706dfef660097f24fb5efbac0d7f14b424492ed\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Mon Feb 10 16:29:42 2025 +0000\n\n    [LV] Forget LCSSA phi with new pred before other SCEV invalidation. (#119897)\n    \n    `forgetLcssaPhiWithNewPredecessor` performs additional invalidation if\n    there is an existing SCEV for the phi, but earlier\n    `forgetBlockAndLoopDispositions` or `forgetLoop` may already invalidate\n    the SCEV for the phi.\n    \n    Change the order to first call `forgetLcssaPhiWithNewPredecessor` to\n    ensure it runs before its SCEV gets invalidated too eagerly.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/119665.\n    \n    PR: https://github.com/llvm/llvm-project/pull/119897\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 610e4904a80a..f2241be60ce0 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -2937,10 +2937,6 @@ void InnerLoopVectorizer::fixVectorizedLoop(VPTransformState &State) {\n   if (EnableVPlanNativePath)\n     fixNonInductionPHIs(State);\n \n-  // Forget the original basic block.\n-  PSE.getSE()->forgetLoop(OrigLoop);\n-  PSE.getSE()->forgetBlockAndLoopDispositions();\n-\n   // After vectorization, the exit blocks of the original loop will have\n   // additional predecessors. Invalidate SCEVs for the exit phis in case SE\n   // looked through single-entry phis.\n@@ -2950,6 +2946,10 @@ void InnerLoopVectorizer::fixVectorizedLoop(VPTransformState &State) {\n     for (PHINode &PN : Exit->phis())\n       PSE.getSE()->forgetLcssaPhiWithNewPredecessor(OrigLoop, &PN);\n \n+  // Forget the original basic block.\n+  PSE.getSE()->forgetLoop(OrigLoop);\n+  PSE.getSE()->forgetBlockAndLoopDispositions();\n+\n   // Don't apply optimizations below when no vector region remains, as they all\n   // require a vector loop at the moment.\n   if (!State.Plan->getVectorLoopRegion())\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/invalidate-scev-at-scope-after-vectorization.ll",
      "commands": [
        "opt -passes='print<scalar-evolution>,loop-vectorize' -force-vector-width=4 -scalar-evolution-classify-expressions=false -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n; Test case for https://github.com/llvm/llvm-project/issues/119665.\n\n; %loop.2's backedge-taken-count depends on %add.1 from %loop.1 via its\n; corresponding SCEV at the scope of %loop.2. After vectorizing %loop.1, %add.1\n; isn't available at the entry of %loop.2 anymore and %add.1 at %loop.2's scope\n; must be invalidated, as well as %loop.2's backedge-taken count.\ndefine void @test_invalidate_scevs_at_scope(ptr %p) {\n;\nentry:\n  br label %loop.1\n\nloop.1:\n  %iv.1 = phi i32 [ 0, %entry ], [ %iv.1.next, %loop.1 ]\n  %1 = load i32, ptr %p, align 4\n  %add.1 = add i32 %1, %iv.1\n  %iv.1.next = add i32 %iv.1, 1\n  %c.1 = icmp eq i32 %iv.1, 100\n  br i1 %c.1, label %exit.1, label %loop.1\n\nexit.1:\n  %add.lcssa = phi i32 [ %add.1, %loop.1 ]\n  br label %loop.2\n\nloop.2:\n  %iv.2 = phi i64 [ 0, %exit.1 ], [ %iv.2.next, %loop.2 ]\n  %iv.2.trunc = trunc i64 %iv.2 to i32\n  %iv.2.next = add i64 %iv.2, 1\n  %gep = getelementptr inbounds i64, ptr %p, i64 %iv.2\n  store i64 %iv.2, ptr %gep\n  %add.2 = add i32 %add.lcssa, %iv.2.trunc\n  %c.2 = icmp slt i32 %add.2, 100\n  br i1 %c.2, label %loop.2, label %exit.2\n\nexit.2:\n  ret void\n}\n\n;.\n;."
        }
      ]
    }
  ],
  "issue": {
    "title": "[clang] Crash at -O2: Assertion `isAvailableAtLoopEntry(LHS, L) && \"LHS is not available at Loop Entry\"' failed.",
    "body": "This code crashes at `-O2`: \n```c\nint a, e;\nint *b;\nshort c[];\nshort d;\nvoid f() {\n  int g;\n  for (;;)\n    for (; a - 3 + g < 6; g = g + 1)\n      c[g] = d;\n}\nvoid h();\nvoid i() {\n  h();\n  f();\n}\nvoid h() {\n  e = 0;\n  for (; e <= 50; ++e) {\n    int *j = &a;\n    *j = *b + e;\n  }\n}\n```\n\nCompiler Explorer: https://godbolt.org/z/jfo65eK9x\n\nCrash:\n```console\nclang: /root/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11744: bool llvm::ScalarEvolution::isLoopEntryGuardedByCond(const llvm::Loop*, llvm::CmpInst::Predicate, const llvm::SCEV*, const llvm::SCEV*): Assertion `isAvailableAtLoopEntry(LHS, L) && \"LHS is not available at Loop Entry\"' failed.\n```\nBacktrace:\n```console\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/clang -gdwarf-4 -g -o /app/output.s -mllvm --x86-asm-syntax=intel -fno-verbose-asm -S --gcc-toolchain=/opt/compiler-explorer/gcc-snapshot -fcolor-diagnostics -fno-crash-diagnostics -O2 -Wall -Wextra -fno-strict-aliasing <source>\n1.\t<eof> parser at end of file\n2.\tOptimizer\n3.\tRunning pass \"function<eager-inv>(float2int,lower-constant-intrinsics,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O2>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"<source>\"\n4.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"i\"\n #0 0x0000000003c19758 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3c19758)\n #1 0x0000000003c17464 llvm::sys::CleanupOnSignal(unsigned long) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3c17464)\n #2 0x0000000003b649c8 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0\n #3 0x000079aa17242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #4 0x000079aa172969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #5 0x000079aa17242476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #6 0x000079aa172287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #7 0x000079aa1722871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #8 0x000079aa17239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #9 0x0000000002c90a7b llvm::ScalarEvolution::isLoopEntryGuardedByCond(llvm::Loop const*, llvm::CmpInst::Predicate, llvm::SCEV const*, llvm::SCEV const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2c90a7b)\n#10 0x0000000002ca6d97 llvm::ScalarEvolution::getTripCountFromExitCount(llvm::SCEV const*, llvm::Type*, llvm::Loop const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x2ca6d97)\n#11 0x00000000058449e4 llvm::VPlan::createInitialVPlan(llvm::Type*, llvm::PredicatedScalarEvolution&, bool, bool, llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x58449e4)\n#12 0x000000000572a8ce llvm::LoopVectorizationPlanner::tryToBuildVPlanWithVPRecipes(llvm::VFRange&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x572a8ce)\n#13 0x000000000572dd5a llvm::LoopVectorizationPlanner::buildVPlansWithVPRecipes(llvm::ElementCount, llvm::ElementCount) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x572dd5a)\n#14 0x000000000572e24f llvm::LoopVectorizationPlanner::plan(llvm::ElementCount, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x572e24f)\n#15 0x000000000573044f llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x573044f)\n#16 0x0000000005732a89 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x5732a89)\n#17 0x00000000057330c3 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x57330c3)\n#18 0x0000000005283abe llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x5283abe)\n#19 0x00000000035c8550 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x35c8550)\n#20 0x00000000010fa0ee llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x10fa0ee)\n#21 0x00000000035c6e6b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x35c6e6b)\n#22 0x00000000010f977e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x10f977e)\n#23 0x00000000035c6870 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x35c6870)\n#24 0x0000000003eca382 (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&, clang::BackendConsumer*) BackendUtil.cpp:0:0\n#25 0x0000000003ecdbfd clang::EmitBackendOutput(clang::DiagnosticsEngine&, clang::HeaderSearchOptions const&, clang::CodeGenOptions const&, clang::TargetOptions const&, clang::LangOptions const&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>, clang::BackendConsumer*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3ecdbfd)\n#26 0x000000000459e07e clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x459e07e)\n#27 0x000000000655704c clang::ParseAST(clang::Sema&, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x655704c)\n#28 0x000000000459e458 clang::CodeGenAction::ExecuteAction() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x459e458)\n#29 0x0000000004856fc9 clang::FrontendAction::Execute() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x4856fc9)\n#30 0x00000000047d989e clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x47d989e)\n#31 0x000000000494267e clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x494267e)\n#32 0x0000000000cb92df cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xcb92df)\n#33 0x0000000000cb0d7a ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\n#34 0x00000000045e2229 void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()>(long) Job.cpp:0:0\n#35 0x0000000003b64e74 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x3b64e74)\n#36 0x00000000045e281f clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const (.part.0) Job.cpp:0:0\n#37 0x00000000045a7f3d clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x45a7f3d)\n#38 0x00000000045a902d clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x45a902d)\n#39 0x00000000045b0565 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0x45b0565)\n#40 0x0000000000cb6123 clang_main(int, char**, llvm::ToolContext const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xcb6123)\n#41 0x0000000000b84564 main (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xb84564)\n#42 0x000079aa17229d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#43 0x000079aa17229e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#44 0x0000000000cb0825 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+0xcb0825)\n```\n",
    "author": "cardigan1008",
    "labels": [
      "release:backport",
      "vectorizers",
      "crash",
      "regression:18"
    ],
    "comments": [
      {
        "author": "shafik",
        "body": "Looks like a clang-18 regression: https://godbolt.org/z/K7MMKxjzb"
      },
      {
        "author": "dtcxzyw",
        "body": "Reduced reproducer: https://godbolt.org/z/s4G9Yb1vG\n```\n; bin/opt -passes=\"print<scalar-evolution>,loop-vectorize\" test.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @i(ptr %p) {\nentry:\n  br label %for.body.i\n\nfor.body.i:                                       ; preds = %for.body.i, %entry\n  %0 = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]\n  %1 = load i32, ptr %p, align 4\n  %add.i = add i32 %1, %0\n  %inc.i = add i32 %0, 1\n  %exitcond.not.i = icmp eq i32 %0, 1\n  br i1 %exitcond.not.i, label %for.cond.i.preheader, label %for.body.i\n\nfor.cond.i.preheader:                             ; preds = %for.body.i\n  br label %for.cond.i\n\nfor.cond.i.loopexit:                              ; preds = %for.body.i1\n  br label %for.cond.i\n\nfor.cond.i:                                       ; preds = %for.cond.i.loopexit, %for.cond.i.preheader\n  br label %for.body.i1\n\nfor.body.i1:                                      ; preds = %for.body.i1, %for.cond.i\n  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i1 ], [ 0, %for.cond.i ]\n  %indvars4.i = trunc i64 %indvars.iv.i to i32\n  %indvars.iv.next.i = add i64 %indvars.iv.i, 1\n  %add.reass.i = add i32 %add.i, %indvars4.i\n  %cmp.i = icmp slt i32 %add.reass.i, 0\n  br i1 %cmp.i, label %for.body.i1, label %for.cond.i.loopexit\n}\n\n```"
      },
      {
        "author": "fhahn",
        "body": "Thanks, let me take a look"
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}