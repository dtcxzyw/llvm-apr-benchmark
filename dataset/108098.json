{
  "bug_id": "108098",
  "issue_url": "https://github.com/llvm/llvm-project/issues/108098",
  "bug_type": "crash",
  "base_commit": "b8239e1201f5871bed5b633b76fa9536672f287f",
  "knowledge_cutoff": "2024-09-10T21:48:37Z",
  "lit_test_dir": [
    "llvm/test/Analysis/CostModel",
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "ea83e1c05a5adee5d8f9e680356ee57556ba64a1",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          1182,
          1194
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "setWideningDecision"
      ]
    }
  },
  "patch": "commit ea83e1c05a5adee5d8f9e680356ee57556ba64a1\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Wed Sep 11 21:04:33 2024 +0100\n\n    [LV] Assign cost to all interleave members when not interleaving.\n    \n    At the moment, the full cost of all interleave group members is assigned\n    to the instruction at the group's insert position, even if the decision\n    was to not form an interleave group.\n    \n    This can lead to inaccurate cost estimates, e.g. if the instruction at\n    the insert position is dead. If the decision is to not vectorize but\n    scalarize or scather/gather, then the cost will be to total cost for all\n    members. In those cases, assign individual the cost per member, to more\n    closely reflect to choice per instruction.\n    \n    This fixes a divergence between legacy and VPlan-based cost model.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/108098.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 640a7bf3d672..3b6b154b9660 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -1182,13 +1182,23 @@ public:\n                            InstructionCost Cost) {\n     assert(VF.isVector() && \"Expected VF >=2\");\n     /// Broadcast this decicion to all instructions inside the group.\n-    /// But the cost will be assigned to one instruction only.\n+    /// When interleaving, the cost will only be assigned one instruction, the\n+    /// insert position. For other cases, add the appropriate fraction of the\n+    /// total cost to each instruction. This ensures accurate costs are used,\n+    /// even if the insert position instruction is not used.\n+    InstructionCost InsertPosCost = Cost;\n+    InstructionCost OtherMemberCost = 0;\n+    if (W != CM_Interleave)\n+      OtherMemberCost = InsertPosCost = Cost / Grp->getNumMembers();\n+    ;\n     for (unsigned Idx = 0; Idx < Grp->getFactor(); ++Idx) {\n       if (auto *I = Grp->getMember(Idx)) {\n         if (Grp->getInsertPos() == I)\n-          WideningDecisions[std::make_pair(I, VF)] = std::make_pair(W, Cost);\n+          WideningDecisions[std::make_pair(I, VF)] =\n+              std::make_pair(W, InsertPosCost);\n         else\n-          WideningDecisions[std::make_pair(I, VF)] = std::make_pair(W, 0);\n+          WideningDecisions[std::make_pair(I, VF)] =\n+              std::make_pair(W, OtherMemberCost);\n       }\n     }\n   }\n",
  "tests": [
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f32-stride-5.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x float], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %in0 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.4\n  %v0 = load float, ptr %in0, align 4\n  %v1 = load float, ptr %in1, align 4\n  %v2 = load float, ptr %in2, align 4\n  %v3 = load float, ptr %in3, align 4\n  %v4 = load float, ptr %in4, align 4\n  %reduce.add.0 = fadd float %v0, %v1\n  %reduce.add.1 = fadd float %reduce.add.0, %v2\n  %reduce.add.2 = fadd float %reduce.add.1, %v3\n  %reduce.add.3 = fadd float %reduce.add.2, %v4\n  %reduce.add.3.narrow = fptoui float %reduce.add.3 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.3.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 5\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f32-stride-7.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x float], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %in0 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.6\n  %v0 = load float, ptr %in0, align 4\n  %v1 = load float, ptr %in1, align 4\n  %v2 = load float, ptr %in2, align 4\n  %v3 = load float, ptr %in3, align 4\n  %v4 = load float, ptr %in4, align 4\n  %v5 = load float, ptr %in5, align 4\n  %v6 = load float, ptr %in6, align 4\n  %reduce.add.0 = fadd float %v0, %v1\n  %reduce.add.1 = fadd float %reduce.add.0, %v2\n  %reduce.add.2 = fadd float %reduce.add.1, %v3\n  %reduce.add.3 = fadd float %reduce.add.2, %v4\n  %reduce.add.4 = fadd float %reduce.add.3, %v5\n  %reduce.add.5 = fadd float %reduce.add.4, %v6\n  %reduce.add.5.narrow = fptoui float %reduce.add.5 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.5.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 7\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f32-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x float], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in0 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.6\n  %in7 = getelementptr inbounds [1024 x float], ptr @A, i64 0, i64 %iv.7\n  %v0 = load float, ptr %in0, align 4\n  %v1 = load float, ptr %in1, align 4\n  %v2 = load float, ptr %in2, align 4\n  %v3 = load float, ptr %in3, align 4\n  %v4 = load float, ptr %in4, align 4\n  %v5 = load float, ptr %in5, align 4\n  %v6 = load float, ptr %in6, align 4\n  %v7 = load float, ptr %in7, align 4\n  %reduce.add.0 = fadd float %v0, %v1\n  %reduce.add.1 = fadd float %reduce.add.0, %v2\n  %reduce.add.2 = fadd float %reduce.add.1, %v3\n  %reduce.add.3 = fadd float %reduce.add.2, %v4\n  %reduce.add.4 = fadd float %reduce.add.3, %v5\n  %reduce.add.5 = fadd float %reduce.add.4, %v6\n  %reduce.add.6 = fadd float %reduce.add.5, %v7\n  %reduce.add.6.narrow = fptoui float %reduce.add.6 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.6.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f64-stride-2.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x double], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %in0 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.1\n  %v0 = load double, ptr %in0, align 8\n  %v1 = load double, ptr %in1, align 8\n  %reduce.add.0 = fadd double %v0, %v1\n  %reduce.add.0.narrow = fptoui double %reduce.add.0 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.0.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 2\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f64-stride-3.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x double], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %in0 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.2\n  %v0 = load double, ptr %in0, align 8\n  %v1 = load double, ptr %in1, align 8\n  %v2 = load double, ptr %in2, align 8\n  %reduce.add.0 = fadd double %v0, %v1\n  %reduce.add.1 = fadd double %reduce.add.0, %v2\n  %reduce.add.1.narrow = fptoui double %reduce.add.1 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.1.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 3\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f64-stride-4.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x double], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %in0 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.3\n  %v0 = load double, ptr %in0, align 8\n  %v1 = load double, ptr %in1, align 8\n  %v2 = load double, ptr %in2, align 8\n  %v3 = load double, ptr %in3, align 8\n  %reduce.add.0 = fadd double %v0, %v1\n  %reduce.add.1 = fadd double %reduce.add.0, %v2\n  %reduce.add.2 = fadd double %reduce.add.1, %v3\n  %reduce.add.2.narrow = fptoui double %reduce.add.2 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.2.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 4\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f64-stride-5.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x double], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %in0 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.4\n  %v0 = load double, ptr %in0, align 8\n  %v1 = load double, ptr %in1, align 8\n  %v2 = load double, ptr %in2, align 8\n  %v3 = load double, ptr %in3, align 8\n  %v4 = load double, ptr %in4, align 8\n  %reduce.add.0 = fadd double %v0, %v1\n  %reduce.add.1 = fadd double %reduce.add.0, %v2\n  %reduce.add.2 = fadd double %reduce.add.1, %v3\n  %reduce.add.3 = fadd double %reduce.add.2, %v4\n  %reduce.add.3.narrow = fptoui double %reduce.add.3 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.3.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 5\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f64-stride-6.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x double], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %in0 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.5\n  %v0 = load double, ptr %in0, align 8\n  %v1 = load double, ptr %in1, align 8\n  %v2 = load double, ptr %in2, align 8\n  %v3 = load double, ptr %in3, align 8\n  %v4 = load double, ptr %in4, align 8\n  %v5 = load double, ptr %in5, align 8\n  %reduce.add.0 = fadd double %v0, %v1\n  %reduce.add.1 = fadd double %reduce.add.0, %v2\n  %reduce.add.2 = fadd double %reduce.add.1, %v3\n  %reduce.add.3 = fadd double %reduce.add.2, %v4\n  %reduce.add.4 = fadd double %reduce.add.3, %v5\n  %reduce.add.4.narrow = fptoui double %reduce.add.4 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.4.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 6\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f64-stride-7.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x double], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %in0 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.6\n  %v0 = load double, ptr %in0, align 8\n  %v1 = load double, ptr %in1, align 8\n  %v2 = load double, ptr %in2, align 8\n  %v3 = load double, ptr %in3, align 8\n  %v4 = load double, ptr %in4, align 8\n  %v5 = load double, ptr %in5, align 8\n  %v6 = load double, ptr %in6, align 8\n  %reduce.add.0 = fadd double %v0, %v1\n  %reduce.add.1 = fadd double %reduce.add.0, %v2\n  %reduce.add.2 = fadd double %reduce.add.1, %v3\n  %reduce.add.3 = fadd double %reduce.add.2, %v4\n  %reduce.add.4 = fadd double %reduce.add.3, %v5\n  %reduce.add.5 = fadd double %reduce.add.4, %v6\n  %reduce.add.5.narrow = fptoui double %reduce.add.5 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.5.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 7\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-f64-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x double], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in0 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.6\n  %in7 = getelementptr inbounds [1024 x double], ptr @A, i64 0, i64 %iv.7\n  %v0 = load double, ptr %in0, align 8\n  %v1 = load double, ptr %in1, align 8\n  %v2 = load double, ptr %in2, align 8\n  %v3 = load double, ptr %in3, align 8\n  %v4 = load double, ptr %in4, align 8\n  %v5 = load double, ptr %in5, align 8\n  %v6 = load double, ptr %in6, align 8\n  %v7 = load double, ptr %in7, align 8\n  %reduce.add.0 = fadd double %v0, %v1\n  %reduce.add.1 = fadd double %reduce.add.0, %v2\n  %reduce.add.2 = fadd double %reduce.add.1, %v3\n  %reduce.add.3 = fadd double %reduce.add.2, %v4\n  %reduce.add.4 = fadd double %reduce.add.3, %v5\n  %reduce.add.5 = fadd double %reduce.add.4, %v6\n  %reduce.add.6 = fadd double %reduce.add.5, %v7\n  %reduce.add.6.narrow = fptoui double %reduce.add.6 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.6.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i16-stride-5.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl,+avx512bw --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i16], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %in0 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.4\n  %v0 = load i16, ptr %in0, align 2\n  %v1 = load i16, ptr %in1, align 2\n  %v2 = load i16, ptr %in2, align 2\n  %v3 = load i16, ptr %in3, align 2\n  %v4 = load i16, ptr %in4, align 2\n  %reduce.add.0 = add i16 %v0, %v1\n  %reduce.add.1 = add i16 %reduce.add.0, %v2\n  %reduce.add.2 = add i16 %reduce.add.1, %v3\n  %reduce.add.3 = add i16 %reduce.add.2, %v4\n  %reduce.add.3.narrow = trunc i16 %reduce.add.3 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.3.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 5\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i16-stride-7.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl,+avx512bw --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i16], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %in0 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.6\n  %v0 = load i16, ptr %in0, align 2\n  %v1 = load i16, ptr %in1, align 2\n  %v2 = load i16, ptr %in2, align 2\n  %v3 = load i16, ptr %in3, align 2\n  %v4 = load i16, ptr %in4, align 2\n  %v5 = load i16, ptr %in5, align 2\n  %v6 = load i16, ptr %in6, align 2\n  %reduce.add.0 = add i16 %v0, %v1\n  %reduce.add.1 = add i16 %reduce.add.0, %v2\n  %reduce.add.2 = add i16 %reduce.add.1, %v3\n  %reduce.add.3 = add i16 %reduce.add.2, %v4\n  %reduce.add.4 = add i16 %reduce.add.3, %v5\n  %reduce.add.5 = add i16 %reduce.add.4, %v6\n  %reduce.add.5.narrow = trunc i16 %reduce.add.5 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.5.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 7\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i16-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl,+avx512bw --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i16], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in0 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.6\n  %in7 = getelementptr inbounds [1024 x i16], ptr @A, i64 0, i64 %iv.7\n  %v0 = load i16, ptr %in0, align 2\n  %v1 = load i16, ptr %in1, align 2\n  %v2 = load i16, ptr %in2, align 2\n  %v3 = load i16, ptr %in3, align 2\n  %v4 = load i16, ptr %in4, align 2\n  %v5 = load i16, ptr %in5, align 2\n  %v6 = load i16, ptr %in6, align 2\n  %v7 = load i16, ptr %in7, align 2\n  %reduce.add.0 = add i16 %v0, %v1\n  %reduce.add.1 = add i16 %reduce.add.0, %v2\n  %reduce.add.2 = add i16 %reduce.add.1, %v3\n  %reduce.add.3 = add i16 %reduce.add.2, %v4\n  %reduce.add.4 = add i16 %reduce.add.3, %v5\n  %reduce.add.5 = add i16 %reduce.add.4, %v6\n  %reduce.add.6 = add i16 %reduce.add.5, %v7\n  %reduce.add.6.narrow = trunc i16 %reduce.add.6 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.6.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i32-stride-4-indices-01uu.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i32], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %in0 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.1\n  %v0 = load i32, ptr %in0, align 4\n  %v1 = load i32, ptr %in1, align 4\n  %reduce.add.0 = add i32 %v0, %v1\n  %reduce.add.1 = add i32 %reduce.add.0, 0\n  %reduce.add.2 = add i32 %reduce.add.1, 0\n  %reduce.add.2.narrow = trunc i32 %reduce.add.2 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.2.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv, 4\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i32-stride-5.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i32], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %in0 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.4\n  %v0 = load i32, ptr %in0, align 4\n  %v1 = load i32, ptr %in1, align 4\n  %v2 = load i32, ptr %in2, align 4\n  %v3 = load i32, ptr %in3, align 4\n  %v4 = load i32, ptr %in4, align 4\n  %reduce.add.0 = add i32 %v0, %v1\n  %reduce.add.1 = add i32 %reduce.add.0, %v2\n  %reduce.add.2 = add i32 %reduce.add.1, %v3\n  %reduce.add.3 = add i32 %reduce.add.2, %v4\n  %reduce.add.3.narrow = trunc i32 %reduce.add.3 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.3.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 5\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i32-stride-7.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i32], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %in0 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.6\n  %v0 = load i32, ptr %in0, align 4\n  %v1 = load i32, ptr %in1, align 4\n  %v2 = load i32, ptr %in2, align 4\n  %v3 = load i32, ptr %in3, align 4\n  %v4 = load i32, ptr %in4, align 4\n  %v5 = load i32, ptr %in5, align 4\n  %v6 = load i32, ptr %in6, align 4\n  %reduce.add.0 = add i32 %v0, %v1\n  %reduce.add.1 = add i32 %reduce.add.0, %v2\n  %reduce.add.2 = add i32 %reduce.add.1, %v3\n  %reduce.add.3 = add i32 %reduce.add.2, %v4\n  %reduce.add.4 = add i32 %reduce.add.3, %v5\n  %reduce.add.5 = add i32 %reduce.add.4, %v6\n  %reduce.add.5.narrow = trunc i32 %reduce.add.5 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.5.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 7\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i32-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i32], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in0 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.6\n  %in7 = getelementptr inbounds [1024 x i32], ptr @A, i64 0, i64 %iv.7\n  %v0 = load i32, ptr %in0, align 4\n  %v1 = load i32, ptr %in1, align 4\n  %v2 = load i32, ptr %in2, align 4\n  %v3 = load i32, ptr %in3, align 4\n  %v4 = load i32, ptr %in4, align 4\n  %v5 = load i32, ptr %in5, align 4\n  %v6 = load i32, ptr %in6, align 4\n  %v7 = load i32, ptr %in7, align 4\n  %reduce.add.0 = add i32 %v0, %v1\n  %reduce.add.1 = add i32 %reduce.add.0, %v2\n  %reduce.add.2 = add i32 %reduce.add.1, %v3\n  %reduce.add.3 = add i32 %reduce.add.2, %v4\n  %reduce.add.4 = add i32 %reduce.add.3, %v5\n  %reduce.add.5 = add i32 %reduce.add.4, %v6\n  %reduce.add.6 = add i32 %reduce.add.5, %v7\n  %reduce.add.6.narrow = trunc i32 %reduce.add.6 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.6.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i64-stride-2.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i64], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %in0 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.1\n  %v0 = load i64, ptr %in0, align 8\n  %v1 = load i64, ptr %in1, align 8\n  %reduce.add.0 = add i64 %v0, %v1\n  %reduce.add.0.narrow = trunc i64 %reduce.add.0 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.0.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 2\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i64-stride-3.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i64], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %in0 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.2\n  %v0 = load i64, ptr %in0, align 8\n  %v1 = load i64, ptr %in1, align 8\n  %v2 = load i64, ptr %in2, align 8\n  %reduce.add.0 = add i64 %v0, %v1\n  %reduce.add.1 = add i64 %reduce.add.0, %v2\n  %reduce.add.1.narrow = trunc i64 %reduce.add.1 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.1.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 3\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i64-stride-4.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i64], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %in0 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.3\n  %v0 = load i64, ptr %in0, align 8\n  %v1 = load i64, ptr %in1, align 8\n  %v2 = load i64, ptr %in2, align 8\n  %v3 = load i64, ptr %in3, align 8\n  %reduce.add.0 = add i64 %v0, %v1\n  %reduce.add.1 = add i64 %reduce.add.0, %v2\n  %reduce.add.2 = add i64 %reduce.add.1, %v3\n  %reduce.add.2.narrow = trunc i64 %reduce.add.2 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.2.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 4\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i64-stride-5.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i64], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %in0 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.4\n  %v0 = load i64, ptr %in0, align 8\n  %v1 = load i64, ptr %in1, align 8\n  %v2 = load i64, ptr %in2, align 8\n  %v3 = load i64, ptr %in3, align 8\n  %v4 = load i64, ptr %in4, align 8\n  %reduce.add.0 = add i64 %v0, %v1\n  %reduce.add.1 = add i64 %reduce.add.0, %v2\n  %reduce.add.2 = add i64 %reduce.add.1, %v3\n  %reduce.add.3 = add i64 %reduce.add.2, %v4\n  %reduce.add.3.narrow = trunc i64 %reduce.add.3 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.3.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 5\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i64-stride-6.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i64], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %in0 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.5\n  %v0 = load i64, ptr %in0, align 8\n  %v1 = load i64, ptr %in1, align 8\n  %v2 = load i64, ptr %in2, align 8\n  %v3 = load i64, ptr %in3, align 8\n  %v4 = load i64, ptr %in4, align 8\n  %v5 = load i64, ptr %in5, align 8\n  %reduce.add.0 = add i64 %v0, %v1\n  %reduce.add.1 = add i64 %reduce.add.0, %v2\n  %reduce.add.2 = add i64 %reduce.add.1, %v3\n  %reduce.add.3 = add i64 %reduce.add.2, %v4\n  %reduce.add.4 = add i64 %reduce.add.3, %v5\n  %reduce.add.4.narrow = trunc i64 %reduce.add.4 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.4.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 6\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i64-stride-7.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i64], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %in0 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.6\n  %v0 = load i64, ptr %in0, align 8\n  %v1 = load i64, ptr %in1, align 8\n  %v2 = load i64, ptr %in2, align 8\n  %v3 = load i64, ptr %in3, align 8\n  %v4 = load i64, ptr %in4, align 8\n  %v5 = load i64, ptr %in5, align 8\n  %v6 = load i64, ptr %in6, align 8\n  %reduce.add.0 = add i64 %v0, %v1\n  %reduce.add.1 = add i64 %reduce.add.0, %v2\n  %reduce.add.2 = add i64 %reduce.add.1, %v3\n  %reduce.add.3 = add i64 %reduce.add.2, %v4\n  %reduce.add.4 = add i64 %reduce.add.3, %v5\n  %reduce.add.5 = add i64 %reduce.add.4, %v6\n  %reduce.add.5.narrow = trunc i64 %reduce.add.5 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.5.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 7\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i64-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i64], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in0 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.6\n  %in7 = getelementptr inbounds [1024 x i64], ptr @A, i64 0, i64 %iv.7\n  %v0 = load i64, ptr %in0, align 8\n  %v1 = load i64, ptr %in1, align 8\n  %v2 = load i64, ptr %in2, align 8\n  %v3 = load i64, ptr %in3, align 8\n  %v4 = load i64, ptr %in4, align 8\n  %v5 = load i64, ptr %in5, align 8\n  %v6 = load i64, ptr %in6, align 8\n  %v7 = load i64, ptr %in7, align 8\n  %reduce.add.0 = add i64 %v0, %v1\n  %reduce.add.1 = add i64 %reduce.add.0, %v2\n  %reduce.add.2 = add i64 %reduce.add.1, %v3\n  %reduce.add.3 = add i64 %reduce.add.2, %v4\n  %reduce.add.4 = add i64 %reduce.add.3, %v5\n  %reduce.add.5 = add i64 %reduce.add.4, %v6\n  %reduce.add.6 = add i64 %reduce.add.5, %v7\n  %reduce.add.6.narrow = trunc i64 %reduce.add.6 to i8\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.6.narrow, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i8-stride-5.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl,+avx512bw --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i8], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %in0 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.4\n  %v0 = load i8, ptr %in0, align 1\n  %v1 = load i8, ptr %in1, align 1\n  %v2 = load i8, ptr %in2, align 1\n  %v3 = load i8, ptr %in3, align 1\n  %v4 = load i8, ptr %in4, align 1\n  %reduce.add.0 = add i8 %v0, %v1\n  %reduce.add.1 = add i8 %reduce.add.0, %v2\n  %reduce.add.2 = add i8 %reduce.add.1, %v3\n  %reduce.add.3 = add i8 %reduce.add.2, %v4\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.3, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 5\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i8-stride-7.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl,+avx512bw --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i8], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %in0 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.6\n  %v0 = load i8, ptr %in0, align 1\n  %v1 = load i8, ptr %in1, align 1\n  %v2 = load i8, ptr %in2, align 1\n  %v3 = load i8, ptr %in3, align 1\n  %v4 = load i8, ptr %in4, align 1\n  %v5 = load i8, ptr %in5, align 1\n  %v6 = load i8, ptr %in6, align 1\n  %reduce.add.0 = add i8 %v0, %v1\n  %reduce.add.1 = add i8 %reduce.add.0, %v2\n  %reduce.add.2 = add i8 %reduce.add.1, %v3\n  %reduce.add.3 = add i8 %reduce.add.2, %v4\n  %reduce.add.4 = add i8 %reduce.add.3, %v5\n  %reduce.add.5 = add i8 %reduce.add.4, %v6\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.5, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 7\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-load-i8-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl,+avx512bw --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i8], align 128\n@B = external global [1024 x i8], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in0 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.0\n  %in1 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.1\n  %in2 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.2\n  %in3 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.3\n  %in4 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.4\n  %in5 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.5\n  %in6 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.6\n  %in7 = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.7\n  %v0 = load i8, ptr %in0, align 1\n  %v1 = load i8, ptr %in1, align 1\n  %v2 = load i8, ptr %in2, align 1\n  %v3 = load i8, ptr %in3, align 1\n  %v4 = load i8, ptr %in4, align 1\n  %v5 = load i8, ptr %in5, align 1\n  %v6 = load i8, ptr %in6, align 1\n  %v7 = load i8, ptr %in7, align 1\n  %reduce.add.0 = add i8 %v0, %v1\n  %reduce.add.1 = add i8 %reduce.add.0, %v2\n  %reduce.add.2 = add i8 %reduce.add.1, %v3\n  %reduce.add.3 = add i8 %reduce.add.2, %v4\n  %reduce.add.4 = add i8 %reduce.add.3, %v5\n  %reduce.add.5 = add i8 %reduce.add.4, %v6\n  %reduce.add.6 = add i8 %reduce.add.5, %v7\n  %out = getelementptr inbounds [1024 x i8], ptr @B, i64 0, i64 %iv.0\n  store i8 %reduce.add.6, ptr %out, align 1\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-store-f64-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i8], align 128\n@B = external global [1024 x double], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.0\n  %v.narrow = load i8, ptr %in, align 1\n  %v = uitofp i8 %v.narrow to double\n  %v0 = fadd double %v, 0.000000e+00\n  %v1 = fadd double %v, 1.000000e+00\n  %v2 = fadd double %v, 2.000000e+00\n  %v3 = fadd double %v, 3.000000e+00\n  %v4 = fadd double %v, 4.000000e+00\n  %v5 = fadd double %v, 5.000000e+00\n  %v6 = fadd double %v, 6.000000e+00\n  %v7 = fadd double %v, 7.000000e+00\n  %out0 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.0\n  %out1 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.1\n  %out2 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.2\n  %out3 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.3\n  %out4 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.4\n  %out5 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.5\n  %out6 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.6\n  %out7 = getelementptr inbounds [1024 x double], ptr @B, i64 0, i64 %iv.7\n  store double %v0, ptr %out0, align 8\n  store double %v1, ptr %out1, align 8\n  store double %v2, ptr %out2, align 8\n  store double %v3, ptr %out3, align 8\n  store double %v4, ptr %out4, align 8\n  store double %v5, ptr %out5, align 8\n  store double %v6, ptr %out6, align 8\n  store double %v7, ptr %out7, align 8\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/interleaved-store-i64-stride-8.ll",
      "commands": [
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+sse2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx  --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx2 --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -vectorizer-maximize-bandwidth -S -mattr=+avx512vl --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@A = external global [1024 x i8], align 128\n@B = external global [1024 x i64], align 128\n\ndefine void @test() {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]\n  %iv.0 = add nuw nsw i64 %iv, 0\n  %iv.1 = add nuw nsw i64 %iv, 1\n  %iv.2 = add nuw nsw i64 %iv, 2\n  %iv.3 = add nuw nsw i64 %iv, 3\n  %iv.4 = add nuw nsw i64 %iv, 4\n  %iv.5 = add nuw nsw i64 %iv, 5\n  %iv.6 = add nuw nsw i64 %iv, 6\n  %iv.7 = add nuw nsw i64 %iv, 7\n  %in = getelementptr inbounds [1024 x i8], ptr @A, i64 0, i64 %iv.0\n  %v.narrow = load i8, ptr %in, align 1\n  %v = zext i8 %v.narrow to i64\n  %v0 = add i64 %v, 0\n  %v1 = add i64 %v, 1\n  %v2 = add i64 %v, 2\n  %v3 = add i64 %v, 3\n  %v4 = add i64 %v, 4\n  %v5 = add i64 %v, 5\n  %v6 = add i64 %v, 6\n  %v7 = add i64 %v, 7\n  %out0 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.0\n  %out1 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.1\n  %out2 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.2\n  %out3 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.3\n  %out4 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.4\n  %out5 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.5\n  %out6 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.6\n  %out7 = getelementptr inbounds [1024 x i64], ptr @B, i64 0, i64 %iv.7\n  store i64 %v0, ptr %out0, align 8\n  store i64 %v1, ptr %out1, align 8\n  store i64 %v2, ptr %out2, align 8\n  store i64 %v3, ptr %out3, align 8\n  store i64 %v4, ptr %out4, align 8\n  store i64 %v5, ptr %out5, align 8\n  store i64 %v6, ptr %out6, align 8\n  store i64 %v7, ptr %out7, align 8\n  %iv.next = add nuw nsw i64 %iv.0, 8\n  %cmp = icmp ult i64 %iv.next, 1024\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Analysis/CostModel/X86/masked-interleaved-store-i16.ll",
      "commands": [
        "opt -passes=loop-vectorize -enable-interleaved-mem-accesses -prefer-predicate-over-epilogue=predicate-dont-vectorize -S -mcpu=skx --debug-only=loop-vectorize < %s 2>&1",
        "opt -passes=loop-vectorize -enable-interleaved-mem-accesses -enable-masked-interleaved-mem-accesses -prefer-predicate-over-epilogue=predicate-dont-vectorize -S -mcpu=skx --debug-only=loop-vectorize < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test2",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @test2(ptr noalias nocapture %points, i32 %numPoints, ptr noalias nocapture readonly %x, ptr noalias nocapture readonly %y) {\nentry:\n  %cmp15 = icmp sgt i32 %numPoints, 0\n  br i1 %cmp15, label %for.body.preheader, label %for.end\n\nfor.body.preheader:                               ; preds = %entry\n  %wide.trip.count = zext i32 %numPoints to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.body.preheader\n  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]\n  %arrayidx = getelementptr inbounds i16, ptr %x, i64 %indvars.iv\n  %0 = load i16, ptr %arrayidx, align 2\n  %1 = shl nsw i64 %indvars.iv, 2\n  %arrayidx2 = getelementptr inbounds i16, ptr %points, i64 %1\n  store i16 %0, ptr %arrayidx2, align 2\n  %arrayidx4 = getelementptr inbounds i16, ptr %y, i64 %indvars.iv\n  %2 = load i16, ptr %arrayidx4, align 2\n  %3 = or disjoint i64 %1, 1\n  %arrayidx7 = getelementptr inbounds i16, ptr %points, i64 %3\n  store i16 %2, ptr %arrayidx7, align 2\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count\n  br i1 %exitcond.not, label %for.end.loopexit, label %for.body\n\nfor.end.loopexit:                                 ; preds = %for.body\n  br label %for.end\n\nfor.end:                                          ; preds = %for.end.loopexit, %entry\n  ret void\n}\n"
        },
        {
          "test_name": "test1",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @test1(ptr noalias nocapture %points, ptr noalias nocapture readonly %x, ptr noalias nocapture readonly %y) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %arrayidx = getelementptr inbounds i16, ptr %x, i64 %indvars.iv\n  %0 = load i16, ptr %arrayidx, align 2\n  %1 = shl nuw nsw i64 %indvars.iv, 2\n  %arrayidx2 = getelementptr inbounds i16, ptr %points, i64 %1\n  store i16 %0, ptr %arrayidx2, align 2\n  %arrayidx4 = getelementptr inbounds i16, ptr %y, i64 %indvars.iv\n  %2 = load i16, ptr %arrayidx4, align 2\n  %3 = or disjoint i64 %1, 1\n  %arrayidx7 = getelementptr inbounds i16, ptr %points, i64 %3\n  store i16 %2, ptr %arrayidx7, align 2\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond.not = icmp eq i64 %indvars.iv.next, 1024\n  br i1 %exitcond.not, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/interleaved-vs-scalar.ll",
      "commands": [
        "opt < %s -force-vector-width=2 -force-vector-interleave=1 -passes=loop-vectorize -S --debug-only=loop-vectorize 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64--linux-gnu\"\n\n%pair = type { i8, i8 }\n\ndefine void @test(ptr %p, ptr %q, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr %pair, ptr %p, i64 %i, i32 0\n  %tmp1 = load i8, ptr %tmp0, align 1\n  %tmp2 = getelementptr %pair, ptr %p, i64 %i, i32 1\n  %tmp3 = load i8, ptr %tmp2, align 1\n  %add = add i8 %tmp1, %tmp3\n  %qi = getelementptr i8, ptr %q, i64 %i\n  store i8 %add, ptr %qi, align 1\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp eq i64 %i.next, %n\n  br i1 %cond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/interleaved_cost.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=2 -debug-only=loop-vectorize -disable-output < %s 2>&1",
        "opt -passes=loop-vectorize -force-vector-width=4 -debug-only=loop-vectorize -disable-output < %s 2>&1",
        "opt -passes=loop-vectorize -force-vector-width=8 -debug-only=loop-vectorize -disable-output < %s 2>&1",
        "opt -passes=loop-vectorize -force-vector-width=16 -debug-only=loop-vectorize -disable-output < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "i8_factor_2",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64\"\n\n%i8.2 = type { i8, i8 }\n\ndefine void @i8_factor_2(ptr %data, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i8.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i8.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i8, ptr %tmp0, align 1\n  %tmp3 = load i8, ptr %tmp1, align 1\n  store i8 %tmp2, ptr %tmp0, align 1\n  store i8 %tmp3, ptr %tmp1, align 1\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "i16_factor_2",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64\"\n\n%i16.2 = type { i16, i16 }\n\ndefine void @i16_factor_2(ptr %data, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i16.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i16.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i16, ptr %tmp0, align 2\n  %tmp3 = load i16, ptr %tmp1, align 2\n  store i16 %tmp2, ptr %tmp0, align 2\n  store i16 %tmp3, ptr %tmp1, align 2\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "i32_factor_2",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64\"\n\n%i32.2 = type { i32, i32 }\n\ndefine void @i32_factor_2(ptr %data, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i32.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i32.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i32, ptr %tmp0, align 4\n  %tmp3 = load i32, ptr %tmp1, align 4\n  store i32 %tmp2, ptr %tmp0, align 4\n  store i32 %tmp3, ptr %tmp1, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "i64_factor_2",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64\"\n\n%i64.2 = type { i64, i64 }\n\ndefine void @i64_factor_2(ptr %data, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i64.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i64.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i64, ptr %tmp0, align 8\n  %tmp3 = load i64, ptr %tmp1, align 8\n  store i64 %tmp2, ptr %tmp0, align 8\n  store i64 %tmp3, ptr %tmp1, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "i64_factor_8",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64\"\n\n%i64.8 = type { i64, i64, i64, i64, i64, i64, i64, i64 }\n\ndefine void @i64_factor_8(ptr %data, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i64.8, ptr %data, i64 %i, i32 2\n  %tmp1 = getelementptr inbounds %i64.8, ptr %data, i64 %i, i32 6\n  %tmp2 = load i64, ptr %tmp0, align 8\n  %tmp3 = load i64, ptr %tmp1, align 8\n  store i64 %tmp2, ptr %tmp0, align 8\n  store i64 %tmp3, ptr %tmp1, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/ARM/mve-interleaved-cost.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=2 -debug-only=loop-vectorize -disable-output < %s 2>&1",
        "opt -passes=loop-vectorize -force-vector-width=4 -debug-only=loop-vectorize -disable-output < %s 2>&1",
        "opt -passes=loop-vectorize -force-vector-width=8 -debug-only=loop-vectorize -disable-output < %s 2>&1",
        "opt -passes=loop-vectorize -force-vector-width=16 -debug-only=loop-vectorize -disable-output < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "i16_factor_3",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i16.3 = type { i16, i16, i16 }\n\ndefine void @i16_factor_3(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i16.3, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i16.3, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i16.3, ptr %data, i64 %i, i32 2\n  %tmp3 = load i16, ptr %tmp0, align 2\n  %tmp4 = load i16, ptr %tmp1, align 2\n  %tmp5 = load i16, ptr %tmp2, align 2\n  store i16 %tmp3, ptr %tmp0, align 2\n  store i16 %tmp4, ptr %tmp1, align 2\n  store i16 %tmp5, ptr %tmp2, align 2\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f16_factor_2",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f16.2 = type { half, half }\n\ndefine void @f16_factor_2(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f16.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f16.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load half, ptr %tmp0, align 2\n  %tmp3 = load half, ptr %tmp1, align 2\n  store half %tmp2, ptr %tmp0, align 2\n  store half %tmp3, ptr %tmp1, align 2\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i32_factor_2",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i32.2 = type { i32, i32 }\n\ndefine void @i32_factor_2(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i32.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i32.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i32, ptr %tmp0, align 4\n  %tmp3 = load i32, ptr %tmp1, align 4\n  store i32 %tmp2, ptr %tmp0, align 4\n  store i32 %tmp3, ptr %tmp1, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i64_factor_4",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i64.4 = type { i64, i64, i64, i64 }\n\ndefine void @i64_factor_4(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i64.4, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i64.4, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i64.4, ptr %data, i64 %i, i32 2\n  %tmp3 = getelementptr inbounds %i64.4, ptr %data, i64 %i, i32 3\n  %tmp4 = load i64, ptr %tmp0, align 8\n  %tmp5 = load i64, ptr %tmp1, align 8\n  %tmp6 = load i64, ptr %tmp2, align 8\n  %tmp7 = load i64, ptr %tmp3, align 8\n  store i64 %tmp4, ptr %tmp0, align 8\n  store i64 %tmp5, ptr %tmp1, align 8\n  store i64 %tmp6, ptr %tmp2, align 8\n  store i64 %tmp7, ptr %tmp3, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f32_factor_3",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f32.3 = type { float, float, float }\n\ndefine void @f32_factor_3(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f32.3, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f32.3, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %f32.3, ptr %data, i64 %i, i32 2\n  %tmp3 = load float, ptr %tmp0, align 4\n  %tmp4 = load float, ptr %tmp1, align 4\n  %tmp5 = load float, ptr %tmp2, align 4\n  store float %tmp3, ptr %tmp0, align 4\n  store float %tmp4, ptr %tmp1, align 4\n  store float %tmp5, ptr %tmp2, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i64_factor_3",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i64.3 = type { i64, i64, i64 }\n\ndefine void @i64_factor_3(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i64.3, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i64.3, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i64.3, ptr %data, i64 %i, i32 2\n  %tmp3 = load i64, ptr %tmp0, align 8\n  %tmp4 = load i64, ptr %tmp1, align 8\n  %tmp5 = load i64, ptr %tmp2, align 8\n  store i64 %tmp3, ptr %tmp0, align 8\n  store i64 %tmp4, ptr %tmp1, align 8\n  store i64 %tmp5, ptr %tmp2, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f16_factor_3",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f16.3 = type { half, half, half }\n\ndefine void @f16_factor_3(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f16.3, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f16.3, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %f16.3, ptr %data, i64 %i, i32 2\n  %tmp3 = load half, ptr %tmp0, align 2\n  %tmp4 = load half, ptr %tmp1, align 2\n  %tmp5 = load half, ptr %tmp2, align 2\n  store half %tmp3, ptr %tmp0, align 2\n  store half %tmp4, ptr %tmp1, align 2\n  store half %tmp5, ptr %tmp2, align 2\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i8_factor_3",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i8.3 = type { i8, i8, i8 }\n\ndefine void @i8_factor_3(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i8.3, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i8.3, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i8.3, ptr %data, i64 %i, i32 2\n  %tmp3 = load i8, ptr %tmp0, align 1\n  %tmp4 = load i8, ptr %tmp1, align 1\n  %tmp5 = load i8, ptr %tmp2, align 1\n  store i8 %tmp3, ptr %tmp0, align 1\n  store i8 %tmp4, ptr %tmp1, align 1\n  store i8 %tmp5, ptr %tmp2, align 1\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f32_factor_2",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f32.2 = type { float, float }\n\ndefine void @f32_factor_2(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f32.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f32.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load float, ptr %tmp0, align 4\n  %tmp3 = load float, ptr %tmp1, align 4\n  store float %tmp2, ptr %tmp0, align 4\n  store float %tmp3, ptr %tmp1, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i8_factor_4",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i8.4 = type { i8, i8, i8, i8 }\n\ndefine void @i8_factor_4(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i8.4, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i8.4, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i8.4, ptr %data, i64 %i, i32 2\n  %tmp3 = getelementptr inbounds %i8.4, ptr %data, i64 %i, i32 3\n  %tmp4 = load i8, ptr %tmp0, align 1\n  %tmp5 = load i8, ptr %tmp1, align 1\n  %tmp6 = load i8, ptr %tmp2, align 1\n  %tmp7 = load i8, ptr %tmp3, align 1\n  store i8 %tmp4, ptr %tmp0, align 1\n  store i8 %tmp5, ptr %tmp1, align 1\n  store i8 %tmp6, ptr %tmp2, align 1\n  store i8 %tmp7, ptr %tmp3, align 1\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i16_factor_2",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i16.2 = type { i16, i16 }\n\ndefine void @i16_factor_2(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i16.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i16.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i16, ptr %tmp0, align 2\n  %tmp3 = load i16, ptr %tmp1, align 2\n  store i16 %tmp2, ptr %tmp0, align 2\n  store i16 %tmp3, ptr %tmp1, align 2\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i16_factor_4",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i16.4 = type { i16, i16, i16, i16 }\n\ndefine void @i16_factor_4(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i16.4, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i16.4, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i16.4, ptr %data, i64 %i, i32 2\n  %tmp3 = getelementptr inbounds %i16.4, ptr %data, i64 %i, i32 3\n  %tmp4 = load i16, ptr %tmp0, align 2\n  %tmp5 = load i16, ptr %tmp1, align 2\n  %tmp6 = load i16, ptr %tmp2, align 2\n  %tmp7 = load i16, ptr %tmp3, align 2\n  store i16 %tmp4, ptr %tmp0, align 2\n  store i16 %tmp5, ptr %tmp1, align 2\n  store i16 %tmp6, ptr %tmp2, align 2\n  store i16 %tmp7, ptr %tmp3, align 2\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f64_factor_3",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f64.3 = type { double, double, double }\n\ndefine void @f64_factor_3(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f64.3, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f64.3, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %f64.3, ptr %data, i64 %i, i32 2\n  %tmp3 = load double, ptr %tmp0, align 8\n  %tmp4 = load double, ptr %tmp1, align 8\n  %tmp5 = load double, ptr %tmp2, align 8\n  store double %tmp3, ptr %tmp0, align 8\n  store double %tmp4, ptr %tmp1, align 8\n  store double %tmp5, ptr %tmp2, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i8_factor_2",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i8.2 = type { i8, i8 }\n\ndefine void @i8_factor_2(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i8.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i8.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i8, ptr %tmp0, align 1\n  %tmp3 = load i8, ptr %tmp1, align 1\n  store i8 %tmp2, ptr %tmp0, align 1\n  store i8 %tmp3, ptr %tmp1, align 1\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i32_factor_4",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i32.4 = type { i32, i32, i32, i32 }\n\ndefine void @i32_factor_4(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i32.4, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i32.4, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i32.4, ptr %data, i64 %i, i32 2\n  %tmp3 = getelementptr inbounds %i32.4, ptr %data, i64 %i, i32 3\n  %tmp4 = load i32, ptr %tmp0, align 4\n  %tmp5 = load i32, ptr %tmp1, align 4\n  %tmp6 = load i32, ptr %tmp2, align 4\n  %tmp7 = load i32, ptr %tmp3, align 4\n  store i32 %tmp4, ptr %tmp0, align 4\n  store i32 %tmp5, ptr %tmp1, align 4\n  store i32 %tmp6, ptr %tmp2, align 4\n  store i32 %tmp7, ptr %tmp3, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i32_factor_3",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i32.3 = type { i32, i32, i32 }\n\ndefine void @i32_factor_3(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i32.3, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i32.3, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %i32.3, ptr %data, i64 %i, i32 2\n  %tmp3 = load i32, ptr %tmp0, align 4\n  %tmp4 = load i32, ptr %tmp1, align 4\n  %tmp5 = load i32, ptr %tmp2, align 4\n  store i32 %tmp3, ptr %tmp0, align 4\n  store i32 %tmp4, ptr %tmp1, align 4\n  store i32 %tmp5, ptr %tmp2, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f64_factor_2",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f64.2 = type { double, double }\n\ndefine void @f64_factor_2(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f64.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f64.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load double, ptr %tmp0, align 8\n  %tmp3 = load double, ptr %tmp1, align 8\n  store double %tmp2, ptr %tmp0, align 8\n  store double %tmp3, ptr %tmp1, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f16_factor_4",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f16.4 = type { half, half, half, half }\n\ndefine void @f16_factor_4(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f16.4, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f16.4, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %f16.4, ptr %data, i64 %i, i32 2\n  %tmp3 = getelementptr inbounds %f16.4, ptr %data, i64 %i, i32 3\n  %tmp4 = load half, ptr %tmp0, align 2\n  %tmp5 = load half, ptr %tmp1, align 2\n  %tmp6 = load half, ptr %tmp2, align 2\n  %tmp7 = load half, ptr %tmp3, align 2\n  store half %tmp4, ptr %tmp0, align 2\n  store half %tmp5, ptr %tmp1, align 2\n  store half %tmp6, ptr %tmp2, align 2\n  store half %tmp7, ptr %tmp3, align 2\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "i64_factor_2",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%i64.2 = type { i64, i64 }\n\ndefine void @i64_factor_2(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %i64.2, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %i64.2, ptr %data, i64 %i, i32 1\n  %tmp2 = load i64, ptr %tmp0, align 8\n  %tmp3 = load i64, ptr %tmp1, align 8\n  store i64 %tmp2, ptr %tmp0, align 8\n  store i64 %tmp3, ptr %tmp1, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f64_factor_4",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f64.4 = type { double, double, double, double }\n\ndefine void @f64_factor_4(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f64.4, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f64.4, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %f64.4, ptr %data, i64 %i, i32 2\n  %tmp3 = getelementptr inbounds %f64.4, ptr %data, i64 %i, i32 3\n  %tmp4 = load double, ptr %tmp0, align 8\n  %tmp5 = load double, ptr %tmp1, align 8\n  %tmp6 = load double, ptr %tmp2, align 8\n  %tmp7 = load double, ptr %tmp3, align 8\n  store double %tmp4, ptr %tmp0, align 8\n  store double %tmp5, ptr %tmp1, align 8\n  store double %tmp6, ptr %tmp2, align 8\n  store double %tmp7, ptr %tmp3, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        },
        {
          "test_name": "f32_factor_4",
          "test_body": "target datalayout = \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\"\ntarget triple = \"thumbv8.1m.main-none-eabi\"\n\n%f32.4 = type { float, float, float, float }\n\ndefine void @f32_factor_4(ptr %data, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.body ]\n  %tmp0 = getelementptr inbounds %f32.4, ptr %data, i64 %i, i32 0\n  %tmp1 = getelementptr inbounds %f32.4, ptr %data, i64 %i, i32 1\n  %tmp2 = getelementptr inbounds %f32.4, ptr %data, i64 %i, i32 2\n  %tmp3 = getelementptr inbounds %f32.4, ptr %data, i64 %i, i32 3\n  %tmp4 = load float, ptr %tmp0, align 4\n  %tmp5 = load float, ptr %tmp1, align 4\n  %tmp6 = load float, ptr %tmp2, align 4\n  %tmp7 = load float, ptr %tmp3, align 4\n  store float %tmp4, ptr %tmp0, align 4\n  store float %tmp5, ptr %tmp1, align 4\n  store float %tmp6, ptr %tmp2, align 4\n  store float %tmp7, ptr %tmp3, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+mve.fp\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/dead-ops-cost.ll",
      "commands": [
        "opt -p loop-vectorize -mtriple riscv64-linux-gnu -mattr=+v,+f -S %s"
      ],
      "tests": [
        {
          "test_name": "dead_load",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine void @dead_load(ptr %p, i16 %start) {\nentry:\n  %start.ext = sext i16 %start to i64\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %start.ext, %entry ], [ %iv.next, %loop ]\n  %gep = getelementptr i16, ptr %p, i64 %iv\n  store i16 0, ptr %gep, align 2\n  %l = load i16, ptr %gep, align 2\n  %iv.next = add i64 %iv, 3\n  %cmp = icmp slt i64 %iv, 111\n  br i1 %cmp, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "cost_of_exit_branch_and_cond_insts",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i16 @llvm.umax.i16(i16, i16) #0\n\ndefine i32 @cost_of_exit_branch_and_cond_insts(ptr %a, ptr %b, i1 %c, i16 %x) #1 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %c, label %then, label %loop.exiting\n\nthen:                                             ; preds = %loop.header\n  %gep = getelementptr inbounds i32, ptr %b, i32 %iv\n  store i1 false, ptr %a, align 1\n  store i32 0, ptr %gep, align 4\n  br label %loop.exiting\n\nloop.exiting:                                     ; preds = %then, %loop.header\n  %iv.next = add i32 %iv, 1\n  %umax = tail call i16 @llvm.umax.i16(i16 %x, i16 111)\n  %umax.ext = zext i16 %umax to i32\n  %sub = sub i32 770, %umax.ext\n  %ec = icmp slt i32 %iv, %sub\n  br i1 %ec, label %loop.latch, label %exit\n\nloop.latch:                                       ; preds = %loop.exiting\n  br label %loop.header\n\nexit:                                             ; preds = %loop.exiting\n  br label %return\n\nreturn:                                           ; preds = %exit\n  ret i32 0\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "gather_interleave_group_with_dead_insert_pos",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine void @gather_interleave_group_with_dead_insert_pos(i64 %N, ptr noalias %src, ptr noalias %dst) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %gep.src.0 = getelementptr i8, ptr %src, i64 %iv\n  %l.dead = load i8, ptr %gep.src.0, align 1\n  %iv.1 = add i64 %iv, 1\n  %gep.src.1 = getelementptr i8, ptr %src, i64 %iv.1\n  %l.1 = load i8, ptr %gep.src.1, align 1\n  %ext = zext i8 %l.1 to i32\n  %gep.dst = getelementptr i32, ptr %dst, i64 %iv\n  store i32 %ext, ptr %gep.dst, align 4\n  %iv.next = add nsw i64 %iv, 4\n  %ec = icmp slt i64 %iv, %N\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "test_phi_in_latch_redundant",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine void @test_phi_in_latch_redundant(ptr %dst, i32 %a) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  br i1 false, label %loop.latch, label %then\n\nthen:                                             ; preds = %loop.header\n  %not.a = xor i32 %a, -1\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %p = phi i32 [ %not.a, %then ], [ 0, %loop.header ]\n  %gep = getelementptr i32, ptr %dst, i64 %iv\n  store i32 %p, ptr %gep, align 4\n  %iv.next = add i64 %iv, 9\n  %ec = icmp slt i64 %iv, 322\n  br i1 %ec, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "dead_live_out_due_to_scalar_epilogue_required",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine i8 @dead_live_out_due_to_scalar_epilogue_required(ptr %src, ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %idxprom = sext i32 %iv to i64\n  %gep.src = getelementptr i8, ptr %src, i64 %idxprom\n  %l = load i8, ptr %gep.src, align 1\n  %gep.dst = getelementptr i8, ptr %dst, i64 %idxprom\n  store i8 0, ptr %gep.dst, align 1\n  %iv.next = add i32 %iv, 4\n  %cmp = icmp ult i32 %iv, 1001\n  br i1 %cmp, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  %r = phi i8 [ %l, %loop ]\n  ret i8 %r\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/SystemZ/mem-interleaving-costs-03.ll",
      "commands": [
        "opt -mtriple=s390x-unknown-linux -mcpu=z16 -passes=loop-vectorize -debug-only=loop-vectorize -force-vector-width=4 -disable-output < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "fun",
          "test_body": "define noundef i32 @fun(i32 %argc, ptr nocapture readnone %argv) {\nentry:\n  %l_4774.i = alloca [4 x [2 x i128]], align 8\n  call void @llvm.lifetime.start.p0(i64 128, ptr nonnull %l_4774.i)\n  br label %for.cond4.preheader.i\n\nfor.cond4.preheader.i:                            ; preds = %for.cond4.preheader.i, %entry\n  %indvars.iv8.i = phi i64 [ 0, %entry ], [ %indvars.iv.next9.i, %for.cond4.preheader.i ]\n  %arrayidx10.i = getelementptr inbounds [4 x [2 x i128]], ptr %l_4774.i, i64 0, i64 %indvars.iv8.i, i64 0\n  store i128 8721036757475490113, ptr %arrayidx10.i, align 8\n  %arrayidx10.i.c = getelementptr inbounds [4 x [2 x i128]], ptr %l_4774.i, i64 0, i64 %indvars.iv8.i, i64 1\n  store i128 8721036757475490113, ptr %arrayidx10.i.c, align 8\n  %indvars.iv.next9.i = add nuw nsw i64 %indvars.iv8.i, 1\n  %exitcond.not.i = icmp eq i64 %indvars.iv.next9.i, 4\n  br i1 %exitcond.not.i, label %func_1.exit, label %for.cond4.preheader.i\n\nfunc_1.exit:                                      ; preds = %for.cond4.preheader.i\n  %arrayidx195.i = getelementptr inbounds [4 x [2 x i128]], ptr %l_4774.i, i64 0, i64 1\n  %0 = load i128, ptr %arrayidx195.i, align 8\n  %cmp200.i = icmp ne i128 %0, 0\n  %conv202.i = zext i1 %cmp200.i to i64\n  %call203.i = tail call i64 @safe_sub_func_int64_t_s_s(i64 noundef %conv202.i, i64 noundef 9139899272418802852)\n  call void @llvm.lifetime.end.p0(i64 128, ptr nonnull %l_4774.i)\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.cond, %func_1.exit\n  br label %for.cond\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #0\n\ndeclare dso_local i64 @safe_sub_func_int64_t_s_s(i64, i64)\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[VPlan] Assertion \" VPlan cost model and legacy cost model disagreed\"' failed.",
    "body": "Tested using: 15106c26662a WITH commits from #107894 cherry-picked on top.\r\n```\r\n> git log --oneline\r\n2bfba9bc7d37 (HEAD -> main) !fixup add TODO\r\n28acd6af75ff Add initial loop-invariant code motion transform.\r\n15106c26662a (origin/main, origin/HEAD) [flang][runtime] Fix odd \"invalid descriptor\" runtime crash\r\n```\r\nTestcase:\r\n```c\r\nchar a;\r\nextern int b[];\r\nshort c;\r\nchar d[1];\r\nvoid checksum() {\r\n  for (long e = 0; e < 3;)\r\n    for (long f = 0; e < 3; e = 709692)\r\n      for (; f < c; f += 4) {\r\n        a = d[f];\r\n        b[f] = d[f - 1];\r\n      }\r\n}\r\n```\r\n`clang -march=rv64gcv -O3 red.c`\r\n\r\nTestcase:\r\n```llvm ir\r\n; ModuleID = 'reduced.bc'\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine void @g(i64 %conv) #0 {\r\nentry:\r\n  br label %for.body8.us23\r\n\r\nfor.body8.us23:                                   ; preds = %for.body8.us23, %entry\r\n  %f.121.us24 = phi i64 [ %add.us30, %for.body8.us23 ], [ 0, %entry ]\r\n  %arrayidx.us25 = getelementptr [1 x i8], ptr null, i64 0, i64 %f.121.us24\r\n  %0 = load i8, ptr %arrayidx.us25, align 1\r\n  %sub.us26 = add i64 %f.121.us24, 1\r\n  %arrayidx9.us27 = getelementptr [1 x i8], ptr null, i64 0, i64 %sub.us26\r\n  %1 = load i8, ptr %arrayidx9.us27, align 1\r\n  %conv10.us28 = zext i8 %1 to i32\r\n  %arrayidx11.us29 = getelementptr [0 x i32], ptr null, i64 0, i64 %f.121.us24\r\n  store i32 %conv10.us28, ptr null, align 4\r\n  %add.us30 = add nsw i64 %f.121.us24, 4\r\n  %cmp6.us31 = icmp slt i64 %f.121.us24, %conv\r\n  br i1 %cmp6.us31, label %for.body8.us23, label %for.cond.cleanup.split.us\r\n\r\nfor.cond.cleanup.split.us:                        ; preds = %for.body8.us23\r\n  ret void\r\n}\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+a,+c,+d,+f,+m,+relax,+v,+zicsr,+zifencei,+zmmul,+zve32f,+zve32x,+zve64d,+zve64f,+zve64x,+zvl128b,+zvl32b,+zvl64b,-b,-e,-experimental-smctr,-experimental-smmpm,-experimental-smnpm,-experimental-ssctr,-experimental-ssnpm,-experimental-sspm,-experimental-supm,-experimental-zacas,-experimental-zalasr,-experimental-zicfilp,-experimental-zicfiss,-experimental-zvbc32e,-experimental-zvkgs,-h,-shcounterenw,-shgatpa,-shtvala,-shvsatpa,-shvstvala,-shvstvecd,-smaia,-smcdeleg,-smcsrind,-smepmp,-smstateen,-ssaia,-ssccfg,-ssccptr,-sscofpmf,-sscounterenw,-sscsrind,-ssqosid,-ssstateen,-ssstrict,-sstc,-sstvala,-sstvecd,-ssu64xl,-svade,-svadu,-svbare,-svinval,-svnapot,-svpbmt,-xcvalu,-xcvbi,-xcvbitmanip,-xcvelw,-xcvmac,-xcvmem,-xcvsimd,-xsfcease,-xsfvcp,-xsfvfnrclipxfqf,-xsfvfwmaccqqq,-xsfvqmaccdod,-xsfvqmaccqoq,-xsifivecdiscarddlone,-xsifivecflushdlone,-xtheadba,-xtheadbb,-xtheadbs,-xtheadcmo,-xtheadcondmov,-xtheadfmemidx,-xtheadmac,-xtheadmemidx,-xtheadmempair,-xtheadsync,-xtheadvdot,-xventanacondops,-xwchc,-za128rs,-za64rs,-zaamo,-zabha,-zalrsc,-zama16b,-zawrs,-zba,-zbb,-zbc,-zbkb,-zbkc,-zbkx,-zbs,-zca,-zcb,-zcd,-zce,-zcf,-zcmop,-zcmp,-zcmt,-zdinx,-zfa,-zfbfmin,-zfh,-zfhmin,-zfinx,-zhinx,-zhinxmin,-zic64b,-zicbom,-zicbop,-zicboz,-ziccamoa,-ziccif,-zicclsm,-ziccrse,-zicntr,-zicond,-zihintntl,-zihintpause,-zihpm,-zimop,-zk,-zkn,-zknd,-zkne,-zknh,-zkr,-zks,-zksed,-zksh,-zkt,-ztso,-zvbb,-zvbc,-zvfbfmin,-zvfbfwma,-zvfh,-zvfhmin,-zvkb,-zvkg,-zvkn,-zvknc,-zvkned,-zvkng,-zvknha,-zvknhb,-zvks,-zvksc,-zvksed,-zvksg,-zvksh,-zvkt,-zvl1024b,-zvl16384b,-zvl2048b,-zvl256b,-zvl32768b,-zvl4096b,-zvl512b,-zvl65536b,-zvl8192b\" }\r\n```\r\n\r\nCommand/backtrace:\r\n```\r\n> /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt --passes loop-vectorize reduced.ll -S\r\nopt: /scratch/tc-testing/tc-compiler-fuzz-trunk/llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7394: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt --passes loop-vectorize reduced.ll -S\r\n1.      Running pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"reduced.ll\"\r\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"g\"\r\n #0 0x00005fabff5a9d80 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x3072d80)\r\n #1 0x00005fabff5a718f llvm::sys::RunSignalHandlers() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x307018f)\r\n #2 0x00005fabff5a72e5 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x00007fe3d2042520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007fe3d20969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007fe3d20969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007fe3d20969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007fe3d2042476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007fe3d20287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007fe3d202871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007fe3d2039e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x00005fabfe550a26 llvm::LoopVectorizationPlanner::computeBestVF() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2019a26)\r\n#12 0x00005fabfe5678fb llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x20308fb)\r\n#13 0x00005fabfe56a911 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2033911)\r\n#14 0x00005fabfe56af87 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2033f87)\r\n#15 0x00005fabfd3adf96 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe76f96)\r\n#16 0x00005fabff3b51ef llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e7e1ef)\r\n#17 0x00005fabfd3b11c6 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe7a1c6)\r\n#18 0x00005fabff3b357b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e7c57b)\r\n#19 0x00005fabfd3ad376 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe76376)\r\n#20 0x00005fabff3b40dd llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e7d0dd)\r\n#21 0x00005fabfcbd49db llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x69d9db)\r\n#22 0x00005fabfcbc6701 optMain (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x68f701)\r\n#23 0x00007fe3d2029d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#24 0x00007fe3d2029e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#25 0x00007fe3d2029e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#26 0x00005fabfcbbcc65 _start (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x685c65)\r\nzsh: IOT instruction (core dumped)  /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt\r\n```\r\nhttps://godbolt.org/z/TTchhsf9h\r\n\r\nFound via fuzzer\r\n\r\nRelated/prior issue: https://github.com/llvm/llvm-project/issues/107473\r\n\r\ncc @fhahn",
    "author": "patrick-rivos",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  },
  "verified": true
}