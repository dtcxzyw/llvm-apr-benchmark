{
  "bug_id": "120615",
  "issue_url": "https://github.com/llvm/llvm-project/issues/120615",
  "bug_type": "crash",
  "base_commit": "e3fe41cdf5583d3a2f7454c76fa5cadccdccaf22",
  "knowledge_cutoff": "2024-12-19T18:18:18Z",
  "lit_test_dir": [
    "llvm/test/Analysis/ScalarEvolution"
  ],
  "hints": {
    "fix_commit": "f035351af785b7349ab7bcd55149c781ceca24cb",
    "components": [
      "ScalarEvolution"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/ScalarEvolution.cpp": [
        [
          15765,
          15770
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/ScalarEvolution.cpp": [
        "ScalarEvolution::LoopGuards::collectFromBlock"
      ]
    }
  },
  "patch": "commit f035351af785b7349ab7bcd55149c781ceca24cb\nAuthor: Julian Nagele <j.nagele@apple.com>\nDate:   Tue Dec 31 10:24:48 2024 +0100\n\n    [SCEV] Make sure starting block is marked as visited when recursively collecting loop guards. (#120749)\n    \n    When `collectFromBlock` is called without a predecessor (in particular\n    for loops that don't have a unique predecessor outside the loop) we\n    never start climbing the predecessor chain, and thus don't mark the\n    starting block as visited.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/120615.\n\ndiff --git a/llvm/lib/Analysis/ScalarEvolution.cpp b/llvm/lib/Analysis/ScalarEvolution.cpp\nindex 8ab56025546e..b5668a14a4a2 100644\n--- a/llvm/lib/Analysis/ScalarEvolution.cpp\n+++ b/llvm/lib/Analysis/ScalarEvolution.cpp\n@@ -15765,6 +15765,7 @@ void ScalarEvolution::LoopGuards::collectFromBlock(\n   // original header.\n   // TODO: share this logic with isLoopEntryGuardedByCond.\n   unsigned NumCollectedConditions = 0;\n+  VisitedBlocks.insert(Block);\n   std::pair<const BasicBlock *, const BasicBlock *> Pair(Pred, Block);\n   for (; Pair.first;\n        Pair = SE.getPredecessorWithUniqueSuccessorForBB(Pair.first)) {\n",
  "tests": [
    {
      "file": "llvm/test/Analysis/ScalarEvolution/backedge-taken-count-guard-info-with-multiple-predecessors.ll",
      "commands": [
        "opt < %s -disable-output \"-passes=print<scalar-evolution>\" -scalar-evolution-max-iterations=0  -scalar-evolution-classify-expressions=0  2>&1"
      ],
      "tests": [
        {
          "test_name": "epilogue",
          "test_body": "define void @epilogue(i64 %count) {\nentry:\n  %cmp = icmp ugt i64 %count, 7\n  br i1 %cmp, label %while.body, label %epilogue.preheader\n\nwhile.body:                                       ; preds = %while.body, %entry\n  %iv = phi i64 [ %sub, %while.body ], [ %count, %entry ]\n  %sub = add i64 %iv, -8\n  %exitcond.not = icmp ugt i64 %sub, 7\n  br i1 %exitcond.not, label %while.body, label %while.loopexit\n\nwhile.loopexit:                                   ; preds = %while.body\n  %sub.exit = phi i64 [ %sub, %while.body ]\n  br label %epilogue.preheader\n\nepilogue.preheader:                               ; preds = %while.loopexit, %entry\n  %count.epilogue = phi i64 [ %count, %entry ], [ %sub.exit, %while.loopexit ]\n  %epilogue.cmp = icmp eq i64 %count.epilogue, 0\n  br i1 %epilogue.cmp, label %exit, label %epilogue\n\nepilogue:                                         ; preds = %epilogue, %epilogue.preheader\n  %iv.epilogue = phi i64 [ %dec, %epilogue ], [ %count.epilogue, %epilogue.preheader ]\n  %dec = add i64 %iv.epilogue, -1\n  %exitcond.epilogue = icmp eq i64 %dec, 0\n  br i1 %exitcond.epilogue, label %exit, label %epilogue\n\nexit:                                             ; preds = %epilogue, %epilogue.preheader\n  ret void\n}\n"
        },
        {
          "test_name": "three_incoming",
          "test_body": "define void @three_incoming(i16 %a, i16 %b, i1 %c, i1 %d) {\nentry:\n  br i1 %c, label %b1, label %entry2\n\nentry2:                                           ; preds = %entry\n  br i1 %d, label %b2, label %b3\n\nb1:                                               ; preds = %entry\n  %cmp1 = icmp ugt i16 %a, 10\n  br i1 %cmp1, label %exit, label %preheader\n\nb2:                                               ; preds = %entry2\n  %cmp2 = icmp ugt i16 %b, 8\n  br i1 %cmp2, label %exit, label %preheader\n\nb3:                                               ; preds = %entry2\n  %cmp3 = icmp ugt i16 %b, 12\n  br i1 %cmp3, label %exit, label %preheader\n\npreheader:                                        ; preds = %b3, %b2, %b1\n  %count = phi i16 [ %a, %b1 ], [ %b, %b2 ], [ %b, %b3 ]\n  %cmp4 = icmp ne i16 %count, 0\n  br i1 %cmp4, label %loop, label %exit\n\nloop:                                             ; preds = %loop, %preheader\n  %iv = phi i16 [ %iv.next, %loop ], [ %count, %preheader ]\n  %iv.next = add i16 %iv, -1\n  %exitcond = icmp eq i16 %iv.next, 0\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %preheader, %b3, %b2, %b1\n  ret void\n}\n"
        },
        {
          "test_name": "pr120615",
          "test_body": "define void @pr120615() {\nentry:\n  br label %header\n\nbb:                                               ; No predecessors!\n  br label %header\n\nheader:                                           ; preds = %header, %bb, %entry\n  %0 = phi i32 [ %1, %header ], [ 0, %bb ], [ 0, %entry ]\n  %1 = add i32 %0, 1\n  %icmp = icmp slt i32 %0, 0\n  br i1 %icmp, label %header, label %exit\n\nexit:                                             ; preds = %header\n  ret void\n}\n"
        },
        {
          "test_name": "pr120442",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #0\n\ndefine void @pr120442(i1 %c.1, i1 %c.2) {\nentry:\n  call void @llvm.assume(i1 %c.1)\n  call void @llvm.assume(i1 %c.2)\n  br label %outer.header\n\nouter.header:                                     ; preds = %bb, %entry\n  %phi7 = phi i32 [ 0, %bb ], [ 0, %entry ]\n  br label %inner.header\n\nbb:                                               ; preds = %bb\n  br i1 false, label %outer.header, label %bb\n\ninner.header:                                     ; preds = %inner.header, %outer.header\n  %phi = phi i32 [ %add, %inner.header ], [ 0, %outer.header ]\n  %add = add i32 %phi, 1\n  %icmp = icmp ugt i32 %add, 0\n  br i1 %icmp, label %exit, label %inner.header\n\nexit:                                             ; preds = %inner.header\n  ret void\n}\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "ugt",
          "test_body": "define void @ugt(i16 %a, i16 %b, i1 %c) {\nentry:\n  br i1 %c, label %b1, label %b2\n\nb1:                                               ; preds = %entry\n  %cmp1 = icmp ugt i16 %a, 11\n  br i1 %cmp1, label %exit, label %preheader\n\nb2:                                               ; preds = %entry\n  %cmp2 = icmp ugt i16 %b, 7\n  br i1 %cmp2, label %exit, label %preheader\n\npreheader:                                        ; preds = %b2, %b1\n  %count = phi i16 [ %a, %b1 ], [ %b, %b2 ]\n  %cmp3 = icmp ne i16 %count, 0\n  br i1 %cmp3, label %loop, label %exit\n\nloop:                                             ; preds = %loop, %preheader\n  %iv = phi i16 [ %iv.next, %loop ], [ %count, %preheader ]\n  %iv.next = add i16 %iv, -1\n  %exitcond = icmp eq i16 %iv.next, 0\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %preheader, %b2, %b1\n  ret void\n}\n"
        },
        {
          "test_name": "slt",
          "test_body": "define void @slt(i16 %a, i16 %b, i1 %c) {\nentry:\n  br i1 %c, label %b1, label %b2\n\nb1:                                               ; preds = %entry\n  %cmp1 = icmp slt i16 %a, 1\n  br i1 %cmp1, label %exit, label %preheader\n\nb2:                                               ; preds = %entry\n  %cmp2 = icmp slt i16 %b, 4\n  br i1 %cmp2, label %exit, label %preheader\n\npreheader:                                        ; preds = %b2, %b1\n  %count = phi i16 [ %a, %b1 ], [ %b, %b2 ]\n  %cmp3 = icmp sle i16 %count, 19\n  br i1 %cmp3, label %loop, label %exit\n\nloop:                                             ; preds = %loop, %preheader\n  %iv = phi i16 [ %iv.next, %loop ], [ %count, %preheader ]\n  %iv.next = add i16 %iv, 1\n  %exitcond = icmp eq i16 %iv.next, 20\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %preheader, %b2, %b1\n  ret void\n}\n"
        },
        {
          "test_name": "ult",
          "test_body": "define void @ult(i16 %a, i16 %b, i1 %c) {\nentry:\n  br i1 %c, label %b1, label %b2\n\nb1:                                               ; preds = %entry\n  %cmp1 = icmp ult i16 %a, 2\n  br i1 %cmp1, label %exit, label %preheader\n\nb2:                                               ; preds = %entry\n  %cmp2 = icmp ult i16 %b, 5\n  br i1 %cmp2, label %exit, label %preheader\n\npreheader:                                        ; preds = %b2, %b1\n  %count = phi i16 [ %a, %b1 ], [ %b, %b2 ]\n  %cmp3 = icmp ule i16 %count, 20\n  br i1 %cmp3, label %loop, label %exit\n\nloop:                                             ; preds = %loop, %preheader\n  %iv = phi i16 [ %iv.next, %loop ], [ %count, %preheader ]\n  %iv.next = add i16 %iv, 1\n  %exitcond = icmp eq i16 %iv.next, 22\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %preheader, %b2, %b1\n  ret void\n}\n"
        },
        {
          "test_name": "sgt",
          "test_body": "define void @sgt(i16 %a, i16 %b, i1 %c) {\nentry:\n  br i1 %c, label %b1, label %b2\n\nb1:                                               ; preds = %entry\n  %cmp1 = icmp sgt i16 %a, 10\n  br i1 %cmp1, label %exit, label %preheader\n\nb2:                                               ; preds = %entry\n  %cmp2 = icmp sgt i16 %b, 8\n  br i1 %cmp2, label %exit, label %preheader\n\npreheader:                                        ; preds = %b2, %b1\n  %count = phi i16 [ %a, %b1 ], [ %b, %b2 ]\n  %cmp3 = icmp sge i16 %count, 1\n  br i1 %cmp3, label %loop, label %exit\n\nloop:                                             ; preds = %loop, %preheader\n  %iv = phi i16 [ %iv.next, %loop ], [ %count, %preheader ]\n  %iv.next = add i16 %iv, -1\n  %exitcond = icmp eq i16 %iv.next, 0\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %preheader, %b2, %b1\n  ret void\n}\n"
        },
        {
          "test_name": "mixed",
          "test_body": "define void @mixed(i16 %a, i16 %b, i1 %c) {\nentry:\n  br i1 %c, label %b1, label %b2\n\nb1:                                               ; preds = %entry\n  %cmp1 = icmp ugt i16 %a, 10\n  br i1 %cmp1, label %exit, label %preheader\n\nb2:                                               ; preds = %entry\n  %cmp2 = icmp sgt i16 %b, 8\n  br i1 %cmp2, label %exit, label %preheader\n\npreheader:                                        ; preds = %b2, %b1\n  %count = phi i16 [ %a, %b1 ], [ %b, %b2 ]\n  %cmp3 = icmp ne i16 %count, 0\n  br i1 %cmp3, label %loop, label %exit\n\nloop:                                             ; preds = %loop, %preheader\n  %iv = phi i16 [ %iv.next, %loop ], [ %count, %preheader ]\n  %iv.next = add i16 %iv, -1\n  %exitcond = icmp eq i16 %iv.next, 0\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %preheader, %b2, %b1\n  ret void\n}\n"
        },
        {
          "test_name": "one_constant",
          "test_body": "define void @one_constant(i16 %a, i16 %b, i1 %c, i16 %d) {\nentry:\n  br i1 %c, label %b1, label %b2\n\nb1:                                               ; preds = %entry\n  %cmp1 = icmp ugt i16 %a, 10\n  br i1 %cmp1, label %exit, label %preheader\n\nb2:                                               ; preds = %entry\n  %cmp2 = icmp ugt i16 %b, %d\n  br i1 %cmp2, label %exit, label %preheader\n\npreheader:                                        ; preds = %b2, %b1\n  %count = phi i16 [ %a, %b1 ], [ %b, %b2 ]\n  %cmp3 = icmp ne i16 %count, 0\n  br i1 %cmp3, label %loop, label %exit\n\nloop:                                             ; preds = %loop, %preheader\n  %iv = phi i16 [ %iv.next, %loop ], [ %count, %preheader ]\n  %iv.next = add i16 %iv, -1\n  %exitcond = icmp eq i16 %iv.next, 0\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop, %preheader, %b2, %b1\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SCEV] Segfault in SCEV LoopGuards",
    "body": "For the following IR:\n```llvm\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @foo() {\n.split.us120:\n  br label %.split.us120.split.split.us.split.split.us.split.split.us.split\n\n.split.us120.split.split.us.split.split.us.split.split.us.split: ; preds = %.noexc7.us.us.us.us.us, %.split.us120\n  br label %.noexc7.us.us.us.us.us\n\n.lr.ph.us.us.us.us407:                            ; No predecessors!\n  switch i32 0, label %.split142.us.split.us.split.us [\n    i32 0, label %.split160.us.split.us.split.us\n    i32 1, label %.noexc7.us.us.us.us.us\n  ]\n\n.noexc7.us.us.us.us.us:                           ; preds = %.noexc7.us.us.us.us.us, %.lr.ph.us.us.us.us407, %.split.us120.split.split.us.split.split.us.split.split.us.split\n  %0 = phi i32 [ %1, %.noexc7.us.us.us.us.us ], [ 0, %.lr.ph.us.us.us.us407 ], [ 0, %.split.us120.split.split.us.split.split.us.split.split.us.split ]\n  %1 = add i32 %0, 1\n  %.not.i3.us.us.us.us384.us = icmp slt i32 %0, 0\n  br i1 %.not.i3.us.us.us.us384.us, label %.noexc7.us.us.us.us.us, label %.split.us120.split.split.us.split.split.us.split.split.us.split\n\n.split142.us.split.us.split.us:                   ; preds = %.lr.ph.us.us.us.us407\n  ret void\n\n.split160.us.split.us.split.us:                   ; preds = %.lr.ph.us.us.us.us407\n  ret void\n}\n```\n`opt` crashes when run using `-passes=nary-reassociate --scalar-evolution-use-expensive-range-sharpening`\n\ngodbolt: https://godbolt.org/z/xPv4TMMo8\n\nBacktrace (truncated due to length limits):\n```\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=nary-reassociate --scalar-evolution-use-expensive-range-sharpening <source>\n1.\tRunning pass \"function(nary-reassociate)\" on module \"<source>\"\n2.\tRunning pass \"nary-reassociate\" on function \"foo\"\n  #0 0x0000000005257198 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5257198)\n  #1 0x0000000005254b9c SignalHandler(int) Signals.cpp:0:0\n  #2 0x00007f9ab9c42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n  #3 0x00000000051640cb llvm::hash_value(llvm::APInt const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x51640cb)\n  #4 0x00000000051641a9 llvm::DenseMapInfo<llvm::APInt, void>::getHashValue(llvm::APInt const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x51641a9)\n  #5 0x0000000004ed726b bool llvm::DenseMapBase<llvm::DenseMap<llvm::APInt, std::unique_ptr<llvm::ConstantInt, std::default_delete<llvm::ConstantInt>>, llvm::DenseMapInfo<llvm::APInt, void>, llvm::detail::DenseMapPair<llvm::APInt, std::unique_ptr<llvm::ConstantInt, std::default_delete<llvm::ConstantInt>>>>, llvm::APInt, std::unique_ptr<llvm::ConstantInt, std::default_delete<llvm::ConstantInt>>, llvm::DenseMapInfo<llvm::APInt, void>, llvm::detail::DenseMapPair<llvm::APInt, std::unique_ptr<llvm::ConstantInt, std::default_delete<llvm::ConstantInt>>>>::LookupBucketFor<llvm::APInt>(llvm::APInt const&, llvm::detail::DenseMapPair<llvm::APInt, std::unique_ptr<llvm::ConstantInt, std::default_delete<llvm::ConstantInt>>>*&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4ed726b)\n  #6 0x0000000004edb996 llvm::ConstantInt::get(llvm::LLVMContext&, llvm::APInt const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4edb996)\n  #7 0x0000000004eeba30 llvm::ConstantInt::get(llvm::Type*, llvm::APInt const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4eeba30)\n  #8 0x0000000004eb6172 llvm::ConstantFoldBinaryInstruction(unsigned int, llvm::Constant*, llvm::Constant*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4eb6172)\n  #9 0x0000000004ee9f2e llvm::ConstantExpr::get(unsigned int, llvm::Constant*, llvm::Constant*, unsigned int, llvm::Type*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4ee9f2e)\n #10 0x00000000049427fb llvm::ScalarEvolution::getNegativeSCEV(llvm::SCEV const*, llvm::SCEV::NoWrapFlags) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x49427fb)\n #11 0x00000000049429c4 llvm::ScalarEvolution::getMinusSCEV(llvm::SCEV const*, llvm::SCEV const*, llvm::SCEV::NoWrapFlags, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x49429c4)\n #12 0x0000000004950e7a llvm::ScalarEvolution::LoopGuards::collectFromBlock(llvm::ScalarEvolution&, llvm::ScalarEvolution::LoopGuards&, llvm::BasicBlock const*, llvm::BasicBlock const*, llvm::SmallPtrSetImpl<llvm::BasicBlock const*>&, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4950e7a)\n #13 0x00000000049524c2 llvm::ScalarEvolution::LoopGuards::collectFromPHI(llvm::ScalarEvolution&, llvm::ScalarEvolution::LoopGuards&, llvm::PHINode const&, llvm::SmallPtrSetImpl<llvm::BasicBlock const*>&, llvm::SmallDenseMap<llvm::BasicBlock const*, llvm::ScalarEvolution::LoopGuards, 4u, llvm::DenseMapInfo<llvm::BasicBlock const*, void>, llvm::detail::DenseMapPair<llvm::BasicBlock const*, llvm::ScalarEvolution::LoopGuards>>&, unsigned int)::'lambda'(unsigned int)::operator()(unsigned int) const ScalarEvolution.cpp:0:0\n #14 0x0000000004952702 llvm::ScalarEvolution::LoopGuards::collectFromPHI(llvm::ScalarEvolution&, llvm::ScalarEvolution::LoopGuards&, llvm::PHINode const&, llvm::SmallPtrSetImpl<llvm::BasicBlock const*>&, llvm::SmallDenseMap<llvm::BasicBlock const*, llvm::ScalarEvolution::LoopGuards, 4u, llvm::DenseMapInfo<llvm::BasicBlock const*, void>, llvm::detail::DenseMapPair<llvm::BasicBlock const*, llvm::ScalarEvolution::LoopGuards>>&, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4952702)\n #15 0x0000000004951839 llvm::ScalarEvolution::LoopGuards::collectFromBlock(llvm::ScalarEvolution&, llvm::ScalarEvolution::LoopGuards&, llvm::BasicBlock const*, llvm::BasicBlock const*, llvm::SmallPtrSetImpl<llvm::BasicBlock const*>&, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4951839)\n #16 0x0000000004952c7d llvm::ScalarEvolution::applyLoopGuards(llvm::SCEV const*, llvm::Loop const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4952c7d)\n #17 0x0000000004952fb0 llvm::ScalarEvolution::getRangeForAffineNoSelfWrappingAR(llvm::SCEVAddRecExpr const*, llvm::SCEV const*, unsigned int, llvm::ScalarEvolution::RangeSignHint) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4952fb0)\n #18 0x000000000492888d llvm::ScalarEvolution::getRangeRef(llvm::SCEV const*, llvm::ScalarEvolution::RangeSignHint, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x492888d)\n #19 0x0000000004942b52 llvm::ScalarEvolution::isKnownPredicateViaConstantRanges(llvm::CmpInst::Predicate, llvm::SCEV const*, llvm::SCEV const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4942b52)\n #20 0x0000000004942e18 llvm::ScalarEvolution::isKnownViaNonRecursiveReasoning(llvm::CmpInst::Predicate, llvm::SCEV const*, llvm::SCEV const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4942e18)\n #21 0x0000000004943799 llvm::ScalarEvolution::getMinMaxExpr(llvm::SCEVTypes, llvm::SmallVectorImpl<llvm::SCEV const*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4943799)\n #22 0x0000000004943f1a llvm::ScalarEvolution::getSMinExpr(llvm::SCEV const*, llvm::SCEV const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4943f1a)\n #23 0x0000000004951128 llvm::ScalarEvolution::LoopGuards::collectFromBlock(llvm::ScalarEvolution&, llvm::ScalarEvolution::LoopGuards&, llvm::BasicBlock const*, llvm::BasicBlock const*, llvm::SmallPtrSetImpl<llvm::BasicBlock const*>&, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4951128)\n...\n#255 0x00000000049524c2 llvm::ScalarEvolution::LoopGuards::collectFromPHI(llvm::ScalarEvolution&, llvm::ScalarEvolution::LoopGuards&, llvm::PHINode const&, llvm::SmallPtrSetImpl<llvm::BasicBlock const*>&, llvm::SmallDenseMap<llvm::BasicBlock const*, llvm::ScalarEvolution::LoopGuards, 4u, llvm::DenseMapInfo<llvm::BasicBlock const*, void>, llvm::detail::DenseMapPair<llvm::BasicBlock const*, llvm::ScalarEvolution::LoopGuards>>&, unsigned int)::'lambda'(unsigned int)::operator()(unsigned int) const ScalarEvolution.cpp:0:0\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\n\nStack exhaustion via some recursion error maybe?",
    "author": "danilaml",
    "labels": [
      "llvm:SCEV",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "danilaml",
        "body": "@juliannagele possibly due to https://github.com/llvm/llvm-project/pull/113915 (from backtrace)"
      },
      {
        "author": "fhahn",
        "body": "Likely the same as https://github.com/llvm/llvm-project/issues/120237"
      },
      {
        "author": "juliannagele",
        "body": "Related, but slightly different, should be fixed here https://github.com/llvm/llvm-project/pull/120749."
      }
    ]
  }
}