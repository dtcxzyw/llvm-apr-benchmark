{
  "bug_id": "168589",
  "issue_url": "https://github.com/llvm/llvm-project/issues/168589",
  "bug_type": "crash",
  "base_commit": "777935c2edae160d20760278a1b462d8408c62f8",
  "knowledge_cutoff": "2025-11-18T18:52:30Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "54d9d4d8683221776928a8aaf3dca3b36f2b879b",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          5663,
          5668
        ],
        [
          5687,
          5700
        ],
        [
          21182,
          21187
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::BlockScheduling::tryScheduleBundle",
        "schedule"
      ]
    }
  },
  "patch": "commit 54d9d4d8683221776928a8aaf3dca3b36f2b879b\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Thu Nov 20 09:55:51 2025 -0800\n\n    [SLP]Check if the non-schedulable phi parent node has unique operands\n    \n    Need to check if the non-schedulable phi parent node has unique\n    operands, if the incoming node has copyables, and the node is\n    commutative. Otherwise, there might be issues with the correct\n    calculation of the dependencies.\n    \n    Fixes #168589\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 22253f5118a1..3b36ccbd677d 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -5663,6 +5663,14 @@ private:\n             // reordered.\n             auto *It = find(Bundle->getTreeEntry()->Scalars, In);\n             SmallDenseSet<std::pair<const ScheduleEntity *, unsigned>> Checked;\n+            bool IsNonSchedulableWithParentPhiNode =\n+                Bundle->getTreeEntry()->doesNotNeedToSchedule() &&\n+                Bundle->getTreeEntry()->UserTreeIndex &&\n+                Bundle->getTreeEntry()->UserTreeIndex.UserTE->hasState() &&\n+                Bundle->getTreeEntry()->UserTreeIndex.UserTE->State !=\n+                    TreeEntry::SplitVectorize &&\n+                Bundle->getTreeEntry()->UserTreeIndex.UserTE->getOpcode() ==\n+                    Instruction::PHI;\n             do {\n               int Lane =\n                   std::distance(Bundle->getTreeEntry()->Scalars.begin(), It);\n@@ -5687,14 +5695,6 @@ private:\n                       Bundle->getTreeEntry()->isCopyableElement(In)) &&\n                      \"Missed TreeEntry operands?\");\n \n-              bool IsNonSchedulableWithParentPhiNode =\n-                  Bundle->getTreeEntry()->doesNotNeedToSchedule() &&\n-                  Bundle->getTreeEntry()->UserTreeIndex &&\n-                  Bundle->getTreeEntry()->UserTreeIndex.UserTE->hasState() &&\n-                  Bundle->getTreeEntry()->UserTreeIndex.UserTE->State !=\n-                      TreeEntry::SplitVectorize &&\n-                  Bundle->getTreeEntry()->UserTreeIndex.UserTE->getOpcode() ==\n-                      Instruction::PHI;\n               // Count the number of unique phi nodes, which are the parent for\n               // parent entry, and exit, if all the unique phis are processed.\n               if (IsNonSchedulableWithParentPhiNode) {\n@@ -21182,6 +21182,26 @@ BoUpSLP::BlockScheduling::tryScheduleBundle(ArrayRef<Value *> VL, BoUpSLP *SLP,\n         return false;\n       }))\n     return std::nullopt;\n+  if (S.areInstructionsWithCopyableElements() && EI) {\n+    bool IsNonSchedulableWithParentPhiNode =\n+        EI.UserTE->doesNotNeedToSchedule() && EI.UserTE->UserTreeIndex &&\n+        EI.UserTE->UserTreeIndex.UserTE->hasState() &&\n+        EI.UserTE->UserTreeIndex.UserTE->State != TreeEntry::SplitVectorize &&\n+        EI.UserTE->UserTreeIndex.UserTE->getOpcode() == Instruction::PHI;\n+    if (IsNonSchedulableWithParentPhiNode) {\n+      SmallSet<std::pair<Value *, Value *>, 4> Values;\n+      for (const auto [Idx, V] :\n+           enumerate(EI.UserTE->UserTreeIndex.UserTE->Scalars)) {\n+        Value *Op = EI.UserTE->UserTreeIndex.UserTE->getOperand(\n+            EI.UserTE->UserTreeIndex.EdgeIdx)[Idx];\n+        auto *I = dyn_cast<Instruction>(Op);\n+        if (!I || !isCommutative(I))\n+          continue;\n+        if (!Values.insert(std::make_pair(V, Op)).second)\n+          return std::nullopt;\n+      }\n+    }\n+  }\n   bool HasCopyables = S.areInstructionsWithCopyableElements();\n   if (((!HasCopyables && doesNotNeedToSchedule(VL)) ||\n        all_of(VL, [&](Value *V) { return S.isNonSchedulable(V); }))) {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/commutable-node-with-non-sched-parent.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -slp-threshold=-99999 -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine void @test() {\n;\nbb:\n  br i1 false, label %bb1, label %bb9\n\nbb1:\n  %add = add i32 0, 0\n  %shl = shl i32 %add, 0\n  %sub = sub i32 0, 1\n  %add2 = add i32 %sub, %shl\n  %add3 = add i32 0, 0\n  %shl4 = shl i32 %add3, 0\n  %ashr = ashr i32 %shl4, 1\n  %add5 = add i32 0, 0\n  br label %bb6\n\nbb6:\n  %phi = phi i32 [ %add2, %bb1 ]\n  %phi7 = phi i32 [ %ashr, %bb1 ]\n  %phi8 = phi i32 [ %add5, %bb1 ]\n  br label %bb9\n\nbb9:\n  %phi10 = phi i32 [ poison, %bb ], [ %phi, %bb6 ]\n  %phi11 = phi i32 [ 0, %bb ], [ %phi7, %bb6 ]\n  %phi12 = phi i32 [ 0, %bb ], [ %phi, %bb6 ]\n  %phi13 = phi i32 [ 0, %bb ], [ %phi8, %bb6 ]\n  %or = or i32 %phi12, 0\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion `all_of(Bundles, [](const ScheduleBundle *Bundle) { return Bundle->isScheduled(); }) && \"must be scheduled at this point\"' failed. Yet another.",
    "body": "To reproduce run opt with the test below using -passes=slp-vectorizer -slp-threshold=-99999:\n```\n; ModuleID = './reduced.ll'\nsource_filename = \"./reduced.ll\"\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @wombat() #0 gc \"statepoint-example\" {\nbb:\n  br i1 false, label %bb1, label %bb9\n\nbb1:                                              ; preds = %bb\n  %add = add i32 0, 0\n  %shl = shl i32 %add, 0\n  %sub = sub i32 0, 1\n  %add2 = add i32 %sub, %shl\n  %add3 = add i32 0, 0\n  %shl4 = shl i32 %add3, 0\n  %ashr = ashr i32 %shl4, 1\n  %add5 = add i32 0, 0\n  br label %bb6\n\nbb6:                                              ; preds = %bb1\n  %phi = phi i32 [ %add2, %bb1 ]\n  %phi7 = phi i32 [ %ashr, %bb1 ]\n  %phi8 = phi i32 [ %add5, %bb1 ]\n  br label %bb9\n\nbb9:                                              ; preds = %bb6, %bb\n  %phi10 = phi i32 [ poison, %bb ], [ %phi, %bb6 ]\n  %phi11 = phi i32 [ 0, %bb ], [ %phi7, %bb6 ]\n  %phi12 = phi i32 [ 0, %bb ], [ %phi, %bb6 ]\n  %phi13 = phi i32 [ 0, %bb ], [ %phi8, %bb6 ]\n  %or = or i32 %phi12, 0\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+prfchw,-cldemote,+avx,+aes,+sahf,+pclmul,-xop,+crc32,-amx-fp8,+xsaves,-avx512fp16,-usermsr,-sm4,-egpr,+sse4.1,-avx10.1,-avx512ifma,+xsave,+sse4.2,-tsxldtrk,-sm3,-ptwrite,-widekl,-movrs,-invpcid,+64bit,+xsavec,-avx512vpopcntdq,+cmov,-avx512vp2intersect,-avx512cd,+movbe,-avxvnniint8,-ccmp,-amx-int8,-kl,-sha512,-avxvnni,-rtm,+adx,+avx2,-hreset,-movdiri,-serialize,-vpclmulqdq,-avx512vl,-uintr,-cf,+clflushopt,-raoint,-cmpccxadd,+bmi,-amx-tile,+sse,-gfni,-avxvnniint16,-amx-fp16,-zu,-ndd,+xsaveopt,+rdrnd,-avx512f,-amx-bf16,-avx512bf16,-avx512vnni,-push2pop2,+cx8,-avx512bw,+sse3,-pku,-nf,-amx-tf32,-amx-avx512,+fsgsbase,+clzero,-mwaitx,-lwp,+lzcnt,+sha,-movdir64b,-ppx,+wbnoinvd,-enqcmd,-avxneconvert,-tbm,-pconfig,-amx-complex,+ssse3,+cx16,-avx10.2,+bmi2,+fma,+popcnt,-avxifma,+f16c,-avx512bitalg,-rdpru,+clwb,+mmx,+sse2,+rdseed,-avx512vbmi2,-prefetchi,-amx-movrs,+rdpid,-fma4,-avx512vbmi,-shstk,-vaes,-waitpkg,-sgx,+fxsr,-avx512dq,+sse4a\" }\n```\nReproducer: https://godbolt.org/z/zKqWEzx9x\n\nStack dump:\n```\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=slp-vectorizer -slp-threshold=-99999 <source>\n1.\tRunning pass \"function(slp-vectorizer)\" on module \"<source>\"\n2.\tRunning pass \"slp-vectorizer\" on function \"wombat\"\n #0 0x000000000596deb8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x596deb8)\n #1 0x000000000596ad64 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x00007da61d642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x00007da61d6969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x00007da61d642476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x00007da61d6287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x00007da61d62871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x00007da61d639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x000000000375746a llvm::slpvectorizer::BoUpSLP::scheduleBlock(llvm::slpvectorizer::BoUpSLP const&, llvm::slpvectorizer::BoUpSLP::BlockScheduling*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x375746a)\n #9 0x00000000037ab75a llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::SmallDenseSet<llvm::Value*, 4u, llvm::DenseMapInfo<llvm::Value*, void>> const&, llvm::Instruction*, llvm::ArrayRef<std::tuple<llvm::Value*, unsigned int, bool>>) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37ab75a)\n#10 0x00000000037afb24 llvm::slpvectorizer::BoUpSLP::vectorizeTree() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37afb24)\n#11 0x00000000037d04a0 llvm::SLPVectorizerPass::tryToVectorizeList(llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP&, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37d04a0)\n#12 0x00000000037d4ebf bool tryToVectorizeSequence<llvm::Value>(llvm::SmallVectorImpl<llvm::Value*>&, llvm::function_ref<bool (llvm::Value*, llvm::Value*)>, llvm::function_ref<bool (llvm::ArrayRef<llvm::Value*>, llvm::Value*)>, llvm::function_ref<bool (llvm::ArrayRef<llvm::Value*>, bool)>, bool, llvm::slpvectorizer::BoUpSLP&) (.constprop.0) SLPVectorizer.cpp:0:0\n#13 0x00000000037d61d8 llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37d61d8)\n#14 0x00000000037de0d6 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (.part.0) SLPVectorizer.cpp:0:0\n#15 0x00000000037decfb llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37decfb)\n#16 0x0000000002fa2ede llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2fa2ede)\n#17 0x000000000574d901 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x574d901)\n#18 0x0000000000efc88e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xefc88e)\n#19 0x000000000574bfca llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x574bfca)\n#20 0x000000000097337e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97337e)\n#21 0x000000000574b981 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x574b981)\n#22 0x000000000097d5aa llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::RTLIB::RuntimeLibcallsInfo&, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97d5aa)\n#23 0x0000000000971628 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x971628)\n#24 0x00007da61d629d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#25 0x00007da61d629e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#26 0x0000000000968835 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x968835)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "TatyanaDoubts",
    "labels": [
      "llvm:SLPVectorizer",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true
}