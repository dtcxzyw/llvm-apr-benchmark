{
  "bug_id": "161367",
  "issue_url": "https://github.com/llvm/llvm-project/issues/161367",
  "bug_type": "crash",
  "base_commit": "6e0d519b3937a2f96179e40f417bc5cc79f3adba",
  "knowledge_cutoff": "2025-09-30T13:05:25Z",
  "lit_test_dir": [
    "llvm/test/Transforms/CorrelatedValuePropagation"
  ],
  "hints": {
    "fix_commit": "d62776d03323e709abb8e4734e0ae36f76dba815",
    "components": [
      "LazyValueInfo"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/LazyValueInfo.cpp": [
        [
          1632,
          1650
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/LazyValueInfo.cpp": [
        "LazyValueInfoImpl::getEdgeValueLocal"
      ]
    }
  },
  "patch": "commit d62776d03323e709abb8e4734e0ae36f76dba815\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Wed Oct 1 14:20:10 2025 +0800\n\n    [LVI] Handle constant value lattice in `getEdgeValueLocal` (#161410)\n    \n    Closes https://github.com/llvm/llvm-project/issues/161367.\n    \n    In https://github.com/llvm/llvm-project/pull/157614, we ignored cases\n    where OpLatticeVal might be a constant or notconstant. Directly\n    returning the result causes a type mismatch. I apologize for the\n    oversight in the previous code review.\n    \n    This patch applies the cast op to constants. For notconstant value\n    lattices, I'd leave it as a todo (it is similar to the constant case,\n    except for trunc without nsw/nuw).\n\ndiff --git a/llvm/lib/Analysis/LazyValueInfo.cpp b/llvm/lib/Analysis/LazyValueInfo.cpp\nindex 6fb28072afe4..0e5bc481383a 100644\n--- a/llvm/lib/Analysis/LazyValueInfo.cpp\n+++ b/llvm/lib/Analysis/LazyValueInfo.cpp\n@@ -1632,19 +1632,25 @@ LazyValueInfoImpl::getEdgeValueLocal(Value *Val, BasicBlock *BBFrom,\n                 *getValueFromCondition(Usr->getOperand(0), Condition,\n                                        isTrueDest, /*UseBlockValue*/ false);\n \n-            if (!OpLatticeVal.isConstantRange())\n-              return OpLatticeVal;\n+            if (OpLatticeVal.isConstantRange()) {\n+              const unsigned ResultBitWidth =\n+                  Usr->getType()->getScalarSizeInBits();\n+              if (auto *Trunc = dyn_cast<TruncInst>(Usr))\n+                return ValueLatticeElement::getRange(\n+                    OpLatticeVal.getConstantRange().truncate(\n+                        ResultBitWidth, Trunc->getNoWrapKind()));\n \n-            const unsigned ResultBitWidth =\n-                Usr->getType()->getScalarSizeInBits();\n-            if (auto *Trunc = dyn_cast<TruncInst>(Usr))\n               return ValueLatticeElement::getRange(\n-                  OpLatticeVal.getConstantRange().truncate(\n-                      ResultBitWidth, Trunc->getNoWrapKind()));\n-\n-            return ValueLatticeElement::getRange(\n-                OpLatticeVal.getConstantRange().castOp(\n-                    cast<CastInst>(Usr)->getOpcode(), ResultBitWidth));\n+                  OpLatticeVal.getConstantRange().castOp(\n+                      cast<CastInst>(Usr)->getOpcode(), ResultBitWidth));\n+            }\n+            if (OpLatticeVal.isConstant()) {\n+              Constant *C = OpLatticeVal.getConstant();\n+              if (auto *CastC = ConstantFoldCastOperand(\n+                      cast<CastInst>(Usr)->getOpcode(), C, Usr->getType(), DL))\n+                return ValueLatticeElement::get(CastC);\n+            }\n+            return ValueLatticeElement::getOverdefined();\n           } else {\n             // If one of Val's operand has an inferred value, we may be able to\n             // infer the value of Val.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/CorrelatedValuePropagation/pr161367.ll",
      "commands": [
        "opt < %s -passes=correlated-propagation -S"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n; Make sure that we apply trunc to the edge value of %x.\n@g = external global i8\n\ndefine i16 @pr161367(i64 %x) {\n;\nentry:\n  %trunc = trunc i64 %x to i16\n  %exitcond = icmp eq i64 %x, sub (i64 0, i64 ptrtoint (ptr @g to i64))\n  br i1 %exitcond, label %exit, label %else\n\nelse:\n  br label %exit\n\nexit:\n  %ret = phi i16 [ %trunc, %entry ], [ 0, %else ]\n  ret i16 %ret\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[CVP] Assertion `getType() == V->getType() && \"All operands to PHI node must be the same type as the PHI node!\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/3anEc1bnb\n```\n; bin/opt -passes=correlated-propagation test.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@g_228 = external global [3 x i8]\n\ndefine i16 @func_219() {\nentry:\n  %0 = trunc i64 0 to i16\n  %exitcond = icmp eq i64 0, sub (i64 0, i64 ptrtoint (ptr @g_228 to i64))\n  br i1 %exitcond, label %lbl_1093.loopexit, label %for.cond373.preheader\n\nfor.cond373.preheader:                            ; preds = %entry\n  br label %lbl_1093.loopexit\n\nlbl_1093.loopexit:                                ; preds = %for.cond373.preheader, %entry\n  %storemerge.lcssa = phi i16 [ %0, %entry ], [ 0, %for.cond373.preheader ]\n  ret i16 %storemerge.lcssa\n}\n```\n```\nopt: /root/llvm-project/llvm/include/llvm/IR/Instructions.h:2718: void llvm::PHINode::setIncomingValue(unsigned int, llvm::Value*): Assertion `getType() == V->getType() && \"All operands to PHI node must be the same type as the PHI node!\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=correlated-propagation <source>\n1.\tRunning pass \"function(correlated-propagation)\" on module \"<source>\"\n2.\tRunning pass \"correlated-propagation\" on function \"func_219\"\n #0 0x00000000058f05c8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x58f05c8)\n #1 0x00000000058ed474 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x0000739263c42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x0000739263c969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x0000739263c42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x0000739263c287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x0000739263c2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x0000739263c39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x000000000452f3c5 runImpl(llvm::Function&, llvm::LazyValueInfo*, llvm::DominatorTree*, llvm::SimplifyQuery const&) CorrelatedValuePropagation.cpp:0:0\n #9 0x000000000452f5cb llvm::CorrelatedValuePropagationPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x452f5cb)\n#10 0x0000000002f5c97e llvm::detail::PassModel<llvm::Function, llvm::CorrelatedValuePropagationPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2f5c97e)\n#11 0x00000000056d7b01 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x56d7b01)\n#12 0x0000000000eecc6e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xeecc6e)\n#13 0x00000000056d606a llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x56d606a)\n#14 0x000000000097366e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97366e)\n#15 0x00000000056d5a21 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x56d5a21)\n#16 0x000000000097d77a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97d77a)\n#17 0x00000000009719c7 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9719c7)\n#18 0x0000739263c29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#19 0x0000739263c29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#20 0x0000000000968ad5 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x968ad5)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\n",
    "author": "dtcxzyw",
    "labels": [
      "crash-on-valid",
      "llvm:analysis",
      "generated by fuzzer"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}