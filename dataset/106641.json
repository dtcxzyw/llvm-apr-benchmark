{
  "bug_id": "106641",
  "issue_url": "https://github.com/llvm/llvm-project/issues/106641",
  "bug_type": "crash",
  "base_commit": "c8568f09577e9332d15edf98beb5376dc8d0672e",
  "knowledge_cutoff": "2024-08-29T23:08:58Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "f0e34f381866b82a26241f7e9aa5964f0dd11ebd",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          7147,
          7153
        ],
        [
          7250,
          7259
        ],
        [
          7284,
          7299
        ],
        [
          7364,
          7371
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel",
        "planContainsAdditionalSimplifications",
        "LoopVectorizationPlanner::cost",
        "canTruncateToMinimalBitwidth",
        "LoopVectorizationPlanner::precomputeCosts",
        "LoopVectorizationPlanner::computeBestVF"
      ]
    }
  },
  "patch": "commit f0e34f381866b82a26241f7e9aa5964f0dd11ebd\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Fri Aug 30 11:29:29 2024 +0100\n\n    [VPlan] Don't skip optimizable truncs in planContainsAdditionalSimps.\n    \n    A optimizable cast can also be removed by VPlan simplifications. Remove\n    the restriction from planContainsAdditionalSimplifications, as this\n    causes it to miss relevant simplifications, triggering false positives\n    for the cost decision verification.\n    \n    Also adds debug output for printing additional cost-precomputations.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/106641.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 6babfd1eee91..fa05b8dd2242 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -7147,7 +7147,12 @@ LoopVectorizationPlanner::precomputeCosts(VPlan &Plan, ElementCount VF,\n     if (!OrigLoop->contains(CondI) ||\n         !CostCtx.SkipCostComputation.insert(CondI).second)\n       continue;\n-    Cost += CostCtx.getLegacyCost(CondI, VF);\n+    InstructionCost CondICost = CostCtx.getLegacyCost(CondI, VF);\n+    LLVM_DEBUG({\n+      dbgs() << \"Cost of \" << CondICost << \" for VF \" << VF\n+             << \": exit condition instruction \" << *CondI << \"\\n\";\n+    });\n+    Cost += CondICost;\n     for (Value *Op : CondI->operands()) {\n       auto *OpI = dyn_cast<Instruction>(Op);\n       if (!OpI || any_of(OpI->users(), [&ExitInstrs, this](User *U) {\n@@ -7250,10 +7255,9 @@ InstructionCost LoopVectorizationPlanner::cost(VPlan &Plan,\n /// not have corresponding recipes in \\p Plan and are not marked to be ignored\n /// in \\p CostCtx. This means the VPlan contains simplification that the legacy\n /// cost-model did not account for.\n-static bool\n-planContainsAdditionalSimplifications(VPlan &Plan, ElementCount VF,\n-                                      VPCostContext &CostCtx, Loop *TheLoop,\n-                                      LoopVectorizationCostModel &CM) {\n+static bool planContainsAdditionalSimplifications(VPlan &Plan,\n+                                                  VPCostContext &CostCtx,\n+                                                  Loop *TheLoop) {\n   // First collect all instructions for the recipes in Plan.\n   auto GetInstructionForCost = [](const VPRecipeBase *R) -> Instruction * {\n     if (auto *S = dyn_cast<VPSingleDefRecipe>(R))\n@@ -7284,16 +7288,13 @@ planContainsAdditionalSimplifications(VPlan &Plan, ElementCount VF,\n   // Return true if the loop contains any instructions that are not also part of\n   // the VPlan or are skipped for VPlan-based cost computations. This indicates\n   // that the VPlan contains extra simplifications.\n-  return any_of(\n-      TheLoop->blocks(), [&SeenInstrs, VF, &CostCtx, &CM](BasicBlock *BB) {\n-        return any_of(*BB, [&SeenInstrs, VF, &CostCtx, &CM](Instruction &I) {\n-          if (isa<PHINode>(&I))\n-            return false;\n-          return !SeenInstrs.contains(&I) &&\n-                 !CostCtx.skipCostComputation(&I, true) &&\n-                 !CM.canTruncateToMinimalBitwidth(&I, VF);\n-        });\n-      });\n+  return any_of(TheLoop->blocks(), [&SeenInstrs, &CostCtx](BasicBlock *BB) {\n+    return any_of(*BB, [&SeenInstrs, &CostCtx](Instruction &I) {\n+      if (isa<PHINode>(&I))\n+        return false;\n+      return !SeenInstrs.contains(&I) && !CostCtx.skipCostComputation(&I, true);\n+    });\n+  });\n }\n #endif\n \n@@ -7364,8 +7365,7 @@ VectorizationFactor LoopVectorizationPlanner::computeBestVF() {\n   precomputeCosts(BestPlan, BestFactor.Width, CostCtx);\n   assert((BestFactor.Width == LegacyVF.Width ||\n           planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width),\n-                                                BestFactor.Width, CostCtx,\n-                                                OrigLoop, CM)) &&\n+                                                CostCtx, OrigLoop)) &&\n          \" VPlan cost model and legacy cost model disagreed\");\n   assert((BestFactor.Width.isScalar() || BestFactor.ScalarCost > 0) &&\n          \"when vectorizing, the scalar cost must be computed.\");\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/truncate-to-minimal-bitwidth-cost.ll",
      "commands": [
        "opt -p loop-vectorize -mattr=+v -S %s"
      ],
      "tests": [
        {
          "test_name": "truncate_to_i1_used_by_branch",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @truncate_to_i1_used_by_branch(i8 %x, ptr %dst) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %f.039 = phi i8 [ 0, %entry ], [ %add, %loop.latch ]\n  %0 = or i8 23, %x\n  %extract.t = trunc i8 %0 to i1\n  br i1 %extract.t, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  store i8 0, ptr %dst, align 1\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %add = add i8 %f.039, 1\n  %conv = sext i8 %f.039 to i32\n  %cmp = icmp slt i32 %conv, 1\n  br i1 %cmp, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v,+zvl256b\" }\n"
        },
        {
          "test_name": "test_pr98413_sext_removed",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @test_pr98413_sext_removed(ptr %src, ptr noalias %dst, i64 %x) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.src = getelementptr inbounds i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep.src, align 8\n  %ext.l = sext i16 %l to i64\n  %and = and i64 %x, %ext.l\n  %trunc.and = trunc i64 %and to i8\n  %gep.dst = getelementptr inbounds i8, ptr %dst, i64 %iv\n  store i8 %trunc.and, ptr %gep.dst, align 1\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv, 96\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "test_pr98413_zext_removed",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @test_pr98413_zext_removed(ptr %src, ptr noalias %dst, i64 %x) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.src = getelementptr inbounds i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep.src, align 8\n  %ext.l = zext i16 %l to i64\n  %and = and i64 %x, %ext.l\n  %trunc.and = trunc i64 %and to i8\n  %gep.dst = getelementptr inbounds i8, ptr %dst, i64 %iv\n  store i8 %trunc.and, ptr %gep.dst, align 1\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv, 96\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[VPlan] Assertion \" VPlan cost model and legacy cost model disagreed\"' failed.",
    "body": "Tested using c4906588ce47de33d59bcd95f3e82ce2c3e61c23\r\n\r\nTestcase:\r\n```c\r\n_Bool a;\r\nchar b;\r\nunsigned char c;\r\nvoid d(_Bool e[][6]) {\r\n  for (signed char f = 0; f < c; f += 3)\r\n    for (_Bool g = ({\r\n           __typeof__(0) h = e[1][2];\r\n           e[f][f] > h ?: h;\r\n         });\r\n         g; g = b)\r\n      for (_Bool i = 0; i < (0 >= 0); i = 1)\r\n        a = 0;\r\n}\r\n```\r\nhttps://godbolt.org/z/Eab8s5e1K\r\n\r\nReduced LLVM IR Testcase:\r\n```llvm ir\r\n; ModuleID = 'reduced.bc'\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine void @d() #0 {\r\nentry:\r\n  br label %for.body\r\n\r\nfor.cond.cleanup.loopexit:                        ; preds = %for.cond.cleanup14\r\n  ret void\r\n\r\nfor.body:                                         ; preds = %for.cond.cleanup14, %entry\r\n  %f.039 = phi i8 [ %add, %for.cond.cleanup14 ], [ 0, %entry ]\r\n  %0 = or i8 0, 0\r\n  %extract.t = trunc i8 %0 to i1\r\n  br i1 %extract.t, label %for.body22.lr.ph, label %for.cond.cleanup14\r\n\r\nfor.body22.lr.ph:                                 ; preds = %for.body\r\n  store i8 0, ptr null, align 1\r\n  br label %for.cond.cleanup14\r\n\r\nfor.cond.cleanup14:                               ; preds = %for.body22.lr.ph, %for.body\r\n  %add = add i8 %f.039, 1\r\n  %conv = sext i8 %f.039 to i32\r\n  %cmp = icmp slt i32 %conv, 1\r\n  br i1 %cmp, label %for.body, label %for.cond.cleanup.loopexit\r\n}\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+a,+c,+d,+f,+m,+relax,+v,+zicsr,+zifencei,+zmmul,+zve32f,+zve32x,+zve64d,+zve64f,+zve64x,+zvl128b,+zvl256b,+zvl32b,+zvl64b,-b,-e,-experimental-smctr,-experimental-smmpm,-experimental-smnpm,-experimental-ssctr,-experimental-ssnpm,-experimental-sspm,-experimental-supm,-experimental-zacas,-experimental-zalasr,-experimental-zicfilp,-experimental-zicfiss,-experimental-zvbc32e,-experimental-zvkgs,-h,-shcounterenw,-shgatpa,-shtvala,-shvsatpa,-shvstvala,-shvstvecd,-smaia,-smcdeleg,-smcsrind,-smepmp,-smstateen,-ssaia,-ssccfg,-ssccptr,-sscofpmf,-sscounterenw,-sscsrind,-ssqosid,-ssstateen,-ssstrict,-sstc,-sstvala,-sstvecd,-ssu64xl,-svade,-svadu,-svbare,-svinval,-svnapot,-svpbmt,-xcvalu,-xcvbi,-xcvbitmanip,-xcvelw,-xcvmac,-xcvmem,-xcvsimd,-xsfcease,-xsfvcp,-xsfvfnrclipxfqf,-xsfvfwmaccqqq,-xsfvqmaccdod,-xsfvqmaccqoq,-xsifivecdiscarddlone,-xsifivecflushdlone,-xtheadba,-xtheadbb,-xtheadbs,-xtheadcmo,-xtheadcondmov,-xtheadfmemidx,-xtheadmac,-xtheadmemidx,-xtheadmempair,-xtheadsync,-xtheadvdot,-xventanacondops,-xwchc,-za128rs,-za64rs,-zaamo,-zabha,-zalrsc,-zama16b,-zawrs,-zba,-zbb,-zbc,-zbkb,-zbkc,-zbkx,-zbs,-zca,-zcb,-zcd,-zce,-zcf,-zcmop,-zcmp,-zcmt,-zdinx,-zfa,-zfbfmin,-zfh,-zfhmin,-zfinx,-zhinx,-zhinxmin,-zic64b,-zicbom,-zicbop,-zicboz,-ziccamoa,-ziccif,-zicclsm,-ziccrse,-zicntr,-zicond,-zihintntl,-zihintpause,-zihpm,-zimop,-zk,-zkn,-zknd,-zkne,-zknh,-zkr,-zks,-zksed,-zksh,-zkt,-ztso,-zvbb,-zvbc,-zvfbfmin,-zvfbfwma,-zvfh,-zvfhmin,-zvkb,-zvkg,-zvkn,-zvknc,-zvkned,-zvkng,-zvknha,-zvknhb,-zvks,-zvksc,-zvksed,-zvksg,-zvksh,-zvkt,-zvl1024b,-zvl16384b,-zvl2048b,-zvl32768b,-zvl4096b,-zvl512b,-zvl65536b,-zvl8192b\" }\r\n```\r\n\r\nCommand/backtrace:\r\n```\r\n> /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes=loop-vectorize reduced.ll -S\r\nopt: /scratch/tc-testing/tc-compiler-fuzz-trunk/llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7365: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), BestFactor.Width, CostCtx, OrigLoop, CM)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes=loop-vectorize reduced.ll -S\r\n1.      Running pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"reduced.ll\"\r\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"d\"\r\n #0 0x000064cd5b412560 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x301e560)\r\n #1 0x000064cd5b40f96f llvm::sys::RunSignalHandlers() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x301b96f)\r\n #2 0x000064cd5b40fac5 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x000072ec5a042520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x000072ec5a0969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x000072ec5a0969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x000072ec5a0969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x000072ec5a042476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x000072ec5a0287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x000072ec5a02871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x000072ec5a039e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x000064cd5a3dd109 llvm::LoopVectorizationPlanner::computeBestVF() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1fe9109)\r\n#12 0x000064cd5a3f3ccb llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1fffccb)\r\n#13 0x000064cd5a3f6ce1 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2002ce1)\r\n#14 0x000064cd5a3f7357 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2003357)\r\n#15 0x000064cd592541b6 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe601b6)\r\n#16 0x000064cd5b21d41f llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e2941f)\r\n#17 0x000064cd59257346 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe63346)\r\n#18 0x000064cd5b21c19b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e2819b)\r\n#19 0x000064cd592535e6 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe5f5e6)\r\n#20 0x000064cd5b21a1dd llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e261dd)\r\n#21 0x000064cd58a7c106 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x688106)\r\n#22 0x000064cd58a6de91 optMain (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x679e91)\r\n#23 0x000072ec5a029d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#24 0x000072ec5a029e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#25 0x000072ec5a029e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#26 0x000064cd58a64245 _start (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x670245)\r\nzsh: IOT instruction (core dumped)  /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt\r\n```\r\nhttps://godbolt.org/z/EzdEYKW7c\r\n\r\nFound via fuzzer\r\n\r\nRelated/prior issue: #106417\r\n\r\ncc @fhahn",
    "author": "patrick-rivos",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  }
}
