{
  "bug_id": "156190",
  "issue_url": "https://github.com/llvm/llvm-project/issues/156190",
  "bug_type": "miscompilation",
  "base_commit": "9fdf2c7105972f16137bfc74456617dd4669febe",
  "knowledge_cutoff": "2025-08-30T16:34:01Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "055e4ff35ab0789494ff9a3d41e3182a3aca8d0a",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          4017,
          4025
        ],
        [
          4029,
          4034
        ],
        [
          4036,
          4041
        ],
        [
          4049,
          4054
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::narrowInterleaveGroups"
      ]
    }
  },
  "patch": "commit 055e4ff35ab0789494ff9a3d41e3182a3aca8d0a\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Wed Sep 10 19:22:30 2025 +0100\n\n    [VPlan] Don't narrow op multiple times in narrowInterleaveGroups.\n    \n    Track which ops already have been narrowed, to avoid narrowing the same\n    operation multiple times. Repeated narrowing will lead to incorrect\n    results, because we could first narrow from an interleave group -> wide\n    load, and then narrow the wide load > single-scalar load.\n    \n    Fixes thttps://github.com/llvm/llvm-project/issues/156190.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex 6b122e19c016..ecb0f093e772 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -4017,9 +4017,10 @@ void VPlanTransforms::narrowInterleaveGroups(VPlan &Plan, ElementCount VF,\n     return;\n \n   // Convert InterleaveGroup \\p R to a single VPWidenLoadRecipe.\n-  auto NarrowOp = [](VPValue *V) -> VPValue * {\n+  SmallPtrSet<VPValue *, 4> NarrowedOps;\n+  auto NarrowOp = [&NarrowedOps](VPValue *V) -> VPValue * {\n     auto *R = V->getDefiningRecipe();\n-    if (!R)\n+    if (!R || NarrowedOps.contains(V))\n       return V;\n     if (auto *LoadGroup = dyn_cast<VPInterleaveRecipe>(R)) {\n       // Narrow interleave group to wide load, as transformed VPlan will only\n@@ -4029,6 +4030,7 @@ void VPlanTransforms::narrowInterleaveGroups(VPlan &Plan, ElementCount VF,\n           LoadGroup->getAddr(), LoadGroup->getMask(), /*Consecutive=*/true,\n           /*Reverse=*/false, {}, LoadGroup->getDebugLoc());\n       L->insertBefore(LoadGroup);\n+      NarrowedOps.insert(L);\n       return L;\n     }\n \n@@ -4036,6 +4038,7 @@ void VPlanTransforms::narrowInterleaveGroups(VPlan &Plan, ElementCount VF,\n       assert(RepR->isSingleScalar() &&\n              isa<LoadInst>(RepR->getUnderlyingInstr()) &&\n              \"must be a single scalar load\");\n+      NarrowedOps.insert(RepR);\n       return RepR;\n     }\n     auto *WideLoad = cast<VPWidenLoadRecipe>(R);\n@@ -4049,6 +4052,7 @@ void VPlanTransforms::narrowInterleaveGroups(VPlan &Plan, ElementCount VF,\n                                     /*IsUniform*/ true,\n                                     /*Mask*/ nullptr, *WideLoad);\n     N->insertBefore(WideLoad);\n+    NarrowedOps.insert(N);\n     return N;\n   };\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/transform-narrow-interleave-to-widen-memory-with-wide-ops.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=2 -force-vector-interleave=1 -S %s",
        "opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "multiple_store_groups_storing_same_wide_bin_op",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"arm64-apple-macosx\"\n\ndefine void @multiple_store_groups_storing_same_wide_bin_op(ptr noalias %A, ptr noalias %B, ptr noalias %C) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.A = getelementptr { double, double }, ptr %A, i64 %iv\n  %l.A.0 = load double, ptr %gep.A, align 8\n  %gep.A.1 = getelementptr inbounds nuw i8, ptr %gep.A, i64 8\n  %l.A.1 = load double, ptr %gep.A.1, align 8\n  %add.0 = fadd contract double %l.A.0, 2.000000e+01\n  %add.1 = fadd contract double %l.A.1, 2.000000e+01\n  %gep.B = getelementptr { double, double }, ptr %B, i64 %iv\n  store double %add.0, ptr %gep.B, align 8\n  %gep.B.1 = getelementptr inbounds nuw i8, ptr %gep.B, i64 8\n  store double %add.1, ptr %gep.B.1, align 8\n  %gep.C = getelementptr { double, double }, ptr %C, i64 %iv\n  %gep.C.1 = getelementptr inbounds nuw i8, ptr %gep.C, i64 8\n  store double %add.0, ptr %gep.C, align 8\n  store double %add.1, ptr %gep.C.1, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %.not = icmp eq i64 %iv.next, 1000\n  br i1 %.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Wrong Answer after LoopVectorize on Arm",
    "body": "[Found in this Fortran test case](https://github.com/fujitsu/compiler-test-suite/blob/main/Fortran/0631/0631_0058.f). We find incorrect answers after loop-vectorize and only see this on aarch64. This is the LLVM IR before and after loop vectorize, with the dependency on the Fortran runtime removed:\n\n* [Before loop vectorize](https://godbolt.org/z/boEbPWxYK) (good output)\n* [After loop vectorize](https://godbolt.org/z/5hYEeshed) (bad output)\n* [Opt LV debug output](https://godbolt.org/z/aPKbqv6qG)\n\nThis is the expected output of the program alongside the output after LV:\n```\nGood:\nv[90][90] = 40.000000 + 0.000000i\ny[90][90] = 21.000000 + 0.000000i\n\nBad:\nv[90][90] = 40.000000 + 40.000000i ;; << real component sum is written to both\ny[90][90] = 21.000000 + 0.000000i\n```\n\nYou can see the real component is written to both the real and imaginary component of this array. If we replace the two instructions responsible for computing the imaginary component, the test yields the expected output again:\n\n```diff\n139,141c139,140\n<   %broadcast.splatinsert13 = insertelement <2 x double> poison, double %47, i64 0, !dbg !8\n<   %broadcast.splat14 = shufflevector <2 x double> %broadcast.splatinsert13, <2 x double> poison, <2 x i32> zeroinitializer, !dbg !8\n<   %48 = fadd contract <2 x double> %broadcast.splat12, %broadcast.splat14, !dbg !8\n---\n>   %wide.load.x = load <2 x double>, ptr %46, align 8, !dbg !8\n>   %48 = fadd contract <2 x double> %wide.load, %wide.load.x, !dbg !8\n```\n\n[This godbolt link has the corrected IR](https://godbolt.org/z/78ofh1Yeh):\n\n```llvm\n  ; this looks wrong\n  %47 = load double, ptr %46, align 8, !dbg !8\n  %broadcast.splatinsert13 = insertelement <2 x double> poison, double %47, i64 0, !dbg !8\n  %broadcast.splat14 = shufflevector <2 x double> %broadcast.splatinsert13, <2 x double> poison, <2 x i32> zeroinitializer, !dbg !8\n  %48 = fadd contract <2 x double> %broadcast.splat12, %broadcast.splat14, !dbg !8\n\n  ; Hand-edits which give expected results\n  ;%wide.load.x = load <2 x double>, ptr %46, align 8, !dbg !8\n  ;%48 = fadd contract <2 x double> %wide.load, %wide.load.x, !dbg !8\n```\n\nNote that if we compile the exact same IR pre-LV for a generic x86 architecture we do not see the same behavior:\n```shell\n> opt /home/amancinelli/tmp.iJQ3cjnSSc-before-pass-316.ll -passes=loop-vectorize -S -o /tmp/t.ll && clang /tmp/t.ll && ./a.out\nopt: WARNING: failed to create target machine for 'aarch64-unknown-linux-gnu': unable to get target for 'aarch64-unknown-linux-gnu', see --version and --triple.\nwarning: overriding the module target triple with x86_64-unknown-linux-gnu\n      [-Woverride-module]\n1 warning generated.\nv[90][90] = 40.000000 + 0.000000i\ny[90][90] = 21.000000 + 0.000000i\n```",
    "author": "ashermancinelli",
    "labels": [
      "miscompilation",
      "release:backport",
      "vectorizers"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "Should be fixed by 055e4ff35ab0789494ff9a3d41e3182a3aca8d0a"
      },
      {
        "author": "nikic",
        "body": "Does this need backporting, or is it a new issue?"
      },
      {
        "author": "fhahn",
        "body": "Yes we should back-port this, https://godbolt.org/z/q7hn6vGdY"
      },
      {
        "author": "fhahn",
        "body": "Cherry-pick PR: https://github.com/llvm/llvm-project/pull/158013"
      },
      {
        "author": "fhahn",
        "body": "Fix for this landed on the release branch as well: https://github.com/llvm/llvm-project/commit/661c387fc2f16c5d2a6ef2843b0e5874b259a3e8"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}