{
  "bug_id": "154330",
  "issue_url": "https://github.com/llvm/llvm-project/issues/154330",
  "bug_type": "crash",
  "base_commit": "b20c291baec94ba3707e92b86836ff1c4bceda8c",
  "knowledge_cutoff": "2025-08-19T13:11:46Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "d67dba5e8880bdd856b0d3812dcdccf8c7902aba",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanUnroll.cpp": [
        [
          473,
          480
        ],
        [
          482,
          492
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanUnroll.cpp": [
        "cloneForLane"
      ]
    }
  },
  "patch": "commit d67dba5e8880bdd856b0d3812dcdccf8c7902aba\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Thu Aug 21 11:34:49 2025 +0100\n\n    [VPlan] Check Def2LaneDefs first in cloneForLane. (NFC)\n    \n    If we have entries in Def2LaneDefs, we always have to use it. Move the\n    check before.\n    \n    Otherwise we may not pick the correct operand, e.g. if Op was a\n    replicate recipe that got single-scalar after replicating it.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/154330.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanUnroll.cpp b/llvm/lib/Transforms/Vectorize/VPlanUnroll.cpp\nindex 62fd83a5e092..d47d76d20373 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanUnroll.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanUnroll.cpp\n@@ -473,8 +473,11 @@ cloneForLane(VPlan &Plan, VPBuilder &Builder, Type *IdxTy,\n   // Collect the operands at Lane, creating extracts as needed.\n   SmallVector<VPValue *> NewOps;\n   for (VPValue *Op : RepR->operands()) {\n-    if (vputils::isSingleScalar(Op)) {\n-      NewOps.push_back(Op);\n+    // If Op is a definition that has been unrolled, directly use the clone for\n+    // the corresponding lane.\n+    auto LaneDefs = Def2LaneDefs.find(Op);\n+    if (LaneDefs != Def2LaneDefs.end()) {\n+      NewOps.push_back(LaneDefs->second[Lane.getKnownLane()]);\n       continue;\n     }\n     if (Lane.getKind() == VPLane::Kind::ScalableLast) {\n@@ -482,11 +485,8 @@ cloneForLane(VPlan &Plan, VPBuilder &Builder, Type *IdxTy,\n           Builder.createNaryOp(VPInstruction::ExtractLastElement, {Op}));\n       continue;\n     }\n-    // If Op is a definition that has been unrolled, directly use the clone for\n-    // the corresponding lane.\n-    auto LaneDefs = Def2LaneDefs.find(Op);\n-    if (LaneDefs != Def2LaneDefs.end()) {\n-      NewOps.push_back(LaneDefs->second[Lane.getKnownLane()]);\n+    if (vputils::isSingleScalar(Op)) {\n+      NewOps.push_back(Op);\n       continue;\n     }\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/replicate-recipe-with-only-first-lane-used.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "uniform_load_replicating_select",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine float @uniform_load_replicating_select(ptr %A, ptr %B, i64 %0) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %l = load float, ptr %A, align 4\n  %c = fcmp ogt float %l, 0.000000e+00\n  %gep.B = getelementptr inbounds float, ptr %B, i64 %iv\n  %sel.ptr = select i1 %c, ptr %A, ptr %gep.B\n  %base = select i1 %c, float 1.000000e+01, float 1.000000e+00\n  %l.2 = load float, ptr %sel.ptr, align 4\n  %div = fdiv float 4.000000e+00, %l.2\n  %pow = tail call float @llvm.pow.f32(float %base, float %div)\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, %0\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret float %pow\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.pow.f32(float, float) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion in Vectorize/VPlan.cpp \"trying to delete a VPValue with remaining users\"",
    "body": "```\n$ clang -c -O2 repro.ll\nclang: .../Linux_x86_64/llvm/lib/Transforms/Vectorize/VPlan.cpp:95: virtual llvm::VPValue::~VPValue(): Assertion `Us\ners.empty() && \"trying to delete a VPValue with remaining users\"' failed.                                                        PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, \nand associated run script.                                                                                                       \nStack dump:                                                                                                                      0.      Program arguments: ...//bin/clang -c -O2 repro.ll                                        1.      Optimizer \n2.      Running pass \"function<eager-inv>(float2int,lower-constant-intrinsics,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer\n-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-inst\ns;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O2>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fi\nxpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-l\noads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"repro.ll\"                                                                                                                        \n3.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"_Qtest\"                  \n #0 0x00000000046945a8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/.../bin/clang+0x4694\n5a8)                                                                                                                             \n #1 0x00000000046919cc llvm::sys::CleanupOnSignal(unsigned long) (.../bin/clang+0x46919cc)\n #2 0x00000000045de438 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0     \n #3 0x00007fe4b29d7420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)      \n #4 0x00007fe4b25ee00b raise /build/glibc-FcRMwW/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise.c:51:1\n #5 0x00007fe4b25cd859 abort /build/glibc-FcRMwW/glibc-2.31/stdlib/abort.c:81:7\n #6 0x00007fe4b25cd729 get_sysdep_segment_value /build/glibc-FcRMwW/glibc-2.31/intl/loadmsgcat.c:509:8\n #7 0x00007fe4b25cd729 _nl_load_domain /build/glibc-FcRMwW/glibc-2.31/intl/loadmsgcat.c:970:34\n #8 0x00007fe4b25defd6 (/lib/x86_64-linux-gnu/libc.so.6+0x33fd6) \n #9 0x0000000005f1d824 llvm::VPValue::~VPValue() (.../bin/clang+0x5f1d824)\n#10 0x0000000005f42356 llvm::VPReplicateRecipe::~VPReplicateRecipe() VPlanRecipes.cpp:0:0\n#11 0x0000000005f476ce llvm::VPRecipeBase::eraseFromParent() (.../bin/clang+0x5f476ce)\n#12 0x0000000005fc3514 llvm::VPlanTransforms::replicateByVF(llvm::VPlan&, llvm::ElementCount) (.../bin/clang+0x5fc3514)                                         \n#13 0x0000000005f02594 llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoo\npVectorizer&, llvm::DominatorTree*, bool) (.../bin/clang+0x5f02594)\n#14 0x0000000005f1691f llvm::LoopVectorizePass::processLoop(llvm::Loop*) (.../bin/clang+0x5f1691\nf)\n#15 0x0000000005f187c0 llvm::LoopVectorizePass::runImpl(llvm::Function&) (.../bin/clang+0x5f187c\n0)\n#16 0x0000000005f18e27 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (.../bin/clang+0x5f18e27)\n#17 0x0000000005b0379e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::r\nun(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) PassBuilder.cpp:0:0\n...\n```\nReduced reproducer:\n```\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @_Qtest(ptr %0, ptr %1, ptr %2, i64 %3, float %4) {\n  br label %6\n\n6:                                                ; preds = %37, %5\n  %7 = phi float [ %.0, %37 ], [ 0.000000e+00, %5 ]\n  %8 = phi i64 [ %38, %37 ], [ %3, %5 ]\n  %9 = icmp sgt i64 %8, 0\n  br i1 %9, label %.critedge, label %39\n\n.critedge:                                        ; preds = %6\n  %10 = call ptr @llvm.stacksave.p0()\n  %11 = load float, ptr %2, align 4\n  %12 = fcmp ogt float %11, 0.000000e+00\n  br i1 %12, label %13, label %25\n\n13:                                               ; preds = %.critedge\n  %14 = load float, ptr %0, align 4\n  %15 = fdiv float 0.000000e+00, %14\n  %16 = load float, ptr %1, align 4\n  %17 = fmul float %14, 0.000000e+00\n  %18 = fdiv float %16, %17\n  %19 = fadd float %4, %18\n  %20 = call float @llvm.pow.f32(float 0.000000e+00, float %15)\n  %21 = fmul float %20, 0.000000e+00\n  %22 = fmul float %19, %4\n  %23 = call float @llvm.exp.f32(float %22)\n  %24 = fmul float %21, %23\n  br label %37\n\n25:                                               ; preds = %.critedge\n  %26 = load float, ptr %1, align 4\n  %27 = fdiv float 0.000000e+00, %26\n  %28 = load float, ptr %0, align 4\n  %29 = fmul float %26, 0.000000e+00\n  %30 = fdiv float %28, %29\n  %31 = fadd float %4, %30\n  %32 = call float @llvm.pow.f32(float %4, float %27)\n  %33 = fmul float %32, 0.000000e+00\n  %34 = fmul float %31, %4\n  %35 = call float @llvm.exp.f32(float %34)\n  %36 = fmul float %33, %35\n  br label %37\n\n37:                                               ; preds = %25, %13\n  %.0 = phi float [ %24, %13 ], [ %36, %25 ]\n  call void @llvm.stackrestore.p0(ptr %10)\n  %38 = add i64 %8, -1\n  br label %6\n\n39:                                               ; preds = %39, %6\n  store float %7, ptr %0, align 4\n  br label %39\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.pow.f32(float, float) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.exp.f32(float) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn\ndeclare ptr @llvm.stacksave.p0() #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn\ndeclare void @llvm.stackrestore.p0(ptr) #1\n\n; uselistorder directives\nuselistorder ptr @llvm.pow.f32, { 1, 0 }\nuselistorder ptr @llvm.exp.f32, { 1, 0 }\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn }\n```\nclang version:\n```\nclang version 22.0.0git (https://github.com/llvm/llvm-project 2f011ea37ad480fdf16e2364e0487409cb4d1c75)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\n```",
    "author": "eugeneepshteyn",
    "labels": [
      "regression",
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "eugeneepshteyn",
        "body": "LLVM build at commit ID 9ddc043538329a0a1386d12e191de7b4c43051e9 is known to work. The issue was introduced sometime after that."
      },
      {
        "author": "fhahn",
        "body": "Suspect this is caused by #151487 (7e9989390d95cbb382cb2dc9eb44b37717e23738). Taking a look"
      },
      {
        "author": "eugeneepshteyn",
        "body": "Thank you @fhahn , I can confirm that the larger use case that was the source of the reproducer also works now."
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}