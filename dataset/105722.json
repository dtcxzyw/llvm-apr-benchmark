{
  "bug_id": "105722",
  "issue_url": "https://github.com/llvm/llvm-project/issues/105722",
  "bug_type": "crash",
  "base_commit": "84497c6f4f6c79b0d8c38da666724eed7e9e8db5",
  "knowledge_cutoff": "2024-08-22T19:30:39Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "533e6bbd0d344a710c491a9eb0ce0ba0852b08cb",
    "components": [
      "VPRecipeBuilder"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h": [
        [
          13,
          18
        ],
        [
          173,
          178
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h": [
        "getVPValueOrAddLiveIn"
      ]
    }
  },
  "patch": "commit 533e6bbd0d344a710c491a9eb0ce0ba0852b08cb\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Mon Aug 26 09:15:58 2024 +0100\n\n    [VPlan] Simplify live-ins if they are SCEVConstant.\n    \n    The legacy cost model in some parts checks if any of the operands are\n    constants via SCEV. Update VPlan construction to replace live-ins that\n    are constants via SCEV with such constants. This means VPlans (and\n    codegen) reflects what we computing the cost of and removes another case\n    where the legacy and VPlan cost model diverged.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/105722.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h b/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h\nindex 0b27933925d8..0fbdeeddaf4a 100644\n--- a/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h\n+++ b/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h\n@@ -13,6 +13,7 @@\n #include \"VPlan.h\"\n #include \"llvm/ADT/DenseMap.h\"\n #include \"llvm/ADT/PointerUnion.h\"\n+#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n #include \"llvm/IR/IRBuilder.h\"\n \n namespace llvm {\n@@ -173,6 +174,11 @@ public:\n       if (auto *R = Ingredient2Recipe.lookup(I))\n         return R->getVPSingleValue();\n     }\n+    ScalarEvolution &SE = *PSE.getSE();\n+    if (!isa<Constant>(V) && SE.isSCEVable(V->getType()))\n+      if (auto *C = dyn_cast<SCEVConstant>(PSE.getSE()->getSCEV(V)))\n+        return Plan.getOrAddLiveIn(C->getValue());\n+\n     return Plan.getOrAddLiveIn(V);\n   }\n };\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-model.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7-avx -S"
      ],
      "tests": [
        {
          "test_name": "cost_assume",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @cost_assume(ptr %end, i64 %N) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %0 = phi i64 [ 0, %entry ], [ %1, %loop ]\n  %1 = add i64 %0, 1\n  %iv.next = add nsw i64 %iv, 1\n  %c = icmp ne i64 %N, 0\n  tail call void @llvm.assume(i1 %c)\n  %gep = getelementptr nusw [9 x i8], ptr null, i64 %iv.next\n  %ec = icmp eq ptr %gep, %end\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i64 %1\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "cost_model_1",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\n@c = external global [2048 x i32], align 16\n@b = external global [2048 x i32], align 16\n@d = external global [2048 x i32], align 16\n@a = external global [2048 x i32], align 16\n\n; Function Attrs: noinline nounwind ssp uwtable\ndefine void @cost_model_1() #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %0 = shl nsw i64 %indvars.iv, 1\n  %arrayidx = getelementptr inbounds [2048 x i32], ptr @c, i64 0, i64 %0\n  %1 = load i32, ptr %arrayidx, align 8\n  %idxprom1 = sext i32 %1 to i64\n  %arrayidx2 = getelementptr inbounds [2048 x i32], ptr @b, i64 0, i64 %idxprom1\n  %2 = load i32, ptr %arrayidx2, align 4\n  %arrayidx4 = getelementptr inbounds [2048 x i32], ptr @d, i64 0, i64 %indvars.iv\n  %3 = load i32, ptr %arrayidx4, align 4\n  %idxprom5 = sext i32 %3 to i64\n  %arrayidx6 = getelementptr inbounds [2048 x i32], ptr @a, i64 0, i64 %idxprom5\n  store i32 %2, ptr %arrayidx6, align 4\n  %indvars.iv.next = add i64 %indvars.iv, 1\n  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, 256\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { noinline nounwind ssp uwtable }\n"
        },
        {
          "test_name": "avx512_cond_load_cost",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @avx512_cond_load_cost(ptr %src, i32 %a, i64 %b, i32 %c, i32 %d) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %c.1 = icmp slt i32 %iv, 0\n  br i1 %c.1, label %if.then, label %loop.latch\n\nif.then:                                          ; preds = %loop.header\n  %0 = urem i32 %a, %c\n  %mul = sub i32 0, %0\n  %div = udiv i32 %c, %d\n  %or = or i32 %div, %mul\n  %ext = sext i32 %or to i64\n  %gep = getelementptr { i64, i64, i64 }, ptr %src, i64 %ext, i32 2\n  %l = load i64, ptr %gep, align 8\n  %or.2 = or i64 %l, %b\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %if.then, %loop.header\n  %res = phi i64 [ 0, %loop.header ], [ %or.2, %if.then ]\n  %iv.next = add i32 %iv, 1\n  %ec = icmp ult i32 %iv, %c\n  br i1 %ec, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret i64 %res\n}\n\nattributes #0 = { \"target-features\"=\"+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl\" }\n"
        },
        {
          "test_name": "multi_exit",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @multi_exit(ptr %dst, ptr %src.1, ptr %src.2, i64 %A, i64 %B) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop.latch, %entry\n  %iv.1.wide = phi i64 [ 0, %entry ], [ %iv.1.next.wide, %loop.latch ]\n  %iv.1 = phi i32 [ 0, %entry ], [ %iv.1.next, %loop.latch ]\n  %ec.1 = icmp ult i64 %iv.1.wide, %A\n  br i1 %ec.1, label %loop.latch, label %exit\n\nloop.latch:                                       ; preds = %loop\n  %l.1 = load i64, ptr %src.1, align 8\n  %l.2 = load i64, ptr %src.2, align 8\n  %cmp55.us = icmp eq i64 %l.1, 0\n  %cmp.i.us = icmp ne i64 %l.2, 0\n  %and = and i1 %cmp.i.us, %cmp55.us\n  %ext = zext i1 %and to i8\n  store i8 %ext, ptr %dst, align 1\n  %iv.1.next = add i32 %iv.1, 1\n  %iv.1.next.wide = zext i32 %iv.1.next to i64\n  %ec.2 = icmp ult i64 %iv.1.next.wide, %B\n  br i1 %ec.2, label %loop, label %exit\n\nexit:                                             ; preds = %loop.latch, %loop\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"penryn\" }\n"
        },
        {
          "test_name": "cost_duplicate_recipe_for_sinking",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @cost_duplicate_recipe_for_sinking(ptr %A, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.shl = shl nsw i64 %iv, 2\n  %gep.0 = getelementptr nusw double, ptr %A, i64 %iv.shl\n  %l = load double, ptr %gep.0, align 8\n  %c = fcmp oeq double %l, 0.000000e+00\n  br i1 %c, label %if.then, label %loop.latch\n\nif.then:                                          ; preds = %loop.header\n  %gep.1 = getelementptr double, ptr %A, i64 %iv.shl\n  store double 0.000000e+00, ptr %gep.1, align 8\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %if.then, %loop.header\n  %iv.next = add nsw i64 %iv, 1\n  %ec = icmp eq i64 %iv, %N\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"znver3\" }\n"
        },
        {
          "test_name": "any_of_cost",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i1 @any_of_cost(ptr %start, ptr %end) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %any.of = phi i1 [ false, %entry ], [ %any.of.next, %loop ]\n  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop ]\n  %gep = getelementptr i8, ptr %ptr.iv, i64 8\n  %l = load ptr, ptr %gep, align 8\n  %cmp13.not.not = icmp eq ptr %l, null\n  %any.of.next = select i1 %cmp13.not.not, i1 %any.of, i1 false\n  %ptr.iv.next = getelementptr inbounds i8, ptr %ptr.iv, i64 40\n  %cmp.not = icmp eq ptr %ptr.iv, %end\n  br i1 %cmp.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i1 %any.of.next\n}\n\nattributes #0 = { \"target-cpu\"=\"penryn\" }\n"
        },
        {
          "test_name": "live_in_known_1_via_scev",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @live_in_known_1_via_scev() {\nentry:\n  %sel = select i1 false, i32 3, i32 0\n  br label %ph\n\nph:                                               ; preds = %entry\n  %p = phi i32 [ 1, %entry ]\n  %N = add nuw nsw i32 %sel, 6\n  %p.ext = zext nneg i32 %p to i64\n  br label %loop\n\nloop:                                             ; preds = %loop, %ph\n  %iv = phi i32 [ 0, %ph ], [ %iv.next, %loop ]\n  %red = phi i64 [ 3, %ph ], [ %red.mul, %loop ]\n  %red.mul = mul nsw i64 %red, %p.ext\n  %iv.next = add nuw nsw i32 %iv, 1\n  %ec = icmp eq i32 %iv.next, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  %res = phi i64 [ %red.mul, %loop ]\n  ret i64 %res\n}\n"
        },
        {
          "test_name": "reduction_store",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @reduction_store(ptr noalias %src, ptr %dst, i1 %x) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %red = phi i32 [ 0, %entry ], [ %red.next, %loop ]\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.src = getelementptr inbounds i32, ptr %src, i32 %iv\n  %l = load i32, ptr %gep.src, align 4\n  %l.and = and i32 %l, 3\n  store i32 %l.and, ptr %dst, align 4\n  %x.ext = zext i1 %x to i64\n  %lshr = lshr i64 %x.ext, 12\n  %t = trunc i64 %lshr to i32\n  %red.next = and i32 %red, %t\n  store i32 %red.next, ptr %dst, align 4\n  %iv.next = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 29\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"znver3\" }\n"
        },
        {
          "test_name": "PR27826",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine float @PR27826(ptr nocapture readonly %a, ptr nocapture readonly %b, i32 %n) {\nentry:\n  %cmp = icmp sgt i32 %n, 0\n  br i1 %cmp, label %preheader, label %for.end\n\npreheader:                                        ; preds = %entry\n  %t0 = sext i32 %n to i64\n  br label %for\n\nfor:                                              ; preds = %for, %preheader\n  %indvars.iv = phi i64 [ 0, %preheader ], [ %indvars.iv.next, %for ]\n  %s.02 = phi float [ 0.000000e+00, %preheader ], [ %add4, %for ]\n  %arrayidx = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  %t1 = load float, ptr %arrayidx, align 4\n  %arrayidx3 = getelementptr inbounds float, ptr %b, i64 %indvars.iv\n  %t2 = load float, ptr %arrayidx3, align 4\n  %add = fadd fast float %t1, %s.02\n  %add4 = fadd fast float %add, %t2\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 32\n  %cmp1 = icmp slt i64 %indvars.iv.next, %t0\n  br i1 %cmp1, label %for, label %loopexit\n\nloopexit:                                         ; preds = %for\n  %add4.lcssa = phi float [ %add4, %for ]\n  br label %for.end\n\nfor.end:                                          ; preds = %loopexit, %entry\n  %s.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %add4.lcssa, %loopexit ]\n  ret float %s.0.lcssa\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[clang] Assertion failed in Vectorize",
    "body": "To reproduce, compile it with -O2: clang -O2 example.c\r\n\r\n```c\r\n#include <stdint.h>\r\nint a;\r\nlong b;\r\nstatic int32_t c;\r\nvoid d(int e, int h) {\r\n  int f = a = 1;\r\n  for (; a <= e; a++)\r\n    f *= a;\r\n  a = 0;\r\n  for (; a < h; a++)\r\n    b *= f;\r\n}\r\nlong g() {}\r\nint32_t i() {\r\n  for (; g();)\r\n    for (c = 3;;)\r\n      ;\r\n}\r\nuint16_t j() { d(c + 1, c + 6); }\r\n```\r\n\r\nThe error message is as follows:\r\n\r\n```\r\nllvm/lib/Transforms/Vectorize/LoopVectorize.cpp:9985: bool llvm::LoopVectorizePass::processLoop(llvm::Loop *): Assertion `VF.Width == BestVF && \"VPlan cost model and legacy cost model disagreed\"' failed.\r\n```",
    "author": "cardigan1008",
    "labels": [
      "vectorizers",
      "confirmed",
      "crash"
    ],
    "comments": [
      {
        "author": "EugeneZelenko",
        "body": "See https://godbolt.org/z/jc8qqo8Ta"
      },
      {
        "author": "shafik",
        "body": "Looks like a recent regression since it does not crash on trunk: https://godbolt.org/z/sKjdvMq54\r\n\r\nAssertion:\r\n\r\n```console\r\nclang++: /root/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7288: \r\nllvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF():\r\nAssertion `BestFactor.Width == LegacyVF.Width && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\n```\r\n\r\nBacktrace: \r\n\r\n```console\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/clang++ -gdwarf-4 -g -o /app/output.s -mllvm --x86-asm-syntax=intel -fno-verbose-asm -S --gcc-toolchain=/opt/compiler-explorer/gcc-snapshot -fcolor-diagnostics -fno-crash-diagnostics -x c -O2 <source>\r\n1.\t<eof> parser at end of file\r\n2.\tOptimizer\r\n3.\tRunning pass \"function<eager-inv>(float2int,lower-constant-intrinsics,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-use-loop-info;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-use-loop-info;no-verify-fixpoint>,loop-unroll<O2>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-use-loop-info;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"<source>\"\r\n4.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"j\"\r\n #0 0x0000000003b02648 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x3b02648)\r\n #1 0x0000000003b0033c llvm::sys::CleanupOnSignal(unsigned long) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x3b0033c)\r\n #2 0x0000000003a492b8 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0\r\n #3 0x000078485ee42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x000078485ee969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #5 0x000078485ee42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #6 0x000078485ee287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #7 0x000078485ee2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #8 0x000078485ee39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #9 0x00000000054df418 llvm::LoopVectorizationPlanner::computeBestVF() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x54df418)\r\n#10 0x00000000054fa07a llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x54fa07a)\r\n#11 0x00000000054fcd39 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x54fcd39)\r\n#12 0x00000000054fd3c3 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x54fd3c3)\r\n#13 0x00000000050ac09e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x50ac09e)\r\n#14 0x00000000034cac68 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x34cac68)\r\n#15 0x00000000010bce6e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x10bce6e)\r\n#16 0x00000000034c966e llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x34c966e)\r\n#17 0x00000000010bc75e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x10bc75e)\r\n#18 0x00000000034c7800 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x34c7800)\r\n#19 0x0000000003da8895 (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&, clang::BackendConsumer*) BackendUtil.cpp:0:0\r\n#20 0x0000000003dab9fd clang::EmitBackendOutput(clang::DiagnosticsEngine&, clang::HeaderSearchOptions const&, clang::CodeGenOptions const&, clang::TargetOptions const&, clang::LangOptions const&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>, clang::BackendConsumer*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x3dab9fd)\r\n#21 0x00000000044196ac clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x44196ac)\r\n#22 0x000000000651f80c clang::ParseAST(clang::Sema&, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x651f80c)\r\n#23 0x0000000004419b18 clang::CodeGenAction::ExecuteAction() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x4419b18)\r\n#24 0x00000000046a79f9 clang::FrontendAction::Execute() (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x46a79f9)\r\n#25 0x000000000462b30e clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x462b30e)\r\n#26 0x000000000479104e clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x479104e)\r\n#27 0x0000000000ca5b0f cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0xca5b0f)\r\n#28 0x0000000000c9ed5a ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\r\n#29 0x000000000445d1d9 void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()>(long) Job.cpp:0:0\r\n#30 0x0000000003a49764 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x3a49764)\r\n#31 0x000000000445d7cf clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const (.part.0) Job.cpp:0:0\r\n#32 0x0000000004423365 clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x4423365)\r\n#33 0x0000000004423dcd clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x4423dcd)\r\n#34 0x000000000442b9e5 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0x442b9e5)\r\n#35 0x0000000000ca2f05 clang_main(int, char**, llvm::ToolContext const&) (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0xca2f05)\r\n#36 0x0000000000b776e4 main (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0xb776e4)\r\n#37 0x000078485ee29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#38 0x000078485ee29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#39 0x0000000000c9e80e _start (/opt/compiler-explorer/clang-assertions-trunk/bin/clang+++0xc9e80e)\r\nclang++: error: clang frontend command failed with exit code 134 (use -v to see invocation)\r\nCompiler returned: 134\r\n```"
      },
      {
        "author": "cardigan1008",
        "body": "The crash persists in the above cases even with the applied patches. "
      },
      {
        "author": "fhahn",
        "body": "@cardigan1008 I can't reproduce the crash locally with latest main. If it still reproduces on current main for you, could you share the crashing IR, using `-mllvm -print-on-crash -mllvm -print-module-scope`?"
      },
      {
        "author": "cardigan1008",
        "body": "@fhahn Apologies for the confusion. I pulled the latest version, and this case is now working. However, I encountered a similar crash with another case that I'm currently fuzzing. I'll open a separate issue as soon as I've finished reducing it."
      },
      {
        "author": "cardigan1008",
        "body": "Hi @fhahn , I have submitted another issue with the same crash in #106248 . "
      }
    ]
  }
}