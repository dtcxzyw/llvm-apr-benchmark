{
  "bug_id": "160068",
  "issue_url": "https://github.com/llvm/llvm-project/issues/160068",
  "bug_type": "crash",
  "base_commit": "eb17a8d599dbcadecba2529dcf9ac234b085088a",
  "knowledge_cutoff": "2025-09-22T10:47:10Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopInterchange"
  ],
  "hints": {
    "fix_commit": "b90a8d385e0d35a2e870aa7b4cf16ee37df10851",
    "components": [
      "LoopInterchange"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/LoopInterchange.cpp": [
        [
          43,
          48
        ],
        [
          1872,
          1877
        ],
        [
          1882,
          1887
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/LoopInterchange.cpp": [
        "LoopInterchangeTransform::adjustLoopBranches",
        "moveLCSSAPhis"
      ]
    }
  },
  "patch": "commit b90a8d385e0d35a2e870aa7b4cf16ee37df10851\nAuthor: Sjoerd Meijer <smeijer@nvidia.com>\nDate:   Mon Oct 20 10:23:36 2025 +0100\n\n    [LoopInterchange] Add simplifyLCSSAPhis: remove phi from non-exit bb  (#160889)\n    \n    This deals with a corner case of LCSSA phi nodes in the outer loop latch\n    block: the loop was in LCSSA form, some transformations can come along\n    (e.g. unswitch) and create an empty block:\n    \n         BB4:\n           br label %BB5\n         BB5:\n           %old.cond.lcssa = phi i16 [ %cond, %BB4 ]\n           br outer.header\n    \n    Interchange then brings it in LCSSA form again and we get:\n    \n         BB4:\n           %new.cond.lcssa = phi i16 [ %cond, %BB3 ]\n           br label %BB5\n         BB5:\n           %old.cond.lcssa = phi i16 [ %new.cond.lcssa, %BB4 ]\n    \n    Which means that we have a chain of LCSSA phi nodes from %new.cond.lcssa\n    to %old.cond.lcssa. The problem is that interchange can reoder blocks\n    BB4 and BB5 placing the use before the def if we don't check this. The\n    solution is to simplify lcssa phis, and remove them from non-exit blocks\n    if they are 1-input phi nodes.\n    \n    Fixes #160068\n\ndiff --git a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp\nindex 28ae4f0a0aad..9aaf6a5aa4d6 100644\n--- a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp\n+++ b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp\n@@ -43,6 +43,7 @@\n #include \"llvm/Support/raw_ostream.h\"\n #include \"llvm/Transforms/Scalar/LoopPassManager.h\"\n #include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n+#include \"llvm/Transforms/Utils/Local.h\"\n #include \"llvm/Transforms/Utils/LoopUtils.h\"\n #include <cassert>\n #include <utility>\n@@ -1872,6 +1873,51 @@ static void moveLCSSAPhis(BasicBlock *InnerExit, BasicBlock *InnerHeader,\n   InnerLatch->replacePhiUsesWith(InnerLatch, OuterLatch);\n }\n \n+/// This deals with a corner case when a LCSSA phi node appears in a non-exit\n+/// block: the outer loop latch block does not need to be exit block of the\n+/// inner loop. Consider a loop that was in LCSSA form, but then some\n+/// transformation like loop-unswitch comes along and creates an empty block,\n+/// where BB5 in this example is the outer loop latch block:\n+///\n+///   BB4:\n+///     br label %BB5\n+///   BB5:\n+///     %old.cond.lcssa = phi i16 [ %cond, %BB4 ]\n+///     br outer.header\n+///\n+/// Interchange then brings it in LCSSA form again resulting in this chain of\n+/// single-input phi nodes:\n+///\n+///   BB4:\n+///     %new.cond.lcssa = phi i16 [ %cond, %BB3 ]\n+///     br label %BB5\n+///   BB5:\n+///     %old.cond.lcssa = phi i16 [ %new.cond.lcssa, %BB4 ]\n+///\n+/// The problem is that interchange can reoder blocks BB4 and BB5 placing the\n+/// use before the def if we don't check this. The solution is to simplify\n+/// lcssa phi nodes (remove) if they appear in non-exit blocks.\n+///\n+static void simplifyLCSSAPhis(Loop *OuterLoop, Loop *InnerLoop) {\n+  BasicBlock *InnerLoopExit = InnerLoop->getExitBlock();\n+  BasicBlock *OuterLoopLatch = OuterLoop->getLoopLatch();\n+\n+  // Do not modify lcssa phis where they actually belong, i.e. in exit blocks.\n+  if (OuterLoopLatch == InnerLoopExit)\n+    return;\n+\n+  // Collect and remove phis in non-exit blocks if they have 1 input.\n+  SmallVector<PHINode *, 8> Phis(\n+      llvm::make_pointer_range(OuterLoopLatch->phis()));\n+  for (PHINode *Phi : Phis) {\n+    assert(Phi->getNumIncomingValues() == 1 && \"Single input phi expected\");\n+    LLVM_DEBUG(dbgs() << \"Removing 1-input phi in non-exit block: \" << *Phi\n+                      << \"\\n\");\n+    Phi->replaceAllUsesWith(Phi->getIncomingValue(0));\n+    Phi->eraseFromParent();\n+  }\n+}\n+\n bool LoopInterchangeTransform::adjustLoopBranches() {\n   LLVM_DEBUG(dbgs() << \"adjustLoopBranches called\\n\");\n   std::vector<DominatorTree::UpdateType> DTUpdates;\n@@ -1882,6 +1928,9 @@ bool LoopInterchangeTransform::adjustLoopBranches() {\n   assert(OuterLoopPreHeader != OuterLoop->getHeader() &&\n          InnerLoopPreHeader != InnerLoop->getHeader() && OuterLoopPreHeader &&\n          InnerLoopPreHeader && \"Guaranteed by loop-simplify form\");\n+\n+  simplifyLCSSAPhis(OuterLoop, InnerLoop);\n+\n   // Ensure that both preheaders do not contain PHI nodes and have single\n   // predecessors. This allows us to move them easily. We use\n   // InsertPreHeaderForLoop to create an 'extra' preheader, if the existing\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopInterchange/lcssa-phi-outer-latch.ll",
      "commands": [
        "opt < %s -passes=loop-interchange -cache-line-size=64 -verify-dom-info -verify-loop-info -verify-scev -verify-loop-lcssa -S"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n; This test is checking that blocks outer.body and outer.latch, where outer.body is the exit\n; block of the inner loop and outer.latch the latch of the outer loop, correctly\n; deal with the phi-node use-def chain %new.cond.lcssa -> %old.cond.lcssa. What we expect\n; here is that block outer.latch does not contain a phi node, because it is a single input\n; phi in a non-exit block.\n\ntarget datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine i16 @main(ptr %a) {\n;\nentry:\n  br label %outer.header\n\nouter.header:\n  %i = phi i64 [ 1, %entry ], [ %i.next, %outer.latch ]\n  br label %inner.header\n\ninner.header:\n  %j = phi i16 [ 0, %outer.header ], [ %j.next, %inner.latch ]\n  %arrayidx.us.us = getelementptr i16, ptr %a, i16 %j\n  %0 = load i16, ptr %arrayidx.us.us, align 1\n  %cond = select i1 false, i16 0, i16 0\n  br label %inner.latch\n\ninner.latch:\n  %j.next = add i16 %j, 1\n  br i1 true, label %outer.body, label %inner.header\n\nouter.body:\n  %new.cond.lcssa = phi i16 [ %cond, %inner.latch ]\n  br label %outer.latch\n\nouter.latch:\n  %old.cond.lcssa = phi i16 [ %new.cond.lcssa, %outer.body ]\n  %i.next = add i64 %i, 1\n  %cmp286.us = icmp ugt i64 %i, 0\n  br i1 %cmp286.us, label %outer.header, label %exit\n\nexit:\n  ret i16 %old.cond.lcssa\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "opt -passes=loop-interchange fails with \"Instruction does not dominate all uses!\"",
    "body": "llvm commit: cca769ac3f1\nReproduce with:\n```opt -passes=loop-interchange bbi-110771.ll -o /dev/null```\nResult:\n```\nInstruction does not dominate all uses!\n  %cond329.us.us.lcssa = phi i16 [ %cond329.us.us, %for.cond.cleanup295.us ]\n  %.us-phi.us = phi i16 [ %cond329.us.us.lcssa, %for.cond.cleanup295.split.us.us ]\nLLVM ERROR: Broken module found, compilation aborted!\n```\n\n[bbi-110771.ll.gz](https://github.com/user-attachments/files/22464426/bbi-110771.ll.gz)",
    "author": "mikaelholmen",
    "labels": [
      "loopoptim",
      "crash",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "nikic",
        "body": "cc @sjoerdmeijer "
      },
      {
        "author": "sjoerdmeijer",
        "body": "Thanks for the CC. \nI will self-assign this, and fix this. "
      },
      {
        "author": "sjoerdmeijer",
        "body": "@mikaelholmen : I've just picked this up, and was wondering if you happen to have the input source code? It's a bit of a weird case. There is a phi node with no uses in a latch block, and I was wondering how we ended up with this. I.e., I am not sure if interchange should be resilient to this (probably), but I am also wondering if something else has gone wrong earlier. "
      },
      {
        "author": "mikaelholmen",
        "body": "@sjoerdmeijer Yes, I have the original (generated) C program. However, it's in a C dialect only supported by our downstream compiler so it's not something you could use anyway.\nI'll see if I can reduce the C input program though and share something more that makes sense.\n\nNote that we've seen this with a non-standard opt pipeline ```-passes='function-simplification<O2>,loop(simple-loop-unswitch<nontrivial>,loop-interchange)' ```, so it's possible that it's only seen when some standard passes are not run."
      },
      {
        "author": "sjoerdmeijer",
        "body": "Ok, great, thanks, also for the context. I think it now makes sense now what I am seeing. I will now start looking into interchange. \n\nJust dumping this here if it helps and maybe for completeness, here's the test case with reshuffled blocks and renamed variables and labels because I couldn't see what was going on with all the long block names:\n\n```\ndefine i16 @main() {\nentry:\n  br label %BB1\n\nBB1:                ; preds = %BB5, %entry\n  %i = phi i64 [ 1, %entry ], [ %i.next, %BB5 ]\n  br label %BB2\n\nBB2:                                ; preds = %BB3, %BB1\n  %j = phi i16 [ 0, %BB1 ], [ %j.next, %BB3 ]\n  %arrayidx.us.us = getelementptr i16, ptr null, i16 %j\n  %0 = load i16, ptr %arrayidx.us.us, align 1\n  %cond329.us.us = select i1 false, i16 0, i16 0\n  br label %BB3\n\nBB3:                                ; preds = %BB2\n  %j.next = add i16 %j, 1\n  br i1 true, label %BB4, label %BB2\n\nBB4:                  ; preds = %BB3\n  br label %BB5\n\nBB5:                           ; preds = %BB4\n  %UNUSED = phi i16 [ %cond329.us.us, %BB4 ]\n  %i.next = add i64 %i, 1\n  %cmp286.us = icmp ugt i64 %i, 0\n  br i1 %cmp286.us, label %BB1, label %exit\n\nexit:                     ; preds = %BB5\n  ret i16 0\n\n; uselistorder directives\n  uselistorder i64 %i, { 1, 0 }\n}\n```"
      },
      {
        "author": "mikaelholmen",
        "body": "Ok, here is something. I don't know if this helps in any way but I'll attach some files.\n\nReduced C program containing two nested loops: r.c\n\nClang output (run for my target, then slightly cleaned): r.ll\n\nThen I ran ```opt -passes=\"function-simplification<O2>\" r.ll -S -o r2.ll``` for my target producing: r2.ll\n(If I don't specify my target here something gets different in the output and it won't expose the crash in the next step.)\n\nNow you can reproduce the crash with:\n ```opt -passes=\"loop(simple-loop-unswitch<nontrivial>,loop-interchange)\" r2.ll -S -o r3.ll```\n\n[r2.ll.gz](https://github.com/user-attachments/files/22489655/r2.ll.gz)\n[r.ll.gz](https://github.com/user-attachments/files/22489653/r.ll.gz)\n[r.c.gz](https://github.com/user-attachments/files/22489654/r.c.gz)"
      },
      {
        "author": "sjoerdmeijer",
        "body": "Thanks a lot, going to take a look!"
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true,
  "bisect": "670259466b238176ac302c8dedf806d2b2be7e0c"
}