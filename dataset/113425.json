{
  "bug_id": "113425",
  "issue_url": "https://github.com/llvm/llvm-project/issues/113425",
  "bug_type": "miscompilation",
  "base_commit": "0af6c304e48e0484672b53be49a15f411d173e59",
  "knowledge_cutoff": "2024-10-23T08:04:00Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "cb5046da26399c0ab545c3ed764e0e68e997ff89",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          9076,
          9089
        ],
        [
          13305,
          13312
        ],
        [
          13315,
          13333
        ],
        [
          14041,
          14047
        ],
        [
          14050,
          14063
        ],
        [
          14330,
          14341
        ],
        [
          14358,
          14369
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::gather",
        "BoUpSLP::processBuildVector",
        "peekThroughShuffles"
      ]
    }
  },
  "patch": "commit cb5046da26399c0ab545c3ed764e0e68e997ff89\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Thu Oct 24 04:33:41 2024 -0700\n\n    [SLP]Do not ignore undefs when trying to replace with \"poisonous\" shuffles\n    \n    Need to consider undefs correctly, when trying to replace them with\n    potentially poisonous values in shuffles. Such elements should not be\n    silently replaced by poison values, instead complex analysis should be\n    implemented to see if it is safe to do it.\n    \n    Fixes #113425\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 889c4d94ba5e..f76e913a57d5 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -9076,14 +9076,14 @@ protected:\n           continue;\n         ExtMask[Idx] = SV->getMaskValue(I);\n       }\n-      bool IsOp1Undef =\n-          isUndefVector(SV->getOperand(0),\n-                        buildUseMask(LocalVF, ExtMask, UseMask::FirstArg))\n-              .all();\n-      bool IsOp2Undef =\n-          isUndefVector(SV->getOperand(1),\n-                        buildUseMask(LocalVF, ExtMask, UseMask::SecondArg))\n-              .all();\n+      bool IsOp1Undef = isUndefVector</*isPoisonOnly=*/true>(\n+                            SV->getOperand(0),\n+                            buildUseMask(LocalVF, ExtMask, UseMask::FirstArg))\n+                            .all();\n+      bool IsOp2Undef = isUndefVector</*isPoisonOnly=*/true>(\n+                            SV->getOperand(1),\n+                            buildUseMask(LocalVF, ExtMask, UseMask::SecondArg))\n+                            .all();\n       if (!IsOp1Undef && !IsOp2Undef) {\n         // Update mask and mark undef elems.\n         for (int &I : Mask) {\n@@ -13305,8 +13305,17 @@ Value *BoUpSLP::gather(ArrayRef<Value *> VL, Value *Root, Type *ScalarTy) {\n     return Vec;\n   };\n   auto *VecTy = getWidenedType(ScalarTy, VL.size());\n-  Value *Vec = Root ? Root : PoisonValue::get(VecTy);\n+  Value *Vec = PoisonValue::get(VecTy);\n   SmallVector<int> NonConsts;\n+  SmallVector<int> Mask(VL.size());\n+  std::iota(Mask.begin(), Mask.end(), 0);\n+  Value *OriginalRoot = Root;\n+  if (auto *SV = dyn_cast_or_null<ShuffleVectorInst>(Root);\n+      SV && isa<PoisonValue>(SV->getOperand(1)) &&\n+      SV->getOperand(0)->getType() == VecTy) {\n+    Root = SV->getOperand(0);\n+    Mask.assign(SV->getShuffleMask().begin(), SV->getShuffleMask().end());\n+  }\n   // Insert constant values at first.\n   for (int I = 0, E = VL.size(); I < E; ++I) {\n     if (PostponedIndices.contains(I))\n@@ -13315,19 +13324,20 @@ Value *BoUpSLP::gather(ArrayRef<Value *> VL, Value *Root, Type *ScalarTy) {\n       NonConsts.push_back(I);\n       continue;\n     }\n-    if (Root) {\n-      if (!isa<UndefValue>(VL[I])) {\n-        NonConsts.push_back(I);\n-        continue;\n-      }\n-      if (isa<PoisonValue>(VL[I]))\n-        continue;\n-      if (auto *SV = dyn_cast<ShuffleVectorInst>(Root)) {\n-        if (SV->getMaskValue(I) == PoisonMaskElem)\n-          continue;\n-      }\n-    }\n+    if (isa<PoisonValue>(VL[I]))\n+      continue;\n     Vec = CreateInsertElement(Vec, VL[I], I, ScalarTy);\n+    Mask[I] = I + E;\n+  }\n+  if (Root) {\n+    if (isa<PoisonValue>(Vec)) {\n+      Vec = OriginalRoot;\n+    } else {\n+      Vec = Builder.CreateShuffleVector(Root, Vec, Mask);\n+      if (auto *OI = dyn_cast<Instruction>(OriginalRoot);\n+          OI && OI->hasNUses(0))\n+        eraseInstruction(OI);\n+    }\n   }\n   // Insert non-constant values.\n   for (int I : NonConsts)\n@@ -14041,7 +14051,8 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Type *ScalarTy,\n   if (!ReorderMask.empty())\n     reorderScalars(GatheredScalars, ReorderMask);\n   auto FindReusedSplat = [&](MutableArrayRef<int> Mask, unsigned InputVF,\n-                             unsigned I, unsigned SliceSize) {\n+                             unsigned I, unsigned SliceSize,\n+                             bool IsNotPoisonous) {\n     if (!isSplat(E->Scalars) || none_of(E->Scalars, [](Value *V) {\n           return isa<UndefValue>(V) && !isa<PoisonValue>(V);\n         }))\n@@ -14050,14 +14061,29 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Type *ScalarTy,\n     unsigned EdgeIdx = E->UserTreeIndices.back().EdgeIdx;\n     if (UserTE->getNumOperands() != 2)\n       return false;\n-    auto *It =\n-        find_if(VectorizableTree, [=](const std::unique_ptr<TreeEntry> &TE) {\n-          return find_if(TE->UserTreeIndices, [=](const EdgeInfo &EI) {\n-                   return EI.UserTE == UserTE && EI.EdgeIdx != EdgeIdx;\n-                 }) != TE->UserTreeIndices.end();\n-        });\n-    if (It == VectorizableTree.end())\n-      return false;\n+    if (!IsNotPoisonous) {\n+      auto *It =\n+          find_if(VectorizableTree, [=](const std::unique_ptr<TreeEntry> &TE) {\n+            return find_if(TE->UserTreeIndices, [=](const EdgeInfo &EI) {\n+                     return EI.UserTE == UserTE && EI.EdgeIdx != EdgeIdx;\n+                   }) != TE->UserTreeIndices.end();\n+          });\n+      if (It == VectorizableTree.end())\n+        return false;\n+      SmallVector<Value *> GS((*It)->Scalars.begin(), (*It)->Scalars.end());\n+      if (!(*It)->ReorderIndices.empty()) {\n+        inversePermutation((*It)->ReorderIndices, ReorderMask);\n+        reorderScalars(GS, ReorderMask);\n+      }\n+      if (!all_of(zip(GatheredScalars, GS), [&](const auto &P) {\n+            Value *V0 = std::get<0>(P);\n+            Value *V1 = std::get<1>(P);\n+            return !isa<UndefValue>(V0) || isa<PoisonValue>(V0) ||\n+                   (isa<UndefValue>(V0) && !isa<PoisonValue>(V0) &&\n+                    is_contained(E->Scalars, V1));\n+          }))\n+        return false;\n+    }\n     int Idx;\n     if ((Mask.size() < InputVF &&\n          ShuffleVectorInst::isExtractSubvectorMask(Mask, InputVF, Idx) &&\n@@ -14330,12 +14356,13 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Type *ScalarTy,\n             isGuaranteedNotToBePoison(Vec1) && isGuaranteedNotToBePoison(Vec2);\n         ShuffleBuilder.add(Vec1, Vec2, ExtractMask);\n       } else if (Vec1) {\n+        bool IsNotPoisonedVec = isGuaranteedNotToBePoison(Vec1);\n         IsUsedInExpr &= FindReusedSplat(\n             ExtractMask,\n             cast<FixedVectorType>(Vec1->getType())->getNumElements(), 0,\n-            ExtractMask.size());\n+            ExtractMask.size(), IsNotPoisonedVec);\n         ShuffleBuilder.add(Vec1, ExtractMask, /*ForExtracts=*/true);\n-        IsNonPoisoned &= isGuaranteedNotToBePoison(Vec1);\n+        IsNonPoisoned &= IsNotPoisonedVec;\n       } else {\n         IsUsedInExpr = false;\n         ShuffleBuilder.add(PoisonValue::get(VecTy), ExtractMask,\n@@ -14358,12 +14385,15 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Type *ScalarTy,\n         VecMask.assign(VecMask.size(), PoisonMaskElem);\n         copy(SubMask, std::next(VecMask.begin(), I * SliceSize));\n         if (TEs.size() == 1) {\n-          IsUsedInExpr &= FindReusedSplat(\n-              VecMask, TEs.front()->getVectorFactor(), I, SliceSize);\n+          bool IsNotPoisonedVec =\n+              TEs.front()->VectorizedValue\n+                  ? isGuaranteedNotToBePoison(TEs.front()->VectorizedValue)\n+                  : true;\n+          IsUsedInExpr &=\n+              FindReusedSplat(VecMask, TEs.front()->getVectorFactor(), I,\n+                              SliceSize, IsNotPoisonedVec);\n           ShuffleBuilder.add(*TEs.front(), VecMask);\n-          if (TEs.front()->VectorizedValue)\n-            IsNonPoisoned &=\n-                isGuaranteedNotToBePoison(TEs.front()->VectorizedValue);\n+          IsNonPoisoned &= IsNotPoisonedVec;\n         } else {\n           IsUsedInExpr = false;\n           ShuffleBuilder.add(*TEs.front(), *TEs.back(), VecMask);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/RISCV/revec-getGatherCost.ll",
      "commands": [
        "opt -mtriple=riscv64 -mcpu=sifive-x280 -passes=slp-vectorizer -S -slp-revec -slp-max-reg-size=1024 -slp-threshold=-20 -pass-remarks-output=%t %s"
      ],
      "tests": [
        {
          "test_name": "test2",
          "test_body": "define void @test2(<8 x float> %load6, <8 x float> %load7, <8 x float> %load8, <8 x float> %load17, <8 x float> %fmuladd7, <8 x float> %fmuladd16, ptr %out_ptr) {\nentry:\n  %vext165.i = shufflevector <8 x float> %load6, <8 x float> %load7, <8 x i32> <i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11>\n  %vext309.i = shufflevector <8 x float> %load7, <8 x float> %load8, <8 x i32> <i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11>\n  %fmuladd8 = tail call noundef <8 x float> @llvm.fmuladd.v8f32(<8 x float> %vext165.i, <8 x float> %load17, <8 x float> %fmuladd7)\n  %fmuladd17 = tail call noundef <8 x float> @llvm.fmuladd.v8f32(<8 x float> %vext309.i, <8 x float> %load17, <8 x float> %fmuladd16)\n  %add.ptr.i.i = getelementptr inbounds i8, ptr %out_ptr, i64 32\n  store <8 x float> %fmuladd8, ptr %out_ptr, align 4\n  store <8 x float> %fmuladd17, ptr %add.ptr.i.i, align 4\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <8 x float> @llvm.fmuladd.v8f32(<8 x float>, <8 x float>, <8 x float>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "test1",
          "test_body": "define void @test1(<4 x float> %load6, <4 x float> %load7, <4 x float> %load8, <4 x float> %load17, <4 x float> %fmuladd7, <4 x float> %fmuladd16, ptr %out_ptr) {\nentry:\n  %vext165.i = shufflevector <4 x float> %load6, <4 x float> %load7, <4 x i32> <i32 2, i32 3, i32 4, i32 5>\n  %vext309.i = shufflevector <4 x float> %load7, <4 x float> %load8, <4 x i32> <i32 2, i32 3, i32 4, i32 5>\n  %fmuladd8 = tail call noundef <4 x float> @llvm.fmuladd.v4f32(<4 x float> %vext165.i, <4 x float> %load17, <4 x float> %fmuladd7)\n  %fmuladd17 = tail call noundef <4 x float> @llvm.fmuladd.v4f32(<4 x float> %vext309.i, <4 x float> %load17, <4 x float> %fmuladd16)\n  %add.ptr.i.i = getelementptr inbounds i8, ptr %out_ptr, i64 16\n  store <4 x float> %fmuladd8, ptr %out_ptr, align 4\n  store <4 x float> %fmuladd17, ptr %add.ptr.i.i, align 4\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x float> @llvm.fmuladd.v4f32(<4 x float>, <4 x float>, <4 x float>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/RISCV/revec.ll",
      "commands": [
        "opt -mtriple=riscv64 -mcpu=sifive-x280 -passes=slp-vectorizer -S -slp-revec -slp-max-reg-size=1024 -slp-threshold=-100 %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define i32 @test() {\nentry:\n  %getelementptr0 = getelementptr i8, ptr null, i64 64036\n  %getelementptr1 = getelementptr i8, ptr null, i64 64064\n  br label %if.end.i87\n\nif.end.i87:                                       ; preds = %entry\n  %0 = load <2 x i32>, ptr %getelementptr0, align 4\n  %1 = load <2 x i32>, ptr %getelementptr1, align 8\n  switch i32 0, label %sw.bb509.i [\n    i32 1, label %sw.bb509.i\n    i32 0, label %if.then458.i\n  ]\n\nif.then458.i:                                     ; preds = %if.end.i87\n  br label %sw.bb509.i\n\nsw.bb509.i:                                       ; preds = %if.then458.i, %if.end.i87, %if.end.i87\n  %2 = phi <2 x i32> [ %0, %if.then458.i ], [ %0, %if.end.i87 ], [ %0, %if.end.i87 ]\n  %3 = phi <2 x i32> [ %1, %if.then458.i ], [ zeroinitializer, %if.end.i87 ], [ zeroinitializer, %if.end.i87 ]\n  ret i32 0\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/matched-shuffled-entries.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -o - -mtriple=x86_64-unknown-linux-gnu -mattr=+avx2 -slp-threshold=50 -slp-recursion-max-depth=6 < %s"
      ],
      "tests": [
        {
          "test_name": "bar",
          "test_body": "define i32 @bar() local_unnamed_addr {\nentry:\n  %add103 = add nsw i32 undef, undef\n  %sub104 = sub nsw i32 undef, undef\n  %add105 = add nsw i32 undef, undef\n  %sub106 = sub nsw i32 undef, undef\n  %shr.i = lshr i32 %add103, 15\n  %and.i = and i32 %shr.i, 65537\n  %mul.i = mul nuw i32 %and.i, 65535\n  %add.i = add i32 %mul.i, %add103\n  %xor.i = xor i32 %add.i, %mul.i\n  %shr.i64 = lshr i32 %add105, 15\n  %and.i65 = and i32 %shr.i64, 65537\n  %mul.i66 = mul nuw i32 %and.i65, 65535\n  %add.i67 = add i32 %mul.i66, %add105\n  %xor.i68 = xor i32 %add.i67, %mul.i66\n  %shr.i69 = lshr i32 %sub104, 15\n  %and.i70 = and i32 %shr.i69, 65537\n  %mul.i71 = mul nuw i32 %and.i70, 65535\n  %add.i72 = add i32 %mul.i71, %sub104\n  %xor.i73 = xor i32 %add.i72, %mul.i71\n  %shr.i74 = lshr i32 %sub106, 15\n  %and.i75 = and i32 %shr.i74, 65537\n  %mul.i76 = mul nuw i32 %and.i75, 65535\n  %add.i77 = add i32 %mul.i76, %sub106\n  %xor.i78 = xor i32 %add.i77, %mul.i76\n  %add110 = add i32 %xor.i68, %xor.i\n  %add112 = add i32 %add110, %xor.i73\n  %add113 = add i32 %add112, %xor.i78\n  %add78.1 = add nsw i32 undef, undef\n  %sub86.1 = sub nsw i32 undef, undef\n  %add94.1 = add nsw i32 undef, undef\n  %sub102.1 = sub nsw i32 undef, undef\n  %add103.1 = add nsw i32 %add94.1, %add78.1\n  %sub104.1 = sub nsw i32 %add78.1, %add94.1\n  %add105.1 = add nsw i32 %sub102.1, %sub86.1\n  %sub106.1 = sub nsw i32 %sub86.1, %sub102.1\n  %shr.i.1 = lshr i32 %add103.1, 15\n  %and.i.1 = and i32 %shr.i.1, 65537\n  %mul.i.1 = mul nuw i32 %and.i.1, 65535\n  %add.i.1 = add i32 %mul.i.1, %add103.1\n  %xor.i.1 = xor i32 %add.i.1, %mul.i.1\n  %shr.i64.1 = lshr i32 %add105.1, 15\n  %and.i65.1 = and i32 %shr.i64.1, 65537\n  %mul.i66.1 = mul nuw i32 %and.i65.1, 65535\n  %add.i67.1 = add i32 %mul.i66.1, %add105.1\n  %xor.i68.1 = xor i32 %add.i67.1, %mul.i66.1\n  %shr.i69.1 = lshr i32 %sub104.1, 15\n  %and.i70.1 = and i32 %shr.i69.1, 65537\n  %mul.i71.1 = mul nuw i32 %and.i70.1, 65535\n  %add.i72.1 = add i32 %mul.i71.1, %sub104.1\n  %xor.i73.1 = xor i32 %add.i72.1, %mul.i71.1\n  %shr.i74.1 = lshr i32 %sub106.1, 15\n  %and.i75.1 = and i32 %shr.i74.1, 65537\n  %mul.i76.1 = mul nuw i32 %and.i75.1, 65535\n  %add.i77.1 = add i32 %mul.i76.1, %sub106.1\n  %xor.i78.1 = xor i32 %add.i77.1, %mul.i76.1\n  %add108.1 = add i32 %xor.i68.1, %add113\n  %add110.1 = add i32 %add108.1, %xor.i.1\n  %add112.1 = add i32 %add110.1, %xor.i73.1\n  %add113.1 = add i32 %add112.1, %xor.i78.1\n  %add78.2 = add nsw i32 undef, undef\n  %add103.2 = add nsw i32 undef, %add78.2\n  %sub104.2 = sub nsw i32 %add78.2, undef\n  %add105.2 = add nsw i32 undef, undef\n  %sub106.2 = sub nsw i32 undef, undef\n  %shr.i.2 = lshr i32 %add103.2, 15\n  %and.i.2 = and i32 %shr.i.2, 65537\n  %mul.i.2 = mul nuw i32 %and.i.2, 65535\n  %add.i.2 = add i32 %mul.i.2, %add103.2\n  %xor.i.2 = xor i32 %add.i.2, %mul.i.2\n  %shr.i64.2 = lshr i32 %add105.2, 15\n  %and.i65.2 = and i32 %shr.i64.2, 65537\n  %mul.i66.2 = mul nuw i32 %and.i65.2, 65535\n  %add.i67.2 = add i32 %mul.i66.2, %add105.2\n  %xor.i68.2 = xor i32 %add.i67.2, %mul.i66.2\n  %shr.i69.2 = lshr i32 %sub104.2, 15\n  %and.i70.2 = and i32 %shr.i69.2, 65537\n  %mul.i71.2 = mul nuw i32 %and.i70.2, 65535\n  %add.i72.2 = add i32 %mul.i71.2, %sub104.2\n  %xor.i73.2 = xor i32 %add.i72.2, %mul.i71.2\n  %shr.i74.2 = lshr i32 %sub106.2, 15\n  %and.i75.2 = and i32 %shr.i74.2, 65537\n  %mul.i76.2 = mul nuw i32 %and.i75.2, 65535\n  %add.i77.2 = add i32 %mul.i76.2, %sub106.2\n  %xor.i78.2 = xor i32 %add.i77.2, %mul.i76.2\n  %add108.2 = add i32 %xor.i68.2, %add113.1\n  %add110.2 = add i32 %add108.2, %xor.i.2\n  %add112.2 = add i32 %add110.2, %xor.i73.2\n  %add113.2 = add i32 %add112.2, %xor.i78.2\n  %sub102.3 = sub nsw i32 undef, undef\n  %add103.3 = add nsw i32 undef, undef\n  %sub104.3 = sub nsw i32 undef, undef\n  %add105.3 = add nsw i32 %sub102.3, undef\n  %sub106.3 = sub nsw i32 undef, %sub102.3\n  %shr.i.3 = lshr i32 %add103.3, 15\n  %and.i.3 = and i32 %shr.i.3, 65537\n  %mul.i.3 = mul nuw i32 %and.i.3, 65535\n  %add.i.3 = add i32 %mul.i.3, %add103.3\n  %xor.i.3 = xor i32 %add.i.3, %mul.i.3\n  %shr.i64.3 = lshr i32 %add105.3, 15\n  %and.i65.3 = and i32 %shr.i64.3, 65537\n  %mul.i66.3 = mul nuw i32 %and.i65.3, 65535\n  %add.i67.3 = add i32 %mul.i66.3, %add105.3\n  %xor.i68.3 = xor i32 %add.i67.3, %mul.i66.3\n  %shr.i69.3 = lshr i32 %sub104.3, 15\n  %and.i70.3 = and i32 %shr.i69.3, 65537\n  %mul.i71.3 = mul nuw i32 %and.i70.3, 65535\n  %add.i72.3 = add i32 %mul.i71.3, %sub104.3\n  %xor.i73.3 = xor i32 %add.i72.3, %mul.i71.3\n  %shr.i74.3 = lshr i32 %sub106.3, 15\n  %and.i75.3 = and i32 %shr.i74.3, 65537\n  %mul.i76.3 = mul nuw i32 %and.i75.3, 65535\n  %add.i77.3 = add i32 %mul.i76.3, %sub106.3\n  %xor.i78.3 = xor i32 %add.i77.3, %mul.i76.3\n  %add108.3 = add i32 %xor.i68.3, %add113.2\n  %add110.3 = add i32 %add108.3, %xor.i.3\n  %add112.3 = add i32 %add110.3, %xor.i73.3\n  %add113.3 = add i32 %add112.3, %xor.i78.3\n  %shr = lshr i32 %add113.3, 16\n  %add119 = add nuw nsw i32 undef, %shr\n  %shr120 = lshr i32 %add119, 1\n  ret i32 %shr120\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/remark_extract_broadcast.ll",
      "commands": [
        "opt -S -mtriple=x86_64-pc-linux-gnu -mcpu=generic -mattr=sse2 -passes=slp-vectorizer -pass-remarks-output=%t < %s -slp-threshold=-2"
      ],
      "tests": [
        {
          "test_name": "fextr",
          "test_body": "define void @fextr(ptr %ptr) {\nentry:\n  %LD = load <8 x i16>, ptr undef, align 16\n  %V0 = extractelement <8 x i16> %LD, i32 0\n  br label %t\n\nt:                                                ; preds = %entry\n  %V1 = extractelement <8 x i16> %LD, i32 1\n  %V2 = extractelement <8 x i16> %LD, i32 2\n  %V3 = extractelement <8 x i16> %LD, i32 3\n  %V4 = extractelement <8 x i16> %LD, i32 4\n  %V5 = extractelement <8 x i16> %LD, i32 5\n  %V6 = extractelement <8 x i16> %LD, i32 6\n  %V7 = extractelement <8 x i16> %LD, i32 7\n  %P1 = getelementptr inbounds i16, ptr %ptr, i64 1\n  %P2 = getelementptr inbounds i16, ptr %ptr, i64 2\n  %P3 = getelementptr inbounds i16, ptr %ptr, i64 3\n  %P4 = getelementptr inbounds i16, ptr %ptr, i64 4\n  %P5 = getelementptr inbounds i16, ptr %ptr, i64 5\n  %P6 = getelementptr inbounds i16, ptr %ptr, i64 6\n  %P7 = getelementptr inbounds i16, ptr %ptr, i64 7\n  %A0 = add i16 %V0, %V0\n  %A1 = add i16 %V1, undef\n  %A2 = add i16 %V2, %V0\n  %A3 = add i16 %V3, %V0\n  %A4 = add i16 %V4, %V0\n  %A5 = add i16 %V5, %V0\n  %A6 = add i16 %V6, %V0\n  %A7 = add i16 %V7, %V0\n  store i16 %A0, ptr %ptr, align 2\n  store i16 %A1, ptr %P1, align 2\n  store i16 %A2, ptr %P2, align 2\n  store i16 %A3, ptr %P3, align 2\n  store i16 %A4, ptr %P4, align 2\n  store i16 %A5, ptr %P5, align 2\n  store i16 %A6, ptr %P6, align 2\n  store i16 %A7, ptr %P7, align 2\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/insertelement-across-zero.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define void @test(i8 %0, i8 %1) {\nentry:\n  %li8 = load i8, ptr getelementptr (i8, ptr null, i32 8), align 1\n  %li9163 = load i8, ptr getelementptr (i8, ptr null, i32 9), align 1\n  %li10 = load i8, ptr getelementptr (i8, ptr null, i32 10), align 1\n  %li11164 = load i8, ptr getelementptr (i8, ptr null, i32 11), align 1\n  %li12 = load i8, ptr getelementptr (i8, ptr null, i32 12), align 1\n  %li13 = load i8, ptr getelementptr (i8, ptr null, i32 13), align 1\n  %li14 = load i8, ptr getelementptr (i8, ptr null, i32 14), align 1\n  %li15165 = load i8, ptr getelementptr (i8, ptr null, i32 15), align 1\n  %lupto8237 = insertelement <16 x i8> zeroinitializer, i8 %li8, i64 8\n  %lupto9238 = insertelement <16 x i8> %lupto8237, i8 %li9163, i64 9\n  %lupto10239 = insertelement <16 x i8> %lupto9238, i8 %li10, i64 10\n  %lupto11240 = insertelement <16 x i8> %lupto10239, i8 %li11164, i64 11\n  %lupto12241 = insertelement <16 x i8> %lupto11240, i8 %li12, i64 12\n  %lupto13242 = insertelement <16 x i8> %lupto12241, i8 %li13, i64 13\n  %lupto14243 = insertelement <16 x i8> %lupto13242, i8 %li14, i64 1\n  %l = insertelement <16 x i8> %lupto14243, i8 %li15165, i64 0\n  %li15 = extractelement <16 x i8> %l, i64 15\n  %2 = icmp ne i8 %0, 0\n  %3 = icmp ne i8 %1, 0\n  %4 = icmp ne i8 %0, 0\n  %.i3 = icmp ne i8 %0, 0\n  %.i4 = icmp ne i8 %0, 0\n  %5 = icmp ne i8 %0, 0\n  %6 = icmp ne i8 %0, 0\n  %7 = icmp ne i8 0, 0\n  %8 = icmp ne i8 %0, 0\n  %.i9 = icmp ne i8 %li9163, 0\n  %9 = icmp ne i8 %0, 0\n  %10 = icmp ne i8 %0, 0\n  %11 = icmp ne i8 %0, 0\n  %12 = icmp ne i8 %0, 0\n  %13 = icmp ne i8 %0, 0\n  %.i15 = icmp ne i8 %li15, 0\n  %i0244 = insertelement <16 x i1> zeroinitializer, i1 %2, i64 0\n  %i1245 = insertelement <16 x i1> %i0244, i1 %3, i64 1\n  %i2246 = insertelement <16 x i1> %i1245, i1 %4, i64 2\n  %i3247 = insertelement <16 x i1> %i2246, i1 %.i3, i64 3\n  %i4248 = insertelement <16 x i1> %i3247, i1 %.i4, i64 4\n  %i5249 = insertelement <16 x i1> %i4248, i1 %5, i64 5\n  %i6250 = insertelement <16 x i1> %i5249, i1 %6, i64 6\n  %i7251 = insertelement <16 x i1> %i6250, i1 %7, i64 7\n  %i8252 = insertelement <16 x i1> %i7251, i1 %8, i64 8\n  %i9253 = insertelement <16 x i1> %i8252, i1 %.i9, i64 9\n  %i10254 = insertelement <16 x i1> %i9253, i1 %9, i64 10\n  %i11255 = insertelement <16 x i1> %i10254, i1 %10, i64 11\n  %i12256 = insertelement <16 x i1> %i11255, i1 %11, i64 12\n  %i13257 = insertelement <16 x i1> %i12256, i1 %12, i64 13\n  %i14 = insertelement <16 x i1> %i13257, i1 %13, i64 14\n  %14 = insertelement <16 x i1> %i14, i1 %.i15, i64 15\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/revec.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -slp-revec -slp-max-reg-size=1024 -slp-threshold=-100 %s"
      ],
      "tests": [
        {
          "test_name": "test10",
          "test_body": "define void @test10() {\nentry:\n  %0 = load <16 x i8>, ptr null, align 1\n  %shuffle.i = shufflevector <16 x i8> %0, <16 x i8> zeroinitializer, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n  %shuffle.i107 = shufflevector <16 x i8> %0, <16 x i8> zeroinitializer, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>\n  %vmovl.i106 = sext <8 x i8> %shuffle.i to <8 x i16>\n  %vmovl.i = sext <8 x i8> %shuffle.i107 to <8 x i16>\n  %shuffle.i113 = shufflevector <8 x i16> %vmovl.i106, <8 x i16> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %shuffle.i115 = shufflevector <8 x i16> %vmovl.i106, <8 x i16> zeroinitializer, <4 x i32> <i32 4, i32 5, i32 6, i32 7>\n  %shuffle.i112 = shufflevector <8 x i16> %vmovl.i, <8 x i16> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %shuffle.i114 = shufflevector <8 x i16> %vmovl.i, <8 x i16> zeroinitializer, <4 x i32> <i32 4, i32 5, i32 6, i32 7>\n  %vmovl.i111 = sext <4 x i16> %shuffle.i113 to <4 x i32>\n  %vmovl.i110 = sext <4 x i16> %shuffle.i115 to <4 x i32>\n  %vmovl.i109 = sext <4 x i16> %shuffle.i112 to <4 x i32>\n  %vmovl.i108 = sext <4 x i16> %shuffle.i114 to <4 x i32>\n  %add.ptr29 = getelementptr i8, ptr null, i64 16\n  %add.ptr32 = getelementptr i8, ptr null, i64 32\n  %add.ptr35 = getelementptr i8, ptr null, i64 48\n  store <4 x i32> %vmovl.i111, ptr null, align 4\n  store <4 x i32> %vmovl.i110, ptr %add.ptr29, align 4\n  store <4 x i32> %vmovl.i109, ptr %add.ptr32, align 4\n  store <4 x i32> %vmovl.i108, ptr %add.ptr35, align 4\n  ret void\n}\n"
        },
        {
          "test_name": "test4",
          "test_body": "define void @test4(ptr %in, ptr %out) {\nentry:\n  %0 = load <8 x float>, ptr %in, align 4\n  %1 = fmul <8 x float> %0, zeroinitializer\n  %2 = fmul <8 x float> %0, zeroinitializer\n  %3 = fadd <8 x float> zeroinitializer, %1\n  %4 = fadd <8 x float> %0, %2\n  %5 = fcmp ogt <8 x float> %3, zeroinitializer\n  %6 = fcmp ogt <8 x float> %4, zeroinitializer\n  %7 = getelementptr i1, ptr %out, i64 8\n  store <8 x i1> %5, ptr %out, align 1\n  store <8 x i1> %6, ptr %7, align 1\n  ret void\n}\n"
        },
        {
          "test_name": "test6",
          "test_body": "define <4 x i1> @test6(ptr %in1, ptr %in2) {\nentry:\n  %0 = load <4 x i32>, ptr %in1, align 4\n  %1 = load <4 x i16>, ptr %in2, align 2\n  %cmp000 = icmp ugt <4 x i32> %0, zeroinitializer\n  %cmp001 = icmp ugt <4 x i32> %0, zeroinitializer\n  %cmp002 = icmp ugt <4 x i32> %0, zeroinitializer\n  %cmp003 = icmp ugt <4 x i32> %0, zeroinitializer\n  %cmp100 = icmp eq <4 x i16> %1, zeroinitializer\n  %cmp101 = icmp eq <4 x i16> %1, zeroinitializer\n  %cmp102 = icmp eq <4 x i16> %1, zeroinitializer\n  %cmp103 = icmp eq <4 x i16> %1, zeroinitializer\n  %and.cmp0 = and <4 x i1> %cmp000, %cmp100\n  %and.cmp1 = and <4 x i1> %cmp001, %cmp101\n  %and.cmp2 = and <4 x i1> %cmp002, %cmp102\n  %and.cmp3 = and <4 x i1> %cmp003, %cmp103\n  %cmp004 = icmp ugt <4 x i32> %0, zeroinitializer\n  %cmp005 = icmp ugt <4 x i32> %0, zeroinitializer\n  %cmp006 = icmp ugt <4 x i32> %0, zeroinitializer\n  %cmp007 = icmp ugt <4 x i32> %0, zeroinitializer\n  %and.cmp4 = and <4 x i1> %and.cmp0, %cmp004\n  %and.cmp5 = and <4 x i1> %and.cmp1, %cmp005\n  %and.cmp6 = and <4 x i1> %and.cmp2, %cmp006\n  %and.cmp7 = and <4 x i1> %and.cmp3, %cmp007\n  %or0 = or <4 x i1> %and.cmp5, %and.cmp4\n  %or1 = or <4 x i1> %or0, %and.cmp6\n  %or2 = or <4 x i1> %or1, %and.cmp7\n  %vbsl = select <4 x i1> %or2, <4 x i32> <i32 1, i32 2, i32 3, i32 4>, <4 x i32> <i32 5, i32 6, i32 7, i32 8>\n  %cmp = icmp ugt <4 x i32> %vbsl, <i32 2, i32 3, i32 4, i32 5>\n  ret <4 x i1> %cmp\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/SLPVectorizer/splat-buildvector.ll",
      "commands": [
        "%if x86-registered-target %{ opt --passes=slp-vectorizer -S -mtriple=x86_64-unknown-linux-gnu %s -o - -slp-threshold=-100",
        "%if aarch64-registered-target %{ opt --passes=slp-vectorizer -S -mtriple=aarch64-unknown-linux-gnu %s -o - -slp-threshold=-100"
      ],
      "tests": [
        {
          "test_name": "foo",
          "test_body": "; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i64 @llvm.smax.i64(i64, i64) #0\n\ndefine i8 @foo(i64 %val_i64_57) {\nentry_1:\n  %val_i64_58 = call i64 @llvm.smax.i64(i64 0, i64 1)\n  %val_i1_89 = icmp ule i64 %val_i64_57, %val_i64_58\n  %val_i1_95 = icmp sle i64 0, undef\n  %val_i1_98 = icmp uge i64 %val_i64_58, %val_i64_58\n  %val_i1_99 = icmp ule i64 0, %val_i64_58\n  ret i8 0\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "`slp-vectorizer` miscompiles when creating `shufflevector` and vectorizing many ops",
    "body": "Alive2 report: https://alive2.llvm.org/ce/z/y-pAyx\r\n\r\n```llvm\r\n----------------------------------------\r\ndefine <2 x i8> @g.2(<2 x i8> %x, <2 x i8> %y) {\r\n#0:\r\n  %x0 = extractelement <2 x i8> %x, i32 0\r\n  %y1 = extractelement <2 x i8> %y, i32 1\r\n  %x0x0 = mul i8 %x0, undef\r\n  %y1y1 = mul nsw i8 %y1, %y1\r\n  %ins1 = insertelement <2 x i8> undef, i8 %x0x0, i32 0\r\n  %ins2 = insertelement <2 x i8> %ins1, i8 %y1y1, i32 1\r\n  ret <2 x i8> %ins2\r\n}\r\n=>\r\ndefine <2 x i8> @g.2(<2 x i8> %x, <2 x i8> %y) {\r\n#0:\r\n  %#1 = shufflevector <2 x i8> %x, <2 x i8> %y, 0, 3\r\n  %#2 = mul <2 x i8> %#1, %y\r\n  ret <2 x i8> %#2\r\n}\r\nTransformation doesn't verify!\r\n\r\nERROR: Target is more poisonous than source\r\n\r\nExample:\r\n<2 x i8> %x = < #x00 (0)\t[based on undef value], poison >\r\n<2 x i8> %y = < poison, poison >\r\n\r\nSource:\r\ni8 %x0 = #x00 (0)\r\ni8 %y1 = poison\r\ni8 %x0x0 = #x00 (0)\r\ni8 %y1y1 = poison\r\n<2 x i8> %ins1 = < #x00 (0), #x00 (0) >\r\n<2 x i8> %ins2 = < #x00 (0), poison >\r\n\r\nTarget:\r\n<2 x i8> %#1 = < #x00 (0), poison >\r\n<2 x i8> %#2 = < poison, poison >\r\nSource value: < #x00 (0), poison >\r\nTarget value: < poison, poison >\r\n\r\nSummary:\r\n  0 correct transformations\r\n  1 incorrect transformations\r\n  0 failed-to-prove transformations\r\n  0 Alive2 errors\r\n```",
    "author": "bongjunj",
    "labels": [
      "miscompilation",
      "llvm:SLPVectorizer"
    ],
    "comments": []
  }
}