{
  "bug_id": "95520",
  "issue_url": "https://github.com/llvm/llvm-project/issues/95520",
  "bug_type": "crash",
  "base_commit": "e7acb3792b8ba971bda2c9564ed26c2a60a2ddbc",
  "knowledge_cutoff": "2024-06-14T09:26:34Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "40a72f8cc414726a8be234a260650fd62354da21",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/VPlan.cpp",
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlan.cpp": [
        [
          231,
          236
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          577,
          583
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlan.cpp": [
        "VPTransformState::get"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPInstruction::generatePerPart"
      ]
    }
  },
  "patch": "commit 40a72f8cc414726a8be234a260650fd62354da21\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Fri Jun 14 22:16:51 2024 +0100\n\n    [VPlan] Support extracting any lane of uniform value.\n    \n    If the value we are extracting a lane from is uniform, only the first\n    lane will be set. Return lane 0 for any requested lane.\n    \n    This fixes a crash when trying to extract the last lane for a\n    first-order recurrence resume value.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/95520.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlan.cpp b/llvm/lib/Transforms/Vectorize/VPlan.cpp\nindex f17be451e684..348a2be5072b 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlan.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlan.cpp\n@@ -231,6 +231,11 @@ Value *VPTransformState::get(VPValue *Def, const VPIteration &Instance) {\n     return Data\n         .PerPartScalars[Def][Instance.Part][Instance.Lane.mapToCacheIndex(VF)];\n   }\n+  if (!Instance.Lane.isFirstLane() &&\n+      vputils::isUniformAfterVectorization(Def) &&\n+      hasScalarValue(Def, {Instance.Part, VPLane::getFirstLane()})) {\n+    return Data.PerPartScalars[Def][Instance.Part][0];\n+  }\n \n   assert(hasVectorValue(Def, Instance.Part));\n   auto *VecPart = Data.PerPartOutput[Def][Instance.Part];\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 7a482455473e..a3ff6395bb39 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -577,7 +577,8 @@ Value *VPInstruction::generatePerPart(VPTransformState &State, unsigned Part) {\n       // When loop is unrolled without vectorizing, retrieve UF - Offset.\n       Res = State.get(getOperand(0), State.UF - Offset);\n     }\n-    Res->setName(Name);\n+    if (isa<ExtractElementInst>(Res))\n+      Res->setName(Name);\n     return Res;\n   }\n   case VPInstruction::LogicalAnd: {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/reduction-recurrence-costs-sve.ll",
      "commands": [
        "opt -p loop-vectorize -S %s",
        "opt -p loop-vectorize -prefer-predicate-over-epilogue=predicate-else-scalar-epilogue -S %s"
      ],
      "tests": [
        {
          "test_name": "chained_recurrences",
          "test_body": "target datalayout = \"e-m:o-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"arm64-apple-macosx14.0.0\"\n\ndefine i32 @chained_recurrences(i32 %x, i64 %y, ptr %src.1, i32 %z, ptr %src.2) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %0 = phi i32 [ 0, %entry ], [ %3, %loop ]\n  %1 = phi i32 [ 0, %entry ], [ %0, %loop ]\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %sum.red = phi i32 [ 0, %entry ], [ %red.2, %loop ]\n  %2 = add i64 %y, 1\n  %gep.1 = getelementptr i32, ptr %src.1, i64 %2\n  %3 = load i32, ptr %gep.1, align 4\n  %or3 = or i32 %1, %x\n  %iv.next = add i64 %iv, 1\n  %shr = lshr i32 %x, 1\n  %4 = shl i32 %or3, 1\n  %5 = or i32 %4, 2\n  %shl19 = shl i32 %x, 1\n  %6 = or i32 %shr, %shl19\n  %7 = or i32 %6, %5\n  %8 = or i32 %7, %x\n  %or20 = or i32 %z, %x\n  %not = and i32 %or20, 1\n  %and = xor i32 %not, 1\n  %idx.ext.1 = zext i32 %and to i64\n  %gep.2 = getelementptr i32, ptr %src.2, i64 %idx.ext.1\n  %9 = load i32, ptr %gep.2, align 4\n  %shr24 = lshr i32 %8, 1\n  %idx.ext.2 = zext i32 %shr24 to i64\n  %gep.3 = getelementptr i32, ptr %src.2, i64 %idx.ext.2\n  %10 = load i32, ptr %gep.3, align 4\n  %red.1 = or i32 %9, %sum.red\n  %red.2 = or i32 %red.1, %10\n  %ec = icmp eq i64 %iv, %y\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i32 %red.2\n}\n\nattributes #0 = { \"target-features\"=\"+sve\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence-chains.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "test_resinking_required",
          "test_body": "define double @test_resinking_required(ptr %p, ptr noalias %a, ptr noalias %b) {\nEntry:\n  br label %Loop\n\nLoop:                                             ; preds = %Loop, %Entry\n  %for.1 = phi double [ %l1, %Loop ], [ 0.000000e+00, %Entry ]\n  %for.2 = phi double [ %l2, %Loop ], [ 0.000000e+00, %Entry ]\n  %for.3 = phi double [ %for.2, %Loop ], [ 0.000000e+00, %Entry ]\n  %iv = phi i64 [ %iv.next, %Loop ], [ 0, %Entry ]\n  %USE_2_FORS = fdiv double %for.3, %for.1\n  %div = fdiv double 0.000000e+00, %for.1\n  %l1 = load double, ptr %a, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %l2 = load double, ptr %b, align 8\n  store double %div, ptr %p, align 8\n  %cond = icmp eq i64 %iv.next, 0\n  br i1 %cond, label %End, label %Loop\n\nEnd:                                              ; preds = %Loop\n  %res.1 = fadd double %for.1, %for.2\n  %res.2 = fadd double %res.1, %for.3\n  ret double %res.2\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence-complex.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "instruction_with_2_FOR_operands",
          "test_body": "define void @instruction_with_2_FOR_operands(ptr noalias %A, ptr noalias %B, ptr noalias %C) {\nbb:\n  br label %bb13\n\nbb13:                                             ; preds = %bb13, %bb\n  %tmp37 = phi float [ %tmp60, %bb13 ], [ 0.000000e+00, %bb ]\n  %tmp27 = phi float [ %tmp49, %bb13 ], [ 1.000000e+00, %bb ]\n  %iv = phi i64 [ %iv.next, %bb13 ], [ 0, %bb ]\n  %tmp38 = fmul fast float %tmp37, %tmp27\n  %iv.next = add nuw nsw i64 %iv, 1\n  %gep = getelementptr inbounds float, ptr %C, i64 %iv\n  %tmp49 = load float, ptr %A, align 4\n  %tmp60 = load float, ptr %B, align 4\n  store float %tmp38, ptr %gep, align 4\n  %tmp12 = icmp slt i64 %iv, 1000\n  br i1 %tmp12, label %bb13, label %bb74\n\nbb74:                                             ; preds = %bb13\n  ret void\n}\n"
        },
        {
          "test_name": "instruction_with_2_FOR_operands_and_multiple_other_uses",
          "test_body": "define void @instruction_with_2_FOR_operands_and_multiple_other_uses(ptr noalias %dst.1, ptr noalias %dst.2, ptr noalias %dst.3, ptr noalias %for.ptr.1, ptr noalias %for.ptr.2) {\nbb:\n  br label %loop\n\nloop:                                             ; preds = %loop, %bb\n  %for.1 = phi float [ 0.000000e+00, %bb ], [ %for.1.next, %loop ]\n  %for.2 = phi float [ 0.000000e+00, %bb ], [ %for.2.next, %loop ]\n  %iv = phi i64 [ 0, %bb ], [ %iv.next, %loop ]\n  %for.1.use.1 = fmul fast float %for.1, 2.000000e+00\n  %used.by.both = fmul fast float %for.1, %for.2\n  %for.2.next = load float, ptr %for.ptr.2, align 4\n  %for.1.use.3 = fadd fast float %for.1, 1.000000e+00\n  %iv.next = add nuw nsw i64 %iv, 1\n  %for.1.next = load float, ptr %for.ptr.1, align 4\n  %gep.dst.1 = getelementptr inbounds float, ptr %dst.1, i64 %iv\n  store float %used.by.both, ptr %gep.dst.1, align 4\n  %gep.dst.2 = getelementptr inbounds float, ptr %dst.2, i64 %iv\n  store float %for.1.use.1, ptr %gep.dst.2, align 4\n  %gep.dst.3 = getelementptr inbounds float, ptr %dst.3, i64 %iv\n  store float %for.1.use.3, ptr %gep.dst.3, align 4\n  %ec = icmp slt i64 %iv, 1000\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "instruction_with_2_FOR_operands_and_multiple_other_uses_chain",
          "test_body": "define void @instruction_with_2_FOR_operands_and_multiple_other_uses_chain(ptr noalias %dst.1, ptr noalias %dst.2, ptr noalias %dst.3, ptr noalias %for.ptr.1, ptr noalias %for.ptr.2) {\nbb:\n  br label %loop\n\nloop:                                             ; preds = %loop, %bb\n  %for.1 = phi float [ 0.000000e+00, %bb ], [ %for.1.next, %loop ]\n  %for.2 = phi float [ 0.000000e+00, %bb ], [ %for.2.next, %loop ]\n  %iv = phi i64 [ 0, %bb ], [ %iv.next, %loop ]\n  %for.1.use.1 = fmul fast float %for.1, 2.000000e+00\n  %for.1.use.c = fmul fast float %for.1.use.1, 2.000000e+00\n  %used.by.both = fmul fast float %for.1.use.c, %for.2\n  %for.2.next = load float, ptr %for.ptr.2, align 4\n  %for.1.use.3 = fadd fast float %for.1, 1.000000e+00\n  %iv.next = add nuw nsw i64 %iv, 1\n  %for.1.next = load float, ptr %for.ptr.1, align 4\n  %gep.dst.1 = getelementptr inbounds float, ptr %dst.1, i64 %iv\n  store float %used.by.both, ptr %gep.dst.1, align 4\n  %gep.dst.2 = getelementptr inbounds float, ptr %dst.2, i64 %iv\n  store float %for.1.use.1, ptr %gep.dst.2, align 4\n  %gep.dst.3 = getelementptr inbounds float, ptr %dst.3, i64 %iv\n  store float %for.1.use.3, ptr %gep.dst.3, align 4\n  %ec = icmp slt i64 %iv, 1000\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence-multiply-recurrences.ll",
      "commands": [],
      "tests": [
        {
          "test_name": "test_pr54223_sink_after_insertion_order",
          "test_body": "define void @test_pr54223_sink_after_insertion_order(ptr noalias %a, ptr noalias %b, ptr noalias %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %for.1 = phi float [ 0.000000e+00, %entry ], [ %for.1.next, %loop ]\n  %for.2 = phi float [ 0.000000e+00, %entry ], [ %for.2.next, %loop ]\n  %neg = fneg float %for.2\n  %muladd = call float @llvm.fmuladd.f32(float %for.1, float %neg, float 0.000000e+00)\n  %dst.gep = getelementptr inbounds float, ptr %dst, i64 %iv\n  %iv.next = add nuw nsw i64 %iv, 1\n  %for.1.next = load float, ptr %a, align 4\n  %for.2.next = load float, ptr %b, align 4\n  store float %muladd, ptr %dst.gep, align 4\n  %exitcond.not = icmp eq i64 %iv.next, 10000\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.fmuladd.f32(float, float, float) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "test_pr54233_for_depend_on_each_other",
          "test_body": "define void @test_pr54233_for_depend_on_each_other(ptr noalias %a, ptr noalias %b) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %for.1 = phi i32 [ 0, %entry ], [ %for.1.next, %loop ]\n  %for.2 = phi i32 [ 0, %entry ], [ %for.2.next, %loop ]\n  %or = or i32 %for.2, 10\n  %shl = shl i32 %for.2, %for.1\n  %xor = xor i32 %shl, 255\n  %and = and i32 %xor, %or\n  %for.1.next = xor i32 12, %for.2\n  %for.2.next = load i32, ptr %b, align 4\n  %a.gep = getelementptr inbounds i32, ptr %a, i64 %iv\n  store i32 %and, ptr %a.gep, align 4\n  %iv.next = add nuw i64 %iv, 1\n  %exitcond = icmp eq i64 %iv, 1000\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize -force-vector-width=1 -force-vector-interleave=2 -force-widen-divrem-via-safe-divisor=0 -S",
        "opt < %s -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -force-widen-divrem-via-safe-divisor=0 -S"
      ],
      "tests": [
        {
          "test_name": "recurrence_3",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @recurrence_3(ptr noalias readonly %a, ptr noalias %b, i32 %n, float %f, i16 %p) {\nentry:\n  %0 = load i16, ptr %a, align 2\n  %conv = sitofp i16 %0 to double\n  %conv1 = fpext float %f to double\n  %conv2 = sitofp i16 %p to double\n  %mul = fmul fast double %conv2, %conv1\n  %sub = fsub fast double %conv, %mul\n  store double %sub, ptr %b, align 8\n  %cmp25 = icmp sgt i32 %n, 1\n  br i1 %cmp25, label %for.preheader, label %for.end\n\nfor.preheader:                                    ; preds = %entry\n  br label %scalar.body\n\nscalar.body:                                      ; preds = %scalar.body, %for.preheader\n  %1 = phi i16 [ %0, %for.preheader ], [ %2, %scalar.body ]\n  %advars.iv = phi i64 [ %advars.iv.next, %scalar.body ], [ 1, %for.preheader ]\n  %arrayidx5 = getelementptr inbounds i16, ptr %a, i64 %advars.iv\n  %2 = load i16, ptr %arrayidx5, align 2\n  %conv6 = sitofp i16 %2 to double\n  %conv11 = sitofp i16 %1 to double\n  %mul12 = fmul fast double %conv11, %conv1\n  %sub13 = fsub fast double %conv6, %mul12\n  %arrayidx15 = getelementptr inbounds double, ptr %b, i64 %advars.iv\n  store double %sub13, ptr %arrayidx15, align 8\n  %advars.iv.next = add nuw nsw i64 %advars.iv, 1\n  %lftr.wideiv = trunc i64 %advars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, %n\n  br i1 %exitcond, label %for.end.loopexit, label %scalar.body\n\nfor.end.loopexit:                                 ; preds = %scalar.body\n  br label %for.end\n\nfor.end:                                          ; preds = %for.end.loopexit, %entry\n  ret void\n}\n"
        },
        {
          "test_name": "PR30183",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @PR30183(i32 %pre_load, ptr %a, ptr %b, i64 %n) {\nentry:\n  br label %scalar.body\n\nscalar.body:                                      ; preds = %scalar.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %scalar.body ]\n  %var0 = phi i32 [ %pre_load, %entry ], [ %var2, %scalar.body ]\n  %i.next = add nuw nsw i64 %i, 2\n  %var1 = getelementptr inbounds i32, ptr %a, i64 %i.next\n  %var2 = load i32, ptr %var1, align 4\n  %cond = icmp eq i64 %i.next, %n\n  br i1 %cond, label %for.end, label %scalar.body\n\nfor.end:                                          ; preds = %scalar.body\n  ret i32 %var0\n}\n"
        },
        {
          "test_name": "do_not_sink_branch",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @do_not_sink_branch(i32 %x, ptr %in, ptr %out, i32 %tc) local_unnamed_addr {\nentry:\n  %cmp530 = icmp slt i32 0, %tc\n  br label %for.body4\n\nfor.body4:                                        ; preds = %cond.end, %entry\n  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %cond.end ]\n  %cmp534 = phi i1 [ %cmp530, %entry ], [ %cmp5, %cond.end ]\n  br i1 %cmp534, label %cond.true, label %cond.end\n\ncond.true:                                        ; preds = %for.body4\n  %arrayidx7 = getelementptr inbounds i32, ptr %in, i32 %indvars.iv\n  %in.val = load i32, ptr %arrayidx7, align 4\n  br label %cond.end\n\ncond.end:                                         ; preds = %cond.true, %for.body4\n  %cond = phi i32 [ %in.val, %cond.true ], [ 0, %for.body4 ]\n  %arrayidx8 = getelementptr inbounds i32, ptr %out, i32 %indvars.iv\n  store i32 %cond, ptr %arrayidx8, align 4\n  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1\n  %cmp5 = icmp slt i32 %indvars.iv.next, %tc\n  %exitcond = icmp eq i32 %indvars.iv.next, %x\n  br i1 %exitcond, label %for.end12.loopexit, label %for.body4\n\nfor.end12.loopexit:                               ; preds = %cond.end\n  ret void\n}\n"
        },
        {
          "test_name": "PR33613",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @PR33613(ptr %b, double %j, i32 %d) {\nentry:\n  %idxprom = sext i32 %d to i64\n  br label %for.body\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  %a.1.lcssa = phi i32 [ %a.1, %for.body ]\n  ret i32 %a.1.lcssa\n\nfor.body:                                         ; preds = %for.body, %entry\n  %b.addr.012 = phi ptr [ %b, %entry ], [ %add.ptr, %for.body ]\n  %i.011 = phi i32 [ 0, %entry ], [ %inc1, %for.body ]\n  %a.010 = phi i32 [ 0, %entry ], [ %a.1, %for.body ]\n  %j.addr.09 = phi double [ %j, %entry ], [ %0, %for.body ]\n  %arrayidx = getelementptr inbounds double, ptr %b.addr.012, i64 %idxprom\n  %0 = load double, ptr %arrayidx, align 8\n  %mul = fmul double %j.addr.09, %0\n  %tobool = fcmp une double %mul, 0.000000e+00\n  %inc = zext i1 %tobool to i32\n  %a.1 = add nsw i32 %a.010, %inc\n  %inc1 = add nuw nsw i32 %i.011, 1\n  %add.ptr = getelementptr inbounds double, ptr %b.addr.012, i64 25\n  %exitcond = icmp eq i32 %inc1, 10240\n  br i1 %exitcond, label %for.cond.cleanup, label %for.body\n}\n"
        },
        {
          "test_name": "PR34711",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @PR34711(ptr noalias %a, ptr noalias %b, ptr noalias %c, i64 %n) {\nentry:\n  %.pre = load i16, ptr %a, align 2\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %0 = phi i16 [ %.pre, %entry ], [ %1, %for.body ]\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %arraycidx = getelementptr inbounds i32, ptr %c, i64 %indvars.iv\n  %cur.index = getelementptr inbounds [2 x i16], ptr %a, i64 %indvars.iv, i64 1\n  store i32 7, ptr %arraycidx, align 4\n  %conv = sext i16 %0 to i32\n  %1 = load i16, ptr %cur.index, align 2\n  %conv3 = sext i16 %1 to i32\n  %mul = mul nsw i32 %conv3, %conv\n  %arrayidx5 = getelementptr inbounds i32, ptr %b, i64 %indvars.iv\n  store i32 %mul, ptr %arrayidx5, align 4\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %n\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "sink_into_replication_region",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @sink_into_replication_region(i32 %y) {\nbb:\n  br label %bb2\n\nbb1:                                              ; preds = %bb2\n  %var = phi i32 [ %var6, %bb2 ]\n  ret i32 %var\n\nbb2:                                              ; preds = %bb2, %bb\n  %var3 = phi i32 [ %var8, %bb2 ], [ %y, %bb ]\n  %var4 = phi i32 [ %var7, %bb2 ], [ 0, %bb ]\n  %var5 = phi i32 [ %var6, %bb2 ], [ 0, %bb ]\n  %var6 = add i32 %var5, %var4\n  %var7 = udiv i32 219220132, %var3\n  %var8 = add nsw i32 %var3, -1\n  %var9 = icmp slt i32 %var3, 2\n  br i1 %var9, label %bb1, label %bb2, !prof !0\n}\n\n!0 = !{!\"branch_weights\", i32 1, i32 1}\n"
        },
        {
          "test_name": "recurrence_1",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @recurrence_1(ptr noalias readonly %a, ptr noalias %b, i32 %n) {\nentry:\n  br label %for.preheader\n\nfor.preheader:                                    ; preds = %entry\n  %pre_load = load i32, ptr %a, align 4\n  br label %scalar.body\n\nscalar.body:                                      ; preds = %scalar.body, %for.preheader\n  %0 = phi i32 [ %pre_load, %for.preheader ], [ %1, %scalar.body ]\n  %indvars.iv = phi i64 [ 0, %for.preheader ], [ %indvars.iv.next, %scalar.body ]\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %arrayidx32 = getelementptr inbounds i32, ptr %a, i64 %indvars.iv.next\n  %1 = load i32, ptr %arrayidx32, align 4\n  %arrayidx34 = getelementptr inbounds i32, ptr %b, i64 %indvars.iv\n  %add35 = add i32 %1, %0\n  store i32 %add35, ptr %arrayidx34, align 4\n  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, %n\n  br i1 %exitcond, label %for.exit, label %scalar.body\n\nfor.exit:                                         ; preds = %scalar.body\n  ret void\n}\n"
        },
        {
          "test_name": "sink_after_dead_inst",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @sink_after_dead_inst(ptr %A.ptr) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i16 [ 0, %entry ], [ %iv.next, %loop ]\n  %for = phi i32 [ 0, %entry ], [ %for.prev, %loop ]\n  %cmp = icmp eq i32 %for, 15\n  %C = icmp eq i1 %cmp, true\n  %vec.dead = and i1 %C, true\n  %iv.next = add i16 %iv, 1\n  %B1 = or i16 %iv.next, %iv.next\n  %B3 = and i1 %cmp, %C\n  %for.prev = zext i16 %B1 to i32\n  %ext = zext i1 %B3 to i32\n  %A.gep = getelementptr i32, ptr %A.ptr, i16 %iv\n  store i32 0, ptr %A.gep, align 4\n  br i1 %vec.dead, label %for.end, label %loop\n\nfor.end:                                          ; preds = %loop\n  ret i32 %for\n}\n"
        },
        {
          "test_name": "sink_into_replication_region_multiple",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @sink_into_replication_region_multiple(ptr %x, i32 %y) {\nbb:\n  br label %bb2\n\nbb1:                                              ; preds = %bb2\n  %var = phi i32 [ %var6, %bb2 ]\n  ret i32 %var\n\nbb2:                                              ; preds = %bb2, %bb\n  %var3 = phi i32 [ %var8, %bb2 ], [ %y, %bb ]\n  %iv = phi i32 [ %iv.next, %bb2 ], [ 0, %bb ]\n  %var4 = phi i32 [ %var7, %bb2 ], [ 0, %bb ]\n  %var5 = phi i32 [ %var6, %bb2 ], [ 0, %bb ]\n  %g = getelementptr inbounds i32, ptr %x, i32 %iv\n  %var6 = add i32 %var5, %var4\n  %var7 = udiv i32 219220132, %var3\n  store i32 %var3, ptr %g, align 4\n  %var8 = add nsw i32 %var3, -1\n  %iv.next = add nsw i32 %iv, 1\n  %var9 = icmp slt i32 %var3, 2\n  br i1 %var9, label %bb1, label %bb2, !prof !0\n}\n\n!0 = !{!\"branch_weights\", i32 1, i32 1}\n"
        },
        {
          "test_name": "PR27246",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @PR27246() {\nentry:\n  br label %for.cond1.preheader\n\nfor.cond1.preheader:                              ; preds = %for.cond.cleanup3, %entry\n  %i.016 = phi i32 [ 1, %entry ], [ %inc, %for.cond.cleanup3 ]\n  %e.015 = phi i32 [ poison, %entry ], [ %e.1.lcssa, %for.cond.cleanup3 ]\n  br label %for.cond1\n\nfor.cond.cleanup:                                 ; preds = %for.cond.cleanup3\n  %e.1.lcssa.lcssa = phi i32 [ %e.1.lcssa, %for.cond.cleanup3 ]\n  ret i32 %e.1.lcssa.lcssa\n\nfor.cond1:                                        ; preds = %for.cond1, %for.cond1.preheader\n  %e.1 = phi i32 [ %k.0, %for.cond1 ], [ %e.015, %for.cond1.preheader ]\n  %k.0 = phi i32 [ %dec, %for.cond1 ], [ %i.016, %for.cond1.preheader ]\n  %cmp2 = icmp sgt i32 %k.0, 1\n  %dec = add nsw i32 %k.0, -1\n  br i1 %cmp2, label %for.cond1, label %for.cond.cleanup3\n\nfor.cond.cleanup3:                                ; preds = %for.cond1\n  %e.1.lcssa = phi i32 [ %e.1, %for.cond1 ]\n  %inc = add nuw nsw i32 %i.016, 1\n  %exitcond = icmp eq i32 %inc, 49\n  br i1 %exitcond, label %for.cond.cleanup, label %for.cond1.preheader\n}\n"
        },
        {
          "test_name": "recurrence_2",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @recurrence_2(ptr nocapture readonly %a, i32 %n) {\nentry:\n  %cmp27 = icmp sgt i32 %n, 0\n  br i1 %cmp27, label %for.preheader, label %for.cond.cleanup\n\nfor.preheader:                                    ; preds = %entry\n  %arrayidx2.phi.trans.insert = getelementptr inbounds i32, ptr %a, i64 -1\n  %.pre = load i32, ptr %arrayidx2.phi.trans.insert, align 4\n  br label %scalar.body\n\nfor.cond.cleanup.loopexit:                        ; preds = %scalar.body\n  %minmax.0.cond.lcssa = phi i32 [ %minmax.0.cond, %scalar.body ]\n  br label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry\n  %minmax.0.lcssa = phi i32 [ poison, %entry ], [ %minmax.0.cond.lcssa, %for.cond.cleanup.loopexit ]\n  ret i32 %minmax.0.lcssa\n\nscalar.body:                                      ; preds = %scalar.body, %for.preheader\n  %0 = phi i32 [ %.pre, %for.preheader ], [ %1, %scalar.body ]\n  %indvars.iv = phi i64 [ 0, %for.preheader ], [ %indvars.iv.next, %scalar.body ]\n  %minmax.028 = phi i32 [ poison, %for.preheader ], [ %minmax.0.cond, %scalar.body ]\n  %arrayidx = getelementptr inbounds i32, ptr %a, i64 %indvars.iv\n  %1 = load i32, ptr %arrayidx, align 4\n  %sub3 = sub nsw i32 %1, %0\n  %cmp4 = icmp sgt i32 %sub3, 0\n  %cond = select i1 %cmp4, i32 %sub3, i32 0\n  %cmp5 = icmp slt i32 %minmax.028, %cond\n  %minmax.0.cond = select i1 %cmp5, i32 %minmax.028, i32 %cond\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, %n\n  br i1 %exitcond, label %for.cond.cleanup.loopexit, label %scalar.body\n}\n"
        },
        {
          "test_name": "PR26734",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @PR26734(ptr %a, ptr %b, ptr %c, i32 %d, ptr %e) {\nentry:\n  %cmp4 = icmp eq i32 %d, 21\n  br i1 %cmp4, label %entry.for.end_crit_edge, label %for.body.lr.ph\n\nentry.for.end_crit_edge:                          ; preds = %entry\n  %.pre = load i32, ptr %b, align 4\n  br label %for.end\n\nfor.body.lr.ph:                                   ; preds = %entry\n  %0 = load i16, ptr %a, align 2\n  %sub = add i16 %0, -6\n  %conv2 = sext i16 %sub to i32\n  %c.promoted = load i32, ptr %c, align 4\n  %b.promoted = load i32, ptr %b, align 4\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.body.lr.ph\n  %inc7 = phi i32 [ %d, %for.body.lr.ph ], [ %inc, %for.body ]\n  %and6 = phi i32 [ %b.promoted, %for.body.lr.ph ], [ %and, %for.body ]\n  %conv25 = phi i32 [ %c.promoted, %for.body.lr.ph ], [ %conv2, %for.body ]\n  %and = and i32 %and6, %conv25\n  %inc = add nsw i32 %inc7, 1\n  %cmp = icmp eq i32 %inc, 21\n  br i1 %cmp, label %for.cond.for.end_crit_edge, label %for.body\n\nfor.cond.for.end_crit_edge:                       ; preds = %for.body\n  %and.lcssa = phi i32 [ %and, %for.body ]\n  store i32 %conv2, ptr %c, align 4\n  store i32 %and.lcssa, ptr %b, align 4\n  store i16 %sub, ptr %e, align 2\n  br label %for.end\n\nfor.end:                                          ; preds = %for.cond.for.end_crit_edge, %entry.for.end_crit_edge\n  ret void\n}\n"
        },
        {
          "test_name": "unused_recurrence",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @unused_recurrence(ptr %a) {\nentry:\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.cond, %entry\n  %iv = phi i16 [ -27, %entry ], [ %iv.next, %for.cond ]\n  %rec.1 = phi i16 [ 0, %entry ], [ %rec.1.prev, %for.cond ]\n  %use.rec.1 = sub i16 %rec.1, 10\n  %iv.next = add i16 %iv, 1\n  %rec.1.prev = add i16 %iv.next, 5\n  %cmp = icmp eq i16 %iv, 1000\n  br i1 %cmp, label %for.end, label %for.cond\n\nfor.end:                                          ; preds = %for.cond\n  ret void\n}\n"
        },
        {
          "test_name": "sink_after_with_multiple_users",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @sink_after_with_multiple_users(ptr noalias %a, ptr noalias %b, i64 %n) {\nentry:\n  %.pre = load i16, ptr %a, align 2\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %0 = phi i16 [ %.pre, %entry ], [ %1, %for.body ]\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %conv = sext i16 %0 to i32\n  %add = add nsw i32 %conv, 2\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %arrayidx2 = getelementptr inbounds i16, ptr %a, i64 %indvars.iv.next\n  %1 = load i16, ptr %arrayidx2, align 2\n  %conv3 = sext i16 %1 to i32\n  %mul = mul nsw i32 %add, %conv3\n  %arrayidx5 = getelementptr inbounds i32, ptr %b, i64 %indvars.iv\n  store i32 %mul, ptr %arrayidx5, align 4\n  %exitcond = icmp eq i64 %indvars.iv.next, %n\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "sink_after",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @sink_after(ptr noalias %a, ptr noalias %b, i64 %n) {\nentry:\n  %.pre = load i16, ptr %a, align 2\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %0 = phi i16 [ %.pre, %entry ], [ %1, %for.body ]\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %conv = sext i16 %0 to i32\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %arrayidx2 = getelementptr inbounds i16, ptr %a, i64 %indvars.iv.next\n  %1 = load i16, ptr %arrayidx2, align 2\n  %conv3 = sext i16 %1 to i32\n  %mul = mul nsw i32 %conv3, %conv\n  %arrayidx5 = getelementptr inbounds i32, ptr %b, i64 %indvars.iv\n  store i32 %mul, ptr %arrayidx5, align 4\n  %exitcond = icmp eq i64 %indvars.iv.next, %n\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "constant_folded_previous_value",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i64 @constant_folded_previous_value() {\nentry:\n  br label %scalar.body\n\nscalar.body:                                      ; preds = %scalar.body, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %scalar.body ]\n  %var2 = phi i64 [ 0, %entry ], [ %var3, %scalar.body ]\n  %var3 = add i64 0, 1\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp eq i64 %i.next, 1000\n  br i1 %cond, label %for.end, label %scalar.body\n\nfor.end:                                          ; preds = %scalar.body\n  ret i64 %var2\n}\n"
        },
        {
          "test_name": "recurence_uniform_load",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @recurence_uniform_load(ptr %src, ptr noalias %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %phi = phi i64 [ 0, %entry ], [ %add, %loop ]\n  %recur = phi i32 [ 0, %entry ], [ %load, %loop ]\n  %add = add i64 %phi, 1\n  %load = load i32, ptr %src, align 4\n  %icmp = icmp ult i64 %phi, 1\n  br i1 %icmp, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret i32 0\n}\n"
        },
        {
          "test_name": "extract_second_last_iteration",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine i32 @extract_second_last_iteration(ptr %cval, i32 %x) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %inc.phi = phi i32 [ 0, %entry ], [ %inc, %for.body ]\n  %val.phi = phi i32 [ 0, %entry ], [ %addx, %for.body ]\n  %inc = add i32 %inc.phi, 1\n  %bc = zext i32 %inc.phi to i64\n  %addx = add i32 %inc.phi, %x\n  %cmp = icmp eq i32 %inc.phi, 95\n  br i1 %cmp, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret i32 %val.phi\n}\n"
        },
        {
          "test_name": "sink_dead_inst",
          "test_body": "target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n\ndefine void @sink_dead_inst(ptr %a) {\nentry:\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.cond, %entry\n  %iv = phi i16 [ -27, %entry ], [ %iv.next, %for.cond ]\n  %rec.1 = phi i16 [ 0, %entry ], [ %rec.1.prev, %for.cond ]\n  %rec.2 = phi i32 [ -27, %entry ], [ %rec.2.prev, %for.cond ]\n  %use.rec.1 = sub i16 %rec.1, 10\n  %cmp = icmp eq i32 %rec.2, 15\n  %iv.next = add i16 %iv, 1\n  %rec.2.prev = zext i16 %iv.next to i32\n  %rec.1.prev = add i16 %iv.next, 5\n  %gep = getelementptr i16, ptr %a, i16 %iv\n  store i16 %use.rec.1, ptr %gep, align 2\n  br i1 %cmp, label %for.end, label %for.cond\n\nfor.end:                                          ; preds = %for.cond\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion `hasVectorValue(Def, Instance.Part)' failed.",
    "body": "To reproduce run the following test opt with -passes loop-vectorize:\r\n```\r\n; ModuleID = './reduced.ll'\r\nsource_filename = \"./reduced.ll\"\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine i32 @wombat() gc \"statepoint-example\" {\r\nbb:\r\n  br label %bb2\r\n\r\nbb1:                                              ; preds = %bb2\r\n  ret i32 0\r\n\r\nbb2:                                              ; preds = %bb2, %bb\r\n  %phi = phi i64 [ 0, %bb ], [ %add, %bb2 ]\r\n  %phi3 = phi i32 [ 0, %bb ], [ %load, %bb2 ]\r\n  %add = add i64 %phi, 1\r\n  %load = load i32, ptr addrspace(1) null, align 4\r\n  %icmp = icmp ult i64 %phi, 1\r\n  br i1 %icmp, label %bb2, label %bb1\r\n}\r\n```\r\nReproducer: https://godbolt.org/z/cv7Tf3vba\r\n\r\nStack dump:\r\n```\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes loop-vectorize <source>\r\n #0 0x0000000004e41688 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e41688)\r\n #1 0x0000000004e3eddc SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007ec2abe42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x00007ec2abe969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #4 0x00007ec2abe42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #5 0x00007ec2abe287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #6 0x00007ec2abe2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #7 0x00007ec2abe39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #8 0x0000000003fecdce (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3fecdce)\r\n #9 0x0000000004008abe llvm::VPInstruction::generatePerPart(llvm::VPTransformState&, unsigned int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4008abe)\r\n#10 0x000000000400ae5e llvm::VPInstruction::execute(llvm::VPTransformState&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x400ae5e)\r\n#11 0x0000000003fe5fbf llvm::VPBasicBlock::executeRecipes(llvm::VPTransformState*, llvm::BasicBlock*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3fe5fbf)\r\n#12 0x0000000003fe9cb0 llvm::VPBasicBlock::execute(llvm::VPTransformState*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3fe9cb0)\r\n#13 0x0000000003feda3e llvm::VPlan::execute(llvm::VPTransformState*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3feda3e)\r\n#14 0x0000000003eda4e5 llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoopVectorizer&, llvm::DominatorTree*, bool, llvm::DenseMap<llvm::SCEV const*, llvm::Value*, llvm::DenseMapInfo<llvm::SCEV const*, void>, llvm::detail::DenseMapPair<llvm::SCEV const*, llvm::Value*>> const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3eda4e5)\r\n#15 0x0000000003eef18b llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3eef18b)\r\n#16 0x0000000003ef1a4d llvm::LoopVectorizePass::runImpl(llvm::Function&, llvm::ScalarEvolution&, llvm::LoopInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::BlockFrequencyInfo*, llvm::TargetLibraryInfo*, llvm::DemandedBits&, llvm::AssumptionCache&, llvm::LoopAccessInfoManager&, llvm::OptimizationRemarkEmitter&, llvm::ProfileSummaryInfo*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3ef1a4d)\r\n#17 0x0000000003ef2c5b llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3ef2c5b)\r\n#18 0x0000000002e0679e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2e0679e)\r\n#19 0x0000000004c49a6c llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c49a6c)\r\n#20 0x0000000000dbabee llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xdbabee)\r\n#21 0x0000000004c483ae llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c483ae)\r\n#22 0x0000000000dbc65e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xdbc65e)\r\n#23 0x0000000004c462bc llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c462bc)\r\n#24 0x00000000008db912 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8db912)\r\n#25 0x00000000008ceabc optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8ceabc)\r\n#26 0x00007ec2abe29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#27 0x00007ec2abe29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#28 0x00000000008c5f0e _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8c5f0e)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139\r\n```\r\n\r\n",
    "author": "TatyanaDoubts",
    "labels": [
      "vectorizers",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "cc @fhahn "
      }
    ]
  }
}
