{
  "bug_id": "106667",
  "issue_url": "https://github.com/llvm/llvm-project/issues/106667",
  "bug_type": "crash",
  "base_commit": "5500e21942f7047344b6fee62d3e08c0ba2f9182",
  "knowledge_cutoff": "2024-08-30T05:59:16Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "a4aa6bc8fc2130761b8db5db4748059127662785",
    "components": [
      "SLPVectorizer"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          2864,
          2869
        ],
        [
          6964,
          6969
        ],
        [
          7095,
          7149
        ],
        [
          9362,
          9383
        ],
        [
          12521,
          12530
        ],
        [
          12532,
          12640
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::getOperandEntry",
        "getTreeEntry",
        "empty",
        "gather",
        "isOperandGatherNode",
        "ShuffleInstructionBuilder",
        "size",
        "BoUpSLP::vectorizeOperand",
        "doesNotNeedToBeScheduled",
        "finalize",
        "add",
        "EdgeInfo",
        "newTreeEntry",
        "getOpcode",
        "InstructionsState",
        "BoUpSLP::buildTree_rec",
        "getNumElements",
        "getSameOpcode",
        "isGather",
        "findLaneForValue",
        "isSame"
      ]
    }
  },
  "patch": "commit a4aa6bc8fc2130761b8db5db4748059127662785\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Fri Aug 30 10:17:31 2024 -0700\n\n    [SLP]Fix PR106667: carefully look for operand nodes.\n    \n    If the operand node has the same scalars as one of the vectorized nodes,\n    the compiler could miss this and incorrectly request minbitwidth data\n    for the wrong node. It may lead to a compiler crash, because the\n      vectorized node might have different minbw result.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/106667\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 4c0a1c4c094b..e9785ef9ded2 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -2864,6 +2864,12 @@ private:\n   /// avoid issues with def-use order.\n   Value *vectorizeTree(TreeEntry *E, bool PostponedPHIs);\n \n+  TreeEntry *getMatchedVectorizedOperand(const TreeEntry *E, unsigned NodeIdx);\n+  const TreeEntry *getMatchedVectorizedOperand(const TreeEntry *E,\n+                                               unsigned NodeIdx) const {\n+    return const_cast<BoUpSLP *>(this)->getMatchedVectorizedOperand(E, NodeIdx);\n+  }\n+\n   /// Vectorize a single entry in the tree, the \\p Idx-th operand of the entry\n   /// \\p E.\n   /// \\param PostponedPHIs true, if need to postpone emission of phi nodes to\n@@ -6964,6 +6970,55 @@ void BoUpSLP::buildTree_rec(ArrayRef<Value *> VL, unsigned Depth,\n     }\n   }\n \n+  // Check if this is a duplicate of another entry.\n+  if (TreeEntry *E = getTreeEntry(S.OpValue)) {\n+    LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.OpValue << \".\\n\");\n+    if (!E->isSame(VL)) {\n+      auto It = MultiNodeScalars.find(S.OpValue);\n+      if (It != MultiNodeScalars.end()) {\n+        auto *TEIt = find_if(It->getSecond(),\n+                             [&](TreeEntry *ME) { return ME->isSame(VL); });\n+        if (TEIt != It->getSecond().end())\n+          E = *TEIt;\n+        else\n+          E = nullptr;\n+      } else {\n+        E = nullptr;\n+      }\n+    }\n+    if (!E) {\n+      if (!doesNotNeedToBeScheduled(S.OpValue)) {\n+        LLVM_DEBUG(dbgs() << \"SLP: Gathering due to partial overlap.\\n\");\n+        if (TryToFindDuplicates(S))\n+          newTreeEntry(VL, std::nullopt /*not vectorized*/, S, UserTreeIdx,\n+                       ReuseShuffleIndices);\n+        return;\n+      }\n+      SmallPtrSet<const TreeEntry *, 4> Nodes;\n+      Nodes.insert(getTreeEntry(S.OpValue));\n+      for (const TreeEntry *E : MultiNodeScalars.lookup(S.OpValue))\n+        Nodes.insert(E);\n+      SmallPtrSet<Value *, 8> Values(VL.begin(), VL.end());\n+      if (any_of(Nodes, [&](const TreeEntry *E) {\n+            return all_of(E->Scalars,\n+                          [&](Value *V) { return Values.contains(V); });\n+          })) {\n+        LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\");\n+        if (TryToFindDuplicates(S))\n+          newTreeEntry(VL, std::nullopt /*not vectorized*/, S, UserTreeIdx,\n+                       ReuseShuffleIndices);\n+        return;\n+      }\n+    } else {\n+      // Record the reuse of the tree node.  FIXME, currently this is only used\n+      // to properly draw the graph rather than for the actual vectorization.\n+      E->UserTreeIndices.push_back(UserTreeIdx);\n+      LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.OpValue\n+                        << \".\\n\");\n+      return;\n+    }\n+  }\n+\n   // Gather if we hit the RecursionMaxDepth, unless this is a load (or z/sext of\n   // a load), in which case peek through to include it in the tree, without\n   // ballooning over-budget.\n@@ -7095,55 +7150,6 @@ void BoUpSLP::buildTree_rec(ArrayRef<Value *> VL, unsigned Depth,\n   // We now know that this is a vector of instructions of the same type from\n   // the same block.\n \n-  // Check if this is a duplicate of another entry.\n-  if (TreeEntry *E = getTreeEntry(S.OpValue)) {\n-    LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.OpValue << \".\\n\");\n-    if (!E->isSame(VL)) {\n-      auto It = MultiNodeScalars.find(S.OpValue);\n-      if (It != MultiNodeScalars.end()) {\n-        auto *TEIt = find_if(It->getSecond(),\n-                             [&](TreeEntry *ME) { return ME->isSame(VL); });\n-        if (TEIt != It->getSecond().end())\n-          E = *TEIt;\n-        else\n-          E = nullptr;\n-      } else {\n-        E = nullptr;\n-      }\n-    }\n-    if (!E) {\n-      if (!doesNotNeedToBeScheduled(S.OpValue)) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Gathering due to partial overlap.\\n\");\n-        if (TryToFindDuplicates(S))\n-          newTreeEntry(VL, std::nullopt /*not vectorized*/, S, UserTreeIdx,\n-                       ReuseShuffleIndices);\n-        return;\n-      }\n-      SmallPtrSet<const TreeEntry *, 4> Nodes;\n-      Nodes.insert(getTreeEntry(S.OpValue));\n-      for (const TreeEntry *E : MultiNodeScalars.lookup(S.OpValue))\n-        Nodes.insert(E);\n-      SmallPtrSet<Value *, 8> Values(VL.begin(), VL.end());\n-      if (any_of(Nodes, [&](const TreeEntry *E) {\n-            return all_of(E->Scalars,\n-                          [&](Value *V) { return Values.contains(V); });\n-          })) {\n-        LLVM_DEBUG(dbgs() << \"SLP: Gathering due to full overlap.\\n\");\n-        if (TryToFindDuplicates(S))\n-          newTreeEntry(VL, std::nullopt /*not vectorized*/, S, UserTreeIdx,\n-                       ReuseShuffleIndices);\n-        return;\n-      }\n-    } else {\n-      // Record the reuse of the tree node.  FIXME, currently this is only used\n-      // to properly draw the graph rather than for the actual vectorization.\n-      E->UserTreeIndices.push_back(UserTreeIdx);\n-      LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.OpValue\n-                        << \".\\n\");\n-      return;\n-    }\n-  }\n-\n   // Check that none of the instructions in the bundle are already in the tree.\n   for (Value *V : VL) {\n     if ((!IsScatterVectorizeUserTE && !isa<Instruction>(V)) ||\n@@ -9362,22 +9368,8 @@ public:\n \n const BoUpSLP::TreeEntry *BoUpSLP::getOperandEntry(const TreeEntry *E,\n                                                    unsigned Idx) const {\n-  Value *Op = E->getOperand(Idx).front();\n-  if (const TreeEntry *TE = getTreeEntry(Op)) {\n-    if (find_if(TE->UserTreeIndices, [&](const EdgeInfo &EI) {\n-          return EI.EdgeIdx == Idx && EI.UserTE == E;\n-        }) != TE->UserTreeIndices.end())\n-      return TE;\n-    auto MIt = MultiNodeScalars.find(Op);\n-    if (MIt != MultiNodeScalars.end()) {\n-      for (const TreeEntry *TE : MIt->second) {\n-        if (find_if(TE->UserTreeIndices, [&](const EdgeInfo &EI) {\n-              return EI.EdgeIdx == Idx && EI.UserTE == E;\n-            }) != TE->UserTreeIndices.end())\n-          return TE;\n-      }\n-    }\n-  }\n+  if (const TreeEntry *VE = getMatchedVectorizedOperand(E, Idx))\n+    return VE;\n   const auto *It =\n       find_if(VectorizableTree, [&](const std::unique_ptr<TreeEntry> &TE) {\n         return TE->isGather() &&\n@@ -12521,10 +12513,9 @@ public:\n   }\n };\n \n-Value *BoUpSLP::vectorizeOperand(TreeEntry *E, unsigned NodeIdx,\n-                                 bool PostponedPHIs) {\n-  ValueList &VL = E->getOperand(NodeIdx);\n-  const unsigned VF = VL.size();\n+BoUpSLP::TreeEntry *BoUpSLP::getMatchedVectorizedOperand(const TreeEntry *E,\n+                                                         unsigned NodeIdx) {\n+  ArrayRef<Value *> VL = E->getOperand(NodeIdx);\n   InstructionsState S = getSameOpcode(VL, *TLI);\n   // Special processing for GEPs bundle, which may include non-gep values.\n   if (!S.getOpcode() && VL.front()->getType()->isPointerTy()) {\n@@ -12532,109 +12523,113 @@ Value *BoUpSLP::vectorizeOperand(TreeEntry *E, unsigned NodeIdx,\n     if (It != VL.end())\n       S = getSameOpcode(*It, *TLI);\n   }\n-  if (S.getOpcode()) {\n-    auto CheckSameVE = [&](const TreeEntry *VE) {\n-      return VE->isSame(VL) &&\n-             (any_of(VE->UserTreeIndices,\n-                     [E, NodeIdx](const EdgeInfo &EI) {\n-                       return EI.UserTE == E && EI.EdgeIdx == NodeIdx;\n-                     }) ||\n-              any_of(VectorizableTree,\n-                     [E, NodeIdx, VE](const std::unique_ptr<TreeEntry> &TE) {\n-                       return TE->isOperandGatherNode({E, NodeIdx}) &&\n-                              VE->isSame(TE->Scalars);\n-                     }));\n+  if (!S.getOpcode())\n+    return nullptr;\n+  auto CheckSameVE = [&](const TreeEntry *VE) {\n+    return VE->isSame(VL) &&\n+           (any_of(VE->UserTreeIndices,\n+                   [E, NodeIdx](const EdgeInfo &EI) {\n+                     return EI.UserTE == E && EI.EdgeIdx == NodeIdx;\n+                   }) ||\n+            any_of(VectorizableTree,\n+                   [E, NodeIdx, VE](const std::unique_ptr<TreeEntry> &TE) {\n+                     return TE->isOperandGatherNode(\n+                                {const_cast<TreeEntry *>(E), NodeIdx}) &&\n+                            VE->isSame(TE->Scalars);\n+                   }));\n+  };\n+  TreeEntry *VE = getTreeEntry(S.OpValue);\n+  if (VE && CheckSameVE(VE))\n+    return VE;\n+  auto It = MultiNodeScalars.find(S.OpValue);\n+  if (It != MultiNodeScalars.end()) {\n+    auto *I = find_if(It->getSecond(), [&](const TreeEntry *TE) {\n+      return TE != VE && CheckSameVE(TE);\n+    });\n+    if (I != It->getSecond().end())\n+      return *I;\n+  }\n+  return nullptr;\n+}\n+\n+Value *BoUpSLP::vectorizeOperand(TreeEntry *E, unsigned NodeIdx,\n+                                 bool PostponedPHIs) {\n+  ValueList &VL = E->getOperand(NodeIdx);\n+  const unsigned VF = VL.size();\n+  if (TreeEntry *VE = getMatchedVectorizedOperand(E, NodeIdx)) {\n+    auto FinalShuffle = [&](Value *V, ArrayRef<int> Mask) {\n+      // V may be affected by MinBWs.\n+      // We want ShuffleInstructionBuilder to correctly support REVEC. The key\n+      // factor is the number of elements, not their type.\n+      Type *ScalarTy = cast<VectorType>(V->getType())->getElementType();\n+      unsigned NumElements = getNumElements(VL.front()->getType());\n+      ShuffleInstructionBuilder ShuffleBuilder(\n+          NumElements != 1 ? FixedVectorType::get(ScalarTy, NumElements)\n+                           : ScalarTy,\n+          Builder, *this);\n+      ShuffleBuilder.add(V, Mask);\n+      SmallVector<std::pair<const TreeEntry *, unsigned>> SubVectors(\n+          E->CombinedEntriesWithIndices.size());\n+      transform(E->CombinedEntriesWithIndices, SubVectors.begin(),\n+                [&](const auto &P) {\n+                  return std::make_pair(VectorizableTree[P.first].get(),\n+                                        P.second);\n+                });\n+      return ShuffleBuilder.finalize(std::nullopt, SubVectors);\n     };\n-    TreeEntry *VE = getTreeEntry(S.OpValue);\n-    bool IsSameVE = VE && CheckSameVE(VE);\n-    if (!IsSameVE) {\n-      auto It = MultiNodeScalars.find(S.OpValue);\n-      if (It != MultiNodeScalars.end()) {\n-        auto *I = find_if(It->getSecond(), [&](const TreeEntry *TE) {\n-          return TE != VE && CheckSameVE(TE);\n-        });\n-        if (I != It->getSecond().end()) {\n-          VE = *I;\n-          IsSameVE = true;\n-        }\n-      }\n-    }\n-    if (IsSameVE) {\n-      auto FinalShuffle = [&](Value *V, ArrayRef<int> Mask) {\n-        // V may be affected by MinBWs.\n-        // We want ShuffleInstructionBuilder to correctly support REVEC. The key\n-        // factor is the number of elements, not their type.\n-        Type *ScalarTy = cast<VectorType>(V->getType())->getElementType();\n-        unsigned NumElements = getNumElements(VL.front()->getType());\n-        ShuffleInstructionBuilder ShuffleBuilder(\n-            NumElements != 1 ? FixedVectorType::get(ScalarTy, NumElements)\n-                             : ScalarTy,\n-            Builder, *this);\n-        ShuffleBuilder.add(V, Mask);\n-        SmallVector<std::pair<const TreeEntry *, unsigned>> SubVectors(\n-            E->CombinedEntriesWithIndices.size());\n-        transform(E->CombinedEntriesWithIndices, SubVectors.begin(),\n-                  [&](const auto &P) {\n-                    return std::make_pair(VectorizableTree[P.first].get(),\n-                                          P.second);\n-                  });\n-        return ShuffleBuilder.finalize(std::nullopt, SubVectors);\n-      };\n-      Value *V = vectorizeTree(VE, PostponedPHIs);\n-      if (VF * getNumElements(VL[0]->getType()) !=\n-          cast<FixedVectorType>(V->getType())->getNumElements()) {\n-        if (!VE->ReuseShuffleIndices.empty()) {\n-          // Reshuffle to get only unique values.\n-          // If some of the scalars are duplicated in the vectorization\n-          // tree entry, we do not vectorize them but instead generate a\n-          // mask for the reuses. But if there are several users of the\n-          // same entry, they may have different vectorization factors.\n-          // This is especially important for PHI nodes. In this case, we\n-          // need to adapt the resulting instruction for the user\n-          // vectorization factor and have to reshuffle it again to take\n-          // only unique elements of the vector. Without this code the\n-          // function incorrectly returns reduced vector instruction with\n-          // the same elements, not with the unique ones.\n-\n-          // block:\n-          // %phi = phi <2 x > { .., %entry} {%shuffle, %block}\n-          // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>\n-          // ... (use %2)\n-          // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}\n-          // br %block\n-          SmallVector<int> Mask(VF, PoisonMaskElem);\n-          for (auto [I, V] : enumerate(VL)) {\n-            if (isa<PoisonValue>(V))\n-              continue;\n-            Mask[I] = VE->findLaneForValue(V);\n-          }\n-          V = FinalShuffle(V, Mask);\n-        } else {\n-          assert(VF < cast<FixedVectorType>(V->getType())->getNumElements() &&\n-                 \"Expected vectorization factor less \"\n-                 \"than original vector size.\");\n-          SmallVector<int> UniformMask(VF, 0);\n-          std::iota(UniformMask.begin(), UniformMask.end(), 0);\n-          V = FinalShuffle(V, UniformMask);\n+    Value *V = vectorizeTree(VE, PostponedPHIs);\n+    if (VF * getNumElements(VL[0]->getType()) !=\n+        cast<FixedVectorType>(V->getType())->getNumElements()) {\n+      if (!VE->ReuseShuffleIndices.empty()) {\n+        // Reshuffle to get only unique values.\n+        // If some of the scalars are duplicated in the vectorization\n+        // tree entry, we do not vectorize them but instead generate a\n+        // mask for the reuses. But if there are several users of the\n+        // same entry, they may have different vectorization factors.\n+        // This is especially important for PHI nodes. In this case, we\n+        // need to adapt the resulting instruction for the user\n+        // vectorization factor and have to reshuffle it again to take\n+        // only unique elements of the vector. Without this code the\n+        // function incorrectly returns reduced vector instruction with\n+        // the same elements, not with the unique ones.\n+\n+        // block:\n+        // %phi = phi <2 x > { .., %entry} {%shuffle, %block}\n+        // %2 = shuffle <2 x > %phi, poison, <4 x > <1, 1, 0, 0>\n+        // ... (use %2)\n+        // %shuffle = shuffle <2 x> %2, poison, <2 x> {2, 0}\n+        // br %block\n+        SmallVector<int> Mask(VF, PoisonMaskElem);\n+        for (auto [I, V] : enumerate(VL)) {\n+          if (isa<PoisonValue>(V))\n+            continue;\n+          Mask[I] = VE->findLaneForValue(V);\n         }\n-      }\n-      // Need to update the operand gather node, if actually the operand is not a\n-      // vectorized node, but the buildvector/gather node, which matches one of\n-      // the vectorized nodes.\n-      if (find_if(VE->UserTreeIndices, [&](const EdgeInfo &EI) {\n-            return EI.UserTE == E && EI.EdgeIdx == NodeIdx;\n-          }) == VE->UserTreeIndices.end()) {\n-        auto *It = find_if(\n-            VectorizableTree, [&](const std::unique_ptr<TreeEntry> &TE) {\n-              return TE->isGather() &&\n-                     TE->UserTreeIndices.front().UserTE == E &&\n-                     TE->UserTreeIndices.front().EdgeIdx == NodeIdx;\n-            });\n-        assert(It != VectorizableTree.end() && \"Expected gather node operand.\");\n-        (*It)->VectorizedValue = V;\n-      }\n-      return V;\n+        V = FinalShuffle(V, Mask);\n+      } else {\n+        assert(VF < cast<FixedVectorType>(V->getType())->getNumElements() &&\n+               \"Expected vectorization factor less \"\n+               \"than original vector size.\");\n+        SmallVector<int> UniformMask(VF, 0);\n+        std::iota(UniformMask.begin(), UniformMask.end(), 0);\n+        V = FinalShuffle(V, UniformMask);\n+      }\n+    }\n+    // Need to update the operand gather node, if actually the operand is not a\n+    // vectorized node, but the buildvector/gather node, which matches one of\n+    // the vectorized nodes.\n+    if (find_if(VE->UserTreeIndices, [&](const EdgeInfo &EI) {\n+          return EI.UserTE == E && EI.EdgeIdx == NodeIdx;\n+        }) == VE->UserTreeIndices.end()) {\n+      auto *It =\n+          find_if(VectorizableTree, [&](const std::unique_ptr<TreeEntry> &TE) {\n+            return TE->isGather() && TE->UserTreeIndices.front().UserTE == E &&\n+                   TE->UserTreeIndices.front().EdgeIdx == NodeIdx;\n+          });\n+      assert(It != VectorizableTree.end() && \"Expected gather node operand.\");\n+      (*It)->VectorizedValue = V;\n     }\n+    return V;\n   }\n \n   // Find the corresponding gather entry and vectorize it.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/multi-nodes-bv-vectorized.ll",
      "commands": [
        "opt -passes=slp-vectorizer -S -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define void @test(ptr %p) {\nentry:\n  %conv548.2.i.13 = zext i32 0 to i64\n  %and551.2.i.13 = and i64 0, %conv548.2.i.13\n  %conv548.3.i.13 = zext i32 0 to i64\n  %and551.3.i.13 = and i64 0, %conv548.3.i.13\n  %0 = trunc i64 %and551.2.i.13 to i32\n  %conv54.2.i.14 = and i32 %0, 0\n  %conv548.2.i.14 = zext i32 %conv54.2.i.14 to i64\n  %and551.2.i.14 = and i64 %and551.2.i.13, %conv548.2.i.14\n  %1 = trunc i64 %and551.3.i.13 to i32\n  %conv54.3.i.14 = and i32 %1, 0\n  %conv548.3.i.14 = zext i32 %conv54.3.i.14 to i64\n  %and551.3.i.14 = and i64 %and551.3.i.13, %conv548.3.i.14\n  %and551.2.i.15 = and i64 %and551.2.i.14, 0\n  %and551.3.i.15 = and i64 %and551.3.i.14, 0\n  %and551.2.i.16 = and i64 %and551.2.i.15, 0\n  %and551.3.i.16 = and i64 %and551.3.i.15, 0\n  %and551.2.i.17 = and i64 %and551.2.i.16, 0\n  %and551.3.i.17 = and i64 %and551.3.i.16, 0\n  %and551.2.i.18 = and i64 %and551.2.i.17, 0\n  %and551.3.i.18 = and i64 %and551.3.i.17, 0\n  %and551.2.i.19 = and i64 %and551.2.i.18, 0\n  %and551.3.i.19 = and i64 %and551.3.i.18, 0\n  %and551.2.i.20 = and i64 %and551.2.i.19, 0\n  %and551.3.i.20 = and i64 %and551.3.i.19, 0\n  %and551.2.i.21 = and i64 %and551.2.i.20, 0\n  %and551.3.i.21 = and i64 %and551.3.i.20, 0\n  %gep1 = getelementptr inbounds i8, ptr %p, i64 16\n  %gep2 = getelementptr inbounds i8, ptr %p, i64 24\n  store i64 %and551.2.i.21, ptr %gep1, align 16\n  store i64 %and551.3.i.21, ptr %gep2, align 8\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Assertion `CastInst::castIsValid(opc, C, Ty) && \"Invalid constantexpr cast!\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/PeoMv3Tsn\r\n```\r\n; bin/opt -passes=slp-vectorizer reduced.ll -S\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine void @main(ptr %p) {\r\nentry:\r\n  %conv548.2.i.13 = zext i32 0 to i64\r\n  %and551.2.i.13 = and i64 0, %conv548.2.i.13\r\n  %conv548.3.i.13 = zext i32 0 to i64\r\n  %and551.3.i.13 = and i64 0, %conv548.3.i.13\r\n  %0 = trunc i64 %and551.2.i.13 to i32\r\n  %conv54.2.i.14 = and i32 %0, 0\r\n  %conv548.2.i.14 = zext i32 %conv54.2.i.14 to i64\r\n  %and551.2.i.14 = and i64 %and551.2.i.13, %conv548.2.i.14\r\n  %1 = trunc i64 %and551.3.i.13 to i32\r\n  %conv54.3.i.14 = and i32 %1, 0\r\n  %conv548.3.i.14 = zext i32 %conv54.3.i.14 to i64\r\n  %and551.3.i.14 = and i64 %and551.3.i.13, %conv548.3.i.14\r\n  %and551.2.i.15 = and i64 %and551.2.i.14, 0\r\n  %and551.3.i.15 = and i64 %and551.3.i.14, 0\r\n  %and551.2.i.16 = and i64 %and551.2.i.15, 0\r\n  %and551.3.i.16 = and i64 %and551.3.i.15, 0\r\n  %and551.2.i.17 = and i64 %and551.2.i.16, 0\r\n  %and551.3.i.17 = and i64 %and551.3.i.16, 0\r\n  %and551.2.i.18 = and i64 %and551.2.i.17, 0\r\n  %and551.3.i.18 = and i64 %and551.3.i.17, 0\r\n  %and551.2.i.19 = and i64 %and551.2.i.18, 0\r\n  %and551.3.i.19 = and i64 %and551.3.i.18, 0\r\n  %and551.2.i.20 = and i64 %and551.2.i.19, 0\r\n  %and551.3.i.20 = and i64 %and551.3.i.19, 0\r\n  %and551.2.i.21 = and i64 %and551.2.i.20, 0\r\n  %and551.3.i.21 = and i64 %and551.3.i.20, 0\r\n  %gep1 = getelementptr inbounds i8, ptr %p, i64 16\r\n  %gep2 = getelementptr inbounds i8, ptr %p, i64 24\r\n  store i64 %and551.2.i.21, ptr %gep1, align 16\r\n  store i64 %and551.3.i.21, ptr %gep2, align 8\r\n  ret void\r\n}\r\n```\r\n```\r\nopt: /home/dtcxzyw/WorkSpace/Projects/compilers/llvm-project/llvm/lib/IR/Constants.cpp:2202: static llvm::Constant* llvm::ConstantExpr::getCast(unsigned int, llvm::Constant*, llvm::Type*, bool): Assertion `CastInst::castIsValid(opc, C, Ty) && \"Invalid constantexpr cast!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: bin/opt -passes=slp-vectorizer reduced.ll -S\r\n1.      Running pass \"function(slp-vectorizer)\" on module \"reduced.ll\"\r\n2.      Running pass \"slp-vectorizer\" on function \"main\"\r\n #0 0x00007c5d3e8138d2 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/libLLVMSupport.so.20.0git+0x2138d2)\r\n #1 0x00007c5d3e81079f llvm::sys::RunSignalHandlers() (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/libLLVMSupport.so.20.0git+0x21079f)\r\n #2 0x00007c5d3e8108e5 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x00007c5d3e242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007c5d3e2969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007c5d3e2969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007c5d3e2969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007c5d3e242476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007c5d3e2287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007c5d3e22871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007c5d3e239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x00007c5d36fb0c4d llvm::ConstantExpr::getCast(unsigned int, llvm::Constant*, llvm::Type*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x1b0c4d)\r\n#12 0x00007c5d394573b5 llvm::IRBuilderBase::CreateCast(llvm::Instruction::CastOps, llvm::Value*, llvm::Type*, llvm::Twine const&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x573b5)\r\n#13 0x00007c5d395ab173 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1ab173)\r\n#14 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#15 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#16 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#17 0x00007c5d395a7cbb llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7cbb)\r\n#18 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#19 0x00007c5d395a7a41 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a41)\r\n#20 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#21 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#22 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#23 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#24 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#25 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#26 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#27 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#28 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#29 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#30 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#31 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#32 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#33 0x00007c5d395a7a13 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a7a13)\r\n#34 0x00007c5d395acf1e llvm::slpvectorizer::BoUpSLP::vectorizeOperand(llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1acf1e)\r\n#35 0x00007c5d395a8f65 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::slpvectorizer::BoUpSLP::TreeEntry*, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1a8f65)\r\n#36 0x00007c5d395ae278 llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::MapVector<llvm::Value*, llvm::SmallVector<llvm::Instruction*, 2u>, llvm::DenseMap<llvm::Value*, unsigned int, llvm::DenseMapInfo<llvm::Value*, void>, llvm::detail::DenseMapPair<llvm::Value*, unsigned int>>, llvm::SmallVector<std::pair<llvm::Value*, llvm::SmallVector<llvm::Instruction*, 2u>>, 0u>> const&, llvm::SmallVectorImpl<std::pair<llvm::Value*, llvm::Value*>>&, llvm::Instruction*) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1ae278)\r\n#37 0x00007c5d395b207c llvm::slpvectorizer::BoUpSLP::vectorizeTree() (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1b207c)\r\n#38 0x00007c5d395c7cac llvm::SLPVectorizerPass::vectorizeStoreChain(llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP&, unsigned int, unsigned int, unsigned int&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1c7cac)\r\n#39 0x00007c5d395c9637 llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&)::'lambda'(std::set<std::pair<unsigned int, int>, llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&)::StoreDistCompare, std::allocator<std::pair<unsigned int, int>>> const&)::operator()(std::set<std::pair<unsigned int, int>, llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&)::StoreDistCompare, std::allocator<std::pair<unsigned int, int>>> const&) const SLPVectorizer.cpp:0:0\r\n#40 0x00007c5d395cb92c llvm::SLPVectorizerPass::vectorizeStores(llvm::ArrayRef<llvm::StoreInst*>, llvm::slpvectorizer::BoUpSLP&, llvm::DenseSet<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, llvm::DenseMapInfo<std::tuple<llvm::Value*, llvm::Value*, llvm::Value*, llvm::Value*, unsigned int>, void>>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1cb92c)\r\n#41 0x00007c5d395cc20f llvm::SLPVectorizerPass::vectorizeStoreChains(llvm::slpvectorizer::BoUpSLP&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1cc20f)\r\n#42 0x00007c5d395cd30f llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1cd30f)\r\n#43 0x00007c5d395cdf86 llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMVectorize.so.20.0git+0x1cdf86)\r\n#44 0x00007c5d39ed4015 llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMPasses.so.20.0git+0xd4015)\r\n#45 0x00007c5d371546ed llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x3546ed)\r\n#46 0x00007c5d3d4d7f35 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMX86CodeGen.so.20.0git+0xd7f35)\r\n#47 0x00007c5d37153256 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x353256)\r\n#48 0x00007c5d3d4d88f5 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMX86CodeGen.so.20.0git+0xd88f5)\r\n#49 0x00007c5d3715121a llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/../lib/libLLVMCore.so.20.0git+0x35121a)\r\n#50 0x00007c5d3eb12fc7 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/libLLVMOptDriver.so.20.0git+0x2cfc7)\r\n#51 0x00007c5d3eb1e962 optMain (/home/dtcxzyw/WorkSpace/Projects/compilers/LLVM/llvm-build/bin/../lib/libLLVMOptDriver.so.20.0git+0x38962)\r\n#52 0x00007c5d3e229d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#53 0x00007c5d3e229e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#54 0x00007c5d3e229e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#55 0x00005949b291d095 _start (bin/opt+0x1095)\r\nAborted (core dumped)\r\n```\r\n\r\ncc @alexey-bataev ",
    "author": "dtcxzyw",
    "labels": [
      "llvm:SLPVectorizer",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "Related PR: https://github.com/llvm/llvm-project/pull/103216\r\n"
      }
    ]
  }
}
