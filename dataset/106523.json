{
  "bug_id": "106523",
  "issue_url": "https://github.com/llvm/llvm-project/issues/106523",
  "bug_type": "crash",
  "base_commit": "2002533802dbe74c82476e30d093baf6d4cdee50",
  "knowledge_cutoff": "2024-08-29T10:12:29Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "2dfb1c664c0a0afc512b900c45989e247406e523",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp",
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.h"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          772,
          777
        ],
        [
          795,
          801
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.h": [
        [
          36,
          46
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::adjustFixedOrderRecurrences",
        "sinkRecurrenceUsersAfterPrevious"
      ]
    }
  },
  "patch": "commit 2dfb1c664c0a0afc512b900c45989e247406e523\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Wed Oct 23 13:12:03 2024 -0700\n\n    [VPlan] Try to hoist Previous (and operands), if sinking fails for FORs. (#108945)\n    \n    In some cases, Previous (and its operands) can be hoisted. This allows\n    supporting additional cases where sinking of all users of to FOR fails,\n    e.g. due having to sink recipes with side-effects.\n    \n    This fixes a crash where we fail to create a scalar VPlan for a\n    first-order recurrence, but can create a vector VPlan, because the trunc\n    instruction of an IV which generates the previous value of the\n    recurrence has been optimized to a truncated induction recipe, thus\n    hoisting it to the beginning.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/106523.\n    \n    PR: https://github.com/llvm/llvm-project/pull/108945\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex d50f3c0c3f3e..c6e09c4f2e6e 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -772,6 +772,105 @@ sinkRecurrenceUsersAfterPrevious(VPFirstOrderRecurrencePHIRecipe *FOR,\n   return true;\n }\n \n+/// Try to hoist \\p Previous and its operands before all users of \\p FOR.\n+static bool hoistPreviousBeforeFORUsers(VPFirstOrderRecurrencePHIRecipe *FOR,\n+                                        VPRecipeBase *Previous,\n+                                        VPDominatorTree &VPDT) {\n+  if (Previous->mayHaveSideEffects() || Previous->mayReadFromMemory())\n+    return false;\n+\n+  // Collect recipes that need hoisting.\n+  SmallVector<VPRecipeBase *> HoistCandidates;\n+  SmallPtrSet<VPRecipeBase *, 8> Visited;\n+  VPRecipeBase *HoistPoint = nullptr;\n+  // Find the closest hoist point by looking at all users of FOR and selecting\n+  // the recipe dominating all other users.\n+  for (VPUser *U : FOR->users()) {\n+    auto *R = dyn_cast<VPRecipeBase>(U);\n+    if (!R)\n+      continue;\n+    if (!HoistPoint || VPDT.properlyDominates(R, HoistPoint))\n+      HoistPoint = R;\n+  }\n+  assert(all_of(FOR->users(),\n+                [&VPDT, HoistPoint](VPUser *U) {\n+                  auto *R = dyn_cast<VPRecipeBase>(U);\n+                  return !R || HoistPoint == R ||\n+                         VPDT.properlyDominates(HoistPoint, R);\n+                }) &&\n+         \"HoistPoint must dominate all users of FOR\");\n+\n+  auto NeedsHoisting = [HoistPoint, &VPDT,\n+                        &Visited](VPValue *HoistCandidateV) -> VPRecipeBase * {\n+    VPRecipeBase *HoistCandidate = HoistCandidateV->getDefiningRecipe();\n+    if (!HoistCandidate)\n+      return nullptr;\n+    VPRegionBlock *EnclosingLoopRegion =\n+        HoistCandidate->getParent()->getEnclosingLoopRegion();\n+    assert((!HoistCandidate->getParent()->getParent() ||\n+            HoistCandidate->getParent()->getParent() == EnclosingLoopRegion) &&\n+           \"CFG in VPlan should still be flat, without replicate regions\");\n+    // Hoist candidate was already visited, no need to hoist.\n+    if (!Visited.insert(HoistCandidate).second)\n+      return nullptr;\n+\n+    // Candidate is outside loop region or a header phi, dominates FOR users w/o\n+    // hoisting.\n+    if (!EnclosingLoopRegion || isa<VPHeaderPHIRecipe>(HoistCandidate))\n+      return nullptr;\n+\n+    // If we reached a recipe that dominates HoistPoint, we don't need to\n+    // hoist the recipe.\n+    if (VPDT.properlyDominates(HoistCandidate, HoistPoint))\n+      return nullptr;\n+    return HoistCandidate;\n+  };\n+  auto CanHoist = [&](VPRecipeBase *HoistCandidate) {\n+    // Avoid hoisting candidates with side-effects, as we do not yet analyze\n+    // associated dependencies.\n+    return !HoistCandidate->mayHaveSideEffects();\n+  };\n+\n+  if (!NeedsHoisting(Previous->getVPSingleValue()))\n+    return true;\n+\n+  // Recursively try to hoist Previous and its operands before all users of FOR.\n+  HoistCandidates.push_back(Previous);\n+\n+  for (unsigned I = 0; I != HoistCandidates.size(); ++I) {\n+    VPRecipeBase *Current = HoistCandidates[I];\n+    assert(Current->getNumDefinedValues() == 1 &&\n+           \"only recipes with a single defined value expected\");\n+    if (!CanHoist(Current))\n+      return false;\n+\n+    for (VPValue *Op : Current->operands()) {\n+      // If we reach FOR, it means the original Previous depends on some other\n+      // recurrence that in turn depends on FOR. If that is the case, we would\n+      // also need to hoist recipes involving the other FOR, which may break\n+      // dependencies.\n+      if (Op == FOR)\n+        return false;\n+\n+      if (auto *R = NeedsHoisting(Op))\n+        HoistCandidates.push_back(R);\n+    }\n+  }\n+\n+  // Order recipes to hoist by dominance so earlier instructions are processed\n+  // first.\n+  sort(HoistCandidates, [&VPDT](const VPRecipeBase *A, const VPRecipeBase *B) {\n+    return VPDT.properlyDominates(A, B);\n+  });\n+\n+  for (VPRecipeBase *HoistCandidate : HoistCandidates) {\n+    HoistCandidate->moveBefore(*HoistPoint->getParent(),\n+                               HoistPoint->getIterator());\n+  }\n+\n+  return true;\n+}\n+\n bool VPlanTransforms::adjustFixedOrderRecurrences(VPlan &Plan,\n                                                   VPBuilder &LoopBuilder) {\n   VPDominatorTree VPDT;\n@@ -795,7 +894,8 @@ bool VPlanTransforms::adjustFixedOrderRecurrences(VPlan &Plan,\n       Previous = PrevPhi->getBackedgeValue()->getDefiningRecipe();\n     }\n \n-    if (!sinkRecurrenceUsersAfterPrevious(FOR, Previous, VPDT))\n+    if (!sinkRecurrenceUsersAfterPrevious(FOR, Previous, VPDT) &&\n+        !hoistPreviousBeforeFORUsers(FOR, Previous, VPDT))\n       return false;\n \n     // Introduce a recipe to combine the incoming and previous values of a\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.h b/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\nindex 60a44bfb0dca..11e094db6294 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.h\n@@ -36,11 +36,11 @@ struct VPlanTransforms {\n                                 GetIntOrFpInductionDescriptor,\n                             ScalarEvolution &SE, const TargetLibraryInfo &TLI);\n \n-  /// Sink users of fixed-order recurrences after the recipe defining their\n-  /// previous value. Then introduce FirstOrderRecurrenceSplice VPInstructions\n-  /// to combine the value from the recurrence phis and previous values. The\n-  /// current implementation assumes all users can be sunk after the previous\n-  /// value, which is enforced by earlier legality checks.\n+  /// Try to have all users of fixed-order recurrences appear after the recipe\n+  /// defining their previous value, by either sinking users or hoisting recipes\n+  /// defining their previous value (and its operands). Then introduce\n+  /// FirstOrderRecurrenceSplice VPInstructions to combine the value from the\n+  /// recurrence phis and previous values.\n   /// \\returns true if all users of fixed-order recurrences could be re-arranged\n   /// as needed or false if it is not possible. In the latter case, \\p Plan is\n   /// not valid.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/fixed-order-recurrence.ll",
      "commands": [
        "opt -passes=loop-vectorize -S -o - %s"
      ],
      "tests": [
        {
          "test_name": "test_pr62954_scalar_epilogue_required",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc_linux\"\n\ndefine i64 @test_pr62954_scalar_epilogue_required(ptr %A, ptr noalias %B, ptr %C) {\nentry:\n  %gep = getelementptr i8, ptr %A, i64 872\n  %rec.start = load i64, ptr %gep, align 8\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 1, %entry ], [ %iv.next, %loop ]\n  %for = phi i64 [ %rec.start, %entry ], [ %neg.iv, %loop ]\n  %gep.B = getelementptr double, ptr %B, i64 %iv\n  %l.B = load double, ptr %gep.B, align 8\n  %neg.iv = sub nsw i64 0, %iv\n  store i64 %neg.iv, ptr %gep, align 8\n  %iv.next = add nuw nsw i64 %iv, 2\n  %ec = icmp ugt i64 %iv, 74\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  %.in.lcssa = phi i64 [ %for, %loop ]\n  %.lcssa = phi double [ %l.B, %loop ]\n  store double %.lcssa, ptr %C, align 8\n  ret i64 %.in.lcssa\n}\n"
        },
        {
          "test_name": "thirdorderrec",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc_linux\"\n\ndefine void @thirdorderrec(ptr nocapture noundef readonly %x, ptr noalias nocapture noundef writeonly %y, i32 noundef %n) {\nentry:\n  %cmp38 = icmp sgt i32 %n, 3\n  br i1 %cmp38, label %for.body.preheader, label %for.cond.cleanup\n\nfor.body.preheader:                               ; preds = %entry\n  %wide.trip.count = zext i32 %n to i64\n  %.pre = load i8, ptr %x, align 1\n  %arrayidx5.phi.trans.insert = getelementptr inbounds i8, ptr %x, i64 1\n  %.pre44 = load i8, ptr %arrayidx5.phi.trans.insert, align 1\n  %arrayidx12.phi.trans.insert = getelementptr inbounds i8, ptr %x, i64 2\n  %.pre45 = load i8, ptr %arrayidx12.phi.trans.insert, align 1\n  br label %for.body\n\nfor.cond.cleanup:                                 ; preds = %for.body, %entry\n  ret void\n\nfor.body:                                         ; preds = %for.body, %for.body.preheader\n  %0 = phi i8 [ %.pre45, %for.body.preheader ], [ %3, %for.body ]\n  %1 = phi i8 [ %.pre44, %for.body.preheader ], [ %0, %for.body ]\n  %2 = phi i8 [ %.pre, %for.body.preheader ], [ %1, %for.body ]\n  %indvars.iv = phi i64 [ 3, %for.body.preheader ], [ %indvars.iv.next, %for.body ]\n  %add8 = add i8 %1, %2\n  %add15 = add i8 %add8, %0\n  %arrayidx18 = getelementptr inbounds i8, ptr %x, i64 %indvars.iv\n  %3 = load i8, ptr %arrayidx18, align 1\n  %add21 = add i8 %add15, %3\n  %arrayidx24 = getelementptr inbounds i8, ptr %y, i64 %indvars.iv\n  store i8 %add21, ptr %arrayidx24, align 1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count\n  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body\n}\n"
        },
        {
          "test_name": "for_iv_trunc_optimized",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc_linux\"\n\ndefine void @for_iv_trunc_optimized(ptr %dst) {\nbb:\n  br label %loop\n\nloop:                                             ; preds = %loop, %bb\n  %iv = phi i64 [ 1, %bb ], [ %add, %loop ]\n  %for.1 = phi i32 [ 1, %bb ], [ %trunc, %loop ]\n  %for.2 = phi i32 [ 0, %bb ], [ %or, %loop ]\n  %or = or i32 %for.1, 3\n  %add = add i64 %iv, 1\n  store i32 %for.2, ptr %dst, align 4\n  %icmp = icmp ult i64 %iv, 337\n  %trunc = trunc i64 %iv to i32\n  br i1 %icmp, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "firstorderrec",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc_linux\"\n\ndefine void @firstorderrec(ptr nocapture noundef readonly %x, ptr noalias nocapture noundef writeonly %y, i32 noundef %n) {\nentry:\n  %cmp18 = icmp sgt i32 %n, 1\n  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup\n\nfor.body.preheader:                               ; preds = %entry\n  %wide.trip.count = zext i32 %n to i64\n  %.pre = load i8, ptr %x, align 1\n  br label %for.body\n\nfor.cond.cleanup:                                 ; preds = %for.body, %entry\n  ret void\n\nfor.body:                                         ; preds = %for.body, %for.body.preheader\n  %0 = phi i8 [ %.pre, %for.body.preheader ], [ %1, %for.body ]\n  %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.body ]\n  %arrayidx4 = getelementptr inbounds i8, ptr %x, i64 %indvars.iv\n  %1 = load i8, ptr %arrayidx4, align 1\n  %add7 = add i8 %1, %0\n  %arrayidx10 = getelementptr inbounds i8, ptr %y, i64 %indvars.iv\n  store i8 %add7, ptr %arrayidx10, align 1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count\n  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence-chains-vplan.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -debug-only=loop-vectorize -disable-output -S %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test_chained_first_order_recurrences_4",
          "test_body": "define i32 @test_chained_first_order_recurrences_4(ptr %base, i64 %x) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %for.x = phi i64 [ %for.x.next, %loop ], [ 0, %entry ]\n  %for.y = phi i32 [ %for.x.prev, %loop ], [ 0, %entry ]\n  %iv.next = add i64 %iv, 1\n  %gep = getelementptr i64, ptr %base, i64 %iv\n  %for.x.prev = trunc i64 %for.x to i32\n  %for.y.i64 = sext i32 %for.y to i64\n  store i64 %for.y.i64, ptr %gep, align 4\n  %for.x.next = mul i64 %x, 2\n  %icmp = icmp ugt i64 %iv, 4096\n  br i1 %icmp, label %ret, label %loop\n\nret:                                              ; preds = %loop\n  ret i32 0\n}\n"
        },
        {
          "test_name": "test_chained_first_order_recurrences_3",
          "test_body": "define void @test_chained_first_order_recurrences_3(ptr %ptr) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %for.1 = phi i16 [ 22, %entry ], [ %for.1.next, %loop ]\n  %for.2 = phi i16 [ 33, %entry ], [ %for.1, %loop ]\n  %for.3 = phi i16 [ 33, %entry ], [ %for.2, %loop ]\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.next = add nuw nsw i64 %iv, 1\n  %gep.ptr = getelementptr inbounds i16, ptr %ptr, i64 %iv\n  %for.1.next = load i16, ptr %gep.ptr, align 2\n  %add.1 = add i16 %for.1, %for.2\n  %add.2 = add i16 %add.1, %for.3\n  store i16 %add.2, ptr %gep.ptr, align 2\n  %exitcond.not = icmp eq i64 %iv.next, 1000\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "test_chained_first_order_recurrences_1",
          "test_body": "define void @test_chained_first_order_recurrences_1(ptr %ptr) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %for.1 = phi i16 [ 22, %entry ], [ %for.1.next, %loop ]\n  %for.2 = phi i16 [ 33, %entry ], [ %for.1, %loop ]\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %iv.next = add nuw nsw i64 %iv, 1\n  %gep.ptr = getelementptr inbounds i16, ptr %ptr, i64 %iv\n  %for.1.next = load i16, ptr %gep.ptr, align 2\n  %add = add i16 %for.1, %for.2\n  store i16 %add, ptr %gep.ptr, align 2\n  %exitcond.not = icmp eq i64 %iv.next, 1000\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "test_chained_first_order_recurrences_5_hoist_to_load",
          "test_body": "define i32 @test_chained_first_order_recurrences_5_hoist_to_load(ptr %base) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %for.x = phi i64 [ %for.x.next, %loop ], [ 0, %entry ]\n  %for.y = phi i32 [ %for.x.prev, %loop ], [ 0, %entry ]\n  %iv.next = add i64 %iv, 1\n  %gep = getelementptr i64, ptr %base, i64 %iv\n  %l = load i64, ptr %gep, align 4\n  %for.x.prev = trunc i64 %for.x to i32\n  %for.y.i64 = sext i32 %for.y to i64\n  store i64 %for.y.i64, ptr %gep, align 4\n  %for.x.next = mul i64 %l, 2\n  %icmp = icmp ugt i64 %iv, 4096\n  br i1 %icmp, label %ret, label %loop\n\nret:                                              ; preds = %loop\n  ret i32 0\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/first-order-recurrence-multiply-recurrences.ll",
      "commands": [],
      "tests": [
        {
          "test_name": "test_pr54223_sink_after_insertion_order",
          "test_body": "define void @test_pr54223_sink_after_insertion_order(ptr noalias %a, ptr noalias %b, ptr noalias %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %for.1 = phi float [ 0.000000e+00, %entry ], [ %for.1.next, %loop ]\n  %for.2 = phi float [ 0.000000e+00, %entry ], [ %for.2.next, %loop ]\n  %neg = fneg float %for.2\n  %muladd = call float @llvm.fmuladd.f32(float %for.1, float %neg, float 0.000000e+00)\n  %dst.gep = getelementptr inbounds float, ptr %dst, i64 %iv\n  %iv.next = add nuw nsw i64 %iv, 1\n  %for.1.next = load float, ptr %a, align 4\n  %for.2.next = load float, ptr %b, align 4\n  store float %muladd, ptr %dst.gep, align 4\n  %exitcond.not = icmp eq i64 %iv.next, 10000\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare float @llvm.fmuladd.f32(float, float, float) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "test_pr54233_for_depend_on_each_other",
          "test_body": "define void @test_pr54233_for_depend_on_each_other(ptr noalias %a, ptr noalias %b) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %for.1 = phi i32 [ 0, %entry ], [ %for.1.next, %loop ]\n  %for.2 = phi i32 [ 0, %entry ], [ %for.2.next, %loop ]\n  %or = or i32 %for.2, 10\n  %shl = shl i32 %for.2, %for.1\n  %xor = xor i32 %shl, 255\n  %and = and i32 %xor, %or\n  %for.1.next = xor i32 12, %for.2\n  %for.2.next = load i32, ptr %b, align 4\n  %a.gep = getelementptr inbounds i32, ptr %a, i64 %iv\n  store i32 %and, ptr %a.gep, align 4\n  %iv.next = add nuw i64 %iv, 1\n  %exitcond = icmp eq i64 %iv, 1000\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion `hasPlanWithVF(ScalarVF) && \"More than a single plan/VF w/o any plan having scalar VF\"' failed.",
    "body": "To reproduce run the following test with -passes=loop-vectorize\r\n```\r\n; ModuleID = './reduced.ll'\r\nsource_filename = \"./reduced.ll\"\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine void @wombat() gc \"statepoint-example\" {\r\nbb:\r\n  br label %bb1\r\n\r\nbb1:                                              ; preds = %bb1, %bb\r\n  %phi = phi i64 [ %add, %bb1 ], [ 1, %bb ]\r\n  %phi2 = phi i32 [ %trunc, %bb1 ], [ 1, %bb ]\r\n  %phi3 = phi i32 [ %or, %bb1 ], [ 0, %bb ]\r\n  %or = or i32 %phi2, 0\r\n  %add = add i64 %phi, 1\r\n  store i32 %phi3, ptr addrspace(1) null, align 4\r\n  %icmp = icmp ult i64 %phi, 337\r\n  %trunc = trunc i64 %phi to i32\r\n  br i1 %icmp, label %bb1, label %bb4\r\n\r\nbb4:                                              ; preds = %bb1\r\n  ret void\r\n}\r\n```\r\n\r\nReproducer: https://godbolt.org/z/e14eWvxMb\r\n\r\nStack dump:\r\n```\r\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7304: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `hasPlanWithVF(ScalarVF) && \"More than a single plan/VF w/o any plan having scalar VF\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=loop-vectorize <source>\r\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"<source>\"\r\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"wombat\"\r\n #0 0x0000000004fa4138 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4fa4138)\r\n #1 0x0000000004fa18ac SignalHandler(int) Signals.cpp:0:0\r\n #2 0x000073e073a42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x000073e073a969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #4 0x000073e073a42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #5 0x000073e073a287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #6 0x000073e073a2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #7 0x000073e073a39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #8 0x0000000003fe5276 llvm::LoopVectorizationPlanner::computeBestVF() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3fe5276)\r\n #9 0x0000000004001214 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4001214)\r\n#10 0x0000000004003eb9 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4003eb9)\r\n#11 0x0000000004004543 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4004543)\r\n#12 0x0000000002ec85ae llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2ec85ae)\r\n#13 0x0000000004da08f8 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4da08f8)\r\n#14 0x0000000000df11be llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xdf11be)\r\n#15 0x0000000004d9f2fe llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4d9f2fe)\r\n#16 0x0000000000df0aae llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xdf0aae)\r\n#17 0x0000000004d9d490 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4d9d490)\r\n#18 0x00000000008e8002 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8e8002)\r\n#19 0x00000000008daedc optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8daedc)\r\n#20 0x000073e073a29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#21 0x000073e073a29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#22 0x00000000008d296e _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8d296e)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139",
    "author": "TatyanaDoubts",
    "labels": [
      "vectorizers",
      "crash-on-valid"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "Very interesting issue thanks! Proposed fix https://github.com/llvm/llvm-project/issues/106523"
      }
    ]
  }
}
