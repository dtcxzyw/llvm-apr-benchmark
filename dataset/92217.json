{
  "bug_id": "92217",
  "issue_url": "https://github.com/llvm/llvm-project/issues/92217",
  "bug_type": "miscompilation",
  "base_commit": "36899d693d91719e7e6cd0f0ee4cf579111b8509",
  "knowledge_cutoff": "2024-05-15T05:14:44Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "04ae6e600a3090ccc1f80d0110a1108aa73a54f8",
    "components": [
      "ValueTracking"
    ],
    "files": [
      "llvm/lib/Analysis/ValueTracking.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        [
          4940,
          4950
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        "computeKnownFPClass"
      ]
    }
  },
  "patch": "commit 04ae6e600a3090ccc1f80d0110a1108aa73a54f8\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Mon May 20 21:52:38 2024 +0800\n\n    [ValueTracking] Fix incorrect inferrence about the signbit of sqrt (#92510)\n    \n    According to IEEE Std 754-2019, `sqrt` returns nan when the input is\n    negative (except for -0). In this case, we cannot make assumptions about\n    sign bit of the result.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/92217\n\ndiff --git a/llvm/lib/Analysis/ValueTracking.cpp b/llvm/lib/Analysis/ValueTracking.cpp\nindex 2d1486d252c3..063162ed38ba 100644\n--- a/llvm/lib/Analysis/ValueTracking.cpp\n+++ b/llvm/lib/Analysis/ValueTracking.cpp\n@@ -4940,11 +4940,8 @@ void computeKnownFPClass(const Value *V, const APInt &DemandedElts,\n       // subnormal input could produce a negative zero output.\n       const Function *F = II->getFunction();\n       if (Q.IIQ.hasNoSignedZeros(II) ||\n-          (F && KnownSrc.isKnownNeverLogicalNegZero(*F, II->getType()))) {\n+          (F && KnownSrc.isKnownNeverLogicalNegZero(*F, II->getType())))\n         Known.knownNot(fcNegZero);\n-        if (KnownSrc.isKnownNeverNaN())\n-          Known.signBitMustBeZero();\n-      }\n \n       break;\n     }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/known-bits.ll",
      "commands": [
        "opt -S -passes=instcombine < %s"
      ],
      "tests": [
        {
          "test_name": "test_none",
          "test_body": "define i32 @test_none(float nofpclass(all) %x) {\n  %y = bitcast float %x to i32\n  %and = and i32 %y, 4194304\n  ret i32 %and\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Bad codegen after commit 3aae916",
    "body": "We have an internal test that recently started producing incorrect output which I bisected back to commit 3aae916ff7fe9d0953aa63b2ba1d0e871f6f76fc.\r\n\r\nConsider the following code:\r\n```c++\r\nstatic void init(unsigned char pred, volatile void *data, unsigned size) {\r\n  unsigned char *bytes = (unsigned char *)data;\r\n  for (unsigned i = 0; i != size; ++i) {\r\n    bytes[i] = pred + i;\r\n  }\r\n}\r\n#define INIT(PRED, VAR) init(PRED, &VAR, sizeof(VAR))\r\n\r\n#include <x86intrin.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n      __m256 id7702;\r\n      INIT(243, id7702);\r\n    __m256 id7701 = _mm256_sqrt_ps(id7702);\r\n  volatile int id7700 = _mm256_movemask_ps(id7701);\r\n  //printf(\"id7700:%x\\n\", id7700);\r\n  return id7700;\r\n}\r\n```\r\nIf compiled with optimizations and `-mavx` and the resulting binary is run, the return value changes after 3aae916ff7fe9d0953aa63b2ba1d0e871f6f76fc:\r\n```\r\n$ ~/src/upstream/3aae916ff7fe9d0953aa63b2ba1d0e871f6f76fc-linux/bin/clang -O2 -mavx repro.cpp -o repro.bad.out\r\n$ ~/src/upstream/f658d84e01bcdd49e27dc9ef80e1a6cc5f9417fe-linux/bin/clang -O2 -mavx repro.cpp -o repro.good.out\r\n$ ./repro.good.out \r\n$ echo $?\r\n7\r\n$ ./repro.bad.out \r\n$ echo $?\r\n0\r\n```\r\n\r\nYou can also see the difference on godbolt comparing with 18.1.0:\r\nhttps://godbolt.org/z/KPbK4jcGc",
    "author": "dyung",
    "labels": [
      "miscompilation",
      "floating-point",
      "llvm:analysis"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "Bisected to EarlyCSE: https://godbolt.org/z/ejMhYfGzs\r\nBefore:\r\n```\r\ndefine dso_local i32 @main(i32 noundef %argc, ptr nocapture noundef readnone %argv) local_unnamed_addr #0 {\r\nentry:\r\n  %id7700 = alloca i32, align 4\r\n  %id7702.sroa.0.0.vec.insert = insertelement <32 x i8> undef, i8 -13, i32 0\r\n  %id7702.sroa.0.1.vec.insert = insertelement <32 x i8> %id7702.sroa.0.0.vec.insert, i8 -12, i32 1\r\n  %id7702.sroa.0.2.vec.insert = insertelement <32 x i8> %id7702.sroa.0.1.vec.insert, i8 -11, i32 2\r\n  %id7702.sroa.0.3.vec.insert = insertelement <32 x i8> %id7702.sroa.0.2.vec.insert, i8 -10, i32 3\r\n  %id7702.sroa.0.4.vec.insert = insertelement <32 x i8> %id7702.sroa.0.3.vec.insert, i8 -9, i32 4\r\n  %id7702.sroa.0.5.vec.insert = insertelement <32 x i8> %id7702.sroa.0.4.vec.insert, i8 -8, i32 5\r\n  %id7702.sroa.0.6.vec.insert = insertelement <32 x i8> %id7702.sroa.0.5.vec.insert, i8 -7, i32 6\r\n  %id7702.sroa.0.7.vec.insert = insertelement <32 x i8> %id7702.sroa.0.6.vec.insert, i8 -6, i32 7\r\n  %id7702.sroa.0.8.vec.insert = insertelement <32 x i8> %id7702.sroa.0.7.vec.insert, i8 -5, i32 8\r\n  %id7702.sroa.0.9.vec.insert = insertelement <32 x i8> %id7702.sroa.0.8.vec.insert, i8 -4, i32 9\r\n  %id7702.sroa.0.10.vec.insert = insertelement <32 x i8> %id7702.sroa.0.9.vec.insert, i8 -3, i32 10\r\n  %id7702.sroa.0.11.vec.insert = insertelement <32 x i8> %id7702.sroa.0.10.vec.insert, i8 -2, i32 11\r\n  %id7702.sroa.0.12.vec.insert = insertelement <32 x i8> %id7702.sroa.0.11.vec.insert, i8 -1, i32 12\r\n  %id7702.sroa.0.13.vec.insert = insertelement <32 x i8> %id7702.sroa.0.12.vec.insert, i8 0, i32 13\r\n  %id7702.sroa.0.14.vec.insert = insertelement <32 x i8> %id7702.sroa.0.13.vec.insert, i8 1, i32 14\r\n  %id7702.sroa.0.15.vec.insert = insertelement <32 x i8> %id7702.sroa.0.14.vec.insert, i8 2, i32 15\r\n  %id7702.sroa.0.16.vec.insert = insertelement <32 x i8> %id7702.sroa.0.15.vec.insert, i8 3, i32 16\r\n  %id7702.sroa.0.17.vec.insert = insertelement <32 x i8> %id7702.sroa.0.16.vec.insert, i8 4, i32 17\r\n  %id7702.sroa.0.18.vec.insert = insertelement <32 x i8> %id7702.sroa.0.17.vec.insert, i8 5, i32 18\r\n  %id7702.sroa.0.19.vec.insert = insertelement <32 x i8> %id7702.sroa.0.18.vec.insert, i8 6, i32 19\r\n  %id7702.sroa.0.20.vec.insert = insertelement <32 x i8> %id7702.sroa.0.19.vec.insert, i8 7, i32 20\r\n  %id7702.sroa.0.21.vec.insert = insertelement <32 x i8> %id7702.sroa.0.20.vec.insert, i8 8, i32 21\r\n  %id7702.sroa.0.22.vec.insert = insertelement <32 x i8> %id7702.sroa.0.21.vec.insert, i8 9, i32 22\r\n  %id7702.sroa.0.23.vec.insert = insertelement <32 x i8> %id7702.sroa.0.22.vec.insert, i8 10, i32 23\r\n  %id7702.sroa.0.24.vec.insert = insertelement <32 x i8> %id7702.sroa.0.23.vec.insert, i8 11, i32 24\r\n  %id7702.sroa.0.25.vec.insert = insertelement <32 x i8> %id7702.sroa.0.24.vec.insert, i8 12, i32 25\r\n  %id7702.sroa.0.26.vec.insert = insertelement <32 x i8> %id7702.sroa.0.25.vec.insert, i8 13, i32 26\r\n  %id7702.sroa.0.27.vec.insert = insertelement <32 x i8> %id7702.sroa.0.26.vec.insert, i8 14, i32 27\r\n  %id7702.sroa.0.28.vec.insert = insertelement <32 x i8> %id7702.sroa.0.27.vec.insert, i8 15, i32 28\r\n  %id7702.sroa.0.29.vec.insert = insertelement <32 x i8> %id7702.sroa.0.28.vec.insert, i8 16, i32 29\r\n  %id7702.sroa.0.30.vec.insert = insertelement <32 x i8> %id7702.sroa.0.29.vec.insert, i8 17, i32 30\r\n  %id7702.sroa.0.31.vec.insert = insertelement <32 x i8> %id7702.sroa.0.30.vec.insert, i8 18, i32 31\r\n  %0 = bitcast <32 x i8> %id7702.sroa.0.31.vec.insert to <8 x float>\r\n  %1 = call <8 x float> @llvm.sqrt.v8f32(<8 x float> %0)\r\n  call void @llvm.lifetime.start.p0(i64 4, ptr %id7700)\r\n  %2 = bitcast <8 x float> %1 to <8 x i32>\r\n  %3 = icmp slt <8 x i32> %2, zeroinitializer\r\n  %4 = bitcast <8 x i1> %3 to i8\r\n  %5 = zext i8 %4 to i32\r\n  store volatile i32 %5, ptr %id7700, align 4, !tbaa !5\r\n  %id7700.0.id7700.0. = load volatile i32, ptr %id7700, align 4, !tbaa !5\r\n  call void @llvm.lifetime.end.p0(i64 4, ptr %id7700)\r\n  ret i32 %id7700.0.id7700.0.\r\n}\r\n```\r\n\r\nAfter:\r\n```\r\n; Function Attrs: nounwind uwtable\r\ndefine dso_local i32 @main(i32 noundef %argc, ptr nocapture noundef readnone %argv) local_unnamed_addr #0 {\r\nentry:\r\n  %id7700 = alloca i32, align 4\r\n  %0 = call <8 x float> @llvm.sqrt.v8f32(<8 x float> <float 0xC6DEBE9E60000000, float 0xC75F3F1EE0000000, float 0xC7DFBF9F60000000, float 0x3840201FE0000000, float 0x38C0A08060000000, float 0x39412100E0000000, float 0x39C1A18160000000, float 0x3A422201E0000000>)\r\n  call void @llvm.lifetime.start.p0(i64 4, ptr %id7700)\r\n  %1 = bitcast <8 x float> %0 to <8 x i32>\r\n  store volatile i32 0, ptr %id7700, align 4, !tbaa !5\r\n  %id7700.0.id7700.0. = load volatile i32, ptr %id7700, align 4, !tbaa !5\r\n  call void @llvm.lifetime.end.p0(i64 4, ptr %id7700)\r\n  ret i32 %id7700.0.id7700.0.\r\n}\r\n```\r\n\r\ncomputeKnownFPClass assumes that the square root of a value is always non-negative.\r\n"
      },
      {
        "author": "dtcxzyw",
        "body": "> computeKnownFPClass assumes that the square root of a value is always non-negative.\r\n\r\nAny thoughts? @arsenm \r\n\r\nC23 Standard ([N3096](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf)) says:\r\n> 7.12.7.10 The sqrt functions\r\n> The sqrt functions compute the nonnegative square root of x. A domain error occurs if the argument is less than zero\r\n"
      },
      {
        "author": "dtcxzyw",
        "body": "See 7.2.1 Treatment of error conditions:\r\n> For all functions, a domain error occurs if and only if an input argument is outside the domain over which the mathematical function is defined. The description of each function lists any re- quired domain errors; an implementation may define additional domain errors, provided that such errors are consistent with the mathematical definition of the function.282) Whether a sig-naling NaN input causes a domain error is implementation-defined. ***On a domain error, the function returns an implementation-defined value***; if the integer expression math_errhandling\r\n& MATH_ERRNO is nonzero, the integer expression errno acquires the value EDOM; if the integer expressionmath_errhandling & MATH_ERREXCEPTisnonzero,the\"invalid\"floating-pointexcep- tion is raised."
      },
      {
        "author": "dtcxzyw",
        "body": "cc @andykaylor @jcranmer-intel "
      },
      {
        "author": "arsenm",
        "body": "> > computeKnownFPClass assumes that the square root of a value is always non-negative.\r\n> \r\n> Any thoughts? @arsenm\r\n\r\nIt is always non-negative, except for -0 "
      },
      {
        "author": "dtcxzyw",
        "body": "> > > computeKnownFPClass assumes that the square root of a value is always non-negative.\r\n> > \r\n> > \r\n> > Any thoughts? @arsenm\r\n> \r\n> It is always non-negative, except for -0\r\n\r\nSee https://github.com/llvm/llvm-project/blob/45726c1a3a3d89ff9f6ebe657c3cb7bcd59b88db/llvm/lib/Analysis/ValueTracking.cpp#L4930-L4938\r\n"
      },
      {
        "author": "arsenm",
        "body": "> See 7.2.1 Treatment of error conditions:\r\n> \r\n\r\nThe C definitions are unhelpful. It returns a NaN, as per IEEE "
      },
      {
        "author": "dtcxzyw",
        "body": "> > See 7.2.1 Treatment of error conditions:\r\n> \r\n> The C definitions are unhelpful. It returns a NaN, as per IEEE\r\n\r\n\r\nIEEE Std 754-2019 IEEE Standard for Floating-Point Arithmetic:\r\n> 6.3 The sign bit 6.3.0\r\nWhen either an input or result is a NaN, this standard does not interpret the sign of a NaN.\r\n...\r\nExcept that squareRoot(\u22120) shall be \u22120, every numeric squareRoot result shall have a positive sign.\r\n\r\nI will post a fix.\r\n"
      }
    ]
  }
}