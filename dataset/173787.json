{
  "bug_id": "173787",
  "issue_url": "https://github.com/llvm/llvm-project/issues/173787",
  "bug_type": "miscompilation",
  "base_commit": "0258aa62b7686b21812999b99aa6e2d1077a96c6",
  "knowledge_cutoff": "2025-12-28T16:30:31Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "57927e9ffcf1ebd36b0b9d76c49e7af1dd5d31d1",
    "components": [
      "InstCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        [
          3846,
          3851
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        "foldBitCeil"
      ]
    }
  },
  "patch": "commit 57927e9ffcf1ebd36b0b9d76c49e7af1dd5d31d1\nAuthor: Yunbo Ni <87902024+cardigan1008@users.noreply.github.com>\nDate:   Mon Dec 29 20:17:36 2025 +0800\n\n    [InstCombine] Restrict `foldBitCeil` to power-of-two integer widths (#173849)\n    \n    The masking rewrite in `foldBitCeil` assumes a power-of-two bitwidth.\n    \n    For non-power-of-two integer types, `(-ctlz) & (BitWidth - 1)` is not\n    equivalent to `BitWidth - ctlz` and can miscompile.\n    \n    This patch restricts the transform to power-of-two bitwidths.\n    \n    Alive2 proof: https://alive2.llvm.org/ce/z/i2E6zT\n    \n    Fixes #173787\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\nindex 67d184583272..480f31980139 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n@@ -3846,6 +3846,8 @@ static Instruction *foldBitCeil(SelectInst &SI, IRBuilderBase &Builder,\n                                 InstCombinerImpl &IC) {\n   Type *SelType = SI.getType();\n   unsigned BitWidth = SelType->getScalarSizeInBits();\n+  if (!isPowerOf2_32(BitWidth))\n+    return nullptr;\n \n   Value *FalseVal = SI.getFalseValue();\n   Value *TrueVal = SI.getTrueValue();\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/bit_ceil.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "bit_ceil_plus_nsw",
          "test_body": "define i32 @bit_ceil_plus_nsw(i32 %x) {\nentry:\n  %sub = add nsw i32 %x, 1\n  %ctlz = tail call i32 @llvm.ctlz.i32(i32 %sub, i1 false)\n  %sub2 = sub nuw nsw i32 32, %ctlz\n  %shl = shl nuw i32 1, %sub2\n  %ult = icmp ult i32 %x, 2147483647\n  %sel = select i1 %ult, i32 %shl, i32 1\n  ret i32 %sel\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctlz.i32(i32, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "test_bit_ceil_i33_non_pow2",
          "test_body": "define i33 @test_bit_ceil_i33_non_pow2(i33 %x) {\n  %ctlz = call i33 @llvm.ctlz.i33(i33 %x, i1 false)\n  %sub = sub i33 33, %ctlz\n  %shl = shl i33 1, %sub\n  %dec = add i33 %x, -1\n  %ult = icmp ult i33 %dec, -2\n  %sel = select i1 %ult, i33 %shl, i33 1\n  ret i33 %sel\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i33 @llvm.ctlz.i33(i33, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "test_drop_range_attr",
          "test_body": "define i32 @test_drop_range_attr(i32 %x) {\n  %ctlz = call range(i32 1, 33) i32 @llvm.ctlz.i32(i32 %x, i1 false)\n  %sub = sub i32 32, %ctlz\n  %shl = shl i32 1, %sub\n  %dec = add i32 %x, -1\n  %ult = icmp ult i32 %dec, -2\n  %sel = select i1 %ult, i32 %shl, i32 1\n  ret i32 %sel\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.ctlz.i32(i32, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] `foldBitCeil` miscompiles non-power-of-two integer widths",
    "body": "There exists an incorrect transformation for non-power-of-two integer widths in `foldBitCeil`.\n\nThe rewrite replaces the original computation `shift = BitWidth - ctlz(x)` to `shift = (-ctlz(x)) & (BitWidth - 1)`. \n\nThis masking trick is only valid when `BitWidth` is a power of two, because in that case `(BitWidth - 1)` is an all-ones mask and the expression effectively computes `(BitWidth - ctlz) mod BitWidth`.\n\nFor non-power-of-two widths (e.g. `i33`), `BitWidth - 1` is not an all-ones mask. As a result, `(-ctlz) & (BitWidth - 1)` does not compute `BitWidth - ctlz` and can produce an entirely different shift amount.\n\nFor example, with `i33` and `x = 7`:\n\n- `ctlz(7) = 30`\n- Source computes `shift = 33 - 30 = 3`, yielding `1 << 3 = 8`\n- Transformed code computes `(-30) & 32 = 32`, yielding` 1 << 32`\n\nThis causes a value mismatch and makes the transformation incorrect for non-power-of-two bit widths. \n\nAlive2 proof: https://alive2.llvm.org/ce/z/Z3Gq8Q\n\nExposed from https://github.com/llvm/llvm-project/commit/2c094ac761912eea0d7e8ccb140bc647b5378bdf, cc @dtcxzyw ",
    "author": "cardigan1008",
    "labels": [
      "miscompilation",
      "llvm:instcombine"
    ],
    "comments": [
      {
        "author": "cardigan1008",
        "body": "I can propose a patch for this. "
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}