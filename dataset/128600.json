{
  "bug_id": "128600",
  "issue_url": "https://github.com/llvm/llvm-project/issues/128600",
  "bug_type": "crash",
  "base_commit": "495774d6d59379edad3c8c35be8c4672d4a513fa",
  "knowledge_cutoff": "2025-02-24T23:53:48Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopFusion"
  ],
  "hints": {
    "fix_commit": "90de4a4ac96ef314e3af9c43c516d5aaf105777a",
    "components": [
      "LoopFuse"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/LoopFuse.cpp": [
        [
          1176,
          1181
        ],
        [
          1481,
          1486
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/LoopFuse.cpp": [
        "canSinkInst",
        "collectMovablePreheaderInsts",
        "movePreheaderInsts"
      ]
    }
  },
  "patch": "commit 90de4a4ac96ef314e3af9c43c516d5aaf105777a\nAuthor: Madhur Amilkanthwar <madhura@nvidia.com>\nDate:   Mon Jul 28 12:08:43 2025 +0530\n\n    [LoopFusion] Fix sink instructions (#147501)\n    \n    If we have instructions in second loop's preheader which can be sunk, we\n    should also be adjusting PHI nodes to receive values from the fused loop's latch block.\n    \n    Fixes #128600\n\ndiff --git a/llvm/lib/Transforms/Scalar/LoopFuse.cpp b/llvm/lib/Transforms/Scalar/LoopFuse.cpp\nindex d6bd92d520e2..b5eb647a042b 100644\n--- a/llvm/lib/Transforms/Scalar/LoopFuse.cpp\n+++ b/llvm/lib/Transforms/Scalar/LoopFuse.cpp\n@@ -1176,6 +1176,28 @@ private:\n     return true;\n   }\n \n+  /// This function fixes PHI nodes after fusion in \\p SafeToSink.\n+  /// \\p SafeToSink instructions are the instructions that are to be moved past\n+  /// the fused loop. Thus, the PHI nodes in \\p SafeToSink should be updated to\n+  /// receive values from the fused loop if they are currently taking values\n+  /// from the first loop (i.e. FC0)'s latch.\n+  void fixPHINodes(ArrayRef<Instruction *> SafeToSink,\n+                   const FusionCandidate &FC0,\n+                   const FusionCandidate &FC1) const {\n+    for (Instruction *Inst : SafeToSink) {\n+      // No update needed for non-PHI nodes.\n+      PHINode *Phi = dyn_cast<PHINode>(Inst);\n+      if (!Phi)\n+        continue;\n+      for (unsigned I = 0; I < Phi->getNumIncomingValues(); I++) {\n+        if (Phi->getIncomingBlock(I) != FC0.Latch)\n+          continue;\n+        assert(FC1.Latch && \"FC1 latch is not set\");\n+        Phi->setIncomingBlock(I, FC1.Latch);\n+      }\n+    }\n+  }\n+\n   /// Collect instructions in the \\p FC1 Preheader that can be hoisted\n   /// to the \\p FC0 Preheader or sunk into the \\p FC1 Body\n   bool collectMovablePreheaderInsts(\n@@ -1481,6 +1503,9 @@ private:\n       assert(I->getParent() == FC1.Preheader);\n       I->moveBefore(*FC1.ExitBlock, FC1.ExitBlock->getFirstInsertionPt());\n     }\n+    // PHI nodes in SinkInsts need to be updated to receive values from the\n+    // fused loop.\n+    fixPHINodes(SinkInsts, FC0, FC1);\n   }\n \n   /// Determine if two fusion candidates have identical guards\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopFusion/sunk-phi-nodes.ll",
      "commands": [
        "opt -passes=loop-fusion -S < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "define dso_local i32 @check_sunk_phi_nodes() {\n;\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %entry, %for.inc\n  %sum1.02 = phi i32 [ 0, %entry ], [ %add, %for.inc ]\n  %i.01 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]\n  %add = add nsw i32 %sum1.02, %i.01\n  br label %for.inc\n\nfor.inc:                                          ; preds = %for.body\n  %inc = add nsw i32 %i.01, 1\n  %cmp = icmp slt i32 %inc, 10\n  br i1 %cmp, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.inc\n  %sum1.0.lcssa = phi i32 [ %add, %for.inc ]\n  br label %for.body4\n\nfor.body4:                                        ; preds = %for.end, %for.inc6\n  %i1.04 = phi i32 [ 0, %for.end ], [ %inc7, %for.inc6 ]\n  %sum2.03 = phi i32 [ 0, %for.end ], [ %add5, %for.inc6 ]\n  %mul = mul nsw i32 %i1.04, %i1.04\n  %add5 = add nsw i32 %sum2.03, %mul\n  br label %for.inc6\n\nfor.inc6:                                         ; preds = %for.body4\n  %inc7 = add nsw i32 %i1.04, 1\n  %cmp3 = icmp slt i32 %inc7, 10\n  br i1 %cmp3, label %for.body4, label %for.end8\n\nfor.end8:                                         ; preds = %for.inc6\n  %sum2.0.lcssa = phi i32 [ %add5, %for.inc6 ]\n  %0 = add i32 %sum1.0.lcssa, %sum2.0.lcssa\n  ret i32 %0\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[Clang] Optimization LoopFuse.cpp crashes on valid LLVM IR. Assertion `!verifyFunction(*FC0.Header->getParent(), &errs())' failed.",
    "body": "To reproduce: https://godbolt.org/z/zMEsM448G\n`opt -passes=mem2reg,loop-rotate,loop-fusion {test}` crashes on the LLVMIR generated from `clang -O0` because of an assertion failure.\nStack Dump:\n```\nPHI node entries do not match predecessors!\n  %sum1.0.lcssa = phi i32 [ %add, %for.inc ]\nlabel %for.inc\nlabel %for.inc6\nopt: /root/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1759: llvm::Loop* {anonymous}::LoopFuser::performFusion(const {anonymous}::FusionCandidate&, const {anonymous}::FusionCandidate&): Assertion `!verifyFunction(*FC0.Header->getParent(), &errs())' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=mem2reg,loop-rotate,loop-fusion <source>\n1.\tRunning pass \"function(mem2reg,loop(loop-rotate<header-duplication;no-prepare-for-lto>),loop-fusion)\" on module \"<source>\"\n2.\tRunning pass \"loop-fusion\" on function \"main\"\n #0 0x00000000054498e8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x54498e8)\n #1 0x00000000054472a4 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x0000704d50642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x0000704d506969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x0000704d50642476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x0000704d506287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x0000704d5062871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x0000704d50639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x000000000402a593 (anonymous namespace)::LoopFuser::performFusion((anonymous namespace)::FusionCandidate const&, (anonymous namespace)::FusionCandidate const&) LoopFuse.cpp:0:0\n #9 0x000000000402cab5 (anonymous namespace)::LoopFuser::fuseCandidates() LoopFuse.cpp:0:0\n#10 0x000000000402e5c1 llvm::LoopFusePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x402e5c1)\n#11 0x00000000031828ae llvm::detail::PassModel<llvm::Function, llvm::LoopFusePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x31828ae)\n#12 0x0000000005243e40 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5243e40)\n#13 0x0000000000e6e23e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe6e23e)\n#14 0x000000000524275b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x524275b)\n#15 0x0000000000e6d54e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe6d54e)\n#16 0x0000000005242160 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5242160)\n#17 0x0000000000935dda llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x935dda)\n#18 0x000000000092944c optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x92944c)\n#19 0x0000704d50629d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#20 0x0000704d50629e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#21 0x0000000000920d25 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x920d25)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\n\nThe Test IR causing the failure:\n```\n@.str = private unnamed_addr constant [7 x i8] c\"%d %d\\0A\\00\", align 1\n\ndefine dso_local i32 @main() #0 {\nentry:\n  %retval = alloca i32, align 4\n  %sum1 = alloca i32, align 4\n  %sum2 = alloca i32, align 4\n  %i = alloca i32, align 4\n  %i1 = alloca i32, align 4\n  store i32 0, ptr %retval, align 4\n  store i32 0, ptr %sum1, align 4\n  store i32 0, ptr %sum2, align 4\n  store i32 0, ptr %i, align 4\n  br label %for.cond\n\nfor.cond:\n  %0 = load i32, ptr %i, align 4\n  %cmp = icmp slt i32 %0, 10\n  br i1 %cmp, label %for.body, label %for.end\n\nfor.body:\n  %1 = load i32, ptr %i, align 4\n  %2 = load i32, ptr %sum1, align 4\n  %add = add nsw i32 %2, %1\n  store i32 %add, ptr %sum1, align 4\n  br label %for.inc\n\nfor.inc:\n  %3 = load i32, ptr %i, align 4\n  %inc = add nsw i32 %3, 1\n  store i32 %inc, ptr %i, align 4\n  br label %for.cond\n\nfor.end:\n  store i32 0, ptr %i1, align 4\n  br label %for.cond2\n\nfor.cond2:\n  %4 = load i32, ptr %i1, align 4\n  %cmp3 = icmp slt i32 %4, 10\n  br i1 %cmp3, label %for.body4, label %for.end8\n\nfor.body4:\n  %5 = load i32, ptr %i1, align 4\n  %6 = load i32, ptr %i1, align 4\n  %mul = mul nsw i32 %5, %6\n  %7 = load i32, ptr %sum2, align 4\n  %add5 = add nsw i32 %7, %mul\n  store i32 %add5, ptr %sum2, align 4\n  br label %for.inc6\n\nfor.inc6:\n  %8 = load i32, ptr %i1, align 4\n  %inc7 = add nsw i32 %8, 1\n  store i32 %inc7, ptr %i1, align 4\n  br label %for.cond2\n\nfor.end8:\n  %9 = load i32, ptr %sum1, align 4\n  %10 = load i32, ptr %sum2, align 4\n  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %9, i32 noundef %10)\n  ret i32 0\n}\n\ndeclare i32 @printf(ptr noundef, ...) #1\n\nattributes #0 = { noinline nounwind uwtable \"frame-pointer\"=\"all\" \"min-legal-vector-width\"=\"0\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" }\nattributes #1 = { \"frame-pointer\"=\"all\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" }\n```\n\nIt is generated from\n```c\n#include <stdio.h>\nint main() {\n    int sum1 = 0, sum2 = 0;\n    for (int i = 0; i < 10; i++) {\n        sum1 += i;\n    }\n    for (int i = 0; i < 10; i++) {\n        sum2 += i * i;\n    }\n    printf(\"%d %d\\n\", sum1, sum2);\n    return 0;\n}\n```\n",
    "author": "zitongzhoueric",
    "labels": [
      "loopoptim",
      "crash"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "bisect": "Cannot find a good commit"
}