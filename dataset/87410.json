{
  "bug_id": "87410",
  "issue_url": "https://github.com/llvm/llvm-project/issues/87410",
  "bug_type": "crash",
  "base_commit": "0bbe953aa3289a32cd816647820c8676bb3a61bc",
  "knowledge_cutoff": "2024-04-02T21:05:28Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "c83698367125703827f1b739393f006c399cb213",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp",
      "llvm/lib/Transforms/Vectorize/VPlan.h",
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          8221,
          8226
        ],
        [
          8233,
          8238
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlan.h": [
        [
          1932,
          1945
        ],
        [
          1949,
          1963
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          1513,
          1518
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "VPRecipeBuilder::tryToBlend"
      ],
      "llvm/lib/Transforms/Vectorize/VPlan.h": [
        "VPBlendRecipe",
        "clone",
        "getIncomingValue",
        "getMask",
        "getNumIncomingValues"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPBlendRecipe::print"
      ]
    }
  },
  "patch": "commit c83698367125703827f1b739393f006c399cb213\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Tue Apr 9 11:14:05 2024 +0100\n\n    [VPlan] Remove unused first mask op from VPBlendRecipe. (#87770)\n    \n    VPBlendRecipe does not use the first mask operand. Removing it allows\n    VPlan-based DCE to remove unused mask computations.\n    \n    This also fixes #87410, where unused Not VPInstructions are considered\n    having only their first lane demanded, but some of their operands\n    providing a vector value due to other users.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/87410\n    \n    PR: https://github.com/llvm/llvm-project/pull/87770\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex fd54faf17ca3..5535cc55e932 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -8221,6 +8221,8 @@ VPBlendRecipe *VPRecipeBuilder::tryToBlend(PHINode *Phi,\n   // builder. At this point we generate the predication tree. There may be\n   // duplications since this is a simple recursive scan, but future\n   // optimizations will clean it up.\n+  // TODO: At the moment the first mask is always skipped, but it would be\n+  // better to skip the most expensive mask.\n   SmallVector<VPValue *, 2> OperandsWithMask;\n \n   for (unsigned In = 0; In < NumIncoming; In++) {\n@@ -8233,6 +8235,8 @@ VPBlendRecipe *VPRecipeBuilder::tryToBlend(PHINode *Phi,\n              \"Distinct incoming values with one having a full mask\");\n       break;\n     }\n+    if (In == 0)\n+      continue;\n     OperandsWithMask.push_back(EdgeMask);\n   }\n   return new VPBlendRecipe(Phi, OperandsWithMask);\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlan.h b/llvm/lib/Transforms/Vectorize/VPlan.h\nindex 5f6334b974cf..5dc905a3c407 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlan.h\n+++ b/llvm/lib/Transforms/Vectorize/VPlan.h\n@@ -1932,14 +1932,12 @@ public:\n class VPBlendRecipe : public VPSingleDefRecipe {\n public:\n   /// The blend operation is a User of the incoming values and of their\n-  /// respective masks, ordered [I0, M0, I1, M1, ...]. Note that a single value\n-  /// might be incoming with a full mask for which there is no VPValue.\n+  /// respective masks, ordered [I0, I1, M1, I2, M2, ...]. Note that the first\n+  /// incoming value does not have a mask associated.\n   VPBlendRecipe(PHINode *Phi, ArrayRef<VPValue *> Operands)\n       : VPSingleDefRecipe(VPDef::VPBlendSC, Operands, Phi, Phi->getDebugLoc()) {\n-    assert(Operands.size() > 0 &&\n-           ((Operands.size() == 1) || (Operands.size() % 2 == 0)) &&\n-           \"Expected either a single incoming value or a positive even number \"\n-           \"of operands\");\n+    assert((Operands.size() + 1) % 2 == 0 &&\n+           \"Expected an odd number of operands\");\n   }\n \n   VPRecipeBase *clone() override {\n@@ -1949,15 +1947,20 @@ public:\n \n   VP_CLASSOF_IMPL(VPDef::VPBlendSC)\n \n-  /// Return the number of incoming values, taking into account that a single\n+  /// Return the number of incoming values, taking into account that the first\n   /// incoming value has no mask.\n   unsigned getNumIncomingValues() const { return (getNumOperands() + 1) / 2; }\n \n   /// Return incoming value number \\p Idx.\n-  VPValue *getIncomingValue(unsigned Idx) const { return getOperand(Idx * 2); }\n+  VPValue *getIncomingValue(unsigned Idx) const {\n+    return Idx == 0 ? getOperand(0) : getOperand(Idx * 2 - 1);\n+  }\n \n   /// Return mask number \\p Idx.\n-  VPValue *getMask(unsigned Idx) const { return getOperand(Idx * 2 + 1); }\n+  VPValue *getMask(unsigned Idx) const {\n+    assert(Idx > 0 && \"First index has no mask associated.\");\n+    return getOperand(Idx * 2);\n+  }\n \n   /// Generate the phi/select nodes.\n   void execute(VPTransformState &State) override;\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 2438e4dae3eb..625319954e9b 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -1513,6 +1513,8 @@ void VPBlendRecipe::print(raw_ostream &O, const Twine &Indent,\n     for (unsigned I = 0, E = getNumIncomingValues(); I < E; ++I) {\n       O << \" \";\n       getIncomingValue(I)->printAsOperand(O, SlotTracker);\n+      if (I == 0)\n+        continue;\n       O << \"/\";\n       getMask(I)->printAsOperand(O, SlotTracker);\n     }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/sve-tail-folding-reductions.ll",
      "commands": [
        "< %s",
        "-prefer-inloop-reductions < %s"
      ],
      "tests": [
        {
          "test_name": "cond_xor_reduction",
          "test_body": "target triple = \"aarch64-unknown-linux-gnu\"\n\ndefine i32 @cond_xor_reduction(ptr noalias %a, ptr noalias %cond, i64 %N) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.inc ]\n  %rdx = phi i32 [ 7, %entry ], [ %res, %for.inc ]\n  %arrayidx = getelementptr inbounds i32, ptr %cond, i64 %iv\n  %0 = load i32, ptr %arrayidx, align 4\n  %tobool = icmp eq i32 %0, 5\n  br i1 %tobool, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %arrayidx2 = getelementptr inbounds i32, ptr %a, i64 %iv\n  %1 = load i32, ptr %arrayidx2, align 4\n  %xor = xor i32 %rdx, %1\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %res = phi i32 [ %rdx, %for.body ], [ %xor, %if.then ]\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, %N\n  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !0\n\nfor.end:                                          ; preds = %for.inc\n  ret i32 %res\n}\n\nattributes #0 = { \"target-features\"=\"+sve\" }\n\n!0 = distinct !{!0, !1, !2}\n!1 = !{!\"llvm.loop.vectorize.width\", i32 4}\n!2 = !{!\"llvm.loop.vectorize.scalable.enable\", i1 true}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/divrem.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -scalable-vectorization=on -mtriple riscv64-linux-gnu -mattr=+v,+f -S 2>%t",
        "opt < %s -passes=loop-vectorize -scalable-vectorization=off -riscv-v-vector-bits-min=-1 -mtriple riscv64-linux-gnu -mattr=+v,+f -S 2>%t"
      ],
      "tests": [
        {
          "test_name": "predicated_udiv",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\"\ntarget triple = \"riscv64\"\n\ndefine void @predicated_udiv(ptr noalias nocapture %a, i64 %v, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %iv\n  %elem = load i64, ptr %arrayidx, align 8\n  %c = icmp ne i64 %v, 0\n  br i1 %c, label %do_op, label %latch\n\ndo_op:                                            ; preds = %for.body\n  %divrem = udiv i64 %elem, %v\n  br label %latch\n\nlatch:                                            ; preds = %do_op, %for.body\n  %phi = phi i64 [ %elem, %for.body ], [ %divrem, %do_op ]\n  store i64 %phi, ptr %arrayidx, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %latch\n  ret void\n}\n"
        },
        {
          "test_name": "predicated_udiv_by_constant",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\"\ntarget triple = \"riscv64\"\n\ndefine void @predicated_udiv_by_constant(ptr noalias nocapture %a, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %iv\n  %elem = load i64, ptr %arrayidx, align 8\n  %c = icmp ne i64 %elem, 42\n  br i1 %c, label %do_op, label %latch\n\ndo_op:                                            ; preds = %for.body\n  %divrem = udiv i64 %elem, 27\n  br label %latch\n\nlatch:                                            ; preds = %do_op, %for.body\n  %phi = phi i64 [ %elem, %for.body ], [ %divrem, %do_op ]\n  store i64 %phi, ptr %arrayidx, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %latch\n  ret void\n}\n"
        },
        {
          "test_name": "predicated_sdiv",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\"\ntarget triple = \"riscv64\"\n\ndefine void @predicated_sdiv(ptr noalias nocapture %a, i64 %v, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %iv\n  %elem = load i64, ptr %arrayidx, align 8\n  %c = icmp ne i64 %v, 0\n  br i1 %c, label %do_op, label %latch\n\ndo_op:                                            ; preds = %for.body\n  %divrem = sdiv i64 %elem, %v\n  br label %latch\n\nlatch:                                            ; preds = %do_op, %for.body\n  %phi = phi i64 [ %elem, %for.body ], [ %divrem, %do_op ]\n  store i64 %phi, ptr %arrayidx, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %latch\n  ret void\n}\n"
        },
        {
          "test_name": "predicated_sdiv_by_minus_one",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\"\ntarget triple = \"riscv64\"\n\ndefine void @predicated_sdiv_by_minus_one(ptr noalias nocapture %a, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %arrayidx = getelementptr inbounds i8, ptr %a, i64 %iv\n  %elem = load i8, ptr %arrayidx, align 1\n  %c = icmp ne i8 %elem, -128\n  br i1 %c, label %do_op, label %latch\n\ndo_op:                                            ; preds = %for.body\n  %divrem = sdiv i8 %elem, -1\n  br label %latch\n\nlatch:                                            ; preds = %do_op, %for.body\n  %phi = phi i8 [ %elem, %for.body ], [ %divrem, %do_op ]\n  store i8 %phi, ptr %arrayidx, align 1\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %latch\n  ret void\n}\n"
        },
        {
          "test_name": "predicated_sdiv_by_constant",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\"\ntarget triple = \"riscv64\"\n\ndefine void @predicated_sdiv_by_constant(ptr noalias nocapture %a, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %iv\n  %elem = load i64, ptr %arrayidx, align 8\n  %c = icmp ne i64 %elem, 42\n  br i1 %c, label %do_op, label %latch\n\ndo_op:                                            ; preds = %for.body\n  %divrem = sdiv i64 %elem, 27\n  br label %latch\n\nlatch:                                            ; preds = %do_op, %for.body\n  %phi = phi i64 [ %elem, %for.body ], [ %divrem, %do_op ]\n  store i64 %phi, ptr %arrayidx, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1024\n  br i1 %exitcond.not, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %latch\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/select-cmp-reduction.ll",
      "commands": [
        "< %s",
        "-scalable-vectorization=on -S < %s"
      ],
      "tests": [
        {
          "test_name": "pred_select_const_i32_from_icmp",
          "test_body": "target triple = \"riscv64\"\n\ndefine i32 @pred_select_const_i32_from_icmp(ptr noalias nocapture readonly %src1, ptr noalias nocapture readonly %src2, i64 %n) #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %i.013 = phi i64 [ %inc, %for.inc ], [ 0, %entry ]\n  %r.012 = phi i32 [ %r.1, %for.inc ], [ 0, %entry ]\n  %arrayidx = getelementptr inbounds i32, ptr %src1, i64 %i.013\n  %0 = load i32, ptr %arrayidx, align 4\n  %cmp1 = icmp sgt i32 %0, 35\n  br i1 %cmp1, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %arrayidx2 = getelementptr inbounds i32, ptr %src2, i64 %i.013\n  %1 = load i32, ptr %arrayidx2, align 4\n  %cmp3 = icmp eq i32 %1, 2\n  %spec.select = select i1 %cmp3, i32 1, i32 %r.012\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %r.1 = phi i32 [ %r.012, %for.body ], [ %spec.select, %if.then ]\n  %inc = add nuw nsw i64 %i.013, 1\n  %exitcond.not = icmp eq i64 %inc, %n\n  br i1 %exitcond.not, label %for.end.loopexit, label %for.body\n\nfor.end.loopexit:                                 ; preds = %for.inc\n  %r.1.lcssa = phi i32 [ %r.1, %for.inc ]\n  ret i32 %r.1.lcssa\n}\n\nattributes #0 = { \"target-features\"=\"+f,+v\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/uniform-load-store.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -scalable-vectorization=on -riscv-v-vector-bits-min=0 -mtriple riscv64-linux-gnu -mattr=+v,+f -S 2>%t",
        "opt < %s -passes=loop-vectorize -scalable-vectorization=off -riscv-v-vector-bits-min=-1 -mtriple riscv64-linux-gnu -mattr=+v,+f -S 2>%t",
        "opt < %s -passes=loop-vectorize -scalable-vectorization=on -riscv-v-vector-bits-min=0 -prefer-predicate-over-epilogue=predicate-dont-vectorize -mtriple riscv64-linux-gnu -mattr=+v,+f -S 2>%t",
        "opt < %s -passes=loop-vectorize -scalable-vectorization=off -riscv-v-vector-bits-min=-1 -prefer-predicate-over-epilogue=predicate-dont-vectorize -mtriple riscv64-linux-gnu -mattr=+v,+f -S 2>%t"
      ],
      "tests": [
        {
          "test_name": "conditional_uniform_load",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\"\ntarget triple = \"riscv64\"\n\ndefine void @conditional_uniform_load(ptr noalias nocapture %a, ptr noalias nocapture %b, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %cmp = icmp ugt i64 %iv, 10\n  br i1 %cmp, label %do_load, label %latch\n\ndo_load:                                          ; preds = %for.body\n  %v = load i64, ptr %b, align 8\n  br label %latch\n\nlatch:                                            ; preds = %do_load, %for.body\n  %phi = phi i64 [ 0, %for.body ], [ %v, %do_load ]\n  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %iv\n  store i64 %phi, ptr %arrayidx, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv.next, 1025\n  br i1 %exitcond.not, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %latch\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/drop-poison-generating-flags.ll",
      "commands": [
        "opt %s -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S"
      ],
      "tests": [
        {
          "test_name": "Bgep_inbounds_unconditionally_due_to_store",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc-linux-gnu\"\n\n; Function Attrs: noinline nounwind uwtable\ndefine void @Bgep_inbounds_unconditionally_due_to_store(ptr noalias %B, ptr readonly %C) #0 {\nentry:\n  br label %loop.body\n\nloop.body:                                        ; preds = %loop.latch, %entry\n  %iv1 = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %C.gep = getelementptr inbounds i32, ptr %C, i64 %iv1\n  %C.lv = load i32, ptr %C.gep, align 4\n  %cmp = icmp eq i32 %C.lv, 20\n  %B.gep.0 = getelementptr inbounds float, ptr %B, i64 %iv1\n  br i1 %cmp, label %loop.latch, label %else\n\nelse:                                             ; preds = %loop.body\n  %B.lv = load float, ptr %B.gep.0, align 4\n  %add = fadd float %B.lv, 2.000000e+00\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else, %loop.body\n  %add.sink = phi float [ %add, %else ], [ 3.300000e+01, %loop.body ]\n  store float %add.sink, ptr %B.gep.0, align 4\n  %iv.next = add nuw nsw i64 %iv1, 1\n  %exitcond.not = icmp eq i64 %iv.next, 10000\n  br i1 %exitcond.not, label %exit, label %loop.body\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { noinline nounwind uwtable \"target-features\"=\"+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl\" }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/imprecise-through-phis.ll",
      "commands": [
        "opt -S -passes=loop-vectorize -mtriple=x86_64-apple-darwin %s",
        "opt -S -passes=loop-vectorize -mtriple=x86_64-apple-darwin -mattr=+avx %s"
      ],
      "tests": [
        {
          "test_name": "sumIfVector",
          "test_body": "define double @sumIfVector(ptr nocapture readonly %arr) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %next.iter, %entry\n  %i = phi i32 [ 0, %entry ], [ %i.next, %next.iter ]\n  %tot = phi double [ 0.000000e+00, %entry ], [ %tot.next, %next.iter ]\n  %addr = getelementptr double, ptr %arr, i32 %i\n  %nextval = load double, ptr %addr, align 8\n  %tst = fcmp fast une double %nextval, 4.200000e+01\n  br i1 %tst, label %do.add, label %no.add\n\ndo.add:                                           ; preds = %loop\n  %tot.new = fadd fast double %tot, %nextval\n  br label %next.iter\n\nno.add:                                           ; preds = %loop\n  br label %next.iter\n\nnext.iter:                                        ; preds = %no.add, %do.add\n  %tot.next = phi double [ %tot, %no.add ], [ %tot.new, %do.add ]\n  %i.next = add i32 %i, 1\n  %again = icmp ult i32 %i.next, 32\n  br i1 %again, label %loop, label %done\n\ndone:                                             ; preds = %next.iter\n  ret double %tot.next\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/load-deref-pred.ll",
      "commands": [
        "opt -S -force-vector-width=4 -passes=loop-vectorize -mcpu=haswell < %s"
      ],
      "tests": [
        {
          "test_name": "neg_off_by_one_byte",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @neg_off_by_one_byte(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [16383 x i8], align 1\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_step_narrower_than_access",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_step_narrower_than_access(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr.i16p = getelementptr inbounds i16, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr.i16p, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_invariant_address",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_invariant_address(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %val = load i32, ptr %alloca, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "neg_off_by_many",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @neg_off_by_many(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [1024 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_allocsize",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\n; Function Attrs: allocsize(0)\ndeclare align 8 dereferenceable_or_null(8) ptr @my_alloc(i32) #0\n\n; Function Attrs: nofree nosync\ndefine i32 @test_allocsize(i64 %len, ptr %test_base) #1 {\nentry:\n  %allocation = call nonnull ptr @my_alloc(i32 16384)\n  call void @init(ptr %allocation)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %allocation, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n\nattributes #0 = { allocsize(0) }\nattributes #1 = { nofree nosync }\n"
        },
        {
          "test_name": "test_allocsize_cond_deref",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\n; Function Attrs: allocsize(0)\ndeclare align 8 dereferenceable_or_null(8) ptr @my_alloc(i32) #0\n\ndeclare void @my_free(ptr)\n\ndefine i32 @test_allocsize_cond_deref(i1 %allzero, ptr %test_base) {\nentry:\n  %allocation = call nonnull ptr @my_alloc(i32 16384)\n  call void @init(ptr %allocation)\n  br i1 %allzero, label %freeit, label %preheader\n\nfreeit:                                           ; preds = %entry\n  call void @my_free(ptr %allocation)\n  br label %preheader\n\npreheader:                                        ; preds = %freeit, %entry\n  br label %loop\n\nloop:                                             ; preds = %latch, %preheader\n  %iv = phi i64 [ 0, %preheader ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %preheader ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %allocation, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n\nattributes #0 = { allocsize(0) }\n"
        },
        {
          "test_name": "test_constant_max",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_constant_max(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  %cmp = icmp ugt i64 %len, 4094\n  %min = select i1 %cmp, i64 4094, i64 %len\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, %min\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_explicit_pred",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_explicit_pred(i64 %len) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %earlycnd = icmp slt i64 %iv, %len\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "neg_off_by_one_iteration",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @neg_off_by_one_iteration(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4095 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_explicit_pred_generic",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_explicit_pred_generic(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_non_unit_stride_four",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_non_unit_stride_four(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [108 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 4\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 100\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "neg_test_non_unit_stride_off_by_four_bytes",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @neg_test_non_unit_stride_off_by_four_bytes(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [103 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 2\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 100\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_non_unit_stride_five",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_non_unit_stride_five(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [110 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 5\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 100\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_stride_three",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_stride_three(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [105 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 3\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 100\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_non_unit_stride",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_non_unit_stride(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 2\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4093\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_max_trip_count",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_max_trip_count(i64 %len, ptr %test_base, i64 %n) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  %min.cmp = icmp ult i64 4096, %n\n  %min.n = select i1 %min.cmp, i64 4096, i64 %n\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, %min.n\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_allocsize_array",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\n; Function Attrs: allocsize(0,1)\ndeclare align 8 dereferenceable_or_null(8) ptr @my_array_alloc(i32, i32) #0\n\n; Function Attrs: nofree nosync\ndefine i32 @test_allocsize_array(i64 %len, ptr %test_base) #1 {\nentry:\n  %allocation = call nonnull ptr @my_array_alloc(i32 4096, i32 4)\n  call void @init(ptr %allocation)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %allocation, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n\nattributes #0 = { allocsize(0,1) }\nattributes #1 = { nofree nosync }\n"
        },
        {
          "test_name": "test_non_zero_start",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_non_zero_start(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 1024, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 4094\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_non_unit_stride_with_first_iteration_step_access",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_non_unit_stride_with_first_iteration_step_access(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [4096 x i32], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 2\n  %test_addr = getelementptr inbounds i1, ptr %test_base, i64 %iv\n  %earlycnd = load i1, ptr %test_addr, align 1\n  br i1 %earlycnd, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %alloca, i64 %iv.next\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp ugt i64 %iv, 300\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/x86-predication.ll",
      "commands": [
        "opt < %s -mattr=avx -force-vector-width=2 -force-vector-interleave=1 -passes=loop-vectorize,simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S",
        "opt -mcpu=skylake-avx512 -S -force-vector-width=8 -force-vector-interleave=1 -passes=loop-vectorize < %s"
      ],
      "tests": [
        {
          "test_name": "predicated_sdiv_masked_load",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i32 @predicated_sdiv_masked_load(ptr %a, ptr %b, i32 %x, i1 %c) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.inc ]\n  %r = phi i32 [ 0, %entry ], [ %t7, %for.inc ]\n  %t0 = getelementptr inbounds i32, ptr %a, i64 %i\n  %t1 = load i32, ptr %t0, align 4\n  br i1 %c, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %t2 = getelementptr inbounds i32, ptr %b, i64 %i\n  %t3 = load i32, ptr %t2, align 4\n  %t4 = sdiv i32 %t3, %x\n  %t5 = add nsw i32 %t4, %t1\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %t6 = phi i32 [ %t1, %for.body ], [ %t5, %if.then ]\n  %t7 = add i32 %r, %t6\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp eq i64 %i.next, 10000\n  br i1 %cond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.inc\n  %t8 = phi i32 [ %t7, %for.inc ]\n  ret i32 %t8\n}\n"
        },
        {
          "test_name": "scalarize_and_sink_gather",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i32 @scalarize_and_sink_gather(ptr %a, i1 %c, i32 %x, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.inc ]\n  %r = phi i32 [ 0, %entry ], [ %t6, %for.inc ]\n  %i7 = mul i64 %i, 777\n  br i1 %c, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %t0 = getelementptr inbounds i32, ptr %a, i64 %i7\n  %t2 = load i32, ptr %t0, align 4\n  %t4 = udiv i32 %t2, %x\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %t5 = phi i32 [ %x, %for.body ], [ %t4, %if.then ]\n  %t6 = add i32 %r, %t5\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.inc\n  %t7 = phi i32 [ %t6, %for.inc ]\n  ret i32 %t7\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/if-pred-non-void.ll",
      "commands": [
        "opt -S -force-vector-width=2 -force-vector-interleave=1 -passes=loop-vectorize,simplifycfg -verify-loop-info -simplifycfg-require-and-preserve-domtree=1 -force-widen-divrem-via-safe-divisor=0 < %s",
        "opt -S -force-vector-width=1 -force-vector-interleave=2 -passes=loop-vectorize -verify-loop-info -force-widen-divrem-via-safe-divisor=0 < %s"
      ],
      "tests": [
        {
          "test_name": "predicated_udiv_scalarized_operand",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine i32 @predicated_udiv_scalarized_operand(ptr %a, i1 %c, i32 %x, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.inc ]\n  %r = phi i32 [ 0, %entry ], [ %t6, %for.inc ]\n  %t0 = getelementptr inbounds i32, ptr %a, i64 %i\n  %t2 = load i32, ptr %t0, align 4\n  br i1 %c, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %t3 = add nsw i32 %t2, %x\n  %t4 = udiv i32 %t2, %t3\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %t5 = phi i32 [ %t2, %for.body ], [ %t4, %if.then ]\n  %t6 = add i32 %r, %t5\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.inc\n  %t7 = phi i32 [ %t6, %for.inc ]\n  ret i32 %t7\n}\n\n!llvm.dbg.cu = !{!0}\n!llvm.module.flags = !{!3, !4}\n\n!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \"clang\", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, enums: !2)\n!1 = !DIFile(filename: \"/tmp/s.c\", directory: \"/tmp\")\n!2 = !{}\n!3 = !{i32 2, !\"Debug Info Version\", i32 3}\n!4 = !{i32 8, !\"PIC Level\", i32 2}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/if-reduction.ll",
      "commands": [
        "opt -S -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 < %s"
      ],
      "tests": [
        {
          "test_name": "fcmp_array_elm_fadd_select2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine double @fcmp_array_elm_fadd_select2(ptr noalias %x, ptr noalias %y, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi double [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx.1 = getelementptr inbounds double, ptr %x, i64 %indvars.iv\n  %0 = load double, ptr %arrayidx.1, align 4\n  %arrayidx.2 = getelementptr inbounds double, ptr %y, i64 %indvars.iv\n  %1 = load double, ptr %arrayidx.2, align 4\n  %cmp.2 = fcmp fast ogt double %0, %1\n  %add = fadd fast double %0, %sum.1\n  %sum.2 = select i1 %cmp.2, double %add, double %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %2 = phi double [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret double %2\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_sub_select1",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine i32 @fcmp_0_sub_select1(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi i32 [ 0, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp ogt float %0, 0.000000e+00\n  %sub = sub nsw i32 %sum.1, 2\n  %sum.2 = select i1 %cmp.2, i32 %sub, i32 %sum.1\n  %indvars.iv.next = sub nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi i32 [ 0, %entry ], [ %sum.2, %for.body ]\n  ret i32 %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_mult_select1",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine i32 @fcmp_0_mult_select1(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi i32 [ 0, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp ogt float %0, 0.000000e+00\n  %mult = mul nsw i32 %sum.1, 2\n  %sum.2 = select i1 %cmp.2, i32 %mult, i32 %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi i32 [ 0, %entry ], [ %sum.2, %for.body ]\n  ret i32 %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fmult_select2_notvectorize",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine double @fcmp_0_fmult_select2_notvectorize(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi double [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds double, ptr %x, i64 %indvars.iv\n  %0 = load double, ptr %arrayidx, align 4\n  %cmp.2 = fcmp ogt double %0, 0.000000e+00\n  %mult = fmul double %sum.1, %0\n  %sum.2 = select i1 %cmp.2, double %mult, double %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi double [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret double %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_fadd_fsub",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_fadd_fsub(ptr nocapture readonly %a, i32 %n) #0 {\nentry:\n  %cmp9 = icmp sgt i32 %n, 0\n  br i1 %cmp9, label %for.body.preheader, label %for.end\n\nfor.body.preheader:                               ; preds = %entry\n  %wide.trip.count = zext i32 %n to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %for.body.preheader\n  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]\n  %sum.010 = phi float [ 0.000000e+00, %for.body.preheader ], [ %sum.1, %for.inc ]\n  %arrayidx = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp1 = fcmp ogt float %0, 1.000000e+00\n  br i1 %cmp1, label %if.then, label %if.else\n\nif.then:                                          ; preds = %for.body\n  %add = fadd fast float %0, %sum.010\n  br label %for.inc\n\nif.else:                                          ; preds = %for.body\n  %cmp8 = fcmp olt float %0, 3.000000e+00\n  br i1 %cmp8, label %if.then10, label %for.inc\n\nif.then10:                                        ; preds = %if.else\n  %sub = fsub fast float %sum.010, %0\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then10, %if.else, %if.then\n  %sum.1 = phi float [ %add, %if.then ], [ %sub, %if.then10 ], [ %sum.010, %if.else ]\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.inc, %entry\n  %sum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %sum.1, %for.inc ]\n  ret float %sum.0.lcssa\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_val_fadd_select1",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_val_fadd_select1(ptr noalias %x, float %y, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi float [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt float %0, %y\n  %add = fadd fast float %0, %sum.1\n  %sum.2 = select i1 %cmp.2, float %add, float %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi float [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret float %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_fadd_fmul",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_fadd_fmul(ptr nocapture readonly %a, i32 %n) #0 {\nentry:\n  %cmp9 = icmp sgt i32 %n, 0\n  br i1 %cmp9, label %for.body.preheader, label %for.end\n\nfor.body.preheader:                               ; preds = %entry\n  %wide.trip.count = zext i32 %n to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %for.body.preheader\n  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]\n  %sum.010 = phi float [ 0.000000e+00, %for.body.preheader ], [ %sum.1, %for.inc ]\n  %arrayidx = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp1 = fcmp ogt float %0, 1.000000e+00\n  br i1 %cmp1, label %if.then, label %if.else\n\nif.then:                                          ; preds = %for.body\n  %add = fadd fast float %0, %sum.010\n  br label %for.inc\n\nif.else:                                          ; preds = %for.body\n  %cmp8 = fcmp olt float %0, 3.000000e+00\n  br i1 %cmp8, label %if.then10, label %for.inc\n\nif.then10:                                        ; preds = %if.else\n  %mul = fmul fast float %0, %sum.010\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then10, %if.else, %if.then\n  %sum.1 = phi float [ %add, %if.then ], [ %mul, %if.then10 ], [ %sum.010, %if.else ]\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.inc, %entry\n  %sum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %sum.1, %for.inc ]\n  ret float %sum.0.lcssa\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "non_reduction_index_half",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n@table = external constant [13 x i16], align 1\n\ndefine i16 @non_reduction_index_half(half noundef %val) {\nentry:\n  br label %for.body\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  %spec.select.lcssa = phi i16 [ %spec.select, %for.body ]\n  ret i16 %spec.select.lcssa\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i.05 = phi i16 [ 12, %entry ], [ %sub, %for.body ]\n  %k.04 = phi i16 [ 0, %entry ], [ %spec.select, %for.body ]\n  %arrayidx = getelementptr inbounds [13 x i16], ptr @table, i16 0, i16 %i.05\n  %0 = load half, ptr %arrayidx, align 1\n  %fcmp1 = fcmp ugt half %0, %val\n  %sub = add nsw i16 %i.05, -1\n  %spec.select = select i1 %fcmp1, i16 %sub, i16 %k.04\n  %cmp.not = icmp eq i16 %sub, 0\n  br i1 %cmp.not, label %for.cond.cleanup, label %for.body\n}\n"
        },
        {
          "test_name": "fcmp_multi",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_multi(ptr nocapture readonly %a, i32 %n) #0 {\nentry:\n  %cmp10 = icmp sgt i32 %n, 0\n  br i1 %cmp10, label %for.body.preheader, label %for.end\n\nfor.body.preheader:                               ; preds = %entry\n  %wide.trip.count = zext i32 %n to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %for.body.preheader\n  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]\n  %sum.011 = phi float [ 0.000000e+00, %for.body.preheader ], [ %sum.1, %for.inc ]\n  %arrayidx = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp1 = fcmp ogt float %0, 1.000000e+00\n  br i1 %cmp1, label %for.inc, label %if.else\n\nif.else:                                          ; preds = %for.body\n  %cmp8 = fcmp olt float %0, 3.000000e+00\n  br i1 %cmp8, label %if.then10, label %if.else14\n\nif.then10:                                        ; preds = %if.else\n  %mul = fmul fast float %0, 2.000000e+00\n  br label %for.inc\n\nif.else14:                                        ; preds = %if.else\n  %mul17 = fmul fast float %0, 3.000000e+00\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.else14, %if.then10, %for.body\n  %.pn = phi float [ %mul, %if.then10 ], [ %mul17, %if.else14 ], [ %0, %for.body ]\n  %sum.1 = fadd fast float %.pn, %sum.011\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.inc, %entry\n  %sum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %sum.1, %for.inc ]\n  ret float %sum.0.lcssa\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fadd_select2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine double @fcmp_0_fadd_select2(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi double [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds double, ptr %x, i64 %indvars.iv\n  %0 = load double, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt double %0, 0.000000e+00\n  %add = fadd fast double %0, %sum.1\n  %sum.2 = select i1 %cmp.2, double %add, double %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi double [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret double %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fsub_select1_novectorize",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_0_fsub_select1_novectorize(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi float [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp ogt float %0, 0.000000e+00\n  %sub = fsub float %sum.1, %0\n  %sum.2 = select i1 %cmp.2, float %sub, float %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi float [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret float %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_array_elm_fadd_select1",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_array_elm_fadd_select1(ptr noalias %x, ptr noalias %y, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi float [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx.1 = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx.1, align 4\n  %arrayidx.2 = getelementptr inbounds float, ptr %y, i64 %indvars.iv\n  %1 = load float, ptr %arrayidx.2, align 4\n  %cmp.2 = fcmp fast ogt float %0, %1\n  %add = fadd fast float %0, %sum.1\n  %sum.2 = select i1 %cmp.2, float %add, float %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %2 = phi float [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret float %2\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fsub_select1",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_0_fsub_select1(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi float [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt float %0, 0.000000e+00\n  %sub = fsub fast float %sum.1, %0\n  %sum.2 = select i1 %cmp.2, float %sub, float %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi float [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret float %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fsub_select2_notvectorize",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine double @fcmp_0_fsub_select2_notvectorize(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi double [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds double, ptr %x, i64 %indvars.iv\n  %0 = load double, ptr %arrayidx, align 4\n  %cmp.2 = fcmp ogt double %0, 0.000000e+00\n  %sub = fsub double %sum.1, %0\n  %sum.2 = select i1 %cmp.2, double %sub, double %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi double [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret double %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_store_back",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_store_back(ptr nocapture %a, i32 %LEN) #0 {\nentry:\n  %cmp7 = icmp sgt i32 %LEN, 0\n  br i1 %cmp7, label %for.body.preheader, label %for.end\n\nfor.body.preheader:                               ; preds = %entry\n  %wide.trip.count = zext i32 %LEN to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.body.preheader\n  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]\n  %sum.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %add = fadd fast float %0, %sum.08\n  store float %add, ptr %arrayidx, align 4\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %sum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %add, %for.body ]\n  ret float %sum.0.lcssa\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_val_fadd_select2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine double @fcmp_val_fadd_select2(ptr noalias %x, double %y, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi double [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds double, ptr %x, i64 %indvars.iv\n  %0 = load double, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt double %0, %y\n  %add = fadd fast double %0, %sum.1\n  %sum.2 = select i1 %cmp.2, double %add, double %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi double [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret double %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "non_reduction_index",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n@table = external constant [13 x i16], align 1\n\ndefine i16 @non_reduction_index(i16 noundef %val) {\nentry:\n  br label %for.body\n\nfor.cond.cleanup:                                 ; preds = %for.body\n  %spec.select.lcssa = phi i16 [ %spec.select, %for.body ]\n  ret i16 %spec.select.lcssa\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i.05 = phi i16 [ 12, %entry ], [ %sub, %for.body ]\n  %k.04 = phi i16 [ 0, %entry ], [ %spec.select, %for.body ]\n  %arrayidx = getelementptr inbounds [13 x i16], ptr @table, i16 0, i16 %i.05\n  %0 = load i16, ptr %arrayidx, align 1\n  %cmp1 = icmp ugt i16 %0, %val\n  %sub = add nsw i16 %i.05, -1\n  %spec.select = select i1 %cmp1, i16 %sub, i16 %k.04\n  %cmp.not = icmp eq i16 %sub, 0\n  br i1 %cmp.not, label %for.cond.cleanup, label %for.body\n}\n"
        },
        {
          "test_name": "fcmp_0_fsub_select2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine double @fcmp_0_fsub_select2(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi double [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds double, ptr %x, i64 %indvars.iv\n  %0 = load double, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt double %0, 0.000000e+00\n  %sub = fsub fast double %sum.1, %0\n  %sum.2 = select i1 %cmp.2, double %sub, double %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi double [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret double %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fmult_select1_notvectorize",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_0_fmult_select1_notvectorize(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi float [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp ogt float %0, 0.000000e+00\n  %mult = fmul float %sum.1, %0\n  %sum.2 = select i1 %cmp.2, float %mult, float %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi float [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret float %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fmult_select1",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_0_fmult_select1(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi float [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt float %0, 0.000000e+00\n  %mult = fmul fast float %sum.1, %0\n  %sum.2 = select i1 %cmp.2, float %mult, float %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi float [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret float %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fadd_select1",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine float @fcmp_0_fadd_select1(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi float [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt float %0, 0.000000e+00\n  %add = fadd fast float %0, %sum.1\n  %sum.2 = select i1 %cmp.2, float %add, float %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi float [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret float %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_add_select2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine i64 @fcmp_0_add_select2(ptr noalias %x, i64 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i64 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi i64 [ 0, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %x, i64 %indvars.iv\n  %0 = load float, ptr %arrayidx, align 4\n  %cmp.2 = fcmp ogt float %0, 0.000000e+00\n  %add = add nsw i64 %sum.1, 2\n  %sum.2 = select i1 %cmp.2, i64 %add, i64 %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %N\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi i64 [ 0, %entry ], [ %sum.2, %for.body ]\n  ret i64 %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        },
        {
          "test_name": "fcmp_0_fmult_select2",
          "test_body": "target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n\n; Function Attrs: nounwind memory(read)\ndefine double @fcmp_0_fmult_select2(ptr noalias %x, i32 %N) #0 {\nentry:\n  %cmp.1 = icmp sgt i32 %N, 0\n  br i1 %cmp.1, label %for.header, label %for.end\n\nfor.header:                                       ; preds = %entry\n  %zext = zext i32 %N to i64\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %for.header\n  %indvars.iv = phi i64 [ 0, %for.header ], [ %indvars.iv.next, %for.body ]\n  %sum.1 = phi double [ 0.000000e+00, %for.header ], [ %sum.2, %for.body ]\n  %arrayidx = getelementptr inbounds double, ptr %x, i64 %indvars.iv\n  %0 = load double, ptr %arrayidx, align 4\n  %cmp.2 = fcmp fast ogt double %0, 0.000000e+00\n  %mult = fmul fast double %sum.1, %0\n  %sum.2 = select i1 %cmp.2, double %mult, double %sum.1\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv.next, %zext\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body, %entry\n  %1 = phi double [ 0.000000e+00, %entry ], [ %sum.2, %for.body ]\n  ret double %1\n}\n\nattributes #0 = { nounwind memory(read) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/load-deref-pred-align.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=2 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "test_access_size_multiple_of_align_but_offset_by_1",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i32 @test_access_size_multiple_of_align_but_offset_by_1(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [163840 x i32], align 4\n  call void @init(ptr %alloca)\n  %start = getelementptr i8, ptr %alloca, i64 2\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i32 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i8, ptr %test_base, i64 %iv\n  %l.t = load i8, ptr %test_addr, align 1\n  %cmp = icmp sge i8 %l.t, 0\n  br i1 %cmp, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i32, ptr %start, i64 %iv\n  %val = load i32, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i32 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i32 %accum, %val.phi\n  %exit = icmp eq i64 %iv, 4095\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i32 %accum.next\n}\n"
        },
        {
          "test_name": "test_access_size_not_multiple_of_align",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1\"\n\ndeclare void @init(ptr nocapture nofree)\n\ndefine i16 @test_access_size_not_multiple_of_align(i64 %len, ptr %test_base) {\nentry:\n  %alloca = alloca [163840 x i16], align 4\n  call void @init(ptr %alloca)\n  br label %loop\n\nloop:                                             ; preds = %latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]\n  %accum = phi i16 [ 0, %entry ], [ %accum.next, %latch ]\n  %iv.next = add i64 %iv, 1\n  %test_addr = getelementptr inbounds i8, ptr %test_base, i64 %iv\n  %l.t = load i8, ptr %test_addr, align 1\n  %cmp = icmp sge i8 %l.t, 0\n  br i1 %cmp, label %pred, label %latch\n\npred:                                             ; preds = %loop\n  %addr = getelementptr inbounds i16, ptr %alloca, i64 %iv\n  %val = load i16, ptr %addr, align 4\n  br label %latch\n\nlatch:                                            ; preds = %pred, %loop\n  %val.phi = phi i16 [ 0, %loop ], [ %val, %pred ]\n  %accum.next = add i16 %accum, %val.phi\n  %exit = icmp eq i64 %iv, 4095\n  br i1 %exit, label %loop_exit, label %loop\n\nloop_exit:                                        ; preds = %latch\n  ret i16 %accum.next\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/reduction-small-size.ll",
      "commands": [
        "opt < %s -force-vector-width=4 -force-vector-interleave=1 -passes=loop-vectorize -S"
      ],
      "tests": [
        {
          "test_name": "PR34687_no_undef",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine i8 @PR34687_no_undef(i1 %c, i32 %x, i32 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %if.end, %entry\n  %i = phi i32 [ 0, %entry ], [ %i.next, %if.end ]\n  %r = phi i32 [ 0, %entry ], [ %r.next, %if.end ]\n  br i1 %c, label %if.then, label %if.end\n\nif.then:                                          ; preds = %for.body\n  %t0 = sdiv i32 99, %x\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %for.body\n  %p = phi i32 [ 0, %for.body ], [ %t0, %if.then ]\n  %t1 = and i32 %r, 255\n  %i.next = add nsw i32 %i, 1\n  %r.next = add nuw nsw i32 %t1, %p\n  %cond = icmp eq i32 %i.next, %n\n  br i1 %cond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %if.end\n  %t2 = phi i32 [ %r.next, %if.end ]\n  %t3 = trunc i32 %t2 to i8\n  ret i8 %t3\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/select-cmp-predicated.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=2 -S < %s",
        "opt -passes=loop-vectorize -force-vector-interleave=2 -force-vector-width=1 -S < %s"
      ],
      "tests": [
        {
          "test_name": "pred_select_const_i32_from_icmp",
          "test_body": "define i32 @pred_select_const_i32_from_icmp(ptr noalias nocapture readonly %src1, ptr noalias nocapture readonly %src2, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %i.013 = phi i64 [ %inc, %for.inc ], [ 0, %entry ]\n  %r.012 = phi i32 [ %r.1, %for.inc ], [ 0, %entry ]\n  %arrayidx = getelementptr inbounds i32, ptr %src1, i64 %i.013\n  %0 = load i32, ptr %arrayidx, align 4\n  %cmp1 = icmp sgt i32 %0, 35\n  br i1 %cmp1, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %arrayidx2 = getelementptr inbounds i32, ptr %src2, i64 %i.013\n  %1 = load i32, ptr %arrayidx2, align 4\n  %cmp3 = icmp eq i32 %1, 2\n  %spec.select = select i1 %cmp3, i32 1, i32 %r.012\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %r.1 = phi i32 [ %r.012, %for.body ], [ %spec.select, %if.then ]\n  %inc = add nuw nsw i64 %i.013, 1\n  %exitcond.not = icmp eq i64 %inc, %n\n  br i1 %exitcond.not, label %for.end.loopexit, label %for.body\n\nfor.end.loopexit:                                 ; preds = %for.inc\n  %r.1.lcssa = phi i32 [ %r.1, %for.inc ]\n  ret i32 %r.1.lcssa\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/single-value-blend-phis.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "single_incoming_phi_no_blend_mask",
          "test_body": "@src = external global [32 x i16], align 1\n@dst = external global [32 x i16], align 1\n\ndefine void @single_incoming_phi_no_blend_mask(i64 %a, i64 %b) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.trunc = trunc i64 %iv to i16\n  br label %loop.cond\n\nloop.cond:                                        ; preds = %loop.header\n  %blend = phi i16 [ %iv.trunc, %loop.header ]\n  %src.ptr = getelementptr inbounds [32 x i16], ptr @src, i16 0, i16 %blend\n  %lv = load i16, ptr %src.ptr, align 1\n  %cmp.b = icmp sgt i64 %iv, %a\n  br i1 %cmp.b, label %loop.next, label %loop.latch\n\nloop.next:                                        ; preds = %loop.cond\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %loop.next, %loop.cond\n  %res = phi i16 [ %lv, %loop.cond ], [ 1, %loop.next ]\n  %dst.ptr = getelementptr inbounds [32 x i16], ptr @dst, i16 0, i64 %iv\n  store i16 %res, ptr %dst.ptr, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp439 = icmp ult i64 %iv, 31\n  br i1 %cmp439, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "multiple_incoming_phi_with_blend_mask",
          "test_body": "@src = external global [32 x i16], align 1\n\ndefine void @multiple_incoming_phi_with_blend_mask(i64 %a, ptr noalias %dst) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.trunc = trunc i64 %iv to i16\n  %iv.trunc.2 = trunc i64 %iv to i16\n  %cmp.a = icmp ugt i64 %iv, %a\n  br i1 %cmp.a, label %loop.next, label %loop.latch\n\nloop.next:                                        ; preds = %loop.header\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %loop.next, %loop.header\n  %blend = phi i16 [ %iv.trunc, %loop.header ], [ %iv.trunc.2, %loop.next ]\n  %src.ptr = getelementptr inbounds [32 x i16], ptr @src, i16 0, i16 %blend\n  %lv = load i16, ptr %src.ptr, align 1\n  %dst.ptr = getelementptr inbounds i16, ptr %dst, i64 %iv\n  store i16 %lv, ptr %dst.ptr, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp439 = icmp ult i64 %iv, 31\n  br i1 %cmp439, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "single_incoming_needs_predication",
          "test_body": "@src = external global [32 x i16], align 1\n@dst = external global [32 x i16], align 1\n\ndefine void @single_incoming_needs_predication(i64 %a, i64 %b) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.trunc = trunc i64 %iv to i16\n  %cmp.a = icmp ugt i64 %iv, %a\n  br i1 %cmp.a, label %loop.cond, label %loop.latch\n\nloop.cond:                                        ; preds = %loop.header\n  %blend = phi i16 [ %iv.trunc, %loop.header ]\n  %src.ptr = getelementptr inbounds [32 x i16], ptr @src, i16 0, i16 %blend\n  %lv = load i16, ptr %src.ptr, align 1\n  %cmp.b = icmp sgt i64 %iv, %a\n  br i1 %cmp.b, label %loop.next, label %loop.latch\n\nloop.next:                                        ; preds = %loop.cond\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %loop.next, %loop.cond, %loop.header\n  %res = phi i16 [ 0, %loop.header ], [ %lv, %loop.cond ], [ 1, %loop.next ]\n  %dst.ptr = getelementptr inbounds [32 x i16], ptr @dst, i16 0, i64 %iv\n  store i16 %res, ptr %dst.ptr, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp439 = icmp ult i64 %iv, 63\n  br i1 %cmp439, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "single_incoming_phi_with_blend_mask",
          "test_body": "@src = external global [32 x i16], align 1\n@dst = external global [32 x i16], align 1\n\ndefine void @single_incoming_phi_with_blend_mask(i64 %a, i64 %b) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.trunc = trunc i64 %iv to i16\n  %cmp.a = icmp ugt i64 %iv, %a\n  br i1 %cmp.a, label %loop.cond, label %loop.latch\n\nloop.cond:                                        ; preds = %loop.header\n  %blend = phi i16 [ %iv.trunc, %loop.header ]\n  %src.ptr = getelementptr inbounds [32 x i16], ptr @src, i16 0, i16 %blend\n  %lv = load i16, ptr %src.ptr, align 1\n  %cmp.b = icmp sgt i64 %iv, %a\n  br i1 %cmp.b, label %loop.next, label %loop.latch\n\nloop.next:                                        ; preds = %loop.cond\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %loop.next, %loop.cond, %loop.header\n  %res = phi i16 [ 0, %loop.header ], [ %lv, %loop.cond ], [ 1, %loop.next ]\n  %dst.ptr = getelementptr inbounds [32 x i16], ptr @dst, i16 0, i64 %iv\n  store i16 %res, ptr %dst.ptr, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp439 = icmp ult i64 %iv, 31\n  br i1 %cmp439, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/uniform-blend.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -S %s"
      ],
      "tests": [
        {
          "test_name": "blend_uniform_iv",
          "test_body": "@dst = external global [32 x i16], align 1\n\ndefine void @blend_uniform_iv(i1 %c) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %c, label %loop.next, label %loop.latch\n\nloop.next:                                        ; preds = %loop.header\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %loop.next, %loop.header\n  %blend = phi i64 [ undef, %loop.header ], [ %iv, %loop.next ]\n  %dst.ptr = getelementptr inbounds [32 x i16], ptr @dst, i16 0, i64 %blend\n  store i16 0, ptr %dst.ptr, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp439 = icmp ult i64 %iv, 31\n  br i1 %cmp439, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "blend_chain_iv",
          "test_body": "@dst = external global [32 x i16], align 1\n\ndefine void @blend_chain_iv(i1 %c) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %c, label %loop.next, label %loop.latch\n\nloop.next:                                        ; preds = %loop.header\n  br i1 %c, label %loop.next.2, label %loop.next.3\n\nloop.next.2:                                      ; preds = %loop.next\n  br label %loop.next.3\n\nloop.next.3:                                      ; preds = %loop.next.2, %loop.next\n  %blend.1 = phi i64 [ undef, %loop.next ], [ %iv, %loop.next.2 ]\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %loop.next.3, %loop.header\n  %blend = phi i64 [ undef, %loop.header ], [ %blend.1, %loop.next.3 ]\n  %dst.ptr = getelementptr inbounds [32 x i16], ptr @dst, i16 0, i64 %blend\n  store i16 0, ptr %dst.ptr, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp439 = icmp ult i64 %iv, 31\n  br i1 %cmp439, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "blend_uniform_iv_trunc",
          "test_body": "@dst = external global [32 x i16], align 1\n\ndefine void @blend_uniform_iv_trunc(i1 %c) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.trunc.2 = trunc i64 %iv to i16\n  br i1 %c, label %loop.next, label %loop.latch\n\nloop.next:                                        ; preds = %loop.header\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %loop.next, %loop.header\n  %blend = phi i16 [ undef, %loop.header ], [ %iv.trunc.2, %loop.next ]\n  %dst.ptr = getelementptr inbounds [32 x i16], ptr @dst, i16 0, i16 %blend\n  store i16 0, ptr %dst.ptr, align 2\n  %iv.next = add nuw nsw i64 %iv, 1\n  %cmp439 = icmp ult i64 %iv, 31\n  br i1 %cmp439, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/unused-blend-mask-for-first-operand.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S %s"
      ],
      "tests": [
        {
          "test_name": "test_not_first_lane_only_constant",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine void @test_not_first_lane_only_constant(ptr %A, ptr noalias %B) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i16 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %gep.A = getelementptr inbounds i16, ptr %A, i16 %iv\n  br i1 false, label %loop.latch, label %else.1\n\nelse.1:                                           ; preds = %loop.header\n  br i1 false, label %then.2, label %else.2\n\nthen.2:                                           ; preds = %else.1\n  br label %else.2\n\nelse.2:                                           ; preds = %then.2, %else.1\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else.2, %loop.header\n  %merge = phi ptr [ %B, %else.2 ], [ poison, %loop.header ]\n  %l = load i16, ptr %merge, align 2\n  %iv.next = add i16 %iv, 1\n  store i16 %l, ptr %gep.A, align 2\n  %c.2 = icmp eq i16 %iv.next, 1000\n  br i1 %c.2, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        },
        {
          "test_name": "test_not_first_lane_only_wide_compare",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine void @test_not_first_lane_only_wide_compare(ptr %A, ptr noalias %B, i16 %x, i16 %y) {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i16 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %gep.A = getelementptr inbounds i16, ptr %A, i16 %iv\n  %l.0 = load i16, ptr %gep.A, align 2\n  %c.0 = icmp ult i16 %l.0, %x\n  br i1 %c.0, label %loop.latch, label %else.1\n\nelse.1:                                           ; preds = %loop.header\n  %c.1 = icmp ult i16 %l.0, %y\n  br i1 %c.1, label %then.2, label %else.2\n\nthen.2:                                           ; preds = %else.1\n  br label %else.2\n\nelse.2:                                           ; preds = %then.2, %else.1\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %else.2, %loop.header\n  %merge = phi ptr [ %B, %else.2 ], [ poison, %loop.header ]\n  %l = load i16, ptr %merge, align 2\n  %iv.next = add i16 %iv, 1\n  store i16 %l, ptr %gep.A, align 2\n  %c.2 = icmp eq i16 %iv.next, 1000\n  br i1 %c.2, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/vplan-printing.ll",
      "commands": [
        "opt -passes=loop-vectorize -debug-only=loop-vectorize -force-vector-interleave=1 -force-vector-width=4 -prefer-inloop-reductions -enable-interleaved-mem-accesses=true -enable-masked-interleaved-mem-accesses -force-widen-divrem-via-safe-divisor=0 -disable-output %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "print_replicate_predicated_phi",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\ndefine void @print_replicate_predicated_phi(i64 %n, ptr %x) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.inc, %entry\n  %i = phi i64 [ 0, %entry ], [ %i.next, %for.inc ]\n  %cmp = icmp ult i64 %i, 5\n  br i1 %cmp, label %if.then, label %for.inc\n\nif.then:                                          ; preds = %for.body\n  %tmp4 = udiv i64 %n, %i\n  br label %for.inc\n\nfor.inc:                                          ; preds = %if.then, %for.body\n  %d = phi i64 [ 0, %for.body ], [ %tmp4, %if.then ]\n  %idx = getelementptr i64, ptr %x, i64 %i\n  store i64 %d, ptr %idx, align 8\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp slt i64 %i.next, %n\n  br i1 %cond, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.inc\n  ret void\n}\n\n!llvm.dbg.cu = !{!0}\n!llvm.module.flags = !{!3, !4}\n\n!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \"clang\", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, enums: !2)\n!1 = !DIFile(filename: \"/tmp/s.c\", directory: \"/tmp\")\n!2 = !{}\n!3 = !{i32 2, !\"Debug Info Version\", i32 3}\n!4 = !{i32 8, !\"PIC Level\", i32 2}\n"
        },
        {
          "test_name": "print_call_flags",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\ndefine void @print_call_flags(ptr readonly %src, ptr noalias %dest, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.loop ]\n  %ld.addr = getelementptr inbounds float, ptr %src, i64 %iv\n  %ld.value = load float, ptr %ld.addr, align 8\n  %ifcond = fcmp oeq float %ld.value, 5.000000e+00\n  br i1 %ifcond, label %if.then, label %for.loop\n\nif.then:                                          ; preds = %for.body\n  %foo.ret.1 = call nnan ninf nsz float @foo(float %ld.value) #0\n  %foo.ret.2 = call float @foo(float %ld.value) #0\n  %fadd = fadd float %foo.ret.1, %foo.ret.2\n  br label %for.loop\n\nfor.loop:                                         ; preds = %if.then, %for.body\n  %st.value = phi float [ %ld.value, %for.body ], [ %fadd, %if.then ]\n  %st.addr = getelementptr inbounds float, ptr %dest, i64 %iv\n  store float %st.value, ptr %st.addr, align 8\n  %iv.next = add nuw nsw i64 %iv, 1\n  %loopcond = icmp eq i64 %iv.next, %n\n  br i1 %loopcond, label %end, label %for.body\n\nend:                                              ; preds = %for.loop\n  ret void\n}\n\n; Function Attrs: nounwind memory(read)\ndeclare float @foo(float) #0\n\nattributes #0 = { nounwind memory(read) \"vector-function-abi-variant\"=\"_ZGV_LLVM_M2v_foo(vector_foo)\" }\n\n!llvm.dbg.cu = !{!0}\n!llvm.module.flags = !{!3, !4}\n\n!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \"clang\", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, enums: !2)\n!1 = !DIFile(filename: \"/tmp/s.c\", directory: \"/tmp\")\n!2 = !{}\n!3 = !{i32 2, !\"Debug Info Version\", i32 3}\n!4 = !{i32 8, !\"PIC Level\", i32 2}\n"
        },
        {
          "test_name": "debug_loc_vpinstruction",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\ndefine void @debug_loc_vpinstruction(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %if.end, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %if.end ]\n  %isd = getelementptr inbounds i32, ptr %asd, i64 %iv\n  %lsd = load i32, ptr %isd, align 4\n  %psd = add nuw nsw i32 %lsd, 23\n  %cmp1 = icmp slt i32 %lsd, 100\n  br i1 %cmp1, label %if.then, label %check, !dbg !7\n\ncheck:                                            ; preds = %loop\n  %cmp2 = icmp sge i32 %lsd, 200\n  br i1 %cmp2, label %if.then, label %if.end, !dbg !8\n\nif.then:                                          ; preds = %check, %loop\n  %sd1 = sdiv i32 %psd, %lsd\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %check\n  %ysd.0 = phi i32 [ %sd1, %if.then ], [ %psd, %check ]\n  store i32 %ysd.0, ptr %isd, align 4\n  %iv.next = add nuw nsw i64 %iv, 1\n  %exitcond = icmp eq i64 %iv.next, 128\n  br i1 %exitcond, label %exit, label %loop\n\nexit:                                             ; preds = %if.end\n  ret void\n}\n\n!llvm.dbg.cu = !{!0}\n!llvm.module.flags = !{!3, !4}\n\n!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \"clang\", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, enums: !2)\n!1 = !DIFile(filename: \"/tmp/s.c\", directory: \"/tmp\")\n!2 = !{}\n!3 = !{i32 2, !\"Debug Info Version\", i32 3}\n!4 = !{i32 8, !\"PIC Level\", i32 2}\n!5 = distinct !DISubprogram(name: \"f\", scope: !1, file: !1, line: 4, type: !6, scopeLine: 4, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !2)\n!6 = !DISubroutineType(types: !2)\n!7 = !DILocation(line: 5, column: 3, scope: !5)\n!8 = !DILocation(line: 5, column: 21, scope: !5)\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/vplan-sink-scalars-and-merge.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=2 -debug -disable-output %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "pred_cfg3",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\n@a = external global [2048 x i32], align 16\n@b = external global [2048 x i32], align 16\n@c = external global [2048 x i32], align 16\n\ndefine void @pred_cfg3(i32 %k, i32 %j) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %next.1, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %next.1 ]\n  %gep.b = getelementptr inbounds [2048 x i32], ptr @b, i32 0, i32 %iv\n  %mul = mul i32 %iv, 10\n  %gep.a = getelementptr inbounds [2048 x i32], ptr @a, i32 0, i32 %mul\n  %gep.c = getelementptr inbounds [2048 x i32], ptr @c, i32 0, i32 %mul\n  %c.0 = icmp ult i32 %iv, %j\n  br i1 %c.0, label %then.0, label %next.0\n\nthen.0:                                           ; preds = %loop\n  %lv.b = load i32, ptr %gep.b, align 4\n  br label %next.0\n\nnext.0:                                           ; preds = %then.0, %loop\n  %p = phi i32 [ 0, %loop ], [ %lv.b, %then.0 ]\n  br i1 %c.0, label %then.1, label %next.1\n\nthen.1:                                           ; preds = %next.0\n  store i32 0, ptr %gep.a, align 4\n  store i32 %p, ptr %gep.c, align 4\n  br label %next.1\n\nnext.1:                                           ; preds = %then.1, %next.0\n  %iv.next = add i32 %iv, 1\n  %large = icmp sge i32 %iv, 8\n  %exitcond = icmp eq i32 %iv, %k\n  %realexit = or i1 %large, %exitcond\n  br i1 %realexit, label %exit, label %loop\n\nexit:                                             ; preds = %next.1\n  ret void\n}\n"
        },
        {
          "test_name": "pred_cfg1",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\n@a = external global [2048 x i32], align 16\n@b = external global [2048 x i32], align 16\n\ndefine void @pred_cfg1(i32 %k, i32 %j) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %next.0, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %next.0 ]\n  %gep.b = getelementptr inbounds [2048 x i32], ptr @b, i32 0, i32 %iv\n  %c.1 = icmp ult i32 %iv, %j\n  %mul = mul i32 %iv, 10\n  %gep.a = getelementptr inbounds [2048 x i32], ptr @a, i32 0, i32 %mul\n  br i1 %c.1, label %then.0, label %next.0\n\nthen.0:                                           ; preds = %loop\n  %lv.b = load i32, ptr %gep.b, align 4\n  br label %next.0\n\nnext.0:                                           ; preds = %then.0, %loop\n  %p = phi i32 [ 0, %loop ], [ %lv.b, %then.0 ]\n  store i32 %p, ptr %gep.a, align 4\n  %iv.next = add i32 %iv, 1\n  %large = icmp sge i32 %iv, 8\n  %exitcond = icmp eq i32 %iv, %k\n  %realexit = or i1 %large, %exitcond\n  br i1 %realexit, label %exit, label %loop\n\nexit:                                             ; preds = %next.0\n  ret void\n}\n"
        },
        {
          "test_name": "pred_cfg2",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n\n@a = external global [2048 x i32], align 16\n@b = external global [2048 x i32], align 16\n\ndefine void @pred_cfg2(i32 %k, i32 %j) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %next.1, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %next.1 ]\n  %gep.b = getelementptr inbounds [2048 x i32], ptr @b, i32 0, i32 %iv\n  %mul = mul i32 %iv, 10\n  %gep.a = getelementptr inbounds [2048 x i32], ptr @a, i32 0, i32 %mul\n  %c.0 = icmp ult i32 %iv, %j\n  %c.1 = icmp ugt i32 %iv, %j\n  br i1 %c.0, label %then.0, label %next.0\n\nthen.0:                                           ; preds = %loop\n  %lv.b = load i32, ptr %gep.b, align 4\n  br label %next.0\n\nnext.0:                                           ; preds = %then.0, %loop\n  %p = phi i32 [ 0, %loop ], [ %lv.b, %then.0 ]\n  br i1 %c.1, label %then.1, label %next.1\n\nthen.1:                                           ; preds = %next.0\n  store i32 %p, ptr %gep.a, align 4\n  br label %next.1\n\nnext.1:                                           ; preds = %then.1, %next.0\n  %iv.next = add i32 %iv, 1\n  %large = icmp sge i32 %iv, 8\n  %exitcond = icmp eq i32 %iv, %k\n  %realexit = or i1 %large, %exitcond\n  br i1 %realexit, label %exit, label %loop\n\nexit:                                             ; preds = %next.1\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize][VPlan] Assertion \"Trying to access a single scalar per part but has multiple scalars per part.\" failed.",
    "body": "Reduced LLVM IR\r\n```llvm ir\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine i32 @main() #0 {\r\nentry:\r\n  br label %for.body.i\r\n\r\nfor.body.i:                                       ; preds = %if.end.i, %entry\r\n  %q.0139.i = phi i16 [ 0, %entry ], [ %add.i, %if.end.i ]\r\n  %idxprom.i = sext i16 0 to i64\r\n  br i1 false, label %if.end.i, label %if.then.i\r\n\r\nif.then.i:                                        ; preds = %for.body.i\r\n  br i1 false, label %cond.end41.i, label %cond.end41.i\r\n\r\ncond.end41.i:                                     ; preds = %if.then.i, %if.then.i\r\n  br label %if.end.i\r\n\r\nif.end.i:                                         ; preds = %cond.end41.i, %for.body.i\r\n  %.in.i = phi ptr [ null, %cond.end41.i ], [ poison, %for.body.i ]\r\n  %0 = load i16, ptr %.in.i, align 2\r\n  %add.i = add i16 %q.0139.i, 1\r\n  %tobool.not.i = icmp eq i16 %add.i, 0\r\n  br i1 %tobool.not.i, label %m.exit, label %for.body.i\r\n\r\nm.exit:                                           ; preds = %if.end.i\r\n  %.lcssa = phi i16 [ %0, %if.end.i ]\r\n  ret i32 0\r\n}\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\r\n```\r\n\r\nBacktrace:\r\n```\r\nopt: /scratch/tc-testing/tc-apr-2/llvm/llvm/lib/Transforms/Vectorize/VPlan.cpp:249: llvm::Value* llvm::VPTransformState::get(llvm::VPValue*, unsigned int, bool): Assertion `(VF.isScalar() || Def->isLiveIn() || (hasScalarValue(Def, VPIteration(Part, 0)) && Data.PerPartScalars[Def][Part].size() == 1)) && \"Trying to access a single scalar per part but has multiple scalars \" \"per part.\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt --passes=loop-vectorize reduced.ll\r\n #0 0x00005ed60f56eb60 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2d84b60)\r\n #1 0x00005ed60f56bf6f llvm::sys::RunSignalHandlers() (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2d81f6f)\r\n #2 0x00005ed60f56c0c5 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x00007f973de42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007f973de969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007f973de969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007f973de969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007f973de42476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007f973de287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007f973de2871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007f973de39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x00005ed60e6cbb72 llvm::VPTransformState::get(llvm::VPValue*, unsigned int, bool) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1ee1b72)\r\n#12 0x00005ed60e6fa9a6 llvm::VPInstruction::generatePerPart(llvm::VPTransformState&, unsigned int) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1f109a6)\r\n#13 0x00005ed60e6fbbdf llvm::VPInstruction::execute(llvm::VPTransformState&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1f11bdf)\r\n#14 0x00005ed60e6d74ff llvm::VPBasicBlock::execute(llvm::VPTransformState*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1eed4ff)\r\n#15 0x00005ed60e6cd9e0 llvm::VPRegionBlock::execute(llvm::VPTransformState*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1ee39e0)\r\n#16 0x00005ed60e6d90e6 llvm::VPlan::execute(llvm::VPTransformState*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1eef0e6)\r\n#17 0x00005ed60e5d76f3 llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoopVectorizer&, llvm::DominatorTree*, bool, llvm::DenseMap<llvm::SCEV const*, llvm::Value*, llvm::DenseMapInfo<llvm::SCEV const*, void>, llvm::detail::DenseMapPair<llvm::SCEV const*, llvm::Value*>> const*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1ded6f3)\r\n#18 0x00005ed60e5e9718 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1dff718)\r\n#19 0x00005ed60e5eb73e llvm::LoopVectorizePass::runImpl(llvm::Function&, llvm::ScalarEvolution&, llvm::LoopInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::BlockFrequencyInfo*, llvm::TargetLibraryInfo*, llvm::DemandedBits&, llvm::AssumptionCache&, llvm::LoopAccessInfoManager&, llvm::OptimizationRemarkEmitter&, llvm::ProfileSummaryInfo*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1e0173e)\r\n#20 0x00005ed60e5ec88d llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1e0288d)\r\n#21 0x00005ed60d4f3276 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0xd09276)\r\n#22 0x00005ed60f395141 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2bab141)\r\n#23 0x00005ed60d4eabd6 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0xd00bd6)\r\n#24 0x00005ed60f393e3b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2ba9e3b)\r\n#25 0x00005ed60d4f2dc6 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0xd08dc6)\r\n#26 0x00005ed60f391cb1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2ba7cb1)\r\n#27 0x00005ed60cd6cce5 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x582ce5)\r\n#28 0x00005ed60cd5f316 optMain (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x575316)\r\n#29 0x00007f973de29d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#30 0x00007f973de29e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#31 0x00007f973de29e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#32 0x00005ed60cd54f95 _start (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x56af95)\r\nzsh: IOT instruction (core dumped)  /scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt\r\n```\r\nGodbolt: https://godbolt.org/z/jYWea8z4q\r\n\r\nFound via fuzzer.",
    "author": "patrick-rivos",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  }
}