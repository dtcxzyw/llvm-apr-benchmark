{
  "bug_id": "155110",
  "issue_url": "https://github.com/llvm/llvm-project/issues/155110",
  "bug_type": "crash",
  "base_commit": "20dd053160f7d933037aacb69067ef4d77996ba1",
  "knowledge_cutoff": "2025-08-23T16:41:15Z",
  "lit_test_dir": [
    "llvm/test/Transforms/VectorCombine"
  ],
  "hints": {
    "fix_commit": "db6a8f10096762d292f135a7b16ac23b39553380",
    "components": [
      "VectorCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VectorCombine.cpp": [
        [
          99,
          104
        ],
        [
          173,
          181
        ],
        [
          4519,
          4531
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VectorCombine.cpp": [
        "VectorCombine::run",
        "eraseInstruction"
      ]
    }
  },
  "patch": "commit db6a8f10096762d292f135a7b16ac23b39553380\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Tue Aug 26 00:22:53 2025 +0800\n\n    [VectorCombine] Avoid crash when the next node is deleted. (#155115)\n    \n    `RecursivelyDeleteTriviallyDeadInstructions` is introduced by\n    https://github.com/llvm/llvm-project/pull/149047 to immediately drop\n    dead instructions. However, it may invalidate the next iterator in\n    `make_early_inc_range` in some edge cases, which leads to a crash. This\n    patch manually maintains the next iterator and updates it when the next\n    instruction is about to be deleted.\n    \n    Closes https://github.com/llvm/llvm-project/issues/155110.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\nindex 092a3a87954f..56a08b843871 100644\n--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n@@ -99,6 +99,10 @@ private:\n \n   InstructionWorklist Worklist;\n \n+  /// Next instruction to iterate. It will be updated when it is erased by\n+  /// RecursivelyDeleteTriviallyDeadInstructions.\n+  Instruction *NextInst;\n+\n   // TODO: Direct calls from the top-level \"run\" loop use a plain \"Instruction\"\n   //       parameter. That should be updated to specific sub-classes because the\n   //       run loop was changed to dispatch on opcode.\n@@ -173,9 +177,11 @@ private:\n         if (auto *OpI = dyn_cast<Instruction>(Op)) {\n           if (RecursivelyDeleteTriviallyDeadInstructions(\n                   OpI, nullptr, nullptr, [this](Value *V) {\n-                    if (auto I = dyn_cast<Instruction>(V)) {\n+                    if (auto *I = dyn_cast<Instruction>(V)) {\n                       LLVM_DEBUG(dbgs() << \"VC: Erased: \" << *I << '\\n');\n                       Worklist.remove(I);\n+                      if (I == NextInst)\n+                        NextInst = NextInst->getNextNode();\n                     }\n                   }))\n             continue;\n@@ -4519,13 +4525,21 @@ bool VectorCombine::run() {\n     if (!DT.isReachableFromEntry(&BB))\n       continue;\n     // Use early increment range so that we can erase instructions in loop.\n-    for (Instruction &I : make_early_inc_range(BB)) {\n-      if (I.isDebugOrPseudoInst())\n-        continue;\n-      MadeChange |= FoldInst(I);\n+    // make_early_inc_range is not applicable here, as the next iterator may\n+    // be invalidated by RecursivelyDeleteTriviallyDeadInstructions.\n+    // We manually maintain the next instruction and update it when it is about\n+    // to be deleted.\n+    Instruction *I = &BB.front();\n+    while (I) {\n+      NextInst = I->getNextNode();\n+      if (!I->isDebugOrPseudoInst())\n+        MadeChange |= FoldInst(*I);\n+      I = NextInst;\n     }\n   }\n \n+  NextInst = nullptr;\n+\n   while (!Worklist.isEmpty()) {\n     Instruction *I = Worklist.removeOne();\n     if (!I)\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/VectorCombine/X86/insert-binop-inseltpoison.ll",
      "commands": [
        "opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2",
        "opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=AVX2"
      ],
      "tests": [
        {
          "test_name": "pr155110",
          "test_body": "define i32 @pr155110(i32 %x) {\nentry:\n  br label %vector.ph\n\nvector.ph:                                        ; preds = %vector.ph, %entry\n  %phi = phi i32 [ 0, %entry ], [ %reduce, %vector.ph ]\n  %inselt = insertelement <4 x i32> poison, i32 %phi, i64 0\n  %and = and <4 x i32> %inselt, zeroinitializer\n  %reduce = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> zeroinitializer)\n  br label %vector.ph\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.vector.reduce.and.v4i32(<4 x i32>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "ins3_ins3_fdiv",
          "test_body": "declare void @usef(<4 x float>)\n\ndefine <4 x float> @ins3_ins3_fdiv(float %x, float %y) {\n  %i0 = insertelement <4 x float> poison, float %x, i32 3\n  call void @usef(<4 x float> %i0)\n  %i1 = insertelement <4 x float> poison, float %y, i32 3\n  call void @usef(<4 x float> %i1)\n  %r = fdiv <4 x float> %i0, %i1\n  ret <4 x float> %r\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[VectorCombine] SIGSEGV at -Os",
    "body": "Crash reproducer: https://godbolt.org/z/nbdfPzcqK\n```\n; bin/opt -passes=vector-combine reduced.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i32 @main() {\nentry:\n  br label %vector.ph\n\nvector.ph:                                        ; preds = %vector.ph, %entry\n  %and48698.lcssa704705.i.i.i = phi i32 [ 0, %entry ], [ %2, %vector.ph ]\n  %0 = insertelement <4 x i32> zeroinitializer, i32 %and48698.lcssa704705.i.i.i, i64 0\n  %1 = and <4 x i32> %0, zeroinitializer\n  %2 = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> zeroinitializer)\n  br label %vector.ph\n}\n```\n```\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-trunk/bin/opt -o /app/output.s -S -passes=vector-combine <source>\n1.\tRunning pass \"function(vector-combine)\" on module \"<source>\"\n2.\tRunning pass \"vector-combine\" on function \"main\"\n #0 0x00000000052bda88 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-trunk/bin/opt+0x52bda88)\n #1 0x00000000052bac54 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x0000766a19042520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x00000000033c6e33 llvm::VectorCombinePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-trunk/bin/opt+0x33c6e33)\n #4 0x0000000002bfe56e llvm::detail::PassModel<llvm::Function, llvm::VectorCombinePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-trunk/bin/opt+0x2bfe56e)\n #5 0x00000000050aacd7 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-trunk/bin/opt+0x50aacd7)\n #6 0x0000000000e5e00e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-trunk/bin/opt+0xe5e00e)\n #7 0x00000000050ab838 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-trunk/bin/opt+0x50ab838)\n #8 0x0000000000980cee llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-trunk/bin/opt+0x980cee)\n #9 0x00000000050ae0c7 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-trunk/bin/opt+0x50ae0c7)\n#10 0x000000000098a83a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-trunk/bin/opt+0x98a83a)\n#11 0x000000000097eef3 optMain (/opt/compiler-explorer/clang-trunk/bin/opt+0x97eef3)\n#12 0x0000766a19029d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#13 0x0000766a19029e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#14 0x0000000000976f05 _start (/opt/compiler-explorer/clang-trunk/bin/opt+0x976f05)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\n",
    "author": "dtcxzyw",
    "labels": [
      "crash-on-valid",
      "generated by fuzzer",
      "llvm::vectorcombine"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true,
  "bisect": "790bee99ded0a7142f435028d8a3bf2b098a8553"
}