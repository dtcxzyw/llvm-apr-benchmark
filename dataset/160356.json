{
  "bug_id": "160356",
  "issue_url": "https://github.com/llvm/llvm-project/issues/160356",
  "bug_type": "crash",
  "base_commit": "fc3a27ff4752bfb8e664e578f686f6030df0147a",
  "knowledge_cutoff": "2025-09-23T18:25:53Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "88aab08ae5682a21edef71b814e5ebc05e7a9450",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          2907,
          2921
        ],
        [
          6908,
          6913
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::getDivRemSpeculationCost",
        "planContainsAdditionalSimplifications"
      ]
    }
  },
  "patch": "commit 88aab08ae5682a21edef71b814e5ebc05e7a9450\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Tue Sep 23 21:54:02 2025 +0100\n\n    [LV] Check for hoisted safe-div selects in planContainsAdditionalSimp.\n    \n    In some cases, safe-divisor selects can be hoisted out of the vector\n    loop. Catching all cases in the legacy cost model isn't possible, in\n    particular checking if all conditions guarding a division are loop\n    invariant.\n    \n    Instead, check in planContainsAdditionalSimplifications if there are any\n    hoisted safe-divisor selects. If so, don't compare to the more\n    inaccurate legacy cost model.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/160354.\n    Fixes https://github.com/llvm/llvm-project/issues/160356.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex ca092dcfcb49..30fcc9b7680e 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -2907,15 +2907,12 @@ LoopVectorizationCostModel::getDivRemSpeculationCost(Instruction *I,\n \n   InstructionCost SafeDivisorCost = 0;\n   auto *VecTy = toVectorTy(I->getType(), VF);\n-  auto *DivisorI = dyn_cast<Instruction>(I->getOperand(1));\n-  if (DivisorI && !Legal->isInvariant(DivisorI)) {\n-    // The cost of the select guard to ensure all lanes are well defined\n-    // after we speculate above any internal control flow.\n-    SafeDivisorCost +=\n-        TTI.getCmpSelInstrCost(Instruction::Select, VecTy,\n-                               toVectorTy(Type::getInt1Ty(I->getContext()), VF),\n-                               CmpInst::BAD_ICMP_PREDICATE, CostKind);\n-  }\n+  // The cost of the select guard to ensure all lanes are well defined\n+  // after we speculate above any internal control flow.\n+  SafeDivisorCost +=\n+      TTI.getCmpSelInstrCost(Instruction::Select, VecTy,\n+                             toVectorTy(Type::getInt1Ty(I->getContext()), VF),\n+                             CmpInst::BAD_ICMP_PREDICATE, CostKind);\n \n   SmallVector<const Value *, 4> Operands(I->operand_values());\n   SafeDivisorCost += TTI.getArithmeticInstrCost(\n@@ -6908,6 +6905,28 @@ static bool planContainsAdditionalSimplifications(VPlan &Plan,\n     return nullptr;\n   };\n \n+  // Check if a select for a safe divisor was hoisted to the pre-header. If so,\n+  // the select doesn't need to be considered for the vector loop cost; go with\n+  // the more accurate VPlan-based cost model.\n+  for (VPRecipeBase &R : *Plan.getVectorPreheader()) {\n+    auto *VPI = dyn_cast<VPInstruction>(&R);\n+    if (!VPI || VPI->getOpcode() != Instruction::Select ||\n+        VPI->getNumUsers() != 1)\n+      continue;\n+\n+    if (auto *WR = dyn_cast<VPWidenRecipe>(*VPI->user_begin())) {\n+      switch (WR->getOpcode()) {\n+      case Instruction::UDiv:\n+      case Instruction::SDiv:\n+      case Instruction::URem:\n+      case Instruction::SRem:\n+        return true;\n+      default:\n+        break;\n+      }\n+    }\n+  }\n+\n   DenseSet<Instruction *> SeenInstrs;\n   auto Iter = vp_depth_first_deep(Plan.getVectorLoopRegion()->getEntry());\n   for (VPBasicBlock *VPBB : VPBlockUtils::blocksOnly<VPBasicBlock>(Iter)) {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/AArch64/predicated-costs.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "srem_sdiv_with_tail_folding",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64-unknown-linux\"\n\ndefine void @srem_sdiv_with_tail_folding(i32 %d.0, i32 %d.1, ptr %dst, i32 %end) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.sub = add nsw i32 %iv, -1\n  %rem = srem i32 %iv.sub, %d.0\n  %rem.1 = add nsw i32 %rem, 1\n  %c = icmp eq i32 %rem.1, %d.0\n  br i1 %c, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  %div = sdiv i32 %iv.sub, %d.1\n  %add.1 = add i32 %div, 1\n  %add.1.ext = sext i32 %add.1 to i64\n  %gep.dst = getelementptr i32, ptr %dst, i64 %add.1.ext\n  store i32 %iv, ptr %gep.dst, align 4\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %iv.next = add nuw nsw i32 %iv, 1\n  %ec = icmp ne i32 %iv.next, %end\n  br i1 %ec, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"neoverse-v1\" }\n"
        },
        {
          "test_name": "srem_sdiv_without_tail_folding",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64-unknown-linux\"\n\ndefine void @srem_sdiv_without_tail_folding(i32 %d.0, i32 %d.1, ptr %dst, i32 %end) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.sub = add nsw i32 %iv, -1\n  %rem = srem i32 %iv.sub, %d.0\n  %rem.1 = add nsw i32 %rem, 1\n  %c = icmp eq i32 %rem.1, %d.0\n  br i1 %c, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  %div = sdiv i32 %iv.sub, %d.1\n  %add.1 = add i32 %div, 1\n  %add.1.ext = sext i32 %add.1 to i64\n  %gep.dst = getelementptr i32, ptr %dst, i64 %add.1.ext\n  store i32 %iv, ptr %gep.dst, align 4\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %iv.next = add nuw nsw i32 %iv, 1\n  %ec = icmp ne i32 %iv.next, %end\n  br i1 %ec, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"neoverse-v2\" }\n"
        },
        {
          "test_name": "test_predicated_load_cast_hint",
          "test_body": "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32\"\ntarget triple = \"aarch64-unknown-linux\"\n\ndefine void @test_predicated_load_cast_hint(ptr %dst.1, ptr %dst.2, ptr %src, i8 %n, i64 %off) #0 {\nentry:\n  %n.ext = sext i8 %n to i32\n  %n.sub = add i32 %n.ext, -15\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i8 [ 0, %entry ], [ %iv.next, %loop ]\n  %l = load i8, ptr %src, align 1\n  %l.ext = zext i8 %l to i64\n  %add = or i64 %l.ext, 1\n  %iv.ext = zext i8 %iv to i64\n  %gep.dst.1 = getelementptr [16 x i64], ptr %dst.1, i64 %iv.ext, i64 %off\n  store i64 %add, ptr %gep.dst.1, align 8\n  store i8 0, ptr %dst.2, align 1\n  %iv.next = add i8 %iv, 4\n  %iv.next.ext = zext i8 %iv.next to i32\n  %cmp = icmp sgt i32 %n.sub, %iv.next.ext\n  br i1 %cmp, label %loop, label %exit, !llvm.loop !0\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"neoverse-v1\" }\n\n!0 = distinct !{!0, !1, !2, !3}\n!1 = !{!\"llvm.loop.mustprogress\"}\n!2 = !{!\"llvm.loop.vectorize.predicate.enable\", i1 true}\n!3 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LV] \" VPlan cost model and legacy cost model disagreed\" regression on Neoverse-V2",
    "body": "Similar to #160345, which was for Neoverse-V1...\n\nWe're seeing a good number of downstream ICEs from a change around 2025-09-22. Here is one reduced issue from Neoverse-V2:\n\n```\nscrubbed:$ cat test.ll\ntarget triple = \"aarch64-unknown-linux-gnu\"\n\ndefine void @foo(ptr %0) local_unnamed_addr #0 {\n  br i1 poison, label %.lr.ph, label %._crit_edge\n\n.lr.ph:                                           ; preds = %1\n  br label %2\n\n2:                                                ; preds = %11, %.lr.ph\n  %3 = phi i64 [ poison, %.lr.ph ], [ %13, %11 ]\n  %4 = phi i32 [ poison, %.lr.ph ], [ %12, %11 ]\n  %5 = srem i32 %4, poison\n  %6 = icmp eq i32 %5, 0\n  br i1 %6, label %7, label %11\n\n7:                                                ; preds = %2\n  %8 = sdiv i32 %4, poison\n  %9 = sext i32 %8 to i64\n  %10 = getelementptr i32, ptr %0, i64 %9\n  store i32 1, ptr %10, align 4\n  br label %11\n\n11:                                               ; preds = %7, %2\n  %12 = add nsw i32 %4, 1\n  %13 = add nsw i64 %3, -1\n  %14 = icmp sgt i64 %3, 1\n  br i1 %14, label %2, label %._crit_edge\n\n._crit_edge:                                      ; preds = %11, %1\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"neoverse-v2\" }\nscrubbed:$ opt --passes=loop-vectorize -S test.ll \nopt: scrubbed/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7090: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || BestPlan.hasEarlyExit() || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop, BestFactor.Width) || planContainsAdditionalSimplifications( getPlanFor(LegacyVF.Width), CostCtx, OrigLoop, LegacyVF.Width)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: opt --passes=loop-vectorize -S test.ll\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"test.ll\"\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"foo\"\n #0 0x0000000001bf3e10 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (scrubbed/llvm-3986/bin/opt+0x1bf3e10)\n #1 0x0000000001bf0f38 llvm::sys::RunSignalHandlers() (scrubbed/llvm-3986/bin/opt+0x1bf0f38)\n #2 0x0000000001bf10bc SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00004003685c08dc (linux-vdso.so.1+0x8dc)\n #4 0x000040036887f200 __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\n #5 0x000040036883a67c gsignal ./signal/../sysdeps/posix/raise.c:27:6\n #6 0x0000400368827130 abort ./stdlib/abort.c:81:7\n #7 0x0000400368833fd0 __assert_fail_base ./assert/assert.c:89:7\n #8 0x0000400368834040 __assert_perror_fail ./assert/assert-perr.c:31:1\n #9 0x0000000003990f98 llvm::LoopVectorizationPlanner::computeBestVF() (scrubbed/llvm-3986/bin/opt+0x3990f98)\n#10 0x000000000399c054 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (scrubbed/llvm-3986/bin/opt+0x399c054)\n#11 0x000000000399e448 llvm::LoopVectorizePass::runImpl(llvm::Function&) (scrubbed/llvm-3986/bin/opt+0x399e448)\n#12 0x000000000399ea08 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (scrubbed/llvm-3986/bin/opt+0x399ea08)\n#13 0x00000000034b2db0 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) PassBuilder.cpp:0:0\n#14 0x0000000001e9e8e4 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (scrubbed/llvm-3986/bin/opt+0x1e9e8e4)\n#15 0x0000000002dd74e0 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) NVPTXTargetMachine.cpp:0:0\n#16 0x0000000001e9d0d0 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (scrubbed/llvm-3986/bin/opt+0x1e9d0d0)\n#17 0x0000000002dd7490 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) NVPTXTargetMachine.cpp:0:0\n#18 0x0000000001e9cb3c llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (scrubbed/llvm-3986/bin/opt+0x1e9cb3c)\n#19 0x00000000033602a0 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (scrubbed/llvm-3986/bin/opt+0x33602a0)\n#20 0x0000000001bd66f4 optMain (scrubbed/llvm-3986/bin/opt+0x1bd66f4)\n#21 0x00004003688273fc __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#22 0x00004003688274cc call_init ./csu/../csu/libc-start.c:128:20\n#23 0x00004003688274cc __libc_start_main ./csu/../csu/libc-start.c:379:5\n#24 0x0000000001bcb38c _start (scrubbed/llvm-3986/bin/opt+0x1bcb38c)\nAborted\n``` ",
    "author": "mcinally",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "mcinally",
        "body": "@fhahn for visibility."
      }
    ]
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  },
  "verified": true
}