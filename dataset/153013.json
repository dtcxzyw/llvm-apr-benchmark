{
  "bug_id": "153013",
  "issue_url": "https://github.com/llvm/llvm-project/issues/153013",
  "bug_type": "crash",
  "base_commit": "52f7cfb5ef0a21173f0c7ae2305c76e1662831c5",
  "knowledge_cutoff": "2025-08-11T14:30:18Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SCCP"
  ],
  "hints": {
    "fix_commit": "ab323eb0c6b2ed8814c4516d4bce179d55372a5a",
    "components": [
      "PredicateInfo"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/PredicateInfo.cpp": [
        [
          291,
          296
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/PredicateInfo.cpp": [
        "PredicateInfoBuilder::convertUsesToDFSOrdered"
      ]
    }
  },
  "patch": "commit ab323eb0c6b2ed8814c4516d4bce179d55372a5a\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Tue Aug 12 12:53:39 2025 +0200\n\n    [SCCP][PredicateInfo] Do not predicate argument of lifetime intrinsic\n    \n    Replacing the argument with a no-op bitcast violates a verifier\n    constraint, even if only temporarily. Any replacement based on it\n    would result in a violation even after the copy has been removed.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/153013.\n\ndiff --git a/llvm/lib/Transforms/Utils/PredicateInfo.cpp b/llvm/lib/Transforms/Utils/PredicateInfo.cpp\nindex 38a312a3715c..13c7ad2927d1 100644\n--- a/llvm/lib/Transforms/Utils/PredicateInfo.cpp\n+++ b/llvm/lib/Transforms/Utils/PredicateInfo.cpp\n@@ -291,6 +291,11 @@ void PredicateInfoBuilder::convertUsesToDFSOrdered(\n     Value *Op, SmallVectorImpl<ValueDFS> &DFSOrderedSet) {\n   for (auto &U : Op->uses()) {\n     if (auto *I = dyn_cast<Instruction>(U.getUser())) {\n+      // Lifetime intrinsics must work directly on alloca, do not replace them\n+      // with a predicated copy.\n+      if (I->isLifetimeStartOrEnd())\n+        continue;\n+\n       ValueDFS VD;\n       // Put the phi node uses in the incoming block.\n       BasicBlock *IBlock;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SCCP/lifetime.ll",
      "commands": [
        "opt -S -passes=ipsccp < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine void @test() {\n;\n  %a = alloca [4 x i16]\n  %cmp = icmp eq ptr %a, inttoptr (i64 -1 to ptr)\n  br i1 %cmp, label %if, label %exit\n\nif:\n  call void @llvm.lifetime.start.p0(ptr %a)\n  br label %exit\n\nexit:\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "ipsccp -> llvm.lifetime.start/end can only be used on alloca or poison",
    "body": "Running ipsccp pass on IR like this\n```\ndefine void @foo() {\n  %g = alloca [4 x i16], align 1\n  %.not1 = icmp eq ptr %g, inttoptr (i16 -1 to ptr)\n  br i1 %.not1, label %for.end35.us.lr.ph, label %for.cond5\n\nfor.end35.us.lr.ph:                               ; preds = %entry\n  br label %for.end35.us\n\nfor.end35.us:                                     ; preds = %for.end35.us, %for.end35.us.lr.ph\n  call void @llvm.lifetime.start.p0(ptr %g)\n  br label %for.end35.us\n\nfor.cond5:                                        ; preds = %entry\n  ret void\n}\n```\nresults in\n```\nlvm.lifetime.start/end can only be used on alloca or poison\n  call void @llvm.lifetime.start.p0(ptr inttoptr (i16 -1 to ptr))\nLLVM ERROR: Broken module found, compilation aborted!\n```\nSee https://godbolt.org/z/jo9zqrP1x",
    "author": "bjope",
    "labels": [
      "crash-on-valid",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "XChy",
        "body": "Maybe we should prevent replacing alloca with constant at `SCCPSolver::tryToReplaceWithConstant`?"
      },
      {
        "author": "bjope",
        "body": "> Maybe we should prevent replacing alloca with constant at `SCCPSolver::tryToReplaceWithConstant`?\n\nIn this case I think problem happens earlier, already when introducing an ssa.copy."
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "N/A"
}