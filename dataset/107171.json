{
  "bug_id": "107171",
  "issue_url": "https://github.com/llvm/llvm-project/issues/107171",
  "bug_type": "crash",
  "base_commit": "34f2c9a9ce73a61b27d75dab7e1eed256491afcc",
  "knowledge_cutoff": "2024-09-04T00:23:05Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "3fe6a064f15cd854fd497594cc20e8b680cd2133",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          6606,
          6614
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::getInstructionCost"
      ]
    }
  },
  "patch": "commit 3fe6a064f15cd854fd497594cc20e8b680cd2133\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Wed Sep 4 20:50:05 2024 +0100\n\n    [LV] Check if compare is truncated directly in getInstructionCost.\n    \n    The current check for truncated compares in getInstructionCost misses\n    cases where either the first or both operands are constants.\n    Check directly if the compare is marked for truncation. In that case,\n    the minimum bitwidth is that of the operands.\n    \n    The patch also adds asserts to ensure that.\n    \n    This fixes a divergence between legacy and VPlan-based cost model, where\n    the legacy cost model incorrectly estimated the cost of compares with\n    truncated operands.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/107171.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 0200525a718d..0ccf442dac99 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -6606,9 +6606,20 @@ LoopVectorizationCostModel::getInstructionCost(Instruction *I,\n   case Instruction::ICmp:\n   case Instruction::FCmp: {\n     Type *ValTy = I->getOperand(0)->getType();\n+\n     Instruction *Op0AsInstruction = dyn_cast<Instruction>(I->getOperand(0));\n-    if (canTruncateToMinimalBitwidth(Op0AsInstruction, VF))\n-      ValTy = IntegerType::get(ValTy->getContext(), MinBWs[Op0AsInstruction]);\n+    (void)Op0AsInstruction;\n+    assert((!canTruncateToMinimalBitwidth(Op0AsInstruction, VF) ||\n+            canTruncateToMinimalBitwidth(I, VF)) &&\n+           \"truncating Op0 must imply truncating the compare\");\n+    if (canTruncateToMinimalBitwidth(I, VF)) {\n+      assert(!canTruncateToMinimalBitwidth(Op0AsInstruction, VF) ||\n+             MinBWs[I] == MinBWs[Op0AsInstruction] &&\n+                 \"if both the operand and the compare are marked for \"\n+                 \"truncation, they must have the same bitwidth\");\n+      ValTy = IntegerType::get(ValTy->getContext(), MinBWs[I]);\n+    }\n+\n     VectorTy = ToVectorTy(ValTy, VF);\n     return TTI.getCmpSelInstrCost(I->getOpcode(), VectorTy, nullptr,\n                                   cast<CmpInst>(I)->getPredicate(), CostKind,\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/truncate-to-minimal-bitwidth-cost.ll",
      "commands": [
        "opt -p loop-vectorize -mattr=+v -S %s"
      ],
      "tests": [
        {
          "test_name": "test_pr98413_zext_removed",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @test_pr98413_zext_removed(ptr %src, ptr noalias %dst, i64 %x) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.src = getelementptr inbounds i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep.src, align 8\n  %ext.l = zext i16 %l to i64\n  %and = and i64 %x, %ext.l\n  %trunc.and = trunc i64 %and to i8\n  %gep.dst = getelementptr inbounds i8, ptr %dst, i64 %iv\n  store i8 %trunc.and, ptr %gep.dst, align 1\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv, 96\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "truncate_to_i1_used_by_branch",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @truncate_to_i1_used_by_branch(i8 %x, ptr %dst) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %f.039 = phi i8 [ 0, %entry ], [ %add, %loop.latch ]\n  %0 = or i8 23, %x\n  %extract.t = trunc i8 %0 to i1\n  br i1 %extract.t, label %then, label %loop.latch\n\nthen:                                             ; preds = %loop.header\n  store i8 0, ptr %dst, align 1\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %add = add i8 %f.039, 1\n  %conv = sext i8 %f.039 to i32\n  %cmp = icmp slt i32 %conv, 1\n  br i1 %cmp, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v,+zvl256b\" }\n"
        },
        {
          "test_name": "icmp_ops_narrowed_to_i1",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine i8 @icmp_ops_narrowed_to_i1() #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i16 [ 0, %entry ], [ %iv.next, %loop ]\n  %c = icmp eq i8 0, 0\n  %ext = zext i1 %c to i64\n  %shr = lshr i64 %ext, 1\n  %trunc = trunc i64 %shr to i8\n  %iv.next = add i16 %iv, 1\n  %ec = icmp eq i16 %iv.next, 100\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i8 %trunc\n}\n\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\n"
        },
        {
          "test_name": "test_pr98413_sext_removed",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine void @test_pr98413_sext_removed(ptr %src, ptr noalias %dst, i64 %x) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.src = getelementptr inbounds i16, ptr %src, i64 %iv\n  %l = load i16, ptr %gep.src, align 8\n  %ext.l = sext i16 %l to i64\n  %and = and i64 %x, %ext.l\n  %trunc.and = trunc i64 %and to i8\n  %gep.dst = getelementptr inbounds i8, ptr %dst, i64 %iv\n  store i8 %trunc.and, ptr %gep.dst, align 1\n  %iv.next = add i64 %iv, 1\n  %exitcond.not = icmp eq i64 %iv, 96\n  br i1 %exitcond.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[VPlan] Assertion \" VPlan cost model and legacy cost model disagreed\"' failed.",
    "body": "Testing using 3bd161e98d89d31696002994771b7761f1c74859\r\n\r\nC testcase:\r\n```c\r\nchar a;\r\nunsigned b = 221;\r\nshort c = 35;\r\nchar d[6];\r\nint main() {\r\n  d[0] = 4079751220931503459;\r\n  for (short e = 3; e; e += 3)\r\n    for (short f = 0; f < 1; f += -1832)\r\n      for (long g = ({\r\n             __typeof__(0) h = !d[f * 1];\r\n             h;\r\n           });\r\n           g < c - 3; g += b - 219)\r\n        a -= 8;\r\n}\r\n```\r\n`/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/clang -I/scratch/tc-testing/compiler-fuzz-ci/csmith-build/include -fsigned-char -fno-strict-aliasing -fwrapv -march=rv64gcv -flto -O3 -fuse-ld=lld red.c -o rv64gcv.out -w`\r\n\r\nLLVM IR:\r\n```llvm ir\r\n; ModuleID = 'reduced.bc'\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine i32 @main() #0 {\r\nentry:\r\n  br label %for.body14.preheader48\r\n\r\nfor.cond.cleanup:                                 ; preds = %for.body14.preheader48\r\n  store i8 %1, ptr null, align 1\r\n  ret i32 0\r\n\r\nfor.body14.preheader48:                           ; preds = %for.body14.preheader48, %entry\r\n  %e.047 = phi i16 [ 0, %entry ], [ %add27, %for.body14.preheader48 ]\r\n  %tobool6.not = icmp eq i8 0, 0\r\n  %conv7 = zext i1 %tobool6.not to i64\r\n  %0 = lshr i64 %conv7, 1\r\n  %1 = trunc i64 %0 to i8\r\n  %add27 = add i16 %e.047, 1\r\n  %tobool.not = icmp eq i16 %add27, 0\r\n  br i1 %tobool.not, label %for.cond.cleanup, label %for.body14.preheader48\r\n}\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+a,+c,+d,+f,+m,+relax,+v,+zicsr,+zifencei,+zmmul,+zve32f,+zve32x,+zve64d,+zve64f,+zve64x,+zvl128b,+zvl32b,+zvl64b,-b,-e,-experimental-smctr,-experimental-smmpm,-experimental-smnpm,-experimental-ssctr,-experimental-ssnpm,-experimental-sspm,-experimental-supm,-experimental-zacas,-experimental-zalasr,-experimental-zicfilp,-experimental-zicfiss,-experimental-zvbc32e,-experimental-zvkgs,-h,-shcounterenw,-shgatpa,-shtvala,-shvsatpa,-shvstvala,-shvstvecd,-smaia,-smcdeleg,-smcsrind,-smepmp,-smstateen,-ssaia,-ssccfg,-ssccptr,-sscofpmf,-sscounterenw,-sscsrind,-ssqosid,-ssstateen,-ssstrict,-sstc,-sstvala,-sstvecd,-ssu64xl,-svade,-svadu,-svbare,-svinval,-svnapot,-svpbmt,-xcvalu,-xcvbi,-xcvbitmanip,-xcvelw,-xcvmac,-xcvmem,-xcvsimd,-xsfcease,-xsfvcp,-xsfvfnrclipxfqf,-xsfvfwmaccqqq,-xsfvqmaccdod,-xsfvqmaccqoq,-xsifivecdiscarddlone,-xsifivecflushdlone,-xtheadba,-xtheadbb,-xtheadbs,-xtheadcmo,-xtheadcondmov,-xtheadfmemidx,-xtheadmac,-xtheadmemidx,-xtheadmempair,-xtheadsync,-xtheadvdot,-xventanacondops,-xwchc,-za128rs,-za64rs,-zaamo,-zabha,-zalrsc,-zama16b,-zawrs,-zba,-zbb,-zbc,-zbkb,-zbkc,-zbkx,-zbs,-zca,-zcb,-zcd,-zce,-zcf,-zcmop,-zcmp,-zcmt,-zdinx,-zfa,-zfbfmin,-zfh,-zfhmin,-zfinx,-zhinx,-zhinxmin,-zic64b,-zicbom,-zicbop,-zicboz,-ziccamoa,-ziccif,-zicclsm,-ziccrse,-zicntr,-zicond,-zihintntl,-zihintpause,-zihpm,-zimop,-zk,-zkn,-zknd,-zkne,-zknh,-zkr,-zks,-zksed,-zksh,-zkt,-ztso,-zvbb,-zvbc,-zvfbfmin,-zvfbfwma,-zvfh,-zvfhmin,-zvkb,-zvkg,-zvkn,-zvknc,-zvkned,-zvkng,-zvknha,-zvknhb,-zvks,-zvksc,-zvksed,-zvksg,-zvksh,-zvkt,-zvl1024b,-zvl16384b,-zvl2048b,-zvl256b,-zvl32768b,-zvl4096b,-zvl512b,-zvl65536b,-zvl8192b\" }\r\n```\r\n\r\nCommand/backtrace:\r\n```\r\n /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes=loop-vectorize reduced.ll -S\r\nopt: /scratch/tc-testing/tc-compiler-fuzz-trunk/llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7389: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes=loop-vectorize reduced.ll -S\r\n1.      Running pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"reduced.ll\"\r\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"main\"\r\n #0 0x000061eac73d9f50 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x3010f50)\r\n #1 0x000061eac73d735f llvm::sys::RunSignalHandlers() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x300e35f)\r\n #2 0x000061eac73d74b5 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x00007496e1242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007496e12969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007496e12969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007496e12969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007496e1242476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007496e12287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007496e122871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007496e1239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x000061eac63ad810 llvm::LoopVectorizationPlanner::computeBestVF() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1fe4810)\r\n#12 0x000061eac63c45bb llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1ffb5bb)\r\n#13 0x000061eac63c75d1 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1ffe5d1)\r\n#14 0x000061eac63c7c47 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1ffec47)\r\n#15 0x000061eac5222626 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe59626)\r\n#16 0x000061eac71e5cef llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e1ccef)\r\n#17 0x000061eac52257b6 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe5c7b6)\r\n#18 0x000061eac71e4a6b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e1ba6b)\r\n#19 0x000061eac5221a56 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xe58a56)\r\n#20 0x000061eac71e2aad llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2e19aad)\r\n#21 0x000061eac4a4fde6 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x686de6)\r\n#22 0x000061eac4a41b71 optMain (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x678b71)\r\n#23 0x00007496e1229d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#24 0x00007496e1229e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#25 0x00007496e1229e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#26 0x000061eac4a37f25 _start (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x66ef25)\r\nzsh: IOT instruction (core dumped)  /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt\r\n```\r\nhttps://godbolt.org/z/x316voG8q\r\n\r\nFound via fuzzer\r\n\r\nRelated/prior issue: https://github.com/llvm/llvm-project/issues/106780\r\n\r\ncc @fhahn",
    "author": "patrick-rivos",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  },
  "verified": true
}