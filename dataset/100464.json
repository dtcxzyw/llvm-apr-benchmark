{
  "bug_id": "100464",
  "issue_url": "https://github.com/llvm/llvm-project/issues/100464",
  "bug_type": "crash",
  "base_commit": "ba461f8c6278a7b2fd7695454c1f184c38897ecd",
  "knowledge_cutoff": "2024-07-24T20:37:49Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "b72689a5cbd8645c183476cd87e32948308c5b64",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          6678,
          6683
        ],
        [
          6693,
          6700
        ],
        [
          6727,
          6742
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::collectValuesToIgnore"
      ]
    }
  },
  "patch": "commit b72689a5cbd8645c183476cd87e32948308c5b64\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Thu Jul 25 11:16:09 2024 +0100\n\n    [LV] Ignore live-out users in cost model if scalar epilogue is required.\n    \n    Follow-up to ba8126b6fef79.\n    \n    If a scalar epilogue is required, users outside the loop won't use\n    live-outs from the vector loop but from the scalar epilogue. Ignore them if\n    that is the case.\n    \n    This fixes another case where the VPlan-based cost-model more accurately\n    computes cost.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/100464.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex b709ccc3c35a..224d98d5c4f9 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -6678,6 +6678,15 @@ void LoopVectorizationCostModel::collectValuesToIgnore() {\n \n   SmallVector<Value *, 4> DeadInterleavePointerOps;\n   SmallVector<Value *, 4> DeadOps;\n+\n+  // If a scalar epilogue is required, users outside the loop won't use\n+  // live-outs from the vector loop but from the scalar epilogue. Ignore them if\n+  // that is the case.\n+  bool RequiresScalarEpilogue = requiresScalarEpilogue(true);\n+  auto IsLiveOutDead = [this, RequiresScalarEpilogue](User *U) {\n+    return RequiresScalarEpilogue &&\n+           !TheLoop->contains(cast<Instruction>(U)->getParent());\n+  };\n   for (BasicBlock *BB : TheLoop->blocks())\n     for (Instruction &I : *BB) {\n       // Find all stores to invariant variables. Since they are going to sink\n@@ -6693,8 +6702,9 @@ void LoopVectorizationCostModel::collectValuesToIgnore() {\n       // Add instructions that would be trivially dead and are only used by\n       // values already ignored to DeadOps to seed worklist.\n       if (wouldInstructionBeTriviallyDead(&I, TLI) &&\n-          all_of(I.users(), [this](User *U) {\n-            return VecValuesToIgnore.contains(U) || ValuesToIgnore.contains(U);\n+          all_of(I.users(), [this, IsLiveOutDead](User *U) {\n+            return VecValuesToIgnore.contains(U) ||\n+                   ValuesToIgnore.contains(U) || IsLiveOutDead(U);\n           }))\n         DeadOps.push_back(&I);\n \n@@ -6727,16 +6737,22 @@ void LoopVectorizationCostModel::collectValuesToIgnore() {\n \n   // Mark ops that would be trivially dead and are only used by ignored\n   // instructions as free.\n+  BasicBlock *Header = TheLoop->getHeader();\n   for (unsigned I = 0; I != DeadOps.size(); ++I) {\n     auto *Op = dyn_cast<Instruction>(DeadOps[I]);\n     // Skip any op that shouldn't be considered dead.\n     if (!Op || !TheLoop->contains(Op) ||\n+        (isa<PHINode>(Op) && Op->getParent() == Header) ||\n         !wouldInstructionBeTriviallyDead(Op, TLI) ||\n-        any_of(Op->users(), [this](User *U) {\n-          return !VecValuesToIgnore.contains(U) && !ValuesToIgnore.contains(U);\n+        any_of(Op->users(), [this, IsLiveOutDead](User *U) {\n+          return !VecValuesToIgnore.contains(U) && ValuesToIgnore.contains(U) &&\n+                 !IsLiveOutDead(U);\n         }))\n       continue;\n \n+    if (!TheLoop->contains(Op->getParent()))\n+      continue;\n+\n     // If all of Op's users are in ValuesToIgnore, add it to ValuesToIgnore\n     // which applies for both scalar and vector versions. Otherwise it is only\n     // dead in vector versions, so only add it to VecValuesToIgnore.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/dead-ops-cost.ll",
      "commands": [
        "opt -p loop-vectorize -mtriple riscv64-linux-gnu -mattr=+v,+f -S %s"
      ],
      "tests": [
        {
          "test_name": "dead_live_out_due_to_scalar_epilogue_required",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine i8 @dead_live_out_due_to_scalar_epilogue_required(ptr %src, ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %idxprom = sext i32 %iv to i64\n  %gep.src = getelementptr i8, ptr %src, i64 %idxprom\n  %l = load i8, ptr %gep.src, align 1\n  %gep.dst = getelementptr i8, ptr %dst, i64 %idxprom\n  store i8 0, ptr %gep.dst, align 1\n  %iv.next = add i32 %iv, 4\n  %cmp = icmp ult i32 %iv, 1001\n  br i1 %cmp, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  %r = phi i8 [ %l, %loop ]\n  ret i8 %r\n}\n"
        },
        {
          "test_name": "dead_load",
          "test_body": "target datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\n\ndefine void @dead_load(ptr %p, i16 %start) {\nentry:\n  %start.ext = sext i16 %start to i64\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ %start.ext, %entry ], [ %iv.next, %loop ]\n  %gep = getelementptr i16, ptr %p, i64 %iv\n  store i16 0, ptr %gep, align 2\n  %l = load i16, ptr %gep, align 2\n  %iv.next = add i64 %iv, 3\n  %cmp = icmp slt i64 %iv, 111\n  br i1 %cmp, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/RISCV/riscv-vector-reverse.ll",
      "commands": [
        "-riscv-v-vector-bits-min=128 -disable-output < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "vector_reverse_i64",
          "test_body": "define void @vector_reverse_i64(ptr nocapture noundef writeonly %A, ptr nocapture noundef readonly %B, i32 noundef signext %n) {\nentry:\n  %cmp7 = icmp sgt i32 %n, 0\n  br i1 %cmp7, label %for.body.preheader, label %for.cond.cleanup\n\nfor.body.preheader:                               ; preds = %entry\n  %0 = zext i32 %n to i64\n  br label %for.body\n\nfor.cond.cleanup:                                 ; preds = %for.body, %entry\n  ret void\n\nfor.body:                                         ; preds = %for.body, %for.body.preheader\n  %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]\n  %i.0.in8 = phi i32 [ %n, %for.body.preheader ], [ %i.0, %for.body ]\n  %i.0 = add nsw i32 %i.0.in8, -1\n  %idxprom = zext i32 %i.0 to i64\n  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %idxprom\n  %1 = load i32, ptr %arrayidx, align 4\n  %add9 = add i32 %1, 1\n  %arrayidx3 = getelementptr inbounds i32, ptr %A, i64 %idxprom\n  store i32 %add9, ptr %arrayidx3, align 4\n  %cmp = icmp ugt i64 %indvars.iv, 1\n  %indvars.iv.next = add nsw i64 %indvars.iv, -1\n  br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !0\n}\n\n!0 = distinct !{!0, !1, !2, !3, !4}\n!1 = !{!\"llvm.loop.mustprogress\"}\n!2 = !{!\"llvm.loop.vectorize.width\", i32 4}\n!3 = !{!\"llvm.loop.vectorize.scalable.enable\", i1 true}\n!4 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n"
        },
        {
          "test_name": "vector_reverse_f32",
          "test_body": "define void @vector_reverse_f32(ptr nocapture noundef writeonly %A, ptr nocapture noundef readonly %B, i32 noundef signext %n) {\nentry:\n  %cmp7 = icmp sgt i32 %n, 0\n  br i1 %cmp7, label %for.body.preheader, label %for.cond.cleanup\n\nfor.body.preheader:                               ; preds = %entry\n  %0 = zext i32 %n to i64\n  br label %for.body\n\nfor.cond.cleanup:                                 ; preds = %for.body, %entry\n  ret void\n\nfor.body:                                         ; preds = %for.body, %for.body.preheader\n  %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]\n  %i.0.in8 = phi i32 [ %n, %for.body.preheader ], [ %i.0, %for.body ]\n  %i.0 = add nsw i32 %i.0.in8, -1\n  %idxprom = zext i32 %i.0 to i64\n  %arrayidx = getelementptr inbounds float, ptr %B, i64 %idxprom\n  %1 = load float, ptr %arrayidx, align 4\n  %conv1 = fadd float %1, 1.000000e+00\n  %arrayidx3 = getelementptr inbounds float, ptr %A, i64 %idxprom\n  store float %conv1, ptr %arrayidx3, align 4\n  %cmp = icmp ugt i64 %indvars.iv, 1\n  %indvars.iv.next = add nsw i64 %indvars.iv, -1\n  br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !0\n}\n\n!0 = distinct !{!0, !1, !2, !3, !4}\n!1 = !{!\"llvm.loop.mustprogress\"}\n!2 = !{!\"llvm.loop.vectorize.width\", i32 4}\n!3 = !{!\"llvm.loop.vectorize.scalable.enable\", i1 true}\n!4 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[VPlan] VPlan cost model and legacy cost model disagreed",
    "body": "Related: #99701, #92555. @fhahn Please let me know if you'd prefer these assert triggering testcases to be all in the same issue or prefer a new issue when a new testcase is found.\r\n\r\nTested using llvm f719a339a89b\r\n\r\nTestcase:\r\n```llvm ir\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine i32 @main(ptr %0) #0 {\r\nentry:\r\n  br label %for.body\r\n\r\nfor.cond.cleanup:                                 ; preds = %for.body\r\n  %.lcssa = phi i8 [ %1, %for.body ]\r\n  ret i32 0\r\n\r\nfor.body:                                         ; preds = %for.body, %entry\r\n  %l.011 = phi i32 [ 0, %entry ], [ %add, %for.body ]\r\n  %idxprom = sext i32 %l.011 to i64\r\n  %arrayidx1 = getelementptr [15 x i8], ptr %0, i64 0, i64 %idxprom\r\n  %1 = load i8, ptr %arrayidx1, align 1\r\n  %arrayidx3 = getelementptr [0 x i8], ptr null, i64 0, i64 %idxprom\r\n  store i8 0, ptr %arrayidx3, align 1\r\n  %add = add i32 %l.011, 4\r\n  %cmp = icmp ult i32 %l.011, -9\r\n  br i1 %cmp, label %for.body, label %for.cond.cleanup\r\n}\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+a,+c,+d,+f,+m,+relax,+v,+zicsr,+zifencei,+zmmul,+zve32f,+zve32x,+zve64d,+zve64f,+zve64x,+zvl128b,+zvl32b,+zvl64b,-b,-e,-experimental-smmpm,-experimental-smnpm,-experimental-ssnpm,-experimental-sspm,-experimental-ssqosid,-experimental-supm,-experimental-zacas,-experimental-zalasr,-experimental-zicfilp,-experimental-zicfiss,-h,-shcounterenw,-shgatpa,-shtvala,-shvsatpa,-shvstvala,-shvstvecd,-smaia,-smcdeleg,-smcsrind,-smepmp,-smstateen,-ssaia,-ssccfg,-ssccptr,-sscofpmf,-sscounterenw,-sscsrind,-ssstateen,-ssstrict,-sstc,-sstvala,-sstvecd,-ssu64xl,-svade,-svadu,-svbare,-svinval,-svnapot,-svpbmt,-xcvalu,-xcvbi,-xcvbitmanip,-xcvelw,-xcvmac,-xcvmem,-xcvsimd,-xsfcease,-xsfvcp,-xsfvfnrclipxfqf,-xsfvfwmaccqqq,-xsfvqmaccdod,-xsfvqmaccqoq,-xsifivecdiscarddlone,-xsifivecflushdlone,-xtheadba,-xtheadbb,-xtheadbs,-xtheadcmo,-xtheadcondmov,-xtheadfmemidx,-xtheadmac,-xtheadmemidx,-xtheadmempair,-xtheadsync,-xtheadvdot,-xventanacondops,-xwchc,-za128rs,-za64rs,-zaamo,-zabha,-zalrsc,-zama16b,-zawrs,-zba,-zbb,-zbc,-zbkb,-zbkc,-zbkx,-zbs,-zca,-zcb,-zcd,-zce,-zcf,-zcmop,-zcmp,-zcmt,-zdinx,-zfa,-zfbfmin,-zfh,-zfhmin,-zfinx,-zhinx,-zhinxmin,-zic64b,-zicbom,-zicbop,-zicboz,-ziccamoa,-ziccif,-zicclsm,-ziccrse,-zicntr,-zicond,-zihintntl,-zihintpause,-zihpm,-zimop,-zk,-zkn,-zknd,-zkne,-zknh,-zkr,-zks,-zksed,-zksh,-zkt,-ztso,-zvbb,-zvbc,-zvfbfmin,-zvfbfwma,-zvfh,-zvfhmin,-zvkb,-zvkg,-zvkn,-zvknc,-zvkned,-zvkng,-zvknha,-zvknhb,-zvks,-zvksc,-zvksed,-zvksg,-zvksh,-zvkt,-zvl1024b,-zvl16384b,-zvl2048b,-zvl256b,-zvl32768b,-zvl4096b,-zvl512b,-zvl65536b,-zvl8192b\" }\r\n```\r\n\r\nCommand/backtrace:\r\n```\r\n> /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes loop-vectorize reduced.ll -S\r\nopt: /scratch/tc-testing/tc-compiler-fuzz-trunk/llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10098: bool llvm::LoopVectorizePass::processLoop(llvm::Loop*): Assertion `VF.Width == Width && \"VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt -passes loop-vectorize reduced.ll -S\r\n1.      Running pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"reduced.ll\"\r\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"main\"\r\n #0 0x0000647de5790dd0 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2f1ddd0)\r\n #1 0x0000647de578e1ef llvm::sys::RunSignalHandlers() (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2f1b1ef)\r\n #2 0x0000647de578e345 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x00007b2a02842520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007b2a028969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007b2a028969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007b2a028969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007b2a02842476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007b2a028287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007b2a0282871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007b2a02839e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x0000647de47acc98 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1f39c98)\r\n#12 0x0000647de47af851 llvm::LoopVectorizePass::runImpl(llvm::Function&, llvm::ScalarEvolution&, llvm::LoopInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::BlockFrequencyInfo*, llvm::TargetLibraryInfo*, llvm::DemandedBits&, llvm::AssumptionCache&, llvm::LoopAccessInfoManager&, llvm::OptimizationRemarkEmitter&, llvm::ProfileSummaryInfo*) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1f3c851)\r\n#13 0x0000647de47affd0 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x1f3cfd0)\r\n#14 0x0000647de3621ff6 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xdaeff6)\r\n#15 0x0000647de55a8e7e llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2d35e7e)\r\n#16 0x0000647de3625186 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xdb2186)\r\n#17 0x0000647de55a7c0b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2d34c0b)\r\n#18 0x0000647de36214d6 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0xdae4d6)\r\n#19 0x0000647de55a5d5d llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x2d32d5d)\r\n#20 0x0000647de2e6b5d6 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x5f85d6)\r\n#21 0x0000647de2e5d211 optMain (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x5ea211)\r\n#22 0x00007b2a02829d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#23 0x00007b2a02829e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#24 0x00007b2a02829e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#25 0x0000647de2e530a5 _start (/scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt+0x5e00a5)\r\nzsh: IOT instruction (core dumped)  /scratch/tc-testing/tc-compiler-fuzz-trunk/build-gcv/build-llvm-linux/bin/opt\r\n```\r\n\r\nGodbolt: https://godbolt.org/z/z7ee8hWWP",
    "author": "patrick-rivos",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "@patrick-rivos thanks for the report. I think it would be best to keep filing separate issues, as the underlying issues usually are different. Although the fuzzers may generate many instances of the same issue as was the case for https://github.com/llvm/llvm-project/issues/99701. Not sure if there's an easy way to catch that other than waiting for a day or so after filing the first issue."
      }
    ]
  }
}