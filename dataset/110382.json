{
  "bug_id": "110382",
  "issue_url": "https://github.com/llvm/llvm-project/issues/110382",
  "bug_type": "crash",
  "base_commit": "72a957ba4c8ef059f1572f6d4ee0cba8dc615268",
  "knowledge_cutoff": "2024-09-28T19:00:52Z",
  "lit_test_dir": [
    "llvm/test/Transforms/VectorCombine"
  ],
  "hints": {
    "fix_commit": "c136d3237a3c6230cfe1ab3f0f6790f903c54a27",
    "components": [
      "VectorCombine"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/VectorCombine.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VectorCombine.cpp": [
        [
          1984,
          2016
        ],
        [
          2038,
          2044
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VectorCombine.cpp": [
        "VectorCombine::foldShuffleToIdentity",
        "generateInstLaneVectorFromOperand"
      ]
    }
  },
  "patch": "commit c136d3237a3c6230cfe1ab3f0f6790f903c54a27\nAuthor: David Green <david.green@arm.com>\nDate:   Wed Oct 9 16:20:03 2024 +0100\n\n    [VectorCombine] Do not try to operate on OperandBundles. (#111635)\n    \n    This bails out if we see an intrinsic with an operand bundle on it, to\n    make sure we don't process the bundles incorrectly.\n    \n    Fixes #110382.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\nindex a2ab5d966640..627edb680dfa 100644\n--- a/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VectorCombine.cpp\n@@ -1984,33 +1984,35 @@ bool VectorCombine::foldShuffleToIdentity(Instruction &I) {\n \n     // We need each element to be the same type of value, and check that each\n     // element has a single use.\n-    if (all_of(drop_begin(Item), [Item](InstLane IL) {\n-          Value *FrontV = Item.front().first->get();\n-          if (!IL.first)\n-            return true;\n-          Value *V = IL.first->get();\n-          if (auto *I = dyn_cast<Instruction>(V); I && !I->hasOneUse())\n-            return false;\n-          if (V->getValueID() != FrontV->getValueID())\n-            return false;\n-          if (auto *CI = dyn_cast<CmpInst>(V))\n-            if (CI->getPredicate() != cast<CmpInst>(FrontV)->getPredicate())\n-              return false;\n-          if (auto *CI = dyn_cast<CastInst>(V))\n-            if (CI->getSrcTy() != cast<CastInst>(FrontV)->getSrcTy())\n-              return false;\n-          if (auto *SI = dyn_cast<SelectInst>(V))\n-            if (!isa<VectorType>(SI->getOperand(0)->getType()) ||\n-                SI->getOperand(0)->getType() !=\n-                    cast<SelectInst>(FrontV)->getOperand(0)->getType())\n-              return false;\n-          if (isa<CallInst>(V) && !isa<IntrinsicInst>(V))\n-            return false;\n-          auto *II = dyn_cast<IntrinsicInst>(V);\n-          return !II || (isa<IntrinsicInst>(FrontV) &&\n-                         II->getIntrinsicID() ==\n-                             cast<IntrinsicInst>(FrontV)->getIntrinsicID());\n-        })) {\n+    auto CheckLaneIsEquivalentToFirst = [Item](InstLane IL) {\n+      Value *FrontV = Item.front().first->get();\n+      if (!IL.first)\n+        return true;\n+      Value *V = IL.first->get();\n+      if (auto *I = dyn_cast<Instruction>(V); I && !I->hasOneUse())\n+        return false;\n+      if (V->getValueID() != FrontV->getValueID())\n+        return false;\n+      if (auto *CI = dyn_cast<CmpInst>(V))\n+        if (CI->getPredicate() != cast<CmpInst>(FrontV)->getPredicate())\n+          return false;\n+      if (auto *CI = dyn_cast<CastInst>(V))\n+        if (CI->getSrcTy() != cast<CastInst>(FrontV)->getSrcTy())\n+          return false;\n+      if (auto *SI = dyn_cast<SelectInst>(V))\n+        if (!isa<VectorType>(SI->getOperand(0)->getType()) ||\n+            SI->getOperand(0)->getType() !=\n+                cast<SelectInst>(FrontV)->getOperand(0)->getType())\n+          return false;\n+      if (isa<CallInst>(V) && !isa<IntrinsicInst>(V))\n+        return false;\n+      auto *II = dyn_cast<IntrinsicInst>(V);\n+      return !II || (isa<IntrinsicInst>(FrontV) &&\n+                     II->getIntrinsicID() ==\n+                         cast<IntrinsicInst>(FrontV)->getIntrinsicID() &&\n+                     !II->hasOperandBundles());\n+    };\n+    if (all_of(drop_begin(Item), CheckLaneIsEquivalentToFirst)) {\n       // Check the operator is one that we support.\n       if (isa<BinaryOperator, CmpInst>(FrontU)) {\n         //  We exclude div/rem in case they hit UB from poison lanes.\n@@ -2038,7 +2040,8 @@ bool VectorCombine::foldShuffleToIdentity(Instruction &I) {\n         Worklist.push_back(generateInstLaneVectorFromOperand(Item, 2));\n         continue;\n       } else if (auto *II = dyn_cast<IntrinsicInst>(FrontU);\n-                 II && isTriviallyVectorizable(II->getIntrinsicID())) {\n+                 II && isTriviallyVectorizable(II->getIntrinsicID()) &&\n+                 !II->hasOperandBundles()) {\n         for (unsigned Op = 0, E = II->getNumOperands() - 1; Op < E; Op++) {\n           if (isVectorIntrinsicWithScalarOpAtArg(II->getIntrinsicID(), Op)) {\n             if (!all_of(drop_begin(Item), [Item, Op](InstLane &IL) {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/VectorCombine/AArch64/shuffletoidentity.ll",
      "commands": [
        "opt -passes=vector-combine -S %s"
      ],
      "tests": [
        {
          "test_name": "add_same_operands",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i32> @add_same_operands(<4 x i32> %x) {\n  %shuf = shufflevector <4 x i32> %x, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %add = add <4 x i32> %shuf, %shuf\n  %revshuf = shufflevector <4 x i32> %add, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  ret <4 x i32> %revshuf\n}\n"
        },
        {
          "test_name": "extrause_add_same_operands",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i32> @extrause_add_same_operands(<4 x i32> %x) {\n  %shuf = shufflevector <4 x i32> %x, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %add = add <4 x i32> %shuf, %shuf\n  %revshuf = shufflevector <4 x i32> %add, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %add2 = add <4 x i32> %shuf, %revshuf\n  ret <4 x i32> %add2\n}\n"
        },
        {
          "test_name": "callinst2",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @callinst2(<8 x half> %a) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x half> @llvm.fabs.v4f16(<4 x half> %at)\n  %abb = call <4 x half> @othercall(<4 x half> %ab)\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n\ndeclare <4 x half> @othercall(<4 x half>)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x half> @llvm.fabs.v4f16(<4 x half>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "poison_intrinsic",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i32> @poison_intrinsic(<2 x i16> %l256) {\n  %l266 = call <2 x i16> @llvm.abs.v2i16(<2 x i16> %l256, i1 false)\n  %l267 = zext <2 x i16> %l266 to <2 x i32>\n  %l271 = shufflevector <2 x i32> %l267, <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>\n  ret <4 x i32> %l271\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <2 x i16> @llvm.abs.v2i16(<2 x i16>, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "splattwice",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @splattwice(<8 x half> %a, <8 x half> %b) {\n  %as = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> zeroinitializer\n  %bs = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> zeroinitializer\n  %ab1 = fadd <4 x half> %as, %bs\n  %ab2 = fadd <4 x half> %as, %bs\n  %r = shufflevector <4 x half> %ab1, <4 x half> %ab2, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n"
        },
        {
          "test_name": "fadd_mismatched_types",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x float> @fadd_mismatched_types(<4 x float> %x, <4 x float> %y) {\n  %shuf.x = shufflevector <4 x float> %x, <4 x float> poison, <2 x i32> <i32 0, i32 2>\n  %shuf.y = shufflevector <4 x float> %y, <4 x float> poison, <2 x i32> <i32 1, i32 3>\n  %fadd = fadd fast <2 x float> %shuf.x, %shuf.y\n  %extshuf = shufflevector <2 x float> %fadd, <2 x float> poison, <4 x i32> <i32 0, i32 2, i32 1, i32 3>\n  ret <4 x float> %extshuf\n}\n"
        },
        {
          "test_name": "intrinsics_minmax",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @intrinsics_minmax(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i8> @llvm.smin.v4i8(<4 x i8> %at, <4 x i8> %bt)\n  %abb = call <4 x i8> @llvm.smin.v4i8(<4 x i8> %ab, <4 x i8> %bb)\n  %abt1 = call <4 x i8> @llvm.smax.v4i8(<4 x i8> %abt, <4 x i8> %bt)\n  %abb1 = call <4 x i8> @llvm.smax.v4i8(<4 x i8> %abb, <4 x i8> %bb)\n  %abt2 = call <4 x i8> @llvm.umin.v4i8(<4 x i8> %abt1, <4 x i8> %bt)\n  %abb2 = call <4 x i8> @llvm.umin.v4i8(<4 x i8> %abb1, <4 x i8> %bb)\n  %abt3 = call <4 x i8> @llvm.umax.v4i8(<4 x i8> %abt2, <4 x i8> %bt)\n  %abb3 = call <4 x i8> @llvm.umax.v4i8(<4 x i8> %abb2, <4 x i8> %bb)\n  %r = shufflevector <4 x i8> %abt3, <4 x i8> %abb3, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.smax.v4i8(<4 x i8>, <4 x i8>) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.smin.v4i8(<4 x i8>, <4 x i8>) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.umax.v4i8(<4 x i8>, <4 x i8>) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.umin.v4i8(<4 x i8>, <4 x i8>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "constantdiff2",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @constantdiff2(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, <i8 1, i8 2, i8 3, i8 4>\n  %abb = add <4 x i8> %ab, <i8 1, i8 2, i8 3, i8 4>\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "fcmpsel",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @fcmpsel(<8 x half> %a, <8 x half> %b, <8 x i8> %c, <8 x i8> %d) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %cb = shufflevector <8 x i8> %c, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %ct = shufflevector <8 x i8> %c, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %db = shufflevector <8 x i8> %d, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %dt = shufflevector <8 x i8> %d, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt1 = fcmp olt <4 x half> %at, %bt\n  %abb1 = fcmp olt <4 x half> %ab, %bb\n  %abt = select <4 x i1> %abt1, <4 x i8> %ct, <4 x i8> %dt\n  %abb = select <4 x i1> %abb1, <4 x i8> %cb, <4 x i8> %db\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "inner_shuffle",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @inner_shuffle(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 4, i32 5, i32 6, i32 7>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 4, i32 5, i32 6, i32 7>\n  %cs = shufflevector <8 x i8> %c, <8 x i8> poison, <4 x i32> zeroinitializer\n  %abt = mul <4 x i8> %at, %bt\n  %abb = mul <4 x i8> %ab, %bb\n  %abt2 = shufflevector <4 x i8> %abt, <4 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %abb2 = shufflevector <4 x i8> %abb, <4 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %abt3 = add <4 x i8> %abt2, %cs\n  %abb3 = add <4 x i8> %abb2, %cs\n  %r = shufflevector <4 x i8> %abt3, <4 x i8> %abb3, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "zext_types",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @zext_types(<8 x i16> %a, <8 x i32> %b, ptr %p) {\n  %ab = shufflevector <8 x i16> %a, <8 x i16> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %at = shufflevector <8 x i32> %b, <8 x i32> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %ab1 = zext <4 x i16> %ab to <4 x i64>\n  %at1 = zext <4 x i32> %at to <4 x i64>\n  %r = shufflevector <4 x i64> %ab1, <4 x i64> %at1, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>\n  store <8 x i64> %r, ptr %p, align 64\n  ret void\n}\n"
        },
        {
          "test_name": "add_different_operands",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @add_different_operands(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, %bt\n  %abb = add <4 x i8> %ab, %bb\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "constantdiff",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @constantdiff(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, <i8 1, i8 2, i8 3, i8 4>\n  %abb = add <4 x i8> %ab, <i8 5, i8 6, i8 7, i8 8>\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "extrause_add_different_operands",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @extrause_add_different_operands(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, %bt\n  %abb = add <4 x i8> %ab, %bb\n  call void @use(<4 x i8> %abb)\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\ndeclare void @use(<4 x i8>)\n"
        },
        {
          "test_name": "icmpsel_diffentcond",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @icmpsel_diffentcond(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c, <8 x i8> %d) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %cb = shufflevector <8 x i8> %c, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %ct = shufflevector <8 x i8> %c, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %db = shufflevector <8 x i8> %d, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %dt = shufflevector <8 x i8> %d, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt1 = icmp slt <4 x i8> %at, %bt\n  %abb1 = icmp ult <4 x i8> %ab, %bb\n  %abt = select <4 x i1> %abt1, <4 x i8> %ct, <4 x i8> %dt\n  %abb = select <4 x i1> %abb1, <4 x i8> %cb, <4 x i8> %db\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "exttrunc",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @exttrunc(<8 x i32> %a, <8 x i32> %b, ptr %p) {\n  %ab = shufflevector <8 x i32> %a, <8 x i32> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %at = shufflevector <8 x i32> %a, <8 x i32> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %bb = shufflevector <8 x i32> %b, <8 x i32> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %bt = shufflevector <8 x i32> %b, <8 x i32> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %ab1 = zext <4 x i32> %ab to <4 x i64>\n  %at1 = zext <4 x i32> %at to <4 x i64>\n  %bb1 = sext <4 x i32> %bb to <4 x i64>\n  %bt1 = sext <4 x i32> %bt to <4 x i64>\n  %abb = add <4 x i64> %ab1, %bb1\n  %abt = add <4 x i64> %at1, %bt1\n  %abb1 = trunc <4 x i64> %abb to <4 x i32>\n  %abt1 = trunc <4 x i64> %abt to <4 x i32>\n  %r = shufflevector <4 x i32> %abb1, <4 x i32> %abt1, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>\n  store <8 x i32> %r, ptr %p, align 32\n  ret void\n}\n"
        },
        {
          "test_name": "lrint",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i32> @lrint(<8 x half> %a) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i32> @llvm.lrint.v4i32.v4f16(<4 x half> %at)\n  %abb = call <4 x i32> @llvm.lrint.v4i32.v4f16(<4 x half> %ab)\n  %r = shufflevector <4 x i32> %abt, <4 x i32> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i32> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i32> @llvm.lrint.v4i32.v4f16(<4 x half>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "fadd",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @fadd(<8 x half> %a, <8 x half> %b) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = fadd <4 x half> %at, %bt\n  %abb = fadd <4 x half> %ab, %bb\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n"
        },
        {
          "test_name": "abs_different",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @abs_different(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %at, i1 true)\n  %abb = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %ab, i1 false)\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.abs.v4i8(<4 x i8>, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "wrong_addsub",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @wrong_addsub(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, %bt\n  %abb = sub <4 x i8> %ab, %bb\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "single_zext",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i64> @single_zext(<4 x i32> %x) {\n  %shuf = shufflevector <4 x i32> %x, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %zext = zext <4 x i32> %shuf to <4 x i64>\n  %revshuf = shufflevector <4 x i64> %zext, <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  ret <4 x i64> %revshuf\n}\n"
        },
        {
          "test_name": "v8f64interleave",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @v8f64interleave(i64 %0, ptr %1, ptr %x, double %z) {\nentry:\n  %broadcast.splatinsert = insertelement <2 x double> poison, double %z, i64 0\n  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer\n  %wide.vec = load <16 x double>, ptr %1, align 8\n  %strided.vec = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 0, i32 8>\n  %strided.vec27 = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 1, i32 9>\n  %strided.vec28 = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 2, i32 10>\n  %strided.vec29 = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 3, i32 11>\n  %strided.vec30 = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 4, i32 12>\n  %strided.vec31 = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 5, i32 13>\n  %strided.vec32 = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 6, i32 14>\n  %strided.vec33 = shufflevector <16 x double> %wide.vec, <16 x double> poison, <2 x i32> <i32 7, i32 15>\n  %2 = fmul fast <2 x double> %strided.vec, %broadcast.splat\n  %3 = getelementptr inbounds double, ptr %x, i64 %0\n  %wide.vec34 = load <16 x double>, ptr %3, align 8\n  %strided.vec35 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 0, i32 8>\n  %strided.vec36 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 1, i32 9>\n  %strided.vec37 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 2, i32 10>\n  %strided.vec38 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 3, i32 11>\n  %strided.vec39 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 4, i32 12>\n  %strided.vec40 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 5, i32 13>\n  %strided.vec41 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 6, i32 14>\n  %strided.vec42 = shufflevector <16 x double> %wide.vec34, <16 x double> poison, <2 x i32> <i32 7, i32 15>\n  %4 = fadd fast <2 x double> %strided.vec35, %2\n  %5 = fmul fast <2 x double> %strided.vec27, %broadcast.splat\n  %6 = fadd fast <2 x double> %strided.vec36, %5\n  %7 = fmul fast <2 x double> %strided.vec28, %broadcast.splat\n  %8 = fadd fast <2 x double> %strided.vec37, %7\n  %9 = fmul fast <2 x double> %strided.vec29, %broadcast.splat\n  %10 = fadd fast <2 x double> %strided.vec38, %9\n  %11 = fmul fast <2 x double> %strided.vec30, %broadcast.splat\n  %12 = fadd fast <2 x double> %strided.vec39, %11\n  %13 = fmul fast <2 x double> %strided.vec31, %broadcast.splat\n  %14 = fadd fast <2 x double> %strided.vec40, %13\n  %15 = fmul fast <2 x double> %strided.vec32, %broadcast.splat\n  %16 = fadd fast <2 x double> %strided.vec41, %15\n  %17 = or disjoint i64 %0, 7\n  %18 = fmul fast <2 x double> %strided.vec33, %broadcast.splat\n  %19 = getelementptr inbounds double, ptr %x, i64 %17\n  %20 = fadd fast <2 x double> %strided.vec42, %18\n  %21 = getelementptr inbounds i8, ptr %19, i64 -56\n  %22 = shufflevector <2 x double> %4, <2 x double> %6, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %23 = shufflevector <2 x double> %8, <2 x double> %10, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %24 = shufflevector <2 x double> %12, <2 x double> %14, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %25 = shufflevector <2 x double> %16, <2 x double> %20, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %26 = shufflevector <4 x double> %22, <4 x double> %23, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n  %27 = shufflevector <4 x double> %24, <4 x double> %25, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n  %interleaved.vec = shufflevector <8 x double> %26, <8 x double> %27, <16 x i32> <i32 0, i32 2, i32 4, i32 6, i32 8, i32 10, i32 12, i32 14, i32 1, i32 3, i32 5, i32 7, i32 9, i32 11, i32 13, i32 15>\n  store <16 x double> %interleaved.vec, ptr %21, align 8\n  ret void\n}\n"
        },
        {
          "test_name": "singleop",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i8> @singleop(<4 x i8> %a, <4 x i8> %b) {\n  %a1 = shufflevector <4 x i8> %a, <4 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %b1 = shufflevector <4 x i8> %b, <4 x i8> poison, <4 x i32> zeroinitializer\n  %a2 = zext <4 x i8> %a1 to <4 x i16>\n  %b2 = zext <4 x i8> %b1 to <4 x i16>\n  %ab = add <4 x i16> %a2, %b2\n  %t = trunc <4 x i16> %ab to <4 x i8>\n  %r = shufflevector <4 x i8> %t, <4 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  ret <4 x i8> %r\n}\n"
        },
        {
          "test_name": "not_bitcast",
          "test_body": "target triple = \"aarch64\"\n\ndefine i32 @not_bitcast(<4 x i8> %x) {\n  %shuf = shufflevector <4 x i8> %x, <4 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bitcast = bitcast <4 x i8> %shuf to i32\n  ret i32 %bitcast\n}\n"
        },
        {
          "test_name": "zext_chain",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i64> @zext_chain(<4 x i16> %x) {\n  %shuf = shufflevector <4 x i16> %x, <4 x i16> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %zext = zext <4 x i16> %shuf to <4 x i32>\n  %sext = sext <4 x i32> %zext to <4 x i64>\n  %revshuf = shufflevector <4 x i64> %sext, <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  ret <4 x i64> %revshuf\n}\n"
        },
        {
          "test_name": "intrinsics_different",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @intrinsics_different(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i8> @llvm.smin.v4i8(<4 x i8> %at, <4 x i8> %bt)\n  %abb = call <4 x i8> @llvm.umin.v4i8(<4 x i8> %ab, <4 x i8> %bb)\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.smin.v4i8(<4 x i8>, <4 x i8>) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.umin.v4i8(<4 x i8>, <4 x i8>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "operandbundles_second",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @operandbundles_second(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %at, i1 false)\n  %abb = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %ab, i1 false) [ \"jl_roots\"(ptr addrspace(10) null, ptr addrspace(10) null) ]\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.abs.v4i8(<4 x i8>, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "cast_mismatched_types",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i64> @cast_mismatched_types(<4 x i32> %x) {\n  %shuf = shufflevector <4 x i32> %x, <4 x i32> poison, <2 x i32> <i32 0, i32 2>\n  %zext = zext <2 x i32> %shuf to <2 x i64>\n  %extshuf = shufflevector <2 x i64> %zext, <2 x i64> poison, <4 x i32> <i32 0, i32 2, i32 1, i32 3>\n  ret <4 x i64> %extshuf\n}\n"
        },
        {
          "test_name": "operandbundles_first",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @operandbundles_first(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %at, i1 false) [ \"jl_roots\"(ptr addrspace(10) null, ptr addrspace(10) null) ]\n  %abb = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %ab, i1 false)\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.abs.v4i8(<4 x i8>, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "wrong_lanes",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @wrong_lanes(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, %bt\n  %abb = add <4 x i8> %ab, %bb\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 6, i32 7, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "first_scalar_select",
          "test_body": "target triple = \"aarch64\"\n\ndefine <2 x float> @first_scalar_select(<2 x float> %0, <2 x float> %1, float %x) {\nentry:\n  %cmp.i903 = fcmp ogt float %x, 0.000000e+00\n  %sel1639 = select i1 %cmp.i903, <2 x float> %0, <2 x float> %1\n  %2 = fcmp ogt <2 x float> %0, zeroinitializer\n  %sel48.i913 = select <2 x i1> %2, <2 x float> %0, <2 x float> %1\n  %3 = shufflevector <2 x float> %sel1639, <2 x float> %sel48.i913, <2 x i32> <i32 0, i32 3>\n  ret <2 x float> %3\n}\n"
        },
        {
          "test_name": "splat0",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @splat0(<8 x half> %a, <8 x half> %b) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bs = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> zeroinitializer\n  %abt = fadd <4 x half> %at, %bs\n  %abb = fadd <4 x half> %ab, %bs\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n"
        },
        {
          "test_name": "splatandidentity",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @splatandidentity(<8 x half> %a, <8 x half> %b) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bs = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> zeroinitializer\n  %abt = fadd <4 x half> %at, %bs\n  %abb = fadd <4 x half> %ab, %bs\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n"
        },
        {
          "test_name": "trivial",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @trivial(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %r = shufflevector <4 x i8> %at, <4 x i8> %ab, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "constantsplat",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @constantsplat(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, splat (i8 10)\n  %abb = add <4 x i8> %ab, splat (i8 10)\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "bitcast_srcty_mismatch",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @bitcast_srcty_mismatch() {\nentry:\n  %shuffle.i.i = shufflevector <2 x i64> zeroinitializer, <2 x i64> zeroinitializer, <2 x i32> <i32 1, i32 3>\n  %0 = bitcast <4 x i32> zeroinitializer to <4 x float>\n  %1 = bitcast <2 x i64> %shuffle.i.i to <4 x float>\n  %shufp.i196 = shufflevector <4 x float> %0, <4 x float> %1, <4 x i32> <i32 2, i32 1, i32 4, i32 7>\n  store <4 x float> %shufp.i196, ptr null, align 16\n  ret void\n}\n"
        },
        {
          "test_name": "zext_add_chain",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i64> @zext_add_chain(<4 x i32> %x) {\n  %shuf = shufflevector <4 x i32> %x, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %zext = zext <4 x i32> %shuf to <4 x i64>\n  %add = add <4 x i64> %zext, %zext\n  %revshuf = shufflevector <4 x i64> %add, <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  ret <4 x i64> %revshuf\n}\n"
        },
        {
          "test_name": "add_chain",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i32> @add_chain(<4 x i32> %x) {\n  %shuf = shufflevector <4 x i32> %x, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %add = add <4 x i32> %shuf, %shuf\n  %add2 = add <4 x i32> %add, %add\n  %revshuf = shufflevector <4 x i32> %add2, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  ret <4 x i32> %revshuf\n}\n"
        },
        {
          "test_name": "splat2",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @splat2(<8 x half> %a, <8 x half> %b) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bs = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> <i32 2, i32 2, i32 2, i32 2>\n  %abt = fadd <4 x half> %at, %bs\n  %abb = fadd <4 x half> %ab, %bs\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n"
        },
        {
          "test_name": "trunc",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @trunc(<8 x i64> %a, <8 x i64> %b, ptr %p) {\n  %ab = shufflevector <8 x i64> %a, <8 x i64> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %at = shufflevector <8 x i64> %a, <8 x i64> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %abb1 = trunc <4 x i64> %ab to <4 x i32>\n  %abt1 = trunc <4 x i64> %at to <4 x i32>\n  %r = shufflevector <4 x i32> %abb1, <4 x i32> %abt1, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>\n  store <8 x i32> %r, ptr %p, align 32\n  ret void\n}\n"
        },
        {
          "test_name": "sext",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @sext(<8 x i16> %a, <8 x i16> %b, ptr %p) {\n  %ab = shufflevector <8 x i16> %a, <8 x i16> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %at = shufflevector <8 x i16> %a, <8 x i16> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %bb = shufflevector <8 x i16> %b, <8 x i16> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %bt = shufflevector <8 x i16> %b, <8 x i16> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %ab1 = sext <4 x i16> %ab to <4 x i32>\n  %at1 = sext <4 x i16> %at to <4 x i32>\n  %bb1 = sext <4 x i16> %bb to <4 x i32>\n  %bt1 = sext <4 x i16> %bt to <4 x i32>\n  %abb = add <4 x i32> %ab1, %bb1\n  %abt = add <4 x i32> %at1, %bt1\n  %r = shufflevector <4 x i32> %abb, <4 x i32> %abt, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>\n  store <8 x i32> %r, ptr %p, align 32\n  ret void\n}\n"
        },
        {
          "test_name": "powi",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @powi(<8 x half> %a) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x half> @llvm.powi.v4f16.i32(<4 x half> %at, i32 10)\n  %abb = call <4 x half> @llvm.powi.v4f16.i32(<4 x half> %ab, i32 10)\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x half> @llvm.powi.v4f16.i32(<4 x half>, i32) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "callinst",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @callinst(<8 x half> %a) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x half> @othercall(<4 x half> %at)\n  %abb = call <4 x half> @llvm.fabs.v4f16(<4 x half> %ab)\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n\ndeclare <4 x half> @othercall(<4 x half>)\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x half> @llvm.fabs.v4f16(<4 x half>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "fma",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @fma(<8 x half> %a, <8 x half> %b, <8 x half> %c) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x half> %b, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %cb = shufflevector <8 x half> %c, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %ct = shufflevector <8 x half> %c, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abb = call <4 x half> @llvm.fma.v4f16(<4 x half> %ab, <4 x half> %bb, <4 x half> %cb)\n  %abt = call <4 x half> @llvm.fma.v4f16(<4 x half> %at, <4 x half> %bt, <4 x half> %ct)\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x half> @llvm.fma.v4f16(<4 x half>, <4 x half>, <4 x half>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "extrause_shuffle",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @extrause_shuffle(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  call void @use(<4 x i8> %bt)\n  %abt = add <4 x i8> %at, %bt\n  %abb = add <4 x i8> %ab, %bb\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\ndeclare void @use(<4 x i8>)\n"
        },
        {
          "test_name": "intrinsics_addsat",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @intrinsics_addsat(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %at, <4 x i8> %bt)\n  %abb = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %ab, <4 x i8> %bb)\n  %abt1 = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %abt, <4 x i8> %bt)\n  %abb1 = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %abb, <4 x i8> %bb)\n  %abt2 = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %abt1, <4 x i8> %bt)\n  %abb2 = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %abb1, <4 x i8> %bb)\n  %abt3 = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %abt2, <4 x i8> %bt)\n  %abb3 = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %abb2, <4 x i8> %bb)\n  %r = shufflevector <4 x i8> %abt3, <4 x i8> %abb3, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8>, <4 x i8>) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8>, <4 x i8>) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8>, <4 x i8>) #0\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.usub.sat.v4i8(<4 x i8>, <4 x i8>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "zext",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @zext(<8 x i16> %a, <8 x i16> %b, ptr %p) {\n  %ab = shufflevector <8 x i16> %a, <8 x i16> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %at = shufflevector <8 x i16> %a, <8 x i16> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %bb = shufflevector <8 x i16> %b, <8 x i16> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %bt = shufflevector <8 x i16> %b, <8 x i16> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %ab1 = zext <4 x i16> %ab to <4 x i32>\n  %at1 = zext <4 x i16> %at to <4 x i32>\n  %bb1 = zext <4 x i16> %bb to <4 x i32>\n  %bt1 = zext <4 x i16> %bt to <4 x i32>\n  %abb = add <4 x i32> %ab1, %bb1\n  %abt = add <4 x i32> %at1, %bt1\n  %r = shufflevector <4 x i32> %abb, <4 x i32> %abt, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>\n  store <8 x i32> %r, ptr %p, align 32\n  ret void\n}\n"
        },
        {
          "test_name": "div",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @div(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = udiv <4 x i8> %at, %bt\n  %abb = udiv <4 x i8> %ab, %bb\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 poison, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "bitcast_smax_v8i32_v4i32",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i64> @bitcast_smax_v8i32_v4i32(<4 x i64> %a, <4 x i64> %b) {\n  %a.bc0 = bitcast <4 x i64> %a to <8 x i32>\n  %b.bc0 = bitcast <4 x i64> %b to <8 x i32>\n  %cmp = icmp slt <8 x i32> %a.bc0, %b.bc0\n  %cmp.lo = shufflevector <8 x i1> %cmp, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %cmp.hi = shufflevector <8 x i1> %cmp, <8 x i1> poison, <4 x i32> <i32 4, i32 5, i32 6, i32 7>\n  %a.bc1 = bitcast <4 x i64> %a to <8 x i32>\n  %b.bc1 = bitcast <4 x i64> %b to <8 x i32>\n  %a.lo = shufflevector <8 x i32> %a.bc1, <8 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %b.lo = shufflevector <8 x i32> %b.bc1, <8 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n  %lo = select <4 x i1> %cmp.lo, <4 x i32> %b.lo, <4 x i32> %a.lo\n  %a.bc2 = bitcast <4 x i64> %a to <8 x i32>\n  %b.bc2 = bitcast <4 x i64> %b to <8 x i32>\n  %a.hi = shufflevector <8 x i32> %a.bc2, <8 x i32> poison, <4 x i32> <i32 4, i32 5, i32 6, i32 7>\n  %b.hi = shufflevector <8 x i32> %b.bc2, <8 x i32> poison, <4 x i32> <i32 4, i32 5, i32 6, i32 7>\n  %hi = select <4 x i1> %cmp.hi, <4 x i32> %b.hi, <4 x i32> %a.hi\n  %concat = shufflevector <4 x i32> %lo, <4 x i32> %hi, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n  %res = bitcast <8 x i32> %concat to <4 x i64>\n  ret <4 x i64> %res\n}\n"
        },
        {
          "test_name": "not_bitcast2",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i16> @not_bitcast2(<4 x i32> %x, <8 x i16> %y) {\n  %cast = bitcast <4 x i32> %x to <8 x i16>\n  %out = shufflevector <8 x i16> %y, <8 x i16> %cast, <8 x i32> <i32 8, i32 1, i32 10, i32 3, i32 12, i32 5, i32 14, i32 7>\n  ret <8 x i16> %out\n}\n"
        },
        {
          "test_name": "abs",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @abs(<8 x i8> %a) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %at, i1 false)\n  %abb = call <4 x i8> @llvm.abs.v4i8(<4 x i8> %ab, i1 false)\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i8> @llvm.abs.v4i8(<4 x i8>, i1 immarg) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "maximal_legal_fpmath",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @maximal_legal_fpmath(ptr %addr1, ptr %addr2, ptr %result, float %val) {\n  %splatinsert = insertelement <4 x float> poison, float %val, i64 0\n  %incoming.vec = shufflevector <4 x float> %splatinsert, <4 x float> poison, <4 x i32> zeroinitializer\n  %vec1 = load <16 x float>, ptr %addr1, align 4\n  %strided.vec1 = shufflevector <16 x float> %vec1, <16 x float> poison, <4 x i32> <i32 0, i32 4, i32 8, i32 12>\n  %strided.vec2 = shufflevector <16 x float> %vec1, <16 x float> poison, <4 x i32> <i32 1, i32 5, i32 9, i32 13>\n  %strided.vec3 = shufflevector <16 x float> %vec1, <16 x float> poison, <4 x i32> <i32 2, i32 6, i32 10, i32 14>\n  %strided.vec4 = shufflevector <16 x float> %vec1, <16 x float> poison, <4 x i32> <i32 3, i32 7, i32 11, i32 15>\n  %vec2 = load <16 x float>, ptr %addr2, align 4\n  %strided.vec6 = shufflevector <16 x float> %vec2, <16 x float> poison, <4 x i32> <i32 0, i32 4, i32 8, i32 12>\n  %strided.vec7 = shufflevector <16 x float> %vec2, <16 x float> poison, <4 x i32> <i32 1, i32 5, i32 9, i32 13>\n  %strided.vec8 = shufflevector <16 x float> %vec2, <16 x float> poison, <4 x i32> <i32 2, i32 6, i32 10, i32 14>\n  %strided.vec9 = shufflevector <16 x float> %vec2, <16 x float> poison, <4 x i32> <i32 3, i32 7, i32 11, i32 15>\n  %1 = fmul fast <4 x float> %incoming.vec, %strided.vec6\n  %2 = fadd fast <4 x float> %strided.vec1, %1\n  %3 = fmul contract <4 x float> %incoming.vec, %strided.vec7\n  %4 = fadd fast <4 x float> %strided.vec2, %3\n  %5 = fmul reassoc contract <4 x float> %incoming.vec, %strided.vec8\n  %6 = fadd fast <4 x float> %strided.vec3, %5\n  %7 = fmul reassoc contract <4 x float> %incoming.vec, %strided.vec9\n  %8 = fadd reassoc contract <4 x float> %strided.vec4, %7\n  %9 = shufflevector <4 x float> %2, <4 x float> %4, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n  %10 = shufflevector <4 x float> %6, <4 x float> %8, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>\n  %interleaved.vec = shufflevector <8 x float> %9, <8 x float> %10, <16 x i32> <i32 0, i32 4, i32 8, i32 12, i32 1, i32 5, i32 9, i32 13, i32 2, i32 6, i32 10, i32 14, i32 3, i32 7, i32 11, i32 15>\n  store <16 x float> %interleaved.vec, ptr %result, align 4\n  ret void\n}\n"
        },
        {
          "test_name": "not_zext",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i64> @not_zext(<4 x i32> %x) {\n  %zext = zext <4 x i32> %x to <4 x i64>\n  %revshuf = shufflevector <4 x i64> %zext, <4 x i64> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  ret <4 x i64> %revshuf\n}\n"
        },
        {
          "test_name": "undeflane",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @undeflane(<8 x i8> %a, <8 x i8> %b) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = add <4 x i8> %at, %bt\n  %abb = add <4 x i8> %ab, %bb\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 poison, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "operandbundles",
          "test_body": "target triple = \"aarch64\"\n\ndefine <16 x i64> @operandbundles(<4 x i64> %a, <4 x i64> %b, <4 x i64> %c) {\n  %call = call <4 x i64> @llvm.fshl.v4i64(<4 x i64> %a, <4 x i64> %b, <4 x i64> %c) [ \"jl_roots\"(ptr addrspace(10) null, ptr addrspace(10) null) ]\n  %shufflevector = shufflevector <4 x i64> %call, <4 x i64> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>\n  %shufflevector1 = shufflevector <16 x i64> %shufflevector, <16 x i64> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n  ret <16 x i64> %shufflevector1\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare <4 x i64> @llvm.fshl.v4i64(<4 x i64>, <4 x i64>, <4 x i64>) #0\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        },
        {
          "test_name": "fneg",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @fneg(<8 x half> %a, <8 x half> %b) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = fneg <4 x half> %at\n  %abb = fneg <4 x half> %ab\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n"
        },
        {
          "test_name": "icmpsel",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x i8> @icmpsel(<8 x i8> %a, <8 x i8> %b, <8 x i8> %c, <8 x i8> %d) {\n  %ab = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x i8> %a, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %bb = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %bt = shufflevector <8 x i8> %b, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %cb = shufflevector <8 x i8> %c, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %ct = shufflevector <8 x i8> %c, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %db = shufflevector <8 x i8> %d, <8 x i8> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %dt = shufflevector <8 x i8> %d, <8 x i8> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt1 = icmp slt <4 x i8> %at, %bt\n  %abb1 = icmp slt <4 x i8> %ab, %bb\n  %abt = select <4 x i1> %abt1, <4 x i8> %ct, <4 x i8> %dt\n  %abb = select <4 x i1> %abb1, <4 x i8> %cb, <4 x i8> %db\n  %r = shufflevector <4 x i8> %abt, <4 x i8> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x i8> %r\n}\n"
        },
        {
          "test_name": "szext",
          "test_body": "target triple = \"aarch64\"\n\ndefine void @szext(<8 x i32> %a, <8 x i32> %b, ptr %p) {\n  %ab = shufflevector <8 x i32> %a, <8 x i32> poison, <4 x i32> <i32 0, i32 2, i32 4, i32 6>\n  %at = shufflevector <8 x i32> %a, <8 x i32> poison, <4 x i32> <i32 1, i32 3, i32 5, i32 7>\n  %ab1 = sext <4 x i32> %ab to <4 x i64>\n  %at1 = zext <4 x i32> %at to <4 x i64>\n  %r = shufflevector <4 x i64> %ab1, <4 x i64> %at1, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>\n  store <8 x i64> %r, ptr %p, align 64\n  ret void\n}\n"
        },
        {
          "test_name": "constantsplatf",
          "test_body": "target triple = \"aarch64\"\n\ndefine <8 x half> @constantsplatf(<8 x half> %a) {\n  %ab = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %at = shufflevector <8 x half> %a, <8 x half> poison, <4 x i32> <i32 7, i32 6, i32 5, i32 4>\n  %abt = fadd <4 x half> %at, splat (half 0xH4900)\n  %abb = fadd <4 x half> %ab, splat (half 0xH4900)\n  %r = shufflevector <4 x half> %abt, <4 x half> %abb, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>\n  ret <8 x half> %r\n}\n"
        },
        {
          "test_name": "not_zext2",
          "test_body": "target triple = \"aarch64\"\n\ndefine <4 x i64> @not_zext2(<4 x i32> %x) {\n  %shuf = shufflevector <4 x i32> %x, <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n  %zext = zext <4 x i32> %shuf to <4 x i64>\n  ret <4 x i64> %zext\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion Failure in Vector Combine",
    "body": "Runnning vector-combine pass on \r\n```llvm\r\nsource_filename = \"text\"\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:10:11:12:13\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine nonnull ptr addrspace(10) @wombat() {\r\n  %call = call <4 x i64> @llvm.fshl.v4i64(<4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> <i64 45, i64 45, i64 45, i64 45>) [ \"jl_roots\"(ptr addrspace(10) null, ptr addrspace(10) null) ]\r\n  %shufflevector = shufflevector <4 x i64> %call, <4 x i64> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>\r\n  %shufflevector1 = shufflevector <16 x i64> %shufflevector, <16 x i64> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\r\n  ret ptr addrspace(10) null\r\n}\r\n\r\ndeclare <4 x i64> @llvm.fshl.v4i64(<4 x i64>, <4 x i64>, <4 x i64>)\r\n```\r\nproduces\r\n```\r\nopt: /root/llvm-project/llvm/include/llvm/Support/Casting.h:578: decltype(auto) llvm::cast(From*) [with To = llvm::FixedVectorType; From = llvm::Type]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=vector-combine <source>\r\n1.\tRunning pass \"function(vector-combine)\" on module \"<source>\"\r\n2.\tRunning pass \"vector-combine\" on function \"wombat\"\r\n #0 0x0000000005079b38 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5079b38)\r\n #1 0x00000000050774ec SignalHandler(int) Signals.cpp:0:0\r\n #2 0x000074d0dce42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x000074d0dce969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #4 0x000074d0dce42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #5 0x000074d0dce287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #6 0x000074d0dce2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #7 0x000074d0dce39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #8 0x0000000004186458 (anonymous namespace)::VectorCombine::foldShuffleToIdentity(llvm::Instruction&) VectorCombine.cpp:0:0\r\n #9 0x0000000004190f01 (anonymous namespace)::VectorCombine::run()::'lambda'(llvm::Instruction&)::operator()(llvm::Instruction&) const (.isra.0) VectorCombine.cpp:0:0\r\n#10 0x0000000004191c25 llvm::VectorCombinePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4191c25)\r\n#11 0x0000000002f2defe llvm::detail::PassModel<llvm::Function, llvm::VectorCombinePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2f2defe)\r\n#12 0x0000000004e7c978 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e7c978)\r\n#13 0x0000000000e157ce llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe157ce)\r\n#14 0x0000000004e7b39e llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e7b39e)\r\n#15 0x0000000000e14f7e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe14f7e)\r\n#16 0x0000000004e7add0 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e7add0)\r\n#17 0x0000000000904cc2 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x904cc2)\r\n#18 0x00000000008f7b4c optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8f7b4c)\r\n#19 0x000074d0dce29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#20 0x000074d0dce29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#21 0x00000000008ef61e _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8ef61e)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139\r\n```\r\nGodbolt: https://godbolt.org/z/MGefYs3M5",
    "author": "Zentrik",
    "labels": [
      "release:backport",
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "Heresh83",
        "body": "> Runnning vector-combine pass on \n> ```llvm\n> source_filename = \"text\"\n> target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:10:11:12:13\"\n> target triple = \"x86_64-unknown-linux-gnu\"\n> \n> define nonnull ptr addrspace(10) @wombat() {\n>   %call = call <4 x i64> @llvm.fshl.v4i64(<4 x i64> zeroinitializer, <4 x i64> zeroinitializer, <4 x i64> <i64 45, i64 45, i64 45, i64 45>) [ \"jl_roots\"(ptr addrspace(10) null, ptr addrspace(10) null) ]\n>   %shufflevector = shufflevector <4 x i64> %call, <4 x i64> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>\n>   %shufflevector1 = shufflevector <16 x i64> %shufflevector, <16 x i64> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>\n>   ret ptr addrspace(10) null\n> }\n> \n> declare <4 x i64> @llvm.fshl.v4i64(<4 x i64>, <4 x i64>, <4 x i64>)\n> ```\n> produces\n> ```\n> opt: /root/llvm-project/llvm/include/llvm/Support/Casting.h:578: decltype(auto) llvm::cast(From*) [with To = llvm::FixedVectorType; From = llvm::Type]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\n> PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\n> Stack dump:\n> 0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=vector-combine <source>\n> 1.\tRunning pass \"function(vector-combine)\" on module \"<source>\"\n> 2.\tRunning pass \"vector-combine\" on function \"wombat\"\n>  #0 0x0000000005079b38 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5079b38)\n>  #1 0x00000000050774ec SignalHandler(int) Signals.cpp:0:0\n>  #2 0x000074d0dce42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n>  #3 0x000074d0dce969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n>  #4 0x000074d0dce42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n>  #5 0x000074d0dce287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n>  #6 0x000074d0dce2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n>  #7 0x000074d0dce39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n>  #8 0x0000000004186458 (anonymous namespace)::VectorCombine::foldShuffleToIdentity(llvm::Instruction&) VectorCombine.cpp:0:0\n>  #9 0x0000000004190f01 (anonymous namespace)::VectorCombine::run()::'lambda'(llvm::Instruction&)::operator()(llvm::Instruction&) const (.isra.0) VectorCombine.cpp:0:0\n> #10 0x0000000004191c25 llvm::VectorCombinePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4191c25)\n> #11 0x0000000002f2defe llvm::detail::PassModel<llvm::Function, llvm::VectorCombinePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2f2defe)\n> #12 0x0000000004e7c978 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e7c978)\n> #13 0x0000000000e157ce llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe157ce)\n> #14 0x0000000004e7b39e llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e7b39e)\n> #15 0x0000000000e14f7e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe14f7e)\n> #16 0x0000000004e7add0 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4e7add0)\n> #17 0x0000000000904cc2 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x904cc2)\n> #18 0x00000000008f7b4c optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8f7b4c)\n> #19 0x000074d0dce29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n> #20 0x000074d0dce29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n> #21 0x00000000008ef61e _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8ef61e)\n> Program terminated with signal: SIGSEGV\n> Compiler returned: 139\n> ```\n> Godbolt: https://godbolt.org/z/MGefYs3M5\n\n"
      },
      {
        "author": "RKSimon",
        "body": "Looks like foldShuffleToIdentity is attempting to fold the operand bundle on the fshl call"
      }
    ]
  }
}
