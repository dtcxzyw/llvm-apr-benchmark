{
  "bug_id": "142518",
  "issue_url": "https://github.com/llvm/llvm-project/issues/142518",
  "bug_type": "miscompilation",
  "base_commit": "9ba332f9963561bb5ac6933266afe38eb8fde8cd",
  "knowledge_cutoff": "2025-06-03T02:15:27Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "e2c698c7e836306f1a25c67597ae9e25a1fcc575",
    "components": [
      "InstCombine"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp": [
        [
          4513,
          4518
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp": [
        "InstCombinerImpl::sinkNotIntoLogicalOp"
      ]
    }
  },
  "patch": "commit e2c698c7e836306f1a25c67597ae9e25a1fcc575\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Wed Jun 4 17:48:01 2025 +0800\n\n    [InstCombine] Fix miscompilation in `sinkNotIntoLogicalOp` (#142727)\n    \n    Consider the following case:\n    ```\n    define i1 @src(i8 %x) {\n      %cmp = icmp slt i8 %x, -1\n      %not1 = xor i1 %cmp, true\n      %or = or i1 %cmp, %not1\n      %not2 = xor i1 %or, true\n      ret i1 %not2\n    }\n    ```\n    `sinkNotIntoLogicalOp(%or)` calls `freelyInvert(%cmp,\n    /*IgnoredUser=*/%or)` first. However, as `%cmp` is also used by `Op1 =\n    %not1`, the RHS of `%or` is set to `%cmp.not = xor i1 %cmp, true`. Thus\n    `Op1` is out of date in the second call to `freelyInvert`. Similarly,\n    the second call may change `Op0`. According to the analysis above, I\n    decided to avoid this fold when one of the operands is also a user of\n    the other.\n    \n    Closes https://github.com/llvm/llvm-project/issues/142518.\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp b/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\nindex 2fb4bfecda8a..c6c231f81c4a 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp\n@@ -4513,6 +4513,12 @@ bool InstCombinerImpl::sinkNotIntoLogicalOp(Instruction &I) {\n   if (Op0 == Op1)\n     return false;\n \n+  // If one of the operands is a user of the other,\n+  // freelyInvert->freelyInvertAllUsersOf will change the operands of I, which\n+  // may cause miscompilation.\n+  if (match(Op0, m_Not(m_Specific(Op1))) || match(Op1, m_Not(m_Specific(Op0))))\n+    return false;\n+\n   Instruction::BinaryOps NewOpc =\n       match(&I, m_LogicalAnd()) ? Instruction::Or : Instruction::And;\n   bool IsBinaryOp = isa<BinaryOperator>(I);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/pr142518.ll",
      "commands": [
        "opt -S -passes=instcombine < %s"
      ],
      "tests": [
        {
          "test_name": "pr142518",
          "test_body": "define i8 @pr142518(ptr %p, i8 %x, i1 %c) #0 {\nentry:\n  %flag = alloca i8, align 1\n  %cmp = icmp slt i8 %x, -1\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %phi = phi i1 [ %cmp, %entry ], [ %c, %loop ]\n  %not1 = xor i1 %phi, true\n  %or = or i1 %cmp, %not1\n  %not2 = xor i1 %or, true\n  %ext2 = zext i1 %not2 to i8\n  store i8 %ext2, ptr %p, align 1\n  store i8 1, ptr %flag, align 1\n  %flagv = load i8, ptr %flag, align 1\n  %cond = icmp eq i8 %flagv, 0\n  br i1 %cond, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  %not3 = xor i1 %or, true\n  %ext3 = zext i1 %not3 to i8\n  ret i8 %ext3\n}\n\nattributes #0 = { \"instcombine-no-verify-fixpoint\" }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "InstCombine miscompilation",
    "body": "Like https://github.com/llvm/llvm-project/issues/139866 this is from a fuzzer that generates Rust MIR: https://github.com/cbeuw/rustlantis.\n\nI've tried to reduce the MIR, but I think there's a pretty complicated structure required because I can't get the MIR very small.\nhttps://godbolt.org/z/G6qsWP57T\n\nThe program seems to miscompile starting at `rustc -Zmir-opt-level=0 -Copt-level=1 -Cllvm-args=-opt-bisect-limit=159`",
    "author": "saethlin",
    "labels": [
      "miscompilation",
      "llvm:instcombine",
      "generated by fuzzer"
    ],
    "comments": [
      {
        "author": "dtcxzyw",
        "body": "Reproducer: https://alive2.llvm.org/ce/z/l2ArgJ\n\n> I've tried to reduce the MIR, but I think there's a pretty complicated structure required because I can't get the MIR very small.\n\nFYI you can use https://github.com/dtcxzyw/llvm-ub-aware-interpreter?tab=readme-ov-file#automatic-ub-free-test-case-reduction-for-middle-end-miscompilation-bugs to reduce csmith/rustlantics-generated miscompilation reproducers.\n"
      },
      {
        "author": "saethlin",
        "body": "I'd love to use llubi but it doesn't compile against the tip of master or the llvm submodule in rust-lang/rust. So I'm not really sure how to get a working build on my system."
      },
      {
        "author": "dtcxzyw",
        "body": "> I'd love to use llubi but it doesn't compile against the tip of master or the llvm submodule in rust-lang/rust. So I'm not really sure how to get a working build on my system.\n\nFixed. It was broken by recent changes to ValueTracking: https://github.com/llvm/llvm-project/pull/142384"
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "d01aec4c769d50fb92e86decd41d077c94105841"
}