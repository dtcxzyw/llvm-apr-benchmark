{
  "bug_id": "117518",
  "issue_url": "https://github.com/llvm/llvm-project/issues/117518",
  "bug_type": "crash",
  "base_commit": "3de21477c49172081e502b47d608e729915f0914",
  "knowledge_cutoff": "2024-11-25T05:31:23Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "f953b5eb72df77fc301aac210eab31c6270ff771",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          10875,
          10883
        ],
        [
          14372,
          14378
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "finalize"
      ]
    }
  },
  "patch": "commit f953b5eb72df77fc301aac210eab31c6270ff771\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Mon Nov 25 08:29:22 2024 -0800\n\n    [SLP]Relax assertion about subvectors mask size\n    \n    SubVectorsMask might be less than CommonMask, if the vectors with larger\n    number of elements are permuted or reused elements are used. Need to\n    consider this when estimation/building the vector to avoid compiler\n    crash\n    \n    Fixes #117518\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 73218f377a06..34b80c1e3608 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -10875,9 +10875,10 @@ public:\n           CommonMask[Idx] = Idx;\n       // Add subvectors permutation cost.\n       if (!SubVectorsMask.empty()) {\n-        assert(SubVectorsMask.size() == CommonMask.size() &&\n+        assert(SubVectorsMask.size() <= CommonMask.size() &&\n                \"Expected same size of masks for subvectors and common mask.\");\n-        SmallVector<int> SVMask(SubVectorsMask.begin(), SubVectorsMask.end());\n+        SmallVector<int> SVMask(CommonMask.size(), PoisonMaskElem);\n+        copy(SubVectorsMask, SVMask.begin());\n         for (auto [I1, I2] : zip(SVMask, CommonMask)) {\n           if (I2 != PoisonMaskElem) {\n             assert(I1 == PoisonMaskElem && \"Expected unused subvectors mask\");\n@@ -14372,7 +14373,8 @@ public:\n       if (SubVectorsMask.empty()) {\n         Vec = CreateSubVectors(Vec, CommonMask);\n       } else {\n-        SmallVector<int> SVMask(SubVectorsMask.begin(), SubVectorsMask.end());\n+        SmallVector<int> SVMask(CommonMask.size(), PoisonMaskElem);\n+        copy(SubVectorsMask, SVMask.begin());\n         for (auto [I1, I2] : zip(SVMask, CommonMask)) {\n           if (I2 != PoisonMaskElem) {\n             assert(I1 == PoisonMaskElem && \"Expected unused subvectors mask\");\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/non-power-of-2-subvectors-insert.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -slp-threshold=-300 -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine void @test() {\n;\n  %xor108.i.i.i = xor i64 0, 1\n  %conv115.i.i.i = trunc i64 %xor108.i.i.i to i16\n  %add.i.i.i.i = or i16 %conv115.i.i.i, 0\n  %add.i.frozen.i.i.i = freeze i16 %add.i.i.i.i\n  %.cmp.not.i.i.i = icmp eq i16 %add.i.frozen.i.i.i, 0\n  %cond.i1002.1.i.i.i = lshr i64 0, 0\n  %conv115.1.i.i.i = trunc i64 %cond.i1002.1.i.i.i to i16\n  %add.i.1.i.i.i = or i16 %conv115.1.i.i.i, 0\n  %add.i.frozen.1.i.i.i = freeze i16 %add.i.1.i.i.i\n  %.cmp.not.1.i.i.i = icmp eq i16 %add.i.frozen.1.i.i.i, 0\n  %cond.i1002.2.i.i.i = lshr i64 %xor108.i.i.i, 0\n  %conv115.2.i.i.i = trunc i64 %cond.i1002.2.i.i.i to i16\n  %add.i.2.i.i.i = or i16 %conv115.2.i.i.i, 0\n  %add.i.frozen.2.i.i.i = freeze i16 %add.i.2.i.i.i\n  %.cmp.not.2.i.i.i = icmp eq i16 %add.i.frozen.2.i.i.i, 0\n  %cond.i1002.3.i.i.i = lshr i64 0, 0\n  %conv115.3.i.i.i = trunc i64 %cond.i1002.3.i.i.i to i16\n  %add.i.3.i.i.i = or i16 %conv115.3.i.i.i, 0\n  %add.i.frozen.3.i.i.i = freeze i16 %add.i.3.i.i.i\n  %.cmp.not.3.i.i.i = icmp eq i16 %add.i.frozen.3.i.i.i, 0\n  %conv115.i.i.i.1 = trunc i64 %xor108.i.i.i to i16\n  %add.i.i.i.i.1 = or i16 %conv115.i.i.i.1, 0\n  %add.i.frozen.i.i.i.1 = freeze i16 %add.i.i.i.i.1\n  %.cmp.not.i.i.i.1 = icmp eq i16 %add.i.frozen.i.i.i.1, 0\n  %cond.i1002.1.i.i.i.1 = lshr i64 0, 0\n  %conv115.1.i.i.i.1 = trunc i64 %cond.i1002.1.i.i.i.1 to i16\n  %add.i.1.i.i.i.1 = or i16 %conv115.1.i.i.i.1, 0\n  %add.i.frozen.1.i.i.i.1 = freeze i16 %add.i.1.i.i.i.1\n  %.cmp.not.1.i.i.i.1 = icmp eq i16 %add.i.frozen.1.i.i.i.1, 0\n  %cond.i1002.2.i.i.i.1 = lshr i64 0, 0\n  %conv115.2.i.i.i.1 = trunc i64 %cond.i1002.2.i.i.i.1 to i16\n  %add.i.2.i.i.i.1 = or i16 %conv115.2.i.i.i.1, 0\n  %add.i.frozen.2.i.i.i.1 = freeze i16 %add.i.2.i.i.i.1\n  %.cmp.not.2.i.i.i.1 = icmp eq i16 %add.i.frozen.2.i.i.i.1, 0\n  %cond.i1002.3.i.i.i.1 = lshr i64 0, 0\n  %conv115.3.i.i.i.1 = trunc i64 %cond.i1002.3.i.i.i.1 to i16\n  %add.i.3.i.i.i.1 = or i16 %conv115.3.i.i.i.1, 0\n  %add.i.frozen.3.i.i.i.1 = freeze i16 %add.i.3.i.i.i.1\n  %.cmp.not.3.i.i.i.1 = icmp eq i16 %add.i.frozen.3.i.i.i.1, 0\n  %conv115.i.i.i.2 = trunc i64 %xor108.i.i.i to i16\n  %add.i.i.i.i.2 = or i16 %conv115.i.i.i.2, 0\n  %add.i.frozen.i.i.i.2 = freeze i16 %add.i.i.i.i.2\n  %.cmp.not.i.i.i.2 = icmp eq i16 %add.i.frozen.i.i.i.2, 0\n  %cond.i1002.1.i.i.i.2 = lshr i64 0, 0\n  %conv115.1.i.i.i.2 = trunc i64 %cond.i1002.1.i.i.i.2 to i16\n  %add.i.1.i.i.i.2 = or i16 %conv115.1.i.i.i.2, 0\n  %add.i.frozen.1.i.i.i.2 = freeze i16 %add.i.1.i.i.i.2\n  %.cmp.not.1.i.i.i.2 = icmp eq i16 %add.i.frozen.1.i.i.i.2, 0\n  %cond.i1002.2.i.i.i.2 = lshr i64 0, 0\n  %conv115.2.i.i.i.2 = trunc i64 %cond.i1002.2.i.i.i.2 to i16\n  %add.i.2.i.i.i.2 = or i16 %conv115.2.i.i.i.2, 0\n  %add.i.frozen.2.i.i.i.2 = freeze i16 %add.i.2.i.i.i.2\n  %.cmp.not.2.i.i.i.2 = icmp eq i16 %add.i.frozen.2.i.i.i.2, 0\n  %cond.i1002.3.i.i.i.2 = lshr i64 0, 0\n  %conv115.3.i.i.i.2 = trunc i64 %cond.i1002.3.i.i.i.2 to i16\n  %add.i.3.i.i.i.2 = or i16 %conv115.3.i.i.i.2, 0\n  %add.i.frozen.3.i.i.i.2 = freeze i16 %add.i.3.i.i.i.2\n  %.cmp.not.3.i.i.i.2 = icmp eq i16 %add.i.frozen.3.i.i.i.2, 0\n  %conv115.i.i.i.3 = trunc i64 %xor108.i.i.i to i16\n  %add.i.i.i.i.3 = or i16 %conv115.i.i.i.3, 0\n  %add.i.frozen.i.i.i.3 = freeze i16 %add.i.i.i.i.3\n  %.cmp.not.i.i.i.3 = icmp eq i16 %add.i.frozen.i.i.i.3, 0\n  %cond.i1002.1.i.i.i.3 = lshr i64 0, 0\n  %conv115.1.i.i.i.3 = trunc i64 %cond.i1002.1.i.i.i.3 to i16\n  %add.i.1.i.i.i.3 = or i16 %conv115.1.i.i.i.3, 0\n  %add.i.frozen.1.i.i.i.3 = freeze i16 %add.i.1.i.i.i.3\n  %.cmp.not.1.i.i.i.3 = icmp eq i16 %add.i.frozen.1.i.i.i.3, 0\n  %cond.i1002.2.i.i.i.3 = lshr i64 0, 0\n  %conv115.2.i.i.i.3 = trunc i64 %cond.i1002.2.i.i.i.3 to i16\n  %add.i.2.i.i.i.3 = or i16 %conv115.2.i.i.i.3, 0\n  %add.i.frozen.2.i.i.i.3 = freeze i16 %add.i.2.i.i.i.3\n  %.cmp.not.2.i.i.i.3 = icmp eq i16 %add.i.frozen.2.i.i.i.3, 0\n  %cond.i1002.3.i.i.i.3 = lshr i64 0, 0\n  %conv115.3.i.i.i.3 = trunc i64 %cond.i1002.3.i.i.i.3 to i16\n  %add.i.3.i.i.i.3 = or i16 %conv115.3.i.i.i.3, 0\n  %add.i.frozen.3.i.i.i.3 = freeze i16 %add.i.3.i.i.i.3\n  %.cmp.not.3.i.i.i.3 = icmp eq i16 %add.i.frozen.3.i.i.i.3, 0\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Assertion `SubVectorsMask.size() == CommonMask.size() && \"Expected same size of masks for subvectors and common mask.\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/chKcKacPK\r\n```\r\n; bin/opt -passes=slp-vectorizer test.ll -S\r\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine void @test() {\r\n  %xor108.i.i.i = xor i64 0, 1\r\n  %conv115.i.i.i = trunc i64 %xor108.i.i.i to i16\r\n  %add.i.i.i.i = or i16 %conv115.i.i.i, 0\r\n  %add.i.frozen.i.i.i = freeze i16 %add.i.i.i.i\r\n  %.cmp.not.i.i.i = icmp eq i16 %add.i.frozen.i.i.i, 0\r\n  %cond.i1002.1.i.i.i = lshr i64 0, 0\r\n  %conv115.1.i.i.i = trunc i64 %cond.i1002.1.i.i.i to i16\r\n  %add.i.1.i.i.i = or i16 %conv115.1.i.i.i, 0\r\n  %add.i.frozen.1.i.i.i = freeze i16 %add.i.1.i.i.i\r\n  %.cmp.not.1.i.i.i = icmp eq i16 %add.i.frozen.1.i.i.i, 0\r\n  %cond.i1002.2.i.i.i = lshr i64 %xor108.i.i.i, 0\r\n  %conv115.2.i.i.i = trunc i64 %cond.i1002.2.i.i.i to i16\r\n  %add.i.2.i.i.i = or i16 %conv115.2.i.i.i, 0\r\n  %add.i.frozen.2.i.i.i = freeze i16 %add.i.2.i.i.i\r\n  %.cmp.not.2.i.i.i = icmp eq i16 %add.i.frozen.2.i.i.i, 0\r\n  %cond.i1002.3.i.i.i = lshr i64 0, 0\r\n  %conv115.3.i.i.i = trunc i64 %cond.i1002.3.i.i.i to i16\r\n  %add.i.3.i.i.i = or i16 %conv115.3.i.i.i, 0\r\n  %add.i.frozen.3.i.i.i = freeze i16 %add.i.3.i.i.i\r\n  %.cmp.not.3.i.i.i = icmp eq i16 %add.i.frozen.3.i.i.i, 0\r\n  %conv115.i.i.i.1 = trunc i64 %xor108.i.i.i to i16\r\n  %add.i.i.i.i.1 = or i16 %conv115.i.i.i.1, 0\r\n  %add.i.frozen.i.i.i.1 = freeze i16 %add.i.i.i.i.1\r\n  %.cmp.not.i.i.i.1 = icmp eq i16 %add.i.frozen.i.i.i.1, 0\r\n  %cond.i1002.1.i.i.i.1 = lshr i64 0, 0\r\n  %conv115.1.i.i.i.1 = trunc i64 %cond.i1002.1.i.i.i.1 to i16\r\n  %add.i.1.i.i.i.1 = or i16 %conv115.1.i.i.i.1, 0\r\n  %add.i.frozen.1.i.i.i.1 = freeze i16 %add.i.1.i.i.i.1\r\n  %.cmp.not.1.i.i.i.1 = icmp eq i16 %add.i.frozen.1.i.i.i.1, 0\r\n  %cond.i1002.2.i.i.i.1 = lshr i64 0, 0\r\n  %conv115.2.i.i.i.1 = trunc i64 %cond.i1002.2.i.i.i.1 to i16\r\n  %add.i.2.i.i.i.1 = or i16 %conv115.2.i.i.i.1, 0\r\n  %add.i.frozen.2.i.i.i.1 = freeze i16 %add.i.2.i.i.i.1\r\n  %.cmp.not.2.i.i.i.1 = icmp eq i16 %add.i.frozen.2.i.i.i.1, 0\r\n  %cond.i1002.3.i.i.i.1 = lshr i64 0, 0\r\n  %conv115.3.i.i.i.1 = trunc i64 %cond.i1002.3.i.i.i.1 to i16\r\n  %add.i.3.i.i.i.1 = or i16 %conv115.3.i.i.i.1, 0\r\n  %add.i.frozen.3.i.i.i.1 = freeze i16 %add.i.3.i.i.i.1\r\n  %.cmp.not.3.i.i.i.1 = icmp eq i16 %add.i.frozen.3.i.i.i.1, 0\r\n  %conv115.i.i.i.2 = trunc i64 %xor108.i.i.i to i16\r\n  %add.i.i.i.i.2 = or i16 %conv115.i.i.i.2, 0\r\n  %add.i.frozen.i.i.i.2 = freeze i16 %add.i.i.i.i.2\r\n  %.cmp.not.i.i.i.2 = icmp eq i16 %add.i.frozen.i.i.i.2, 0\r\n  %cond.i1002.1.i.i.i.2 = lshr i64 0, 0\r\n  %conv115.1.i.i.i.2 = trunc i64 %cond.i1002.1.i.i.i.2 to i16\r\n  %add.i.1.i.i.i.2 = or i16 %conv115.1.i.i.i.2, 0\r\n  %add.i.frozen.1.i.i.i.2 = freeze i16 %add.i.1.i.i.i.2\r\n  %.cmp.not.1.i.i.i.2 = icmp eq i16 %add.i.frozen.1.i.i.i.2, 0\r\n  %cond.i1002.2.i.i.i.2 = lshr i64 0, 0\r\n  %conv115.2.i.i.i.2 = trunc i64 %cond.i1002.2.i.i.i.2 to i16\r\n  %add.i.2.i.i.i.2 = or i16 %conv115.2.i.i.i.2, 0\r\n  %add.i.frozen.2.i.i.i.2 = freeze i16 %add.i.2.i.i.i.2\r\n  %.cmp.not.2.i.i.i.2 = icmp eq i16 %add.i.frozen.2.i.i.i.2, 0\r\n  %cond.i1002.3.i.i.i.2 = lshr i64 0, 0\r\n  %conv115.3.i.i.i.2 = trunc i64 %cond.i1002.3.i.i.i.2 to i16\r\n  %add.i.3.i.i.i.2 = or i16 %conv115.3.i.i.i.2, 0\r\n  %add.i.frozen.3.i.i.i.2 = freeze i16 %add.i.3.i.i.i.2\r\n  %.cmp.not.3.i.i.i.2 = icmp eq i16 %add.i.frozen.3.i.i.i.2, 0\r\n  %conv115.i.i.i.3 = trunc i64 %xor108.i.i.i to i16\r\n  %add.i.i.i.i.3 = or i16 %conv115.i.i.i.3, 0\r\n  %add.i.frozen.i.i.i.3 = freeze i16 %add.i.i.i.i.3\r\n  %.cmp.not.i.i.i.3 = icmp eq i16 %add.i.frozen.i.i.i.3, 0\r\n  %cond.i1002.1.i.i.i.3 = lshr i64 0, 0\r\n  %conv115.1.i.i.i.3 = trunc i64 %cond.i1002.1.i.i.i.3 to i16\r\n  %add.i.1.i.i.i.3 = or i16 %conv115.1.i.i.i.3, 0\r\n  %add.i.frozen.1.i.i.i.3 = freeze i16 %add.i.1.i.i.i.3\r\n  %.cmp.not.1.i.i.i.3 = icmp eq i16 %add.i.frozen.1.i.i.i.3, 0\r\n  %cond.i1002.2.i.i.i.3 = lshr i64 0, 0\r\n  %conv115.2.i.i.i.3 = trunc i64 %cond.i1002.2.i.i.i.3 to i16\r\n  %add.i.2.i.i.i.3 = or i16 %conv115.2.i.i.i.3, 0\r\n  %add.i.frozen.2.i.i.i.3 = freeze i16 %add.i.2.i.i.i.3\r\n  %.cmp.not.2.i.i.i.3 = icmp eq i16 %add.i.frozen.2.i.i.i.3, 0\r\n  %cond.i1002.3.i.i.i.3 = lshr i64 0, 0\r\n  %conv115.3.i.i.i.3 = trunc i64 %cond.i1002.3.i.i.i.3 to i16\r\n  %add.i.3.i.i.i.3 = or i16 %conv115.3.i.i.i.3, 0\r\n  %add.i.frozen.3.i.i.i.3 = freeze i16 %add.i.3.i.i.i.3\r\n  %.cmp.not.3.i.i.i.3 = icmp eq i16 %add.i.frozen.3.i.i.i.3, 0\r\n  ret void\r\n}\r\n```\r\n```\r\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10880: llvm::InstructionCost llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::finalize(llvm::ArrayRef<int>, llvm::ArrayRef<std::pair<const llvm::slpvectorizer::BoUpSLP::TreeEntry*, unsigned int> >, llvm::ArrayRef<int>, unsigned int, llvm::function_ref<void(llvm::Value*&, llvm::SmallVectorImpl<int>&)>): Assertion `SubVectorsMask.size() == CommonMask.size() && \"Expected same size of masks for subvectors and common mask.\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=slp-vectorizer <source>\r\n1.\tRunning pass \"function(slp-vectorizer)\" on module \"<source>\"\r\n2.\tRunning pass \"slp-vectorizer\" on function \"test\"\r\n #0 0x00000000051b7378 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x51b7378)\r\n #1 0x00000000051b4d6c SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007ac42d642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x00007ac42d6969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\r\n #4 0x00007ac42d642476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #5 0x00007ac42d6287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #6 0x00007ac42d62871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #7 0x00007ac42d639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #8 0x00000000041e9132 llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::finalize(llvm::ArrayRef<int>, llvm::ArrayRef<std::pair<llvm::slpvectorizer::BoUpSLP::TreeEntry const*, unsigned int>>, llvm::ArrayRef<int>, unsigned int, llvm::function_ref<void (llvm::Value*&, llvm::SmallVectorImpl<int>&)>) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x41e9132)\r\n #9 0x00000000042256f9 llvm::InstructionCost llvm::slpvectorizer::BoUpSLP::processBuildVector<llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator, llvm::InstructionCost, llvm::TargetTransformInfo, llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP, llvm::SmallPtrSetImpl<llvm::Value*>>(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::Type*, llvm::TargetTransformInfo&, llvm::ArrayRef<llvm::Value*>&, llvm::slpvectorizer::BoUpSLP&, llvm::SmallPtrSetImpl<llvm::Value*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x42256f9)\r\n#10 0x000000000422f707 llvm::slpvectorizer::BoUpSLP::getEntryCost(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::SmallPtrSetImpl<llvm::Value*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x422f707)\r\n#11 0x00000000042636a1 llvm::slpvectorizer::BoUpSLP::getTreeCost(llvm::ArrayRef<llvm::Value*>) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x42636a1)\r\n#12 0x000000000426d57c llvm::SLPVectorizerPass::tryToVectorizeList(llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP&, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x426d57c)\r\n#13 0x000000000427168f bool llvm::SLPVectorizerPass::vectorizeCmpInsts<std::reverse_iterator<llvm::CmpInst* const*>>(llvm::iterator_range<std::reverse_iterator<llvm::CmpInst* const*>>, llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x427168f)\r\n#14 0x0000000004271fdb llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&)::'lambda3'(bool)::operator()(bool) const SLPVectorizer.cpp:0:0\r\n#15 0x0000000004275785 llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4275785)\r\n#16 0x000000000427bf86 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (.part.0) SLPVectorizer.cpp:0:0\r\n#17 0x000000000427ca9b llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x427ca9b)\r\n#18 0x0000000002fcc5ce llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2fcc5ce)\r\n#19 0x0000000004fb6a68 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4fb6a68)\r\n#20 0x0000000000e3dd4e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe3dd4e)\r\n#21 0x0000000004fb548e llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4fb548e)\r\n#22 0x0000000000e3d3fe llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xe3d3fe)\r\n#23 0x0000000004fb4ec0 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4fb4ec0)\r\n#24 0x000000000090ce7a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x90ce7a)\r\n#25 0x00000000008ff519 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8ff519)\r\n#26 0x00007ac42d629d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#27 0x00007ac42d629e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#28 0x00000000008f6d6e _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x8f6d6e)\r\nProgram terminated with signal: SIGSEGV\r\nCompiler returned: 139\r\n```",
    "author": "dtcxzyw",
    "labels": [
      "llvm:SLPVectorizer",
      "crash-on-valid"
    ],
    "comments": []
  }
}