{
  "bug_id": "141568",
  "issue_url": "https://github.com/llvm/llvm-project/issues/141568",
  "bug_type": "crash",
  "base_commit": "48a0bb71053bf4dd7884cae998ed341df02ecef3",
  "knowledge_cutoff": "2025-05-27T09:13:25Z",
  "lit_test_dir": [
    "llvm/test/Transforms/Inline"
  ],
  "hints": {
    "fix_commit": "0956febc4c1d7c66eae0064ce02dbb98880021dc",
    "components": [
      "IR"
    ],
    "bug_location_lineno": {
      "llvm/lib/IR/DebugInfo.cpp": [
        [
          375,
          380
        ],
        [
          385,
          395
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/IR/DebugInfo.cpp": [
        "DebugInfoFinder::addScope",
        "updateLoopMetadataDebugLocationsImpl"
      ]
    }
  },
  "patch": "commit 0956febc4c1d7c66eae0064ce02dbb98880021dc\nAuthor: Bj\u00f6rn Pettersson <bjorn.a.pettersson@ericsson.com>\nDate:   Thu Sep 25 15:20:55 2025 +0200\n\n    [DebugInfo] Handle followup loop metadata in updateLoopMetadataDebugLocations (#157557)\n    \n    Inliner/IROutliner/CodeExtractor all uses the\n    updateLoopMetadataDebugLocations helper in order to modify debug\n    location related to loop metadata. However, the helper has only\n    been updating DILocation nodes found as operands to the first level\n    of the MD_loop metadata. There could however be more DILocations\n    as part of the various kinds of followup metadata. A typical example\n    would be llvm.loop metadata like this\n    \n      !6 = distinct !{!6, !7, !8, !9, !10, !11}\n      !7 = !DILocation(line: 6, column: 3, scope: !3)\n      !8 = !DILocation(line: 7, column: 22, scope: !3)\n      !11 = !{!\"llvm.loop.distribute.followup_all\", !7, !8, ..., !14}\n      !14 = !{!\"llvm.loop.vectorize.followup_all\", !7, !8, ...}\n    \n    Instead of just updating !7 and !8 in !6, this patch make sure that\n    we now recursively update the DILocations in !11 and !14 as well.\n    \n    Fixes #141568\n\ndiff --git a/llvm/lib/IR/DebugInfo.cpp b/llvm/lib/IR/DebugInfo.cpp\nindex 166521a27664..f9ded507f832 100644\n--- a/llvm/lib/IR/DebugInfo.cpp\n+++ b/llvm/lib/IR/DebugInfo.cpp\n@@ -375,6 +375,38 @@ bool DebugInfoFinder::addScope(DIScope *Scope) {\n   return true;\n }\n \n+/// Recursively handle DILocations in followup metadata etc.\n+///\n+/// TODO: If for example a followup loop metadata would refence itself this\n+/// function would go into infinite recursion. We do not expect such cycles in\n+/// the loop metadata (except for the self-referencing first element\n+/// \"LoopID\"). However, we could at least handle such situations more gracefully\n+/// somehow (e.g. by keeping track of visited nodes and dropping metadata).\n+static Metadata *updateLoopMetadataDebugLocationsRecursive(\n+    Metadata *MetadataIn, function_ref<Metadata *(Metadata *)> Updater) {\n+  const MDTuple *M = dyn_cast_or_null<MDTuple>(MetadataIn);\n+  // The loop metadata options should start with a MDString.\n+  if (!M || M->getNumOperands() < 1 || !isa<MDString>(M->getOperand(0)))\n+    return MetadataIn;\n+\n+  bool Updated = false;\n+  SmallVector<Metadata *, 4> MDs{M->getOperand(0)};\n+  for (Metadata *MD : llvm::drop_begin(M->operands())) {\n+    if (!MD) {\n+      MDs.push_back(nullptr);\n+      continue;\n+    }\n+    Metadata *NewMD =\n+        Updater(updateLoopMetadataDebugLocationsRecursive(MD, Updater));\n+    if (NewMD)\n+      MDs.push_back(NewMD);\n+    Updated |= NewMD != MD;\n+  }\n+\n+  assert(!M->isDistinct() && \"M should not be distinct.\");\n+  return Updated ? MDNode::get(M->getContext(), MDs) : MetadataIn;\n+}\n+\n static MDNode *updateLoopMetadataDebugLocationsImpl(\n     MDNode *OrigLoopID, function_ref<Metadata *(Metadata *)> Updater) {\n   assert(OrigLoopID && OrigLoopID->getNumOperands() > 0 &&\n@@ -385,11 +417,11 @@ static MDNode *updateLoopMetadataDebugLocationsImpl(\n   // Save space for the self-referential LoopID.\n   SmallVector<Metadata *, 4> MDs = {nullptr};\n \n-  for (unsigned i = 1; i < OrigLoopID->getNumOperands(); ++i) {\n-    Metadata *MD = OrigLoopID->getOperand(i);\n+  for (Metadata *MD : llvm::drop_begin(OrigLoopID->operands())) {\n     if (!MD)\n       MDs.push_back(nullptr);\n-    else if (Metadata *NewMD = Updater(MD))\n+    else if (Metadata *NewMD = Updater(\n+                 updateLoopMetadataDebugLocationsRecursive(MD, Updater)))\n       MDs.push_back(NewMD);\n   }\n \n",
  "tests": [
    {
      "file": "llvm/test/Transforms/Inline/dilocation-loop-metadata-update.ll",
      "commands": [
        "opt < %s -passes=inline -S"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n; When inlining we need to update DILocation recursively for the followup\n; metadata when updating llvm.loop metadata.\n\ndefine void @a() !dbg !3 {\n;\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  br label %for.body, !llvm.loop !6\n}\n\ndefine void @f() !dbg !17 {\n;\nentry:\n  call void @a(), !dbg !18\n  ret void\n}\n\n!llvm.dbg.cu = !{!0}\n!llvm.module.flags = !{!2}\n\n!0 = distinct !DICompileUnit(language: DW_LANG_C11, file: !1, producer: \"clang\", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, splitDebugInlining: false, nameTableKind: None)\n!1 = !DIFile(filename: \"foo.c\", directory: \"/\")\n!2 = !{i32 2, !\"Debug Info Version\", i32 3}\n!3 = distinct !DISubprogram(name: \"a\", scope: !1, file: !1, line: 3, type: !4, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)\n!4 = !DISubroutineType(types: !5)\n!5 = !{}\n!6 = distinct !{!6, !7, !8, !9, !10, !11}\n!7 = !DILocation(line: 6, column: 3, scope: !3)\n!8 = !DILocation(line: 7, column: 22, scope: !3)\n!9 = !{!\"llvm.loop.mustprogress\"}\n!10 = !{!\"llvm.loop.distribute.enable\", i1 true}\n!11 = !{!\"llvm.loop.distribute.followup_all\", !7, !8, !9, !12, !13, !14}\n!12 = !{!\"llvm.loop.vectorize.width\", i32 8}\n!13 = !{!\"llvm.loop.vectorize.enable\", i1 true}\n!14 = !{!\"llvm.loop.vectorize.followup_all\", !7, !8, !9, !15, !16}\n!15 = !{!\"llvm.loop.isvectorized\"}\n!16 = !{!\"llvm.loop.unroll.count\", i32 1}\n!17 = distinct !DISubprogram(name: \"f\", scope: !1, file: !1, line: 9, type: !4, scopeLine: 9, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)\n!18 = !DILocation(line: 9, column: 12, scope: !17)\n;.\n;."
        }
      ]
    }
  ],
  "issue": {
    "title": "\"!dbg attachment points at wrong subprogram for function\" after InlinerPass",
    "body": "llvm commit: 8fe33a05b94d\nReproduce with:\n```opt -passes=\"inline\" bbi-106975.ll -S -verify-each```\nResult:\n```\n!dbg attachment points at wrong subprogram for function\n!15 = distinct !DISubprogram(name: \"f\", scope: !1, file: !1, line: 9, type: !6, scopeLine: 9, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)\nptr @f\n  br label %for.body.i, !llvm.loop !3\n!4 = !DILocation(line: 6, column: 3, scope: !5)\n!5 = distinct !DISubprogram(name: \"a\", scope: !1, file: !1, line: 3, type: !6, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)\n!5 = distinct !DISubprogram(name: \"a\", scope: !1, file: !1, line: 3, type: !6, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)\nLLVM ERROR: Broken module found after pass \"InlinerPass\", compilation aborted!\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: build-all/bin/opt -passes=inline bbi-106975.ll -S -verify-each\n1.\tRunning pass \"cgscc(inline)\" on module \"bbi-106975.ll\"\n #0 0x000055e012d317c6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (build-all/bin/opt+0x46be7c6)\n #1 0x000055e012d2f20e llvm::sys::RunSignalHandlers() (build-all/bin/opt+0x46bc20e)\n #2 0x000055e012d320b9 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x00007fd2706c6d10 __restore_rt (/lib64/libpthread.so.0+0x12d10)\n #4 0x00007fd26e06652f raise (/lib64/libc.so.6+0x4e52f)\n #5 0x00007fd26e039e65 abort (/lib64/libc.so.6+0x21e65)\n #6 0x000055e012d17ef3 llvm::report_fatal_error(llvm::Twine const&, bool) (build-all/bin/opt+0x46a4ef3)\n #7 0x000055e0141b113a void llvm::detail::UniqueFunctionBase<void, llvm::StringRef, llvm::Any, llvm::PreservedAnalyses const&>::CallImpl<llvm::VerifyInstrumentation::registerCallbacks(llvm::PassInstrumentationCallbacks&, llvm::AnalysisManager<llvm::Module>*)::$_0>(void*, llvm::StringRef, llvm::Any&, llvm::PreservedAnalyses const&) StandardInstrumentations.cpp:0:0\n #8 0x000055e0139344e2 llvm::PassManager<llvm::LazyCallGraph::SCC, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) (build-all/bin/opt+0x52c14e2)\n #9 0x000055e0141f79fd llvm::detail::PassModel<llvm::LazyCallGraph::SCC, llvm::PassManager<llvm::LazyCallGraph::SCC, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&>::run(llvm::LazyCallGraph::SCC&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::LazyCallGraph&, llvm::CGSCCUpdateResult&) PassBuilderPipelines.cpp:0:0\n#10 0x000055e013935a7d llvm::ModuleToPostOrderCGSCCPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (build-all/bin/opt+0x52c2a7d)\n#11 0x000055e0141f7b6d llvm::detail::PassModel<llvm::Module, llvm::ModuleToPostOrderCGSCCPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) PassBuilderPipelines.cpp:0:0\n#12 0x000055e012f21bf7 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (build-all/bin/opt+0x48aebf7)\n#13 0x000055e014183dec llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (build-all/bin/opt+0x5b10dec)\n#14 0x000055e012cf3c7e optMain (build-all/bin/opt+0x4680c7e)\n#15 0x00007fd26e0527e5 __libc_start_main (/lib64/libc.so.6+0x3a7e5)\n#16 0x000055e012cf176e _start (build-all/bin/opt+0x467e76e)\nAbort (core dumped)\n```\nThis doesn't seem to be new, I've reproduced it with old builds from June 2019.\n\n\n[bbi-106975.ll.gz](https://github.com/user-attachments/files/20453899/bbi-106975.ll.gz)",
    "author": "mikaelholmen",
    "labels": [
      "debuginfo",
      "crash",
      "llvm:ir"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  }
}