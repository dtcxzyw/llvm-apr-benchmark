{
  "bug_id": "87407",
  "issue_url": "https://github.com/llvm/llvm-project/issues/87407",
  "bug_type": "crash",
  "base_commit": "980d027a3f2fbce173ad813a3f01bb51c2c2bc4b",
  "knowledge_cutoff": "2024-04-02T20:25:12Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "49842426f3fc70af756f9e6fe80ecf829178a1b2",
    "components": [
      "LoopVectorize",
      "VectorUtils"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/VectorUtils.cpp": [
        [
          827,
          832
        ],
        [
          882,
          888
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          1639,
          1645
        ],
        [
          1712,
          1718
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/VectorUtils.cpp": [
        "llvm::computeMinimumValueSizes"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::truncateToMinimalBitwidths"
      ]
    }
  },
  "patch": "commit 49842426f3fc70af756f9e6fe80ecf829178a1b2\nAuthor: Ramkumar Ramachandra <ramkumar.ramachandra@codasip.com>\nDate:   Tue Apr 29 09:47:38 2025 +0100\n\n    [LV] Fix MinBWs in WidenIntrinsic case (#137005)\n    \n    There is a bug in the computation and handling of MinBWs in the case of\n    VPWidenIntrinsicRecipe: a crash is observed in\n    VPlanTransforms::truncateToMinimalBitwidths due to a mismatch between\n    the number of recipes processed and the number of entries in MinBWs. Fix\n    handling of calls in llvm::computeMinimumValueSizes, and handle\n    VPWidenIntrinsicRecipe in truncateToMinimalBitwidths, fixing the bug.\n    \n    Fixes #87407.\n\ndiff --git a/llvm/lib/Analysis/VectorUtils.cpp b/llvm/lib/Analysis/VectorUtils.cpp\nindex 6448c372f5d5..4d394ea4d99c 100644\n--- a/llvm/lib/Analysis/VectorUtils.cpp\n+++ b/llvm/lib/Analysis/VectorUtils.cpp\n@@ -827,6 +827,11 @@ llvm::computeMinimumValueSizes(ArrayRef<BasicBlock *> Blocks, DemandedBits &DB,\n     if (isa<PHINode>(I))\n       continue;\n \n+    // Don't modify the types of operands of a call, as doing that would cause a\n+    // signature mismatch.\n+    if (isa<CallBase>(I))\n+      continue;\n+\n     if (DBits[Leader] == ~0ULL)\n       // All bits demanded, no point continuing.\n       continue;\n@@ -882,7 +887,9 @@ llvm::computeMinimumValueSizes(ArrayRef<BasicBlock *> Blocks, DemandedBits &DB,\n \n       // If any of M's operands demand more bits than MinBW then M cannot be\n       // performed safely in MinBW.\n-      if (any_of(MI->operands(), [&DB, MinBW](Use &U) {\n+      auto *Call = dyn_cast<CallBase>(MI);\n+      auto Ops = Call ? Call->args() : MI->operands();\n+      if (any_of(Ops, [&DB, MinBW](Use &U) {\n             auto *CI = dyn_cast<ConstantInt>(U);\n             // For constants shift amounts, check if the shift would result in\n             // poison.\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex 8e43d856c277..7093d378d8c3 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -1639,7 +1639,8 @@ void VPlanTransforms::truncateToMinimalBitwidths(\n            vp_depth_first_deep(Plan.getVectorLoopRegion()))) {\n     for (VPRecipeBase &R : make_early_inc_range(*VPBB)) {\n       if (!isa<VPWidenRecipe, VPWidenCastRecipe, VPReplicateRecipe,\n-               VPWidenSelectRecipe, VPWidenLoadRecipe>(&R))\n+               VPWidenSelectRecipe, VPWidenLoadRecipe, VPWidenIntrinsicRecipe>(\n+              &R))\n         continue;\n \n       VPValue *ResultVPV = R.getVPSingleValue();\n@@ -1712,7 +1713,7 @@ void VPlanTransforms::truncateToMinimalBitwidths(\n       }\n \n       assert(!isa<VPWidenStoreRecipe>(&R) && \"stores cannot be narrowed\");\n-      if (isa<VPWidenLoadRecipe>(&R))\n+      if (isa<VPWidenLoadRecipe, VPWidenIntrinsicRecipe>(&R))\n         continue;\n \n       // Shrink operands by introducing truncates as needed.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/pr87407-trunc-with-intrinsic.ll",
      "commands": [
        "opt -passes=loop-vectorize -force-vector-width=4 -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine i8 @pr87407(i8 %x, i64 %y, i64 %n) {\n;\nentry:\n  %zext.x = zext i8 %x to i64\n  br label %loop\n\nloop:\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %max = tail call i64 @llvm.umax.i64(i64 %zext.x, i64 %y)\n  %cmp.max.0 = icmp ne i64 %max, 0\n  %zext.cmp = zext i1 %cmp.max.0 to i64\n  %trunc = trunc i64 %zext.cmp to i32\n  %shl = shl i32 %trunc, 8\n  %res = trunc i32 %shl to i8\n  %iv.next = add i64 %iv, 1\n  %exit.cond = icmp ne i64 %iv.next, %n\n  br i1 %exit.cond, label %loop, label %exit\n\nexit:\n  ret i8 %res\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize][VPlan] Assertion `MinBWs.size() == NumProcessedRecipes && \"some entries in MinBWs haven't been processed\"' failed.",
    "body": "Reduced LLVM IR:\r\n``` llvm ir\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine i32 @main() #0 {\r\nentry:\r\n  %conv21.us.i = sext i16 0 to i32\r\n  br label %for.cond3.preheader.us.i\r\n\r\nfor.cond3.preheader.us.i:                         ; preds = %for.cond3.preheader.us.i, %entry\r\n  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.cond3.preheader.us.i ], [ 0, %entry ]\r\n  %add67.lcssa7984.us.i = phi i8 [ %2, %for.cond3.preheader.us.i ], [ 0, %entry ]\r\n  %.conv21.us99.i = tail call i32 @llvm.smax.i32(i32 0, i32 %conv21.us.i)\r\n  %cmp35.us100.i = icmp eq i32 %.conv21.us99.i, 0\r\n  %conv36.us101.i = zext i1 %cmp35.us100.i to i32\r\n  %0 = lshr i32 %conv36.us101.i, 1\r\n  %1 = trunc i32 %0 to i8\r\n  %2 = or i8 %add67.lcssa7984.us.i, %1\r\n  %indvars.iv.next.i = add i64 %indvars.iv.i, 1\r\n  %cmp.us.i = icmp slt i64 %indvars.iv.i, 1\r\n  br i1 %cmp.us.i, label %for.cond3.preheader.us.i, label %for.cond.for.cond.cleanup_crit_edge.split.us.i\r\n\r\nfor.cond.for.cond.cleanup_crit_edge.split.us.i:   ; preds = %for.cond3.preheader.us.i\r\n  store i8 %2, ptr null, align 1\r\n  ret i32 0\r\n}\r\n\r\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\r\ndeclare i32 @llvm.smax.i32(i32, i32) #1\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\r\nattributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\r\n```\r\n\r\nBacktrace:\r\n```\r\nopt: /scratch/tc-testing/tc-apr-2/llvm/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:1061: static void llvm::VPlanTransforms::truncateToMinimalBitwidths(llvm::VPlan&, const llvm::MapVector<llvm::Instruction*, long unsigned int>&, llvm\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt --passes=loop-vectorize reduced.ll\r\n #0 0x0000596ae80c5b60 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2d84b60)\r\n #1 0x0000596ae80c2f6f llvm::sys::RunSignalHandlers() (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2d81f6f)\r\n #2 0x0000596ae80c30c5 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x00007a0a45642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007a0a456969fc __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\r\n #5 0x00007a0a456969fc __pthread_kill_internal ./nptl/pthread_kill.c:78:10\r\n #6 0x00007a0a456969fc pthread_kill ./nptl/pthread_kill.c:89:10\r\n #7 0x00007a0a45642476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #8 0x00007a0a456287f3 abort ./stdlib/abort.c:81:7\r\n #9 0x00007a0a4562871b _nl_load_domain ./intl/loadmsgcat.c:1177:9\r\n#10 0x00007a0a45639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#11 0x0000596ae7260af2 llvm::VPlanTransforms::truncateToMinimalBitwidths(llvm::VPlan&, llvm::MapVector<llvm::Instruction*, unsigned long, llvm::DenseMap<llvm::Instruction*, unsigned int, llvm::DenseMapInfo<llvm::Instruction*, void>, llvm::detail::DenseMapPair<llvm::Instruction*, unsigned int>>, llvm::SmallVector<std::pair<llvm::Instruction*, unsigned long>, 0u>> const&, llvm::LLVMContext&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1f1faf2)\r\n#12 0x0000596ae7135f3e llvm::LoopVectorizationPlanner::buildVPlansWithVPRecipes(llvm::ElementCount, llvm::ElementCount) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1df4f3e)\r\n#13 0x0000596ae713c319 llvm::LoopVectorizationPlanner::plan(llvm::ElementCount, unsigned int) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1dfb319)\r\n#14 0x0000596ae713f8a9 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1dfe8a9)\r\n#15 0x0000596ae714273e llvm::LoopVectorizePass::runImpl(llvm::Function&, llvm::ScalarEvolution&, llvm::LoopInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::BlockFrequencyInfo*, llvm::TargetLibraryInfo*, llvm::DemandedBits&, llvm::AssumptionCache&, llvm::LoopAccessInfoManager&, llvm::OptimizationRemarkEmitter&, llvm::ProfileSummaryInfo*) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1e0173e)\r\n#16 0x0000596ae714388d llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x1e0288d)\r\n#17 0x0000596ae604a276 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0xd09276)\r\n#18 0x0000596ae7eec141 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2bab141)\r\n#19 0x0000596ae6041bd6 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0xd00bd6)\r\n#20 0x0000596ae7eeae3b llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2ba9e3b)\r\n#21 0x0000596ae6049dc6 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0xd08dc6)\r\n#22 0x0000596ae7ee8cb1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x2ba7cb1)\r\n#23 0x0000596ae58c3ce5 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x582ce5)\r\n#24 0x0000596ae58b6316 optMain (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x575316)\r\n#25 0x00007a0a45629d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#26 0x00007a0a45629e40 call_init ./csu/../csu/libc-start.c:128:20\r\n#27 0x00007a0a45629e40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#28 0x0000596ae58abf95 _start (/scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt+0x56af95)\r\nzsh: IOT instruction (core dumped)  /scratch/tc-testing/tc-apr-2/build-rv64gcv/build-llvm-linux/bin/opt\r\n```\r\n\r\nGodbolt: https://godbolt.org/z/6TxWGMz6e\r\n\r\nAssert: https://github.com/llvm/llvm-project/blob/c403a478076a16172d9b50e16c288b0d360f42ce/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp#L1061-L1063\r\n\r\nFound via fuzzer.",
    "author": "patrick-rivos",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "patrick-rivos",
        "body": "Partially cleaned up testcase:\r\n```llvm ir\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\ntarget triple = \"riscv64-unknown-linux-gnu\"\r\n\r\ndefine i32 @main() #0 {\r\nentry:\r\n  %sext.0 = sext i16 0 to i32\r\n  br label %loop.preheader\r\n\r\nloop.preheader:                         ; preds = %loop.preheader, %entry\r\n  %iv.i = phi i64 [ %iv.next.i, %loop.preheader ], [ 0, %entry ]\r\n  %phi.0 = phi i8 [ %or.0, %loop.preheader ], [ 0, %entry ]\r\n  %max.0 = tail call i32 @llvm.smax.i32(i32 0, i32 %sext.0)\r\n  %cmp = icmp eq i32 %max.0, 0\r\n  %zext.true = zext i1 %cmp to i32\r\n  %0 = lshr i32 %zext.true, 1\r\n  %1 = trunc i32 %0 to i8\r\n  %or.0 = or i8 %phi.0, %1\r\n  %iv.next.i = add i64 %iv.i, 1\r\n  %cmp.us.i = icmp slt i64 %iv.i, 1\r\n  br i1 %cmp.us.i, label %loop.preheader, label %loop.exit\r\n\r\nloop.exit:   ; preds = %loop.preheader\r\n  store i8 %or.0, ptr null, align 1\r\n  ret i32 0\r\n}\r\n\r\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\r\ndeclare i32 @llvm.smax.i32(i32, i32) #1\r\n\r\nattributes #0 = { \"target-features\"=\"+64bit,+v\" }\r\n```\r\n\r\nBasic analysis:\r\n\r\nThe issue is caused by:\r\nhttps://github.com/llvm/llvm-project/blob/39bfdb7f33f7f53ab662c5cea25129c45a9b4c11/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp#L1074-L1076\r\nwhen `%sext.0 = sext i16 0 to i32` is the only unaccounted for MinBWs entry.\r\n\r\n`Op->getLiveInIRValue()` returns a _Constant_ `i32 0`, so the dynamic cast to _Instruction_ returns a null pointer which does not exist in MinBWs.\r\n\r\nI think the _Constant_ is an optimized `sext i16 0 to i32` so I'll try to find where the constant comes from next."
      },
      {
        "author": "patrick-rivos",
        "body": "Alright I _think_ I understand everything that's going on here\r\n\r\nUsing this testcase:\r\n```llvm ir\r\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\r\n\r\ndefine i32 @main() #1 {\r\nentry:\r\n  %zext.0 = zext i8 0 to i64\r\n  br label %loop\r\n\r\nloop:                             ; preds = %loop, %entry\r\n  %phi.0 = phi i64 [ %incrementor, %loop ], [ 0, %entry ]\r\n  %incrementor = add i64 %phi.0, 1\r\n  %max.0 = tail call i64 @llvm.umax.i64(i64 %zext.0, i64 0)\r\n  %cmp.0 = icmp ne i64 %max.0, 0\r\n  %zext.1 = zext i1 %cmp.0 to i64\r\n  %trunc.0 = trunc i64 %zext.1 to i32\r\n  %shl.0 = shl i32 %trunc.0, 8 ; Truncate and shift to make all bits dead\r\n  %trunc.1 = trunc i32 %shl.0 to i8\r\n  %exitcond6 = icmp ne i64 %phi.0, 16\r\n  br i1 %exitcond6, label %loop, label %loop.exit\r\n\r\nloop.exit:                           ; preds = %loop\r\n  store i8 %trunc.1, ptr null, align 1\r\n  ret i32 0\r\n}\r\n\r\nattributes #1 = { \"target-features\"=\"+v\" }\r\n```\r\n\r\ncomputeMinimumValueSizes operates on a region, but a chain terminated with one instruction outside the bounds of the region is still considered valid. This compounded with weirdness with WIDEN-CALL causes issues in truncateToMinimalBitwidths where this range is considered:\r\n```\r\n<x1> vector loop: {\r\n  vector.body:\r\n    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>\r\n    WIDEN-INDUCTION %phi.0 = phi %incrementor, 0, ir<1>\r\n    CLONE ir<%incrementor> = add ir<%phi.0>, ir<1>\r\n    WIDEN-CALL ir<%max.0> = call @llvm.umax.i64(ir<%zext.0>, ir<0>) (using vector intrinsic)\r\n    WIDEN ir<%cmp.0> = icmp ne ir<%max.0>, ir<0>\r\n    WIDEN-CAST ir<%zext.1> = zext  ir<%cmp.0> to i64\r\n    WIDEN-CAST ir<%trunc.0> = trunc  ir<%zext.1> to i32\r\n    WIDEN ir<%shl.0> = shl ir<%trunc.0>, ir<8>\r\n    WIDEN-CAST ir<%trunc.1> = trunc  ir<%shl.0> to i8\r\n    CLONE ir<%exitcond6> = icmp ne ir<%phi.0>, ir<16>\r\n  Successor(s):\r\n\r\n  :\r\n  Successor(s): vector.latch\r\n\r\n  vector.latch:\r\n    EMIT vp<%3> = add nuw vp<%2>, vp<%0>\r\n    EMIT branch-on-count vp<%3>, vp<%1>\r\n  No successors\r\n}\r\nSuccessor(s): middle.block\r\n```\r\n\r\nThe MinBWs are:\r\n```\r\n%cmp.0 = icmp ne i64 %max.0, 0 Size: 1\r\n%zext.0 = zext i8 0 to i64 Size: 1\r\n```\r\n\r\ncomp.0 is found easily but zext.0 isn't in the region. Normally chains outside the region are handled\r\nby [this](https://github.com/llvm/llvm-project/blob/eae7554d3f1fb1546c629a9a2ae0654b1001ab41/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp#L1056) which pulls in arguments.\r\n\r\nWe don't consider WIDEN-CALL since it doesn't have an [entry in MinBW](https://github.com/llvm/llvm-project/blob/eae7554d3f1fb1546c629a9a2ae0654b1001ab41/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp#L984-L986) (and isn't [allowed](https://github.com/llvm/llvm-project/blob/eae7554d3f1fb1546c629a9a2ae0654b1001ab41/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp#L978-L979)).\r\nIt doesn't have an entry since the function call uses a ptr which cannot be truncated so [that op fails to truncate](https://github.com/llvm/llvm-project/blob/main/llvm/lib/Analysis/VectorUtils.cpp#L682-L693).\r\n\r\nDemandedBits understands a [subset of all intrinsics](https://github.com/llvm/llvm-project/blob/49bb993959668b3f319e9ea5fa0c97a41ab0890e/llvm/lib/Analysis/DemandedBits.cpp#L87-L149) while VPlanAnalysis doesn't handle any of them (for the pointer reason).\r\n\r\n## Fix\r\n\r\nThis can be fixed by ignoring the call function pointer argument for all intrinsic cases that DemandedBits handles.\r\n\r\nVPWidenCallRecipe also needs a way to specify a new return type when executed so I added getResultType and setResultType methods.\r\n\r\nI'll submit a PR soon.\r\n"
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  },
  "bisect": "N/A"
}