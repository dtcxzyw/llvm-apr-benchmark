{
  "bug_id": "158660",
  "issue_url": "https://github.com/llvm/llvm-project/issues/158660",
  "bug_type": "crash",
  "base_commit": "dbc96f41f15fc30d4fc6198eb1c2dcb57547a160",
  "knowledge_cutoff": "2025-09-15T15:25:10Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "1858532c48cf5d93aa82966110fe1cada6ab6ba8",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          3163,
          3171
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPReplicateRecipe::computeCost"
      ]
    }
  },
  "patch": "commit 1858532c48cf5d93aa82966110fe1cada6ab6ba8\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Mon Sep 15 21:46:49 2025 +0100\n\n    [VPlan] Handle predicated UDiv in VPReplicateRecipe::computeCost.\n    \n    Account for predicated UDiv,SDiv,URem,SRem in\n    VPReplicateRecipe::computeCost: compute costs of extra phis and apply\n    getPredBlockCostDivisor.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/158660\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 723363fba572..2844b8348027 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -3163,9 +3163,22 @@ InstructionCost VPReplicateRecipe::computeCost(ElementCount VF,\n     if (isSingleScalar())\n       return ScalarCost;\n \n-    return ScalarCost * VF.getFixedValue() +\n-           Ctx.getScalarizationOverhead(Ctx.Types.inferScalarType(this),\n-                                        to_vector(operands()), VF);\n+    ScalarCost = ScalarCost * VF.getFixedValue() +\n+                 Ctx.getScalarizationOverhead(Ctx.Types.inferScalarType(this),\n+                                              to_vector(operands()), VF);\n+    // If the recipe is not predicated (i.e. not in a replicate region), return\n+    // the scalar cost. Otherwise handle predicated cost.\n+    if (!getParent()->getParent()->isReplicator())\n+      return ScalarCost;\n+\n+    // Account for the phi nodes that we will create.\n+    ScalarCost += VF.getFixedValue() *\n+                  Ctx.TTI.getCFInstrCost(Instruction::PHI, Ctx.CostKind);\n+    // Scale the cost by the probability of executing the predicated blocks.\n+    // This assumes the predicated block for each vector lane is equally\n+    // likely.\n+    ScalarCost /= getPredBlockCostDivisor(Ctx.CostKind);\n+    return ScalarCost;\n   }\n   case Instruction::Load:\n   case Instruction::Store: {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-conditional-branches.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7-avx -S"
      ],
      "tests": [
        {
          "test_name": "test_predicated_udiv",
          "test_body": "target triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @test_predicated_udiv(i32 %d, i1 %c) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  br i1 %c, label %loop.latch, label %then\n\nthen:                                             ; preds = %loop.header\n  %call = tail call i32 @llvm.usub.sat.i32(i32 %iv, i32 1)\n  %udiv = udiv i32 %call, %d\n  %zext = zext i32 %udiv to i64\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %then, %loop.header\n  %merge = phi i64 [ %zext, %then ], [ 0, %loop.header ]\n  %iv.next = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 1000\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret i64 %merge\n}\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.usub.sat.i32(i32, i32) #1\n\nattributes #0 = { \"target-cpu\"=\"znver3\" }\nattributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "New case of \"VPlan cost model and legacy cost model disagreed\"",
    "body": "Our testing encountered a new regression which bisects to 91d4c0dfdf226665c17d4a44e2fab466e6103d18 (tag @fhahn ).\n\nLet me know if you need any more info!\n\n\nhttps://godbolt.org/z/r4qo3e9fs\n\n```\ntarget triple = \"x86_64-unknown-unknown\"\n\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.usub.sat.i32(i32, i32) #0\n\ndefine i64 @baz(i32 %arg, i1 %arg1) #1 {\nbb:\n  br label %bb3\n\nbb2:                                              ; preds = %bb5\n  ret i64 %phi6\n\nbb3:                                              ; preds = %bb5, %bb\n  %phi = phi i32 [ 0, %bb ], [ %add, %bb5 ]\n  br i1 %arg1, label %bb5, label %bb4\n\nbb4:                                              ; preds = %bb3\n  %call = tail call i32 @llvm.usub.sat.i32(i32 %phi, i32 1)\n  %udiv = udiv i32 %call, %arg\n  %zext = zext i32 %udiv to i64\n  br label %bb5\n\nbb5:                                              ; preds = %bb4, %bb3\n  %phi6 = phi i64 [ %zext, %bb4 ], [ 0, %bb3 ]\n  %add = add i32 %phi, 1\n  %icmp = icmp eq i32 %phi, %arg\n  br i1 %icmp, label %bb2, label %bb3\n}\n\nattributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }\nattributes #1 = { \"target-cpu\"=\"znver2\" }\n```\n\n```\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7074: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || BestPlan.hasEarlyExit() || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop, BestFactor.Width) || planContainsAdditionalSimplifications( getPlanFor(LegacyVF.Width), CostCtx, OrigLoop, LegacyVF.Width)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S --passes=loop-vectorize <source>\n1.\tRunning pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"<source>\"\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"baz\"\n #0 0x00000000058a7268 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x58a7268)\n #1 0x00000000058a4114 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x0000710df7042520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x0000710df70969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x0000710df7042476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x0000710df70287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x0000710df702871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x0000710df7039e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x000000000362ead6 llvm::LoopVectorizationPlanner::computeBestVF() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x362ead6)\n #9 0x000000000363c224 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x363c224)\n#10 0x000000000363f420 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x363f420)\n#11 0x000000000363fb05 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x363fb05)\n#12 0x0000000002f3816e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2f3816e)\n#13 0x00000000056905d1 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x56905d1)\n#14 0x0000000000eec31e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xeec31e)\n#15 0x000000000568eb3a llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x568eb3a)\n#16 0x000000000096f54e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x96f54e)\n#17 0x000000000568e4f1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x568e4f1)\n#18 0x0000000000979848 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x979848)\n#19 0x000000000096d8c9 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x96d8c9)\n#20 0x0000710df7029d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#21 0x0000710df7029e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#22 0x0000000000964a15 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x964a15)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "gregbedwell",
    "labels": [
      "vectorizers",
      "crash-on-valid"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}