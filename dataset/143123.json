{
  "bug_id": "143123",
  "issue_url": "https://github.com/llvm/llvm-project/issues/143123",
  "bug_type": "miscompilation",
  "base_commit": "5d3899d293e902124c3602b466031b6b799fb123",
  "knowledge_cutoff": "2025-06-06T12:10:51Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "2f15637e04f51e3ef435c0c0d39aab0e8b933023",
    "components": [
      "ValueTracking"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        [
          8660,
          8665
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/ValueTracking.cpp": [
        "matchSelectPattern"
      ]
    }
  },
  "patch": "commit 2f15637e04f51e3ef435c0c0d39aab0e8b933023\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Mon Jun 9 15:46:09 2025 +0800\n\n    [ValueTracking] Update `Ordered` when both operands are non-NaN. (#143349)\n    \n    When the original predicate is ordered and both operands are non-NaN,\n    `Ordered` should be set to true. This variable still matters even if\n    both operands are non-NaN because FMF only applies to select, not fcmp.\n    \n    Closes https://github.com/llvm/llvm-project/issues/143123.\n\ndiff --git a/llvm/lib/Analysis/ValueTracking.cpp b/llvm/lib/Analysis/ValueTracking.cpp\nindex d6bb852e208f..d8c1096049dc 100644\n--- a/llvm/lib/Analysis/ValueTracking.cpp\n+++ b/llvm/lib/Analysis/ValueTracking.cpp\n@@ -8660,6 +8660,7 @@ static SelectPatternResult matchSelectPattern(CmpInst::Predicate Pred,\n     if (LHSSafe && RHSSafe) {\n       // Both operands are known non-NaN.\n       NaNBehavior = SPNB_RETURNS_ANY;\n+      Ordered = CmpInst::isOrdered(Pred);\n     } else if (CmpInst::isOrdered(Pred)) {\n       // An ordered comparison will return false when given a NaN, so it\n       // returns the RHS.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/fcmp-select.ll",
      "commands": [
        "opt < %s -passes=instcombine -S"
      ],
      "tests": [
        {
          "test_name": "test_fcmp_ord_select_fcmp_oeq_var_const",
          "test_body": "define i1 @test_fcmp_ord_select_fcmp_oeq_var_const(double %x) {\n  %cmp1 = fcmp ord double %x, 0.000000e+00\n  %sel = select i1 %cmp1, double %x, double 0.000000e+00\n  %cmp2 = fcmp oeq double %sel, 1.000000e+00\n  ret i1 %cmp2\n}\n"
        },
        {
          "test_name": "test_select_nnan_nsz_fcmp_olt",
          "test_body": "define float @test_select_nnan_nsz_fcmp_olt(float %x) {\n  %cmp = fcmp olt float %x, 0.000000e+00\n  %sel = select nnan nsz i1 %cmp, float %x, float -0.000000e+00\n  ret float %sel\n}\n"
        },
        {
          "test_name": "test_select_nnan_nsz_fcmp_ult",
          "test_body": "define float @test_select_nnan_nsz_fcmp_ult(float %x) {\n  %cmp = fcmp ult float %x, 0.000000e+00\n  %sel = select nnan nsz i1 %cmp, float %x, float -0.000000e+00\n  ret float %sel\n}\n"
        },
        {
          "test_name": "test_fcmp_select_var_const_unordered",
          "test_body": "define i1 @test_fcmp_select_var_const_unordered(double %x, double %y) {\n  %cmp1 = fcmp ult double %x, 0x3E80000000000000\n  %sel = select i1 %cmp1, double %y, double 0.000000e+00\n  %cmp2 = fcmp ugt double %sel, 0x3E80000000000000\n  ret i1 %cmp2\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[InstCombine] fcmp is incorrectly inverted",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/yVw9wM\n```\ndefine float @src(float %x) {\n  %cmp = fcmp olt float %x, 0.000000e+00\n  %sel = select nnan nsz i1 %cmp, float %x, float -0.000000e+00\n  ret float %sel\n}\n\ndefine float @tgt(float %x) {\n  %.inv = fcmp oge float %x, 0.000000e+00\n  %sel1 = select i1 %.inv, float -0.000000e+00, float %x\n  ret float %sel1\n}\n```\n```\n----------------------------------------\ndefine float @src(float %x) {\n#0:\n  %cmp = fcmp olt float %x, 0.000000\n  %sel = select nnan nsz i1 %cmp, float %x, float -0.000000\n  ret float %sel\n}\n=>\ndefine float @tgt(float %x) {\n#0:\n  %.inv = fcmp oge float %x, 0.000000\n  %sel1 = select i1 %.inv, float -0.000000, float %x\n  ret float %sel1\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nExample:\nfloat %x = #x7f800002 (SNaN)\n\nSource:\ni1 %cmp = #x0 (0)\nfloat %sel = #x80000000 (-0.0)\n\nTarget:\ni1 %.inv = #x0 (0)\nfloat %sel1 = #x7f800002 (SNaN)\nSource value: #x80000000 (-0.0)\nTarget value: #x7f800002 (SNaN)\n```\n",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "floating-point",
      "llvm:analysis",
      "generated by fuzzer"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "1984c7539ebeb2697233f8163a051a2ce0d4fa50"
}