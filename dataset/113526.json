{
  "bug_id": "113526",
  "issue_url": "https://github.com/llvm/llvm-project/issues/113526",
  "bug_type": "crash",
  "base_commit": "8c4bc1e75de27adfbaead34b895b0efbaf17bd02",
  "knowledge_cutoff": "2024-10-24T06:14:03Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "e724226da753f10fd36fbb0ea392f04ab0fdbdab",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          1524,
          1529
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPWidenCastRecipe::computeCost"
      ]
    }
  },
  "patch": "commit e724226da753f10fd36fbb0ea392f04ab0fdbdab\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Fri Oct 25 12:35:33 2024 +0100\n\n    [VPlan] Return cost of 0 for VPWidenCastRecipe without underlying value.\n    \n    In some cases, VPWidenCastRecipes are created but not considered in the\n    legacy cost model, including truncates/extends when evaluating a reduction\n    in a smaller type. Return 0 for such casts for now, to avoid divergences\n    between VPlan and legacy cost models.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/113526.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 0eb4f7c7c88c..2080b77157b6 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -1524,6 +1524,11 @@ void VPWidenCastRecipe::execute(VPTransformState &State) {\n \n InstructionCost VPWidenCastRecipe::computeCost(ElementCount VF,\n                                                VPCostContext &Ctx) const {\n+  // TODO: In some cases, VPWidenCastRecipes are created but not considered in\n+  // the legacy cost model, including truncates/extends when evaluating a\n+  // reduction in a smaller type.\n+  if (!getUnderlyingValue())\n+    return 0;\n   // Computes the CastContextHint from a recipes that may access memory.\n   auto ComputeCCH = [&](const VPRecipeBase *R) -> TTI::CastContextHint {\n     if (VF.isScalar())\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/cost-model.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7-avx -S"
      ],
      "tests": [
        {
          "test_name": "narrowed_reduction",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i32 @narrowed_reduction(ptr %a, i1 %cmp) #0 {\nentry:\n  %conv = zext i1 %cmp to i32\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 1, %entry ], [ %inc, %loop ]\n  %or13 = phi i32 [ 0, %entry ], [ %or, %loop ]\n  %and = and i32 %or13, 1\n  %or = or i32 %and, %conv\n  %inc = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 0\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i32 %or\n}\n\nattributes #0 = { \"target-cpu\"=\"penryn\" }\n"
        },
        {
          "test_name": "cost_assume",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @cost_assume(ptr %end, i64 %N) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %0 = phi i64 [ 0, %entry ], [ %1, %loop ]\n  %1 = add i64 %0, 1\n  %iv.next = add nsw i64 %iv, 1\n  %c = icmp ne i64 %N, 0\n  tail call void @llvm.assume(i1 %c)\n  %gep = getelementptr nusw [9 x i8], ptr null, i64 %iv.next\n  %ec = icmp eq ptr %gep, %end\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i64 %1\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "PR27826",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine float @PR27826(ptr nocapture readonly %a, ptr nocapture readonly %b, i32 %n) {\nentry:\n  %cmp = icmp sgt i32 %n, 0\n  br i1 %cmp, label %preheader, label %for.end\n\npreheader:                                        ; preds = %entry\n  %t0 = sext i32 %n to i64\n  br label %for\n\nfor:                                              ; preds = %for, %preheader\n  %indvars.iv = phi i64 [ 0, %preheader ], [ %indvars.iv.next, %for ]\n  %s.02 = phi float [ 0.000000e+00, %preheader ], [ %add4, %for ]\n  %arrayidx = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  %t1 = load float, ptr %arrayidx, align 4\n  %arrayidx3 = getelementptr inbounds float, ptr %b, i64 %indvars.iv\n  %t2 = load float, ptr %arrayidx3, align 4\n  %add = fadd fast float %t1, %s.02\n  %add4 = fadd fast float %add, %t2\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 32\n  %cmp1 = icmp slt i64 %indvars.iv.next, %t0\n  br i1 %cmp1, label %for, label %loopexit\n\nloopexit:                                         ; preds = %for\n  %add4.lcssa = phi float [ %add4, %for ]\n  br label %for.end\n\nfor.end:                                          ; preds = %loopexit, %entry\n  %s.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %add4.lcssa, %loopexit ]\n  ret float %s.0.lcssa\n}\n"
        },
        {
          "test_name": "reduction_store",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @reduction_store(ptr noalias %src, ptr %dst, i1 %x) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %red = phi i32 [ 0, %entry ], [ %red.next, %loop ]\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.src = getelementptr inbounds i32, ptr %src, i32 %iv\n  %l = load i32, ptr %gep.src, align 4\n  %l.and = and i32 %l, 3\n  store i32 %l.and, ptr %dst, align 4\n  %x.ext = zext i1 %x to i64\n  %lshr = lshr i64 %x.ext, 12\n  %t = trunc i64 %lshr to i32\n  %red.next = and i32 %red, %t\n  store i32 %red.next, ptr %dst, align 4\n  %iv.next = add i32 %iv, 1\n  %ec = icmp eq i32 %iv, 29\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"znver3\" }\n"
        },
        {
          "test_name": "cost_loop_invariant_recipes",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @cost_loop_invariant_recipes(i1 %x, i64 %y) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next.i.i.i, %loop ]\n  %red = phi i64 [ 1, %entry ], [ %red.mul, %loop ]\n  %not.x = xor i1 %x, true\n  %ext = zext i1 %not.x to i64\n  %shl = shl i64 %y, %ext\n  %red.mul = mul i64 %shl, %red\n  %iv.next.i.i.i = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i64 %red.mul\n}\n"
        },
        {
          "test_name": "multi_exit",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @multi_exit(ptr %dst, ptr %src.1, ptr %src.2, i64 %A, i64 %B) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop.latch, %entry\n  %iv.1.wide = phi i64 [ 0, %entry ], [ %iv.1.next.wide, %loop.latch ]\n  %iv.1 = phi i32 [ 0, %entry ], [ %iv.1.next, %loop.latch ]\n  %ec.1 = icmp ult i64 %iv.1.wide, %A\n  br i1 %ec.1, label %loop.latch, label %exit\n\nloop.latch:                                       ; preds = %loop\n  %l.1 = load i64, ptr %src.1, align 8\n  %l.2 = load i64, ptr %src.2, align 8\n  %cmp55.us = icmp eq i64 %l.1, 0\n  %cmp.i.us = icmp ne i64 %l.2, 0\n  %and = and i1 %cmp.i.us, %cmp55.us\n  %ext = zext i1 %and to i8\n  store i8 %ext, ptr %dst, align 1\n  %iv.1.next = add i32 %iv.1, 1\n  %iv.1.next.wide = zext i32 %iv.1.next to i64\n  %ec.2 = icmp ult i64 %iv.1.next.wide, %B\n  br i1 %ec.2, label %loop, label %exit\n\nexit:                                             ; preds = %loop.latch, %loop\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"penryn\" }\n"
        },
        {
          "test_name": "cost_model_1",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\n@c = external global [2048 x i32], align 16\n@b = external global [2048 x i32], align 16\n@d = external global [2048 x i32], align 16\n@a = external global [2048 x i32], align 16\n\n; Function Attrs: noinline nounwind ssp uwtable\ndefine void @cost_model_1() #0 {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %0 = shl nsw i64 %indvars.iv, 1\n  %arrayidx = getelementptr inbounds [2048 x i32], ptr @c, i64 0, i64 %0\n  %1 = load i32, ptr %arrayidx, align 8\n  %idxprom1 = sext i32 %1 to i64\n  %arrayidx2 = getelementptr inbounds [2048 x i32], ptr @b, i64 0, i64 %idxprom1\n  %2 = load i32, ptr %arrayidx2, align 4\n  %arrayidx4 = getelementptr inbounds [2048 x i32], ptr @d, i64 0, i64 %indvars.iv\n  %3 = load i32, ptr %arrayidx4, align 4\n  %idxprom5 = sext i32 %3 to i64\n  %arrayidx6 = getelementptr inbounds [2048 x i32], ptr @a, i64 0, i64 %idxprom5\n  store i32 %2, ptr %arrayidx6, align 4\n  %indvars.iv.next = add i64 %indvars.iv, 1\n  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n  %exitcond = icmp eq i32 %lftr.wideiv, 256\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n\nattributes #0 = { noinline nounwind ssp uwtable }\n"
        },
        {
          "test_name": "any_of_cost",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i1 @any_of_cost(ptr %start, ptr %end) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %any.of = phi i1 [ false, %entry ], [ %any.of.next, %loop ]\n  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop ]\n  %gep = getelementptr i8, ptr %ptr.iv, i64 8\n  %l = load ptr, ptr %gep, align 8\n  %cmp13.not.not = icmp eq ptr %l, null\n  %any.of.next = select i1 %cmp13.not.not, i1 %any.of, i1 false\n  %ptr.iv.next = getelementptr inbounds i8, ptr %ptr.iv, i64 40\n  %cmp.not = icmp eq ptr %ptr.iv, %end\n  br i1 %cmp.not, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i1 %any.of.next\n}\n\nattributes #0 = { \"target-cpu\"=\"penryn\" }\n"
        },
        {
          "test_name": "cost_duplicate_recipe_for_sinking",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine void @cost_duplicate_recipe_for_sinking(ptr %A, i64 %N) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %iv.shl = shl nsw i64 %iv, 2\n  %gep.0 = getelementptr nusw double, ptr %A, i64 %iv.shl\n  %l = load double, ptr %gep.0, align 8\n  %c = fcmp oeq double %l, 0.000000e+00\n  br i1 %c, label %if.then, label %loop.latch\n\nif.then:                                          ; preds = %loop.header\n  %gep.1 = getelementptr double, ptr %A, i64 %iv.shl\n  store double 0.000000e+00, ptr %gep.1, align 8\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %if.then, %loop.header\n  %iv.next = add nsw i64 %iv, 1\n  %ec = icmp eq i64 %iv, %N\n  br i1 %ec, label %exit, label %loop.header\n\nexit:                                             ; preds = %loop.latch\n  ret void\n}\n\nattributes #0 = { \"target-cpu\"=\"znver3\" }\n"
        },
        {
          "test_name": "avx512_cond_load_cost",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @avx512_cond_load_cost(ptr %src, i32 %a, i64 %b, i32 %c, i32 %d) #0 {\nentry:\n  br label %loop.header\n\nloop.header:                                      ; preds = %loop.latch, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n  %c.1 = icmp slt i32 %iv, 0\n  br i1 %c.1, label %if.then, label %loop.latch\n\nif.then:                                          ; preds = %loop.header\n  %0 = urem i32 %a, %c\n  %mul = sub i32 0, %0\n  %div = udiv i32 %c, %d\n  %or = or i32 %div, %mul\n  %ext = sext i32 %or to i64\n  %gep = getelementptr { i64, i64, i64 }, ptr %src, i64 %ext, i32 2\n  %l = load i64, ptr %gep, align 8\n  %or.2 = or i64 %l, %b\n  br label %loop.latch\n\nloop.latch:                                       ; preds = %if.then, %loop.header\n  %res = phi i64 [ 0, %loop.header ], [ %or.2, %if.then ]\n  %iv.next = add i32 %iv, 1\n  %ec = icmp ult i32 %iv, %c\n  br i1 %ec, label %loop.header, label %exit\n\nexit:                                             ; preds = %loop.latch\n  ret i64 %res\n}\n\nattributes #0 = { \"target-features\"=\"+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl\" }\n"
        },
        {
          "test_name": "live_in_known_1_via_scev",
          "test_body": "target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.8.0\"\n\ndefine i64 @live_in_known_1_via_scev() {\nentry:\n  %sel = select i1 false, i32 3, i32 0\n  br label %ph\n\nph:                                               ; preds = %entry\n  %p = phi i32 [ 1, %entry ]\n  %N = add nuw nsw i32 %sel, 6\n  %p.ext = zext nneg i32 %p to i64\n  br label %loop\n\nloop:                                             ; preds = %loop, %ph\n  %iv = phi i32 [ 0, %ph ], [ %iv.next, %loop ]\n  %red = phi i64 [ 3, %ph ], [ %red.mul, %loop ]\n  %red.mul = mul nsw i64 %red, %p.ext\n  %iv.next = add nuw nsw i32 %iv, 1\n  %ec = icmp eq i32 %iv.next, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  %res = phi i64 [ %red.mul, %loop ]\n  ret i64 %res\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "clang crashes at -O{s,2,3} on x86_64-linux-gnu: Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed ",
    "body": "It appears to be a recent regression as it doesn't reproduce with 19.1.0 and earlier.\r\n\r\nCompiler Explorer: https://godbolt.org/z/jPaW9fnKj\r\n\r\n```\r\n[531] % clangtk -v\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project.git a9050525954cbe11d45b415e2248d9e25e004bfe)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /local/home/suz/suz-local/software/local/clang-trunk/bin\r\nBuild config: +assertions\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11\r\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12\r\nSelected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/12\r\nCandidate multilib: .;@m64\r\nSelected multilib: .;@m64\r\nFound CUDA installation: /usr/local/cuda, version 11.8\r\n[532] %\r\n[532] % clangtk -O3 small.c\r\nclang-20: /local/suz-local/software/clangbuild/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7519: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\r\nStack dump:\r\n0.      Program arguments: /local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20 -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -dumpdir a- -disable-free -clear-ast-before-backend -main-file-name small.c -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debugger-tuning=gdb -fdebug-compilation-dir=/local/suz-local/software/emitesting/bugs/20241024-clangtk-m64-Os-build-062114/delta -fcoverage-compilation-dir=/local/suz-local/software/emitesting/bugs/20241024-clangtk-m64-Os-build-062114/delta -resource-dir /local/home/suz/suz-local/software/local/clang-trunk/lib/clang/20 -I /usr/local/include -I /local/suz-local/software/local/include -internal-isystem /local/home/suz/suz-local/software/local/clang-trunk/lib/clang/20/include -internal-isystem /usr/local/include -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -ferror-limit 19 -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcolor-diagnostics -vectorize-loops -vectorize-slp -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o /tmp/small-22743c.o -x c small.c\r\n1.      <eof> parser at end of file\r\n2.      Optimizer\r\n3.      Running pass \"function<eager-inv>(float2int,lower-constant-intrinsics,chr,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O3>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"small.c\"\r\n4.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"main\"\r\n #0 0x000056385e381f80 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x43e3f80)\r\n #1 0x000056385e37f38f llvm::sys::RunSignalHandlers() (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x43e138f)\r\n #2 0x000056385e37f4e5 SignalHandler(int) Signals.cpp:0:0\r\n #3 0x00007fe699585520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #4 0x00007fe6995d9a7c pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x96a7c)\r\n #5 0x00007fe699585476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\r\n #6 0x00007fe69956b7f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\r\n #7 0x00007fe69956b71b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\r\n #8 0x00007fe69957ce96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n #9 0x000056385fd39986 llvm::LoopVectorizationPlanner::computeBestVF() (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x5d9b986)\r\n#10 0x000056385fd50d8c llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x5db2d8c)\r\n#11 0x000056385fd53ea1 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x5db5ea1)\r\n#12 0x000056385fd54517 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x5db6517)\r\n#13 0x000056385f8a7d86 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x5909d86)\r\n#14 0x000056385dd0d52f llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x3d6f52f)\r\n#15 0x000056385b779146 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x17db146)\r\n#16 0x000056385dd0b8bb llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x3d6d8bb)\r\n#17 0x000056385b777be6 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x17d9be6)\r\n#18 0x000056385dd0c41d llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x3d6e41d)\r\n#19 0x000056385e6253b6 (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&, clang::BackendConsumer*) BackendUtil.cpp:0:0\r\n#20 0x000056385e628d53 clang::EmitBackendOutput(clang::DiagnosticsEngine&, clang::HeaderSearchOptions const&, clang::CodeGenOptions const&, clang::TargetOptions const&, clang::LangOptions const&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>, clang::BackendConsumer*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x468ad53)\r\n#21 0x000056385eceb3f5 clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x4d4d3f5)\r\n#22 0x0000563860a56ffc clang::ParseAST(clang::Sema&, bool, bool) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x6ab8ffc)\r\n#23 0x000056385efcbdd9 clang::FrontendAction::Execute() (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x502ddd9)\r\n#24 0x000056385ef45205 clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x4fa7205)\r\n#25 0x000056385f0aa403 clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x510c403)\r\n#26 0x000056385b330b57 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x1392b57)\r\n#27 0x000056385b3275ea ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\r\n#28 0x000056385b32b96f clang_main(int, char**, llvm::ToolContext const&) (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x138d96f)\r\n#29 0x000056385b21ef2b main (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x1280f2b)\r\n#30 0x00007fe69956cd90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\r\n#31 0x00007fe69956ce40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\r\n#32 0x000056385b326d15 _start (/local/home/suz/suz-local/software/local/clang-trunk/bin/clang-20+0x1388d15)\r\nclangtk: error: unable to execute command: Aborted\r\nclangtk: error: clang frontend command failed due to signal (use -v to see invocation)\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project.git a9050525954cbe11d45b415e2248d9e25e004bfe)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /local/home/suz/suz-local/software/local/clang-trunk/bin\r\nBuild config: +assertions\r\nclangtk: note: diagnostic msg:\r\n********************\r\n\r\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\r\nPreprocessed source(s) and associated run script(s) are located at:\r\nclangtk: note: diagnostic msg: /tmp/small-ed84bf.c\r\nclangtk: note: diagnostic msg: /tmp/small-ed84bf.sh\r\nclangtk: note: diagnostic msg:\r\n\r\n********************\r\n[533] %\r\n[533] % cat small.c\r\nint a, b, c;\r\nint main() {\r\n  for (; a; a++) {\r\n    c &= 1;\r\n    c |= b == 1;\r\n  }\r\n  return 0;\r\n}\r\n```",
    "author": "zhendongsu",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "zhendongsu",
        "body": "@fhahn "
      }
    ]
  }
}