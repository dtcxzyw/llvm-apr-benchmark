{
  "bug_id": "150479",
  "issue_url": "https://github.com/llvm/llvm-project/issues/150479",
  "bug_type": "crash",
  "base_commit": "8952225d88a5ce58a65c8b8695c610f4499d7181",
  "knowledge_cutoff": "2025-07-24T17:33:31Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "c9cea24fe68e24750b2d479144f839e1c2ec9d2b",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          6861,
          6867
        ],
        [
          15704,
          15710
        ],
        [
          15803,
          15809
        ],
        [
          15816,
          15822
        ],
        [
          16438,
          16461
        ],
        [
          16470,
          16482
        ],
        [
          16512,
          16522
        ],
        [
          16554,
          16560
        ],
        [
          16586,
          16592
        ],
        [
          21001,
          21009
        ],
        [
          21253,
          21258
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "BoUpSLP::computeMinimumValueSizes",
        "BoUpSLP::getLastInstructionInBundle",
        "BoUpSLP::getReorderingData",
        "BoUpSLP::isGatherShuffledSingleRegisterEntry"
      ]
    }
  },
  "patch": "commit c9cea24fe68e24750b2d479144f839e1c2ec9d2b\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Thu Jul 24 11:40:26 2025 -0700\n\n    [SLP] Check if the user node has state before trying getting main instruction/opcode\n    \n    Need to check if the parent node has state to prevent compiler crashes.\n    Fixes #150479\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 0adad5a90d31..44dc43d5e77c 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -6861,7 +6861,7 @@ BoUpSLP::getReorderingData(const TreeEntry &TE, bool TopToBottom,\n     return std::move(ResOrder);\n   }\n   if (TE.State == TreeEntry::StridedVectorize && !TopToBottom &&\n-      (!TE.UserTreeIndex ||\n+      (!TE.UserTreeIndex || !TE.UserTreeIndex.UserTE->hasState() ||\n        !Instruction::isBinaryOp(TE.UserTreeIndex.UserTE->getOpcode())) &&\n       (TE.ReorderIndices.empty() || isReverseOrder(TE.ReorderIndices)))\n     return std::nullopt;\n@@ -15704,7 +15704,8 @@ BoUpSLP::isGatherShuffledSingleRegisterEntry(\n   const BasicBlock *TEInsertBlock = nullptr;\n   // Main node of PHI entries keeps the correct order of operands/incoming\n   // blocks.\n-  if (auto *PHI = dyn_cast<PHINode>(TEUseEI.UserTE->getMainOp());\n+  if (auto *PHI = dyn_cast_or_null<PHINode>(\n+          TEUseEI.UserTE->hasState() ? TEUseEI.UserTE->getMainOp() : nullptr);\n       PHI && TEUseEI.UserTE->State != TreeEntry::SplitVectorize) {\n     TEInsertBlock = PHI->getIncomingBlock(TEUseEI.EdgeIdx);\n     TEInsertPt = TEInsertBlock->getTerminator();\n@@ -15803,7 +15804,8 @@ BoUpSLP::isGatherShuffledSingleRegisterEntry(\n              \"Expected only single user of a gather node.\");\n       const EdgeInfo &UseEI = TEPtr->UserTreeIndex;\n \n-      PHINode *UserPHI = UseEI.UserTE->State != TreeEntry::SplitVectorize\n+      PHINode *UserPHI = (UseEI.UserTE->State != TreeEntry::SplitVectorize &&\n+                          UseEI.UserTE->hasState())\n                              ? dyn_cast<PHINode>(UseEI.UserTE->getMainOp())\n                              : nullptr;\n       Instruction *InsertPt =\n@@ -15816,7 +15818,8 @@ BoUpSLP::isGatherShuffledSingleRegisterEntry(\n              TEUseEI.UserTE->isAltShuffle()) &&\n             all_of(TEUseEI.UserTE->Scalars, isUsedOutsideBlock)) {\n           if (UseEI.UserTE->State != TreeEntry::Vectorize ||\n-              (UseEI.UserTE->getOpcode() == Instruction::PHI &&\n+              (UseEI.UserTE->hasState() &&\n+               UseEI.UserTE->getOpcode() == Instruction::PHI &&\n                !UseEI.UserTE->isAltShuffle()) ||\n               !all_of(UseEI.UserTE->Scalars, isUsedOutsideBlock))\n             continue;\n@@ -16438,24 +16441,31 @@ Instruction &BoUpSLP::getLastInstructionInBundle(const TreeEntry *E) {\n   // Get the basic block this bundle is in. All instructions in the bundle\n   // should be in this block (except for extractelement-like instructions with\n   // constant indices or gathered loads or copyables).\n-  auto *Front = E->getMainOp();\n+  Instruction *Front;\n+  unsigned Opcode;\n+  if (E->hasState()) {\n+    Front = E->getMainOp();\n+    Opcode = E->getOpcode();\n+  } else {\n+    Front = cast<Instruction>(*find_if(E->Scalars, IsaPred<Instruction>));\n+    Opcode = Front->getOpcode();\n+  }\n   auto *BB = Front->getParent();\n-  assert(((GatheredLoadsEntriesFirst.has_value() &&\n-           E->getOpcode() == Instruction::Load && E->isGather() &&\n-           E->Idx < *GatheredLoadsEntriesFirst) ||\n-          E->State == TreeEntry::SplitVectorize || E->hasCopyableElements() ||\n-          all_of(E->Scalars,\n-                 [=](Value *V) -> bool {\n-                   if (E->getOpcode() == Instruction::GetElementPtr &&\n-                       !isa<GetElementPtrInst>(V))\n-                     return true;\n-                   auto *I = dyn_cast<Instruction>(V);\n-                   return !I || !E->getMatchingMainOpOrAltOp(I) ||\n-                          I->getParent() == BB ||\n-                          isVectorLikeInstWithConstOps(I);\n-                 })) &&\n-         \"Expected gathered loads or GEPs or instructions from same basic \"\n-         \"block.\");\n+  assert(\n+      ((GatheredLoadsEntriesFirst.has_value() && Opcode == Instruction::Load &&\n+        E->isGather() && E->Idx < *GatheredLoadsEntriesFirst) ||\n+       E->State == TreeEntry::SplitVectorize || E->hasCopyableElements() ||\n+       all_of(E->Scalars,\n+              [=](Value *V) -> bool {\n+                if (Opcode == Instruction::GetElementPtr &&\n+                    !isa<GetElementPtrInst>(V))\n+                  return true;\n+                auto *I = dyn_cast<Instruction>(V);\n+                return !I || !E->getMatchingMainOpOrAltOp(I) ||\n+                       I->getParent() == BB || isVectorLikeInstWithConstOps(I);\n+              })) &&\n+      \"Expected gathered loads or GEPs or instructions from same basic \"\n+      \"block.\");\n \n   auto FindLastInst = [&]() {\n     Instruction *LastInst = Front;\n@@ -16470,13 +16480,13 @@ Instruction &BoUpSLP::getLastInstructionInBundle(const TreeEntry *E) {\n           LastInst = I;\n         continue;\n       }\n-      assert(((E->getOpcode() == Instruction::GetElementPtr &&\n+      assert(((Opcode == Instruction::GetElementPtr &&\n                !isa<GetElementPtrInst>(I)) ||\n               E->State == TreeEntry::SplitVectorize ||\n               (isVectorLikeInstWithConstOps(LastInst) &&\n                isVectorLikeInstWithConstOps(I)) ||\n               (GatheredLoadsEntriesFirst.has_value() &&\n-               E->getOpcode() == Instruction::Load && E->isGather() &&\n+               Opcode == Instruction::Load && E->isGather() &&\n                E->Idx < *GatheredLoadsEntriesFirst)) &&\n              \"Expected vector-like or non-GEP in GEP node insts only.\");\n       if (!DT->isReachableFromEntry(LastInst->getParent())) {\n@@ -16512,11 +16522,11 @@ Instruction &BoUpSLP::getLastInstructionInBundle(const TreeEntry *E) {\n           FirstInst = I;\n         continue;\n       }\n-      assert(((E->getOpcode() == Instruction::GetElementPtr &&\n-              !isa<GetElementPtrInst>(I)) ||\n-             (isVectorLikeInstWithConstOps(FirstInst) &&\n-              isVectorLikeInstWithConstOps(I))) &&\n-                 \"Expected vector-like or non-GEP in GEP node insts only.\");\n+      assert(((Opcode == Instruction::GetElementPtr &&\n+               !isa<GetElementPtrInst>(I)) ||\n+              (isVectorLikeInstWithConstOps(FirstInst) &&\n+               isVectorLikeInstWithConstOps(I))) &&\n+             \"Expected vector-like or non-GEP in GEP node insts only.\");\n       if (!DT->isReachableFromEntry(FirstInst->getParent())) {\n         FirstInst = I;\n         continue;\n@@ -16554,7 +16564,7 @@ Instruction &BoUpSLP::getLastInstructionInBundle(const TreeEntry *E) {\n   // Set insertpoint for gathered loads to the very first load.\n   if (GatheredLoadsEntriesFirst.has_value() &&\n       E->Idx >= *GatheredLoadsEntriesFirst && !E->isGather() &&\n-      E->getOpcode() == Instruction::Load) {\n+      Opcode == Instruction::Load) {\n     Res = FindFirstInst();\n     EntryToLastInstruction.try_emplace(E, Res);\n     return *Res;\n@@ -16586,7 +16596,7 @@ Instruction &BoUpSLP::getLastInstructionInBundle(const TreeEntry *E) {\n   };\n   const ScheduleBundle *Bundle = FindScheduleBundle(E);\n   if (!E->isGather() && !Bundle) {\n-    if ((E->getOpcode() == Instruction::GetElementPtr &&\n+    if ((Opcode == Instruction::GetElementPtr &&\n          any_of(E->Scalars,\n                 [](Value *V) {\n                   return !isa<GetElementPtrInst>(V) && isa<Instruction>(V);\n@@ -21001,9 +21011,10 @@ void BoUpSLP::computeMinimumValueSizes() {\n                     if (!isa<CastInst, BinaryOperator, FreezeInst, PHINode,\n                              SelectInst>(U) ||\n                         isa<SIToFPInst, UIToFPInst>(U) ||\n-                        !isa<CastInst, BinaryOperator, FreezeInst, PHINode,\n-                             SelectInst>(UserTE->getMainOp()) ||\n-                        isa<SIToFPInst, UIToFPInst>(UserTE->getMainOp()))\n+                        (UserTE->hasState() &&\n+                         (!isa<CastInst, BinaryOperator, FreezeInst, PHINode,\n+                               SelectInst>(UserTE->getMainOp()) ||\n+                          isa<SIToFPInst, UIToFPInst>(UserTE->getMainOp()))))\n                       return true;\n                     unsigned UserTESz = DL->getTypeSizeInBits(\n                         UserTE->Scalars.front()->getType());\n@@ -21253,6 +21264,7 @@ void BoUpSLP::computeMinimumValueSizes() {\n           NodeIdx < VectorizableTree.size() &&\n           VectorizableTree[NodeIdx]->UserTreeIndex &&\n           VectorizableTree[NodeIdx]->UserTreeIndex.EdgeIdx == 0 &&\n+          VectorizableTree[NodeIdx]->UserTreeIndex.UserTE->hasState() &&\n           VectorizableTree[NodeIdx]->UserTreeIndex.UserTE->getOpcode() ==\n               Instruction::Trunc &&\n           !VectorizableTree[NodeIdx]->UserTreeIndex.UserTE->isAltShuffle();\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/user-node-no-state.ll",
      "commands": [
        "opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\n@g = global [128 x i8] zeroinitializer, align 16\n\ndefine i64 @test() {\n;\nentry:\n  %0 = load i64, ptr @g, align 8\n  br label %func_154.exit.func_146.exit_crit_edge.i\n\nfunc_154.exit.func_146.exit_crit_edge.i:\n  %1 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 80), align 16\n  %2 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 88), align 8\n  %3 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 32), align 16\n  %4 = load i64, ptr @g, align 16\n  %5 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 8), align 8\n  %6 = load i64, ptr @g, align 16\n  %7 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 24), align 8\n  %8 = xor i64 %1, %2\n  %9 = xor i64 %8, %3\n  %10 = xor i64 %9, %4\n  %11 = xor i64 %10, %5\n  %12 = xor i64 %11, %6\n  %13 = xor i64 %12, %7\n  %14 = xor i64 %13, %0\n  ret i64 %14\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[SLPVectorizer] Assertion `valid() && \"InstructionsState is invalid.\"' failed.",
    "body": "Reproducer: https://godbolt.org/z/Pj96ao9TK\n```\n; bin/opt -passes=slp-vectorizer test.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@g = global [128 x i8] zeroinitializer, align 16\n\ndefine i64 @main() {\nentry:\n  %0 = load i64, ptr @g, align 8\n  br label %func_154.exit.func_146.exit_crit_edge.i\n\nfunc_154.exit.func_146.exit_crit_edge.i:          ; preds = %entry\n  %1 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 80), align 16\n  %2 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 88), align 8\n  %3 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 32), align 16\n  %4 = load i64, ptr @g, align 16\n  %5 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 8), align 8\n  %6 = load i64, ptr @g, align 16\n  %7 = load i64, ptr getelementptr inbounds nuw (i8, ptr @g, i64 24), align 8\n  %8 = xor i64 %1, %2\n  %9 = xor i64 %8, %3\n  %10 = xor i64 %9, %4\n  %11 = xor i64 %10, %5\n  %12 = xor i64 %11, %6\n  %13 = xor i64 %12, %7\n  %14 = xor i64 %13, %0\n  ret i64 %14\n}\n```\n```\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1204: llvm::Instruction* {anonymous}::InstructionsState::getMainOp() const: Assertion `valid() && \"InstructionsState is invalid.\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=slp-vectorizer <source>\n1.\tRunning pass \"function(slp-vectorizer)\" on module \"<source>\"\n2.\tRunning pass \"slp-vectorizer\" on function \"main\"\n #0 0x0000000005664458 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5664458)\n #1 0x0000000005661304 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x000075a3c1242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x000075a3c12969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x000075a3c1242476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x000075a3c12287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x000075a3c122871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x000075a3c1239e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x00000000034a0043 (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x34a0043)\n #9 0x0000000003513355 llvm::slpvectorizer::BoUpSLP::getLastInstructionInBundle(llvm::slpvectorizer::BoUpSLP::TreeEntry const*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3513355)\n#10 0x000000000355424e llvm::slpvectorizer::BoUpSLP::isGatherShuffledSingleRegisterEntry(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::MutableArrayRef<int>, llvm::SmallVectorImpl<llvm::slpvectorizer::BoUpSLP::TreeEntry const*>&, unsigned int, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x355424e)\n#11 0x0000000003558408 llvm::slpvectorizer::BoUpSLP::isGatherShuffledEntry(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::SmallVectorImpl<int>&, llvm::SmallVectorImpl<llvm::SmallVector<llvm::slpvectorizer::BoUpSLP::TreeEntry const*, 6u>>&, unsigned int, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3558408)\n#12 0x000000000355a2de llvm::InstructionCost llvm::slpvectorizer::BoUpSLP::processBuildVector<llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator, llvm::InstructionCost, llvm::TargetTransformInfo, llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP, llvm::SmallPtrSetImpl<llvm::Value*>>(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::Type*, llvm::TargetTransformInfo&, llvm::ArrayRef<llvm::Value*>&, llvm::slpvectorizer::BoUpSLP&, llvm::SmallPtrSetImpl<llvm::Value*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x355a2de)\n#13 0x000000000355c98f llvm::slpvectorizer::BoUpSLP::getEntryCost(llvm::slpvectorizer::BoUpSLP::TreeEntry const*, llvm::ArrayRef<llvm::Value*>, llvm::SmallPtrSetImpl<llvm::Value*>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x355c98f)\n#14 0x000000000359597f llvm::slpvectorizer::BoUpSLP::getTreeCost(llvm::ArrayRef<llvm::Value*>, llvm::InstructionCost) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x359597f)\n#15 0x000000000359ba1b (anonymous namespace)::HorizontalReduction::tryToReduce(llvm::slpvectorizer::BoUpSLP&, llvm::DataLayout const&, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo const&, llvm::AssumptionCache*) SLPVectorizer.cpp:0:0\n#16 0x000000000359ef90 llvm::SLPVectorizerPass::vectorizeHorReduction(llvm::PHINode*, llvm::Instruction*, llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&, llvm::SmallVectorImpl<llvm::WeakTrackingVH>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x359ef90)\n#17 0x00000000035a430b llvm::SLPVectorizerPass::vectorizeRootInstruction(llvm::PHINode*, llvm::Instruction*, llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (.constprop.0) SLPVectorizer.cpp:0:0\n#18 0x00000000035a8c0f llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x35a8c0f)\n#19 0x00000000035aef06 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (.part.0) SLPVectorizer.cpp:0:0\n#20 0x00000000035af9eb llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x35af9eb)\n#21 0x0000000002dab8ce llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2dab8ce)\n#22 0x0000000005456241 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5456241)\n#23 0x0000000000eb675e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xeb675e)\n#24 0x0000000005456714 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5456714)\n#25 0x0000000000eb6a2e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xeb6a2e)\n#26 0x00000000054542e1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x54542e1)\n#27 0x0000000000964bfa llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x964bfa)\n#28 0x0000000000958c79 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x958c79)\n#29 0x000075a3c1229d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#30 0x000075a3c1229e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#31 0x000000000094fd45 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x94fd45)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\n\nI found this crash when fuzzing the code in https://github.com/llvm/llvm-project/pull/137297.\n",
    "author": "dtcxzyw",
    "labels": [
      "llvm:SLPVectorizer",
      "crash-on-valid",
      "generated by fuzzer"
    ],
    "comments": []
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": false
  }
}