{
  "bug_id": "122602",
  "issue_url": "https://github.com/llvm/llvm-project/issues/122602",
  "bug_type": "miscompilation",
  "base_commit": "b4ce29ab31b29ca926704c160e3909298ddf2b2b",
  "knowledge_cutoff": "2025-01-11T16:58:09Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "8df64ed77727ab9b7540819f2fe64379e88a50be",
    "components": [
      "LoopVectorize"
    ],
    "files": [
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp",
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          3806,
          3812
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          621,
          648
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::collectLoopUniforms"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "legalizeAndOptimizeInductions"
      ]
    }
  },
  "patch": "commit 8df64ed77727ab9b7540819f2fe64379e88a50be\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Sun Jan 12 22:03:21 2025 +0000\n\n    [LV] Don't consider IV increments uniform if exit value is used outside.\n    \n    In some cases, there might be a chain of uniform instructions producing\n    the exit value. To generate correct code in all cases, consider the IV\n    increment not uniform, if there are users outside the loop.\n    \n    Instead, let VPlan narrow the IV, if possible using the logic from\n    3ff1d01985752.\n    \n    Test case from #122602 verified with Alive2:\n        https://alive2.llvm.org/ce/z/bA4EGj\n    \n    Fixes https://github.com/llvm/llvm-project/issues/122496.\n    Fixes https://github.com/llvm/llvm-project/issues/122602.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex b017b61a45a0..d32a463a996c 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -3806,7 +3806,7 @@ void LoopVectorizationCostModel::collectLoopUniforms(ElementCount VF) {\n     // uniform after vectorization.\n     bool UniformIndUpdate = all_of(IndUpdate->users(), [&](User *U) -> bool {\n       auto *I = cast<Instruction>(U);\n-      return I == Ind || !TheLoop->contains(I) || Worklist.count(I) ||\n+      return I == Ind || Worklist.count(I) ||\n              IsVectorizedMemAccessUse(I, IndUpdate);\n     });\n     if (!UniformIndUpdate)\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex f440bf2eb022..545d277d7aa0 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -621,28 +621,6 @@ static void legalizeAndOptimizeInductions(VPlan &Plan) {\n       Def->replaceAllUsesWith(Clone);\n     }\n \n-    // Check if any uniform VPReplicateRecipes using the phi recipe are used by\n-    // ExtractFromEnd. Those must be replaced by a regular VPReplicateRecipe to\n-    // ensure the final value is available.\n-    // TODO: Remove once uniformity analysis is done on VPlan.\n-    for (VPUser *U : Users) {\n-      auto *ExitIRI = dyn_cast<VPIRInstruction>(U);\n-      VPValue *Op;\n-      if (!ExitIRI || !match(ExitIRI->getOperand(0),\n-                             m_VPInstruction<VPInstruction::ExtractFromEnd>(\n-                                 m_VPValue(Op), m_VPValue())))\n-        continue;\n-      auto *RepR = dyn_cast<VPReplicateRecipe>(Op);\n-      if (!RepR || !RepR->isUniform())\n-        continue;\n-      assert(!RepR->isPredicated() && \"RepR must not be predicated\");\n-      Instruction *I = RepR->getUnderlyingInstr();\n-      auto *Clone =\n-          new VPReplicateRecipe(I, RepR->operands(), /*IsUniform*/ false);\n-      Clone->insertAfter(RepR);\n-      RepR->replaceAllUsesWith(Clone);\n-    }\n-\n     // Replace wide pointer inductions which have only their scalars used by\n     // PtrAdd(IndStart, ScalarIVSteps (0, Step)).\n     if (auto *PtrIV = dyn_cast<VPWidenPointerInductionRecipe>(&Phi)) {\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/uniform-phi.ll",
      "commands": [
        "opt < %s -passes=loop-vectorize -mtriple=x86_64-apple-macosx10.8.0 -mcpu=corei7 -debug-only=loop-vectorize -S 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @test(ptr noalias nocapture %a, ptr noalias nocapture readonly %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %b, i64 %indvars.iv\n  %tmp0 = load float, ptr %arrayidx, align 4\n  %add = fadd float %tmp0, 1.000000e+00\n  %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  store float %add, ptr %arrayidx5, align 4\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv, 1599\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "goo",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i64 @goo(ptr noalias nocapture %a, ptr noalias nocapture readonly %b) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]\n  %arrayidx = getelementptr inbounds float, ptr %b, i64 %indvars.iv\n  %tmp0 = load float, ptr %arrayidx, align 4\n  %add = fadd float %tmp0, 1.000000e+00\n  %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv\n  store float %add, ptr %arrayidx5, align 4\n  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n  %exitcond = icmp eq i64 %indvars.iv, 1599\n  br i1 %exitcond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  %retval = add i64 %indvars.iv, %indvars.iv.next\n  ret i64 %retval\n}\n"
        },
        {
          "test_name": "foo",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @foo(ptr %a, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %i = phi i64 [ %i.next, %for.body ], [ 0, %entry ]\n  %tmp0 = trunc i64 %i to i32\n  %tmp1 = getelementptr inbounds i32, ptr %a, i32 %tmp0\n  store i32 %tmp0, ptr %tmp1, align 4\n  %i.next = add nuw nsw i64 %i, 1\n  %cond = icmp eq i64 %i.next, %n\n  br i1 %cond, label %for.end, label %for.body\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        },
        {
          "test_name": "PR38786",
          "test_body": "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @PR38786(ptr %y, ptr %x, i64 %n) {\nentry:\n  br label %for.body\n\nfor.body:                                         ; preds = %for.body, %entry\n  %phi32 = phi i32 [ 0, %entry ], [ %i32next, %for.body ]\n  %phi64 = phi i64 [ 0, %entry ], [ %i64next, %for.body ]\n  %i32next = add i32 %phi32, 1\n  %i64next = zext i32 %i32next to i64\n  %xip = getelementptr inbounds double, ptr %x, i64 %i64next\n  %yip = getelementptr inbounds double, ptr %y, i64 %phi64\n  %xi = load double, ptr %xip, align 8\n  store double %xi, ptr %yip, align 8\n  %cmp = icmp slt i64 %i64next, %n\n  br i1 %cmp, label %for.body, label %for.end\n\nfor.end:                                          ; preds = %for.body\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/iv_outside_user.ll",
      "commands": [
        "opt -S -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=2 < %s",
        "opt -S -passes=loop-vectorize -force-vector-interleave=2 -force-vector-width=1 < %s"
      ],
      "tests": [
        {
          "test_name": "iv_ext_used_outside",
          "test_body": "define i32 @iv_ext_used_outside(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv.1 = phi i16 [ 0, %entry ], [ %iv.1.next, %loop ]\n  %iv.2 = phi i32 [ 0, %entry ], [ %iv.1.ext, %loop ]\n  %gep = getelementptr inbounds nuw i32, ptr %dst, i16 %iv.1\n  store i32 0, ptr %gep, align 4\n  %iv.1.next = add nuw nsw i16 %iv.1, 1\n  %iv.1.ext = zext nneg i16 %iv.1.next to i32\n  %ec = icmp samesign ult i16 %iv.1, 128\n  br i1 %ec, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  %iv.1.ext.lcssa = phi i32 [ %iv.1.ext, %loop ]\n  ret i32 %iv.1.ext.lcssa\n}\n"
        },
        {
          "test_name": "test_iv_increment_incremented",
          "test_body": "define i64 @test_iv_increment_incremented(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv.1 = phi i64 [ 3, %entry ], [ %iv.1.next, %loop ]\n  %iv.2 = phi i64 [ 2, %entry ], [ %iv.2.next, %loop ]\n  %gep = getelementptr i16, ptr %dst, i64 %iv.1\n  store i16 1, ptr %gep, align 2\n  %iv.2.next = add i64 %iv.2, -1\n  %ec = icmp eq i64 %iv.2.next, 0\n  %iv.1.next = add i64 %iv.2.next, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret i64 %iv.1.next\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/scalable-iv-outside-user.ll",
      "commands": [
        "opt -scalable-vectorization=on -force-target-supports-scalable-vectors=true -passes=loop-vectorize -force-vector-width=2 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "iv_live_out_wide",
          "test_body": "define i32 @iv_live_out_wide(ptr %dst) {\nentry:\n  %step.1 = sext i8 0 to i32\n  %step.2 = add nsw i32 %step.1, 1\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.dst = getelementptr inbounds i16, ptr %dst, i32 %iv\n  store i16 0, ptr %gep.dst, align 2\n  %iv.next = add i32 %step.2, %iv\n  %cmp.i = icmp slt i32 %iv.next, 2000\n  br i1 %cmp.i, label %loop, label %e.exit\n\ne.exit:                                           ; preds = %loop\n  %res = phi i32 [ %iv.next, %loop ]\n  ret i32 %res\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize] Miscompilation",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/PASME7\n```\n; bin/opt -passes=loop-vectorize reduced.ll -S -o opt.ll\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\n@e = global [1 x [4 x i16]] zeroinitializer\n@crc32_tab = global [256 x i32] zeroinitializer\n\ndefine i32 @src() {\nentry:\n  store i32 1, ptr @crc32_tab, align 4\n  br label %for.cond4.preheader.outer.i.i.split\n\nfor.cond4.preheader.outer.i.i.split:              ; preds = %for.cond4.preheader.outer.i.i.split, %entry\n  %0 = phi i64 [ %1, %for.cond4.preheader.outer.i.i.split ], [ 3, %entry ]\n  %indvars.iv.i.i23 = phi i64 [ %indvars.iv.next.i.i, %for.cond4.preheader.outer.i.i.split ], [ 2, %entry ]\n  %arrayidx9.i.i = getelementptr i16, ptr @e, i64 %0\n  store i16 1, ptr %arrayidx9.i.i, align 2\n  %indvars.iv.next.i.i = add i64 %indvars.iv.i.i23, -1\n  %tobool7.not.i.i = icmp eq i64 %indvars.iv.next.i.i, 0\n  %1 = add i64 %indvars.iv.next.i.i, 1\n  br i1 %tobool7.not.i.i, label %for.end.thread.i.i.1, label %for.cond4.preheader.outer.i.i.split\n\nfor.end.thread.i.i.1:                             ; preds = %for.cond4.preheader.outer.i.i.split\n  %arrayidx947.i.i = getelementptr i16, ptr @e, i64 %1\n  store i16 0, ptr %arrayidx947.i.i, align 2\n  br label %for.body3\n\nfor.body3:                                        ; preds = %for.body3, %for.end.thread.i.i.1\n  %indvars.iv = phi i64 [ 0, %for.end.thread.i.i.1 ], [ %indvars.iv.next, %for.body3 ]\n  %xor2.i70.i.i1718 = phi i32 [ 0, %for.end.thread.i.i.1 ], [ %3, %for.body3 ]\n  %arrayidx5 = getelementptr i16, ptr @e, i64 %indvars.iv\n  %2 = load i16, ptr %arrayidx5, align 2\n  %conv = zext i16 %2 to i64\n  %idxprom.i.i.i = and i64 %conv, 1\n  %arrayidx.i.i.i = getelementptr i32, ptr @crc32_tab, i64 %idxprom.i.i.i\n  %3 = load i32, ptr %arrayidx.i.i.i, align 4\n  %indvars.iv.next = add i64 %indvars.iv, 1\n  %exitcond.not = icmp eq i64 %indvars.iv.next, 4\n  br i1 %exitcond.not, label %for.end8, label %for.body3\n\nfor.end8:                                         ; preds = %for.body3\n  ret i32 %xor2.i70.i.i1718\n}\n```\n```\n> bin/lli reduced.ll\n> echo $?\n0\n> bin/lli opt.ll\n> echo $?\n1\n```\nllvm version: ab9a80a3ad78f611fd06cd6f7215bd828809310c",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "vectorizers"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "I think this is the same issue as https://github.com/llvm/llvm-project/issues/122496\n\nShould have a fix soon"
      }
    ]
  }
}