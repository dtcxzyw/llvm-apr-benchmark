{
  "bug_id": "164242",
  "issue_url": "https://github.com/llvm/llvm-project/issues/164242",
  "bug_type": "crash",
  "base_commit": "32b534b1927089bffe71b8f6560a31a567a2b87b",
  "knowledge_cutoff": "2025-10-20T11:53:35Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SLPVectorizer"
  ],
  "hints": {
    "fix_commit": "e7f370f910701b6c67d41dab80e645227692c58b",
    "components": [
      "SLPVectorizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        [
          5578,
          5584
        ],
        [
          5586,
          5591
        ],
        [
          5602,
          5638
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp": [
        "schedule"
      ]
    }
  },
  "patch": "commit e7f370f910701b6c67d41dab80e645227692c58b\nAuthor: Alexey Bataev <a.bataev@outlook.com>\nDate:   Mon Oct 20 15:48:36 2025 -0700\n\n    [SLP] Check all copyable children for non-schedulable parent nodes\n    \n    If the parent node is non-schedulable and it includes several copies of\n    the same instruction, its operand might be replaced by the copyable\n    nodes in multiple children nodes, and if the instruction is commutative,\n    they can be used in different operands. The compiler shall consider this\n    opportunity, taking into account that non-copyable children are\n    scheduled only ones for the same parent instruction.\n    \n    Fixes #164242\n\ndiff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\nindex 3f18bd70539a..106cde352e0b 100644\n--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp\n@@ -5578,7 +5578,7 @@ private:\n           // Decrement the unscheduled counter and insert to ready list if\n           // ready.\n           auto DecrUnschedForInst = [&](Instruction *I, TreeEntry *UserTE,\n-                                        unsigned OpIdx) {\n+                                        unsigned OpIdx, bool FirstRun = false) {\n             if (!ScheduleCopyableDataMap.empty()) {\n               const EdgeInfo EI = {UserTE, OpIdx};\n               if (ScheduleCopyableData *CD = getScheduleCopyableData(EI, I)) {\n@@ -5586,6 +5586,8 @@ private:\n                 return;\n               }\n             }\n+            if (!FirstRun)\n+              return;\n             auto It = OperandsUses.find(I);\n             assert(It != OperandsUses.end() && \"Operand not found\");\n             if (It->second > 0) {\n@@ -5602,37 +5604,48 @@ private:\n               break;\n             // Need to search for the lane since the tree entry can be\n             // reordered.\n-            int Lane = std::distance(Bundle->getTreeEntry()->Scalars.begin(),\n-                                     find(Bundle->getTreeEntry()->Scalars, In));\n-            assert(Lane >= 0 && \"Lane not set\");\n-            if (isa<StoreInst>(In) &&\n-                !Bundle->getTreeEntry()->ReorderIndices.empty())\n-              Lane = Bundle->getTreeEntry()->ReorderIndices[Lane];\n-            assert(Lane < static_cast<int>(\n-                              Bundle->getTreeEntry()->Scalars.size()) &&\n-                   \"Couldn't find extract lane\");\n-\n-            // Since vectorization tree is being built recursively this\n-            // assertion ensures that the tree entry has all operands set before\n-            // reaching this code. Couple of exceptions known at the moment are\n-            // extracts where their second (immediate) operand is not added.\n-            // Since immediates do not affect scheduler behavior this is\n-            // considered okay.\n-            assert(In &&\n-                   (isa<ExtractValueInst, ExtractElementInst, CallBase>(In) ||\n-                    In->getNumOperands() ==\n-                        Bundle->getTreeEntry()->getNumOperands() ||\n-                    Bundle->getTreeEntry()->isCopyableElement(In)) &&\n-                   \"Missed TreeEntry operands?\");\n-\n-            for (unsigned OpIdx :\n-                 seq<unsigned>(Bundle->getTreeEntry()->getNumOperands()))\n-              if (auto *I = dyn_cast<Instruction>(\n-                      Bundle->getTreeEntry()->getOperand(OpIdx)[Lane])) {\n-                LLVM_DEBUG(dbgs() << \"SLP:   check for readiness (def): \" << *I\n-                                  << \"\\n\");\n-                DecrUnschedForInst(I, Bundle->getTreeEntry(), OpIdx);\n-              }\n+            auto *It = find(Bundle->getTreeEntry()->Scalars, In);\n+            bool FirstRun = true;\n+            do {\n+              int Lane =\n+                  std::distance(Bundle->getTreeEntry()->Scalars.begin(), It);\n+              assert(Lane >= 0 && \"Lane not set\");\n+              if (isa<StoreInst>(In) &&\n+                  !Bundle->getTreeEntry()->ReorderIndices.empty())\n+                Lane = Bundle->getTreeEntry()->ReorderIndices[Lane];\n+              assert(Lane < static_cast<int>(\n+                                Bundle->getTreeEntry()->Scalars.size()) &&\n+                     \"Couldn't find extract lane\");\n+\n+              // Since vectorization tree is being built recursively this\n+              // assertion ensures that the tree entry has all operands set\n+              // before reaching this code. Couple of exceptions known at the\n+              // moment are extracts where their second (immediate) operand is\n+              // not added. Since immediates do not affect scheduler behavior\n+              // this is considered okay.\n+              assert(In &&\n+                     (isa<ExtractValueInst, ExtractElementInst, CallBase>(In) ||\n+                      In->getNumOperands() ==\n+                          Bundle->getTreeEntry()->getNumOperands() ||\n+                      Bundle->getTreeEntry()->isCopyableElement(In)) &&\n+                     \"Missed TreeEntry operands?\");\n+\n+              for (unsigned OpIdx :\n+                   seq<unsigned>(Bundle->getTreeEntry()->getNumOperands()))\n+                if (auto *I = dyn_cast<Instruction>(\n+                        Bundle->getTreeEntry()->getOperand(OpIdx)[Lane])) {\n+                  LLVM_DEBUG(dbgs() << \"SLP:   check for readiness (def): \"\n+                                    << *I << \"\\n\");\n+                  DecrUnschedForInst(I, Bundle->getTreeEntry(), OpIdx,\n+                                     FirstRun);\n+                }\n+              // If parent node is schedulable, it will be handle correctly.\n+              if (!Bundle->getTreeEntry()->doesNotNeedToSchedule())\n+                break;\n+              It = std::find(std::next(It),\n+                             Bundle->getTreeEntry()->Scalars.end(), In);\n+              FirstRun = false;\n+            } while (It != Bundle->getTreeEntry()->Scalars.end());\n           }\n         } else {\n           // If BundleMember is a stand-alone instruction, no operand reordering\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SLPVectorizer/X86/non-schedulable-parent-multi-copyables.ll",
      "commands": [
        "opt -S -passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s -slp-threshold=-99999"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine void @test() {\n;\nbb:\n  br i1 false, label %bb1, label %bb6\n\nbb1:\n  %add = add i32 0, 0\n  %shl = shl i32 %add, 0\n  %sub = sub i32 0, 1\n  %add2 = add i32 %sub, %shl\n  %add3 = add i32 0, 0\n  %shl4 = shl i32 %add3, 0\n  %ashr = ashr i32 %shl4, 1\n  %add5 = add i32 0, 0\n  br label %bb6\n\nbb6:\n  %phi = phi i32 [ poison, %bb ], [ %add2, %bb1 ]\n  %phi7 = phi i32 [ 0, %bb ], [ %ashr, %bb1 ]\n  %phi8 = phi i32 [ 0, %bb ], [ %add2, %bb1 ]\n  %phi9 = phi i32 [ 0, %bb ], [ %add5, %bb1 ]\n  %or = or i32 %phi8, 0\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "Assertion `all_of(Bundles, [](const ScheduleBundle *Bundle) { return Bundle->isScheduled(); }) && \"must be scheduled at this point\"' failed.",
    "body": "To reproduce run opt with the test below using -passes=slp-vectorizer -slp-threshold=-99999:\n```\n; ModuleID = './reduced.ll'\nsource_filename = \"./reduced.ll\"\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine void @wombat() #0 gc \"statepoint-example\" {\nbb:\n  br i1 false, label %bb1, label %bb6\n\nbb1:                                              ; preds = %bb\n  %add = add i32 0, 0\n  %shl = shl i32 %add, 0\n  %sub = sub i32 0, 1\n  %add2 = add i32 %sub, %shl\n  %add3 = add i32 0, 0\n  %shl4 = shl i32 %add3, 0\n  %ashr = ashr i32 %shl4, 1\n  %add5 = add i32 0, 0\n  br label %bb6\n\nbb6:                                              ; preds = %bb1, %bb\n  %phi = phi i32 [ poison, %bb ], [ %add2, %bb1 ]\n  %phi7 = phi i32 [ 0, %bb ], [ %ashr, %bb1 ]\n  %phi8 = phi i32 [ 0, %bb ], [ %add2, %bb1 ]\n  %phi9 = phi i32 [ 0, %bb ], [ %add5, %bb1 ]\n  %or = or i32 %phi8, 0\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+prfchw,-cldemote,+avx,+aes,+sahf,+pclmul,-xop,+crc32,-amx-fp8,+xsaves,-avx512fp16,-usermsr,-sm4,-egpr,+sse4.1,-avx10.1,-avx512ifma,+xsave,+sse4.2,-tsxldtrk,-sm3,-ptwrite,-widekl,-movrs,-invpcid,+64bit,+xsavec,-avx512vpopcntdq,+cmov,-avx512vp2intersect,-avx512cd,+movbe,-avxvnniint8,-ccmp,-amx-int8,-kl,-sha512,-avxvnni,-rtm,+adx,+avx2,-hreset,-movdiri,-serialize,-vpclmulqdq,-avx512vl,-uintr,-cf,+clflushopt,-raoint,-cmpccxadd,+bmi,-amx-tile,+sse,-gfni,-avxvnniint16,-amx-fp16,-zu,-ndd,+xsaveopt,+rdrnd,-avx512f,-amx-bf16,-avx512bf16,-avx512vnni,-push2pop2,+cx8,-avx512bw,+sse3,-pku,-nf,-amx-tf32,-amx-avx512,+fsgsbase,+clzero,-mwaitx,-lwp,+lzcnt,+sha,-movdir64b,-ppx,+wbnoinvd,-enqcmd,-amx-transpose,-avxneconvert,-tbm,-pconfig,-amx-complex,+ssse3,+cx16,-avx10.2,+bmi2,+fma,+popcnt,-avxifma,+f16c,-avx512bitalg,-rdpru,+clwb,+mmx,+sse2,+rdseed,-avx512vbmi2,-prefetchi,-amx-movrs,+rdpid,-fma4,-avx512vbmi,-shstk,-vaes,-waitpkg,-sgx,+fxsr,-avx512dq,+sse4a\" }\n```\nReproducer: https://godbolt.org/z/rf8Y3ezGe\n\nStack dump:\n```\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=slp-vectorizer -slp-threshold=-99999 <source>\n1.\tRunning pass \"function(slp-vectorizer)\" on module \"<source>\"\n2.\tRunning pass \"slp-vectorizer\" on function \"wombat\"\n #0 0x0000000005945ce8 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5945ce8)\n #1 0x0000000005942b94 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x00007ed06f642520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x00007ed06f6969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x00007ed06f642476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x00007ed06f6287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x00007ed06f62871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x00007ed06f639e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x00000000037732cf llvm::slpvectorizer::BoUpSLP::scheduleBlock(llvm::slpvectorizer::BoUpSLP const&, llvm::slpvectorizer::BoUpSLP::BlockScheduling*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37732cf)\n #9 0x000000000378dbba llvm::slpvectorizer::BoUpSLP::vectorizeTree(llvm::SmallDenseSet<llvm::Value*, 4u, llvm::DenseMapInfo<llvm::Value*, void>> const&, llvm::Instruction*, llvm::ArrayRef<std::tuple<llvm::Value*, unsigned int, bool>>) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x378dbba)\n#10 0x0000000003792012 llvm::slpvectorizer::BoUpSLP::vectorizeTree() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3792012)\n#11 0x00000000037b2fa8 llvm::SLPVectorizerPass::tryToVectorizeList(llvm::ArrayRef<llvm::Value*>, llvm::slpvectorizer::BoUpSLP&, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37b2fa8)\n#12 0x00000000037b7c9f bool tryToVectorizeSequence<llvm::Value>(llvm::SmallVectorImpl<llvm::Value*>&, llvm::function_ref<bool (llvm::Value*, llvm::Value*)>, llvm::function_ref<bool (llvm::ArrayRef<llvm::Value*>, llvm::Value*)>, llvm::function_ref<bool (llvm::ArrayRef<llvm::Value*>, bool)>, bool, llvm::slpvectorizer::BoUpSLP&) (.constprop.0) SLPVectorizer.cpp:0:0\n#13 0x00000000037b900b llvm::SLPVectorizerPass::vectorizeChainsInBlock(llvm::BasicBlock*, llvm::slpvectorizer::BoUpSLP&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37b900b)\n#14 0x00000000037c0e26 llvm::SLPVectorizerPass::runImpl(llvm::Function&, llvm::ScalarEvolution*, llvm::TargetTransformInfo*, llvm::TargetLibraryInfo*, llvm::AAResults*, llvm::LoopInfo*, llvm::DominatorTree*, llvm::AssumptionCache*, llvm::DemandedBits*, llvm::OptimizationRemarkEmitter*) (.part.0) SLPVectorizer.cpp:0:0\n#15 0x00000000037c193b llvm::SLPVectorizerPass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x37c193b)\n#16 0x0000000002f8895e llvm::detail::PassModel<llvm::Function, llvm::SLPVectorizerPass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2f8895e)\n#17 0x00000000057202b1 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x57202b1)\n#18 0x0000000000ef5fce llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xef5fce)\n#19 0x000000000571e81a llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x571e81a)\n#20 0x000000000097887e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97887e)\n#21 0x000000000571e1d1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x571e1d1)\n#22 0x000000000098298a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x98298a)\n#23 0x0000000000976c0e optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x976c0e)\n#24 0x00007ed06f629d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#25 0x00007ed06f629e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#26 0x000000000096df65 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x96df65)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "TatyanaDoubts",
    "labels": [
      "llvm:SLPVectorizer",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  }
}