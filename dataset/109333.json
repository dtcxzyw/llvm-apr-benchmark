{
  "bug_id": "109333",
  "issue_url": "https://github.com/llvm/llvm-project/issues/109333",
  "bug_type": "crash",
  "base_commit": "c498af71d73e96e95730f3b3caaea08d3edbe62c",
  "knowledge_cutoff": "2024-09-19T20:50:34Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopUnroll"
  ],
  "hints": {
    "fix_commit": "5bcc82d43388bb0daa122d5fe7ecda5eca27fc16",
    "components": [
      "LoopPeel"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/LoopPeel.cpp": [
        [
          859,
          865
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/LoopPeel.cpp": [
        "cloneLoopBlocks"
      ]
    }
  },
  "patch": "commit 5bcc82d43388bb0daa122d5fe7ecda5eca27fc16\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Fri Sep 20 16:57:46 2024 +0200\n\n    [LoopPeel] Fix LCSSA phi node invalidation\n    \n    In the test case, the BECount of the second loop uses %load,\n    but we only have an LCSSA phi node for %add, so that is what\n    gets invalidated. Use the forgetLcssaPhiWithNewPredecessor()\n    API instead, which will invalidate the roots of the expression\n    instead.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/109333.\n\ndiff --git a/llvm/lib/Transforms/Utils/LoopPeel.cpp b/llvm/lib/Transforms/Utils/LoopPeel.cpp\nindex 5d7c0d947fac..760f1619e030 100644\n--- a/llvm/lib/Transforms/Utils/LoopPeel.cpp\n+++ b/llvm/lib/Transforms/Utils/LoopPeel.cpp\n@@ -859,7 +859,7 @@ static void cloneLoopBlocks(\n       if (LatchInst && L->contains(LatchInst))\n         LatchVal = VMap[LatchVal];\n       PHI.addIncoming(LatchVal, cast<BasicBlock>(VMap[Edge.first]));\n-      SE.forgetValue(&PHI);\n+      SE.forgetLcssaPhiWithNewPredecessor(L, &PHI);\n     }\n \n   // LastValueMap is updated with the values for the current loop\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopUnroll/pr109333.ll",
      "commands": [
        "opt -S -passes=\"print<scalar-evolution>,loop-unroll\" -unroll-runtime < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "test",
          "test_body": "define void @test(i1 %c, ptr %p) {\nentry:\n  br label %loop.1\n\nloop.1:                                           ; preds = %loop.1, %entry\n  %phi = phi ptr [ null, %entry ], [ %p, %loop.1 ]\n  %load = load i64, ptr %p, align 8\n  %add = add i64 %load, 1\n  br i1 %c, label %if, label %loop.1\n\nif:                                               ; preds = %loop.1\n  %add.lcssa = phi i64 [ %add, %loop.1 ]\n  %gep = getelementptr i64, ptr %p, i64 %add.lcssa\n  br label %loop.2\n\nloop.2:                                           ; preds = %loop.2, %if\n  %iv = phi ptr [ %p, %if ], [ %iv.next, %loop.2 ]\n  %iv.next = getelementptr i8, ptr %iv, i64 8\n  %icmp = icmp eq ptr %iv, %gep\n  br i1 %icmp, label %exit, label %loop.2\n\nexit:                                             ; preds = %loop.2\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "LTO error: Instruction does not dominate all uses",
    "body": "clang crashes while linking\r\n```\r\nclang: error: unable to execute command: Aborted (core dumped)\r\nclang: error: linker command failed due to signal (use -v to see invocation)\r\n```\r\nI followed the instructions [here](https://llvm.org/docs/HowToSubmitABug.html) and narrowed it down to an LTO bug. File to reproduce is attached. [a.out.0.2.internalize-reduced.bc.tar.gz](https://github.com/user-attachments/files/17066318/a.out.0.2.internalize-reduced.bc.tar.gz)\r\n```\r\n$ opt \"-passes=lto<O3>\" a.out.0.2.internalize-reduced.bc\r\nWARNING: You're attempting to print out a bitcode file.\r\nThis is inadvisable as it may cause display problems. If\r\nyou REALLY want to taste LLVM bitcode first-hand, you\r\ncan force output with the `-f' option.\r\n\r\nInstruction does not dominate all uses!\r\n  %.lcssa16 = phi i64 [ %12, %9 ]\r\n  %27 = add i64 %.lcssa16, 2\r\nLLVM ERROR: Broken module found, compilation aborted!\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: opt -passes=lto<O3> reduced-redacted.bc                                                                                                                             #0 0x00007e899efc4d90 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /usr/src/debug/llvm/llvm-18.1.8.src/lib/Support/Unix/Signals.inc:723:22\r\n #1 0x00007e899efc1d4d llvm::sys::RunSignalHandlers() /usr/src/debug/llvm/llvm-18.1.8.src/lib/Support/Signals.cpp:105:20\r\n #2 0x00007e899efc1d4d SignalHandler /usr/src/debug/llvm/llvm-18.1.8.src/lib/Support/Unix/Signals.inc:403:31\r\n #3 0x00007e899e24c1d0 (/usr/lib/libc.so.6+0x3d1d0)\r\n #4 0x00007e899e2a53f4 __pthread_kill_implementation /usr/src/debug/glibc/glibc/nptl/pthread_kill.c:44:76\r\n #5 0x00007e899e24c120 raise /usr/src/debug/glibc/glibc/signal/../sysdeps/posix/raise.c:27:6\r\n #6 0x00007e899e2334c3 abort /usr/src/debug/glibc/glibc/stdlib/abort.c:81:7\r\n #7 0x00007e899ecaba1b std::mutex::lock() /usr/include/c++/14.1.1/bits/std_mutex.h:117:22\r\n #8 0x00007e899ecaba1b std::lock_guard<std::mutex>::lock_guard(std::mutex&) /usr/include/c++/14.1.1/bits/std_mutex.h:250:23\r\n #9 0x00007e899ecaba1b llvm::install_bad_alloc_error_handler(void (*)(void*, char const*, bool), void*) /usr/src/debug/llvm/llvm-18.1.8.src/lib/Support/ErrorHandling.cpp:131:61\r\n#10 0x00007e899eec070e (/usr/lib/libLLVM.so.18.1+0x6c070e)\r\n#11 0x00007e899f21aa1b (/usr/lib/libLLVM.so.18.1+0xa1aa1b)\r\n#12 0x000055a86e4acf57 llvm::detail::PassModel<llvm::Module, llvm::VerifierPass, llvm::PreservedAnalyses, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm:\r\n:Module>&) /usr/src/debug/llvm/llvm-18.1.8.src/include/llvm/IR/PassManagerInternal.h:90:3\r\n#13 0x00007e899f1d767e llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) /usr/src/debug/llvm/llvm-18.1.8.src/incl\r\nude/llvm/IR/PassManager.h:547:20\r\n#14 0x000055a86e4b7052 llvm::SmallPtrSetImplBase::isSmall() const /usr/src/debug/llvm/llvm-18.1.8.src/include/llvm/ADT/SmallPtrSet.h:195:33\r\n#15 0x000055a86e4b7052 llvm::SmallPtrSetImplBase::~SmallPtrSetImplBase() /usr/src/debug/llvm/llvm-18.1.8.src/include/llvm/ADT/SmallPtrSet.h:83:17\r\n#16 0x000055a86e4b7052 llvm::SmallPtrSetImpl<llvm::AnalysisKey*>::~SmallPtrSetImpl() /usr/src/debug/llvm/llvm-18.1.8.src/include/llvm/ADT/SmallPtrSet.h:345:7\r\n#17 0x000055a86e4b7052 llvm::SmallPtrSet<llvm::AnalysisKey*, 2u>::~SmallPtrSet() /usr/src/debug/llvm/llvm-18.1.8.src/include/llvm/ADT/SmallPtrSet.h:451:7\r\n#18 0x000055a86e4b7052 llvm::PreservedAnalyses::~PreservedAnalyses() /usr/src/debug/llvm/llvm-18.1.8.src/include/llvm/IR/PassManager.h:172:7\r\n#19 0x000055a86e4b7052 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutpu\r\ntFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool) /usr/src/debug/llvm/llvm-18.1.8\r\n.src/tools/opt/NewPMDriver.cpp:527:10\r\n#20 0x000055a86e4ab1ed std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string() /usr/include/c++/14.1.1/bits/basic_string.h:809:19\r\n#21 0x000055a86e4ab1ed main /usr/src/debug/llvm/llvm-18.1.8.src/tools/opt/opt.cpp:747:3\r\n#22 0x00007e899e234e08 __libc_start_call_main /usr/src/debug/glibc/glibc/csu/../sysdeps/nptl/libc_start_call_main.h:74:3\r\n#23 0x00007e899e234ecc call_init /usr/src/debug/glibc/glibc/csu/../csu/libc-start.c:128:20\r\n#24 0x00007e899e234ecc __libc_start_main /usr/src/debug/glibc/glibc/csu/../csu/libc-start.c:347:5\r\n#25 0x000055a86e4abfd5 _start (/usr/bin/opt+0x1cfd5)\r\nAborted (core dumped)\r\n```\r\nThis happened after adding `-fsplit-lto-unit` to some parts of my code base.\r\n",
    "author": "googlebleh",
    "labels": [
      "loopoptim",
      "release:backport",
      "llvm:crash"
    ],
    "comments": [
      {
        "author": "googlebleh",
        "body": "While bisecting using this reduced test case, I was able to reproduce this crash on several versions of LLVM between 15 and 18.1.8. I was also able to reproduce on the tip of `main` (e439fdf4ea0dbc6f001428f4d4956700bf26bb97). However, this crash did not reproduce on 15.0.7. The commit on 15.0.7 that \"fixed\" the issue is\r\n```\r\ncommit f3c5289e78462fb96015f79c954d95a0d527ba55                                                                        \r\nAuthor: Martin Storsj\u00f6 <martin@martin.st>                                                                              \r\nDate:   Wed Oct 5 14:44:21 2022 +0300                                                                                  \r\n                                                                                                                       \r\n    Revert \"Recommit \"[SCEV] Look through single value PHIs.\" (take 3)\"                                                \r\n                                                                                                                       \r\n    This reverts commit 20d798bd47ec5191de1b2a8a031da06a04e612e1.                                                      \r\n                                                                                                                       \r\n    This commit caused crashes in some cases, see github issue #58152.                                                 \r\n    This is fixed on main, but backporting it requires multiple                                                                                                                                                                               \r\n    nontrivial cherrypicks.                                                                                            \r\n                                                                                                                       \r\n    Updating llvm/test/Transforms/LoopVectorize/create-induction-resume.ll                                             \r\n    with update_test_checks.py, so this isn't an exact automatic revert,                                               \r\n    as that test case was added after the reverted commit.                                                             \r\n                                                                                                                       \r\n    This fixes #58152 for the release branch.                                                                          \r\n                                                                                                                       \r\n llvm/lib/Analysis/ScalarEvolution.cpp              |  7 ++-\r\n llvm/test/Analysis/DependenceAnalysis/lcssa.ll     |  2 +-                                                            \r\n llvm/test/Analysis/ScalarEvolution/cycled_phis.ll  |  4 +-                                                            \r\n .../ScalarEvolution/incorrect-exit-count.ll        |  2 +-                                                                                                                                                                                   \r\n .../Analysis/ScalarEvolution/solve-quadratic-i1.ll |  4 +-                                                            \r\n .../ScalarEvolution/solve-quadratic-overflow.ll    |  6 +--                                                                                                                                                                                  \r\n llvm/test/Analysis/ScalarEvolution/trivial-phis.ll |  2 +-                                                            \r\n llvm/test/Transforms/LoopStrengthReduce/funclet.ll | 40 +++++++++-------\r\n .../LoopVectorize/create-induction-resume.ll       | 24 ++++------\r\n llvm/test/Transforms/LoopVectorize/pr45259.ll      | 55 +++++++++++-----------\r\n 10 files changed, 75 insertions(+), 71 deletions(-)\r\n```\r\nspecifically, this (almost) 1-line diff\r\n```diff\r\ndiff --git a/llvm/lib/Analysis/ScalarEvolution.cpp b/llvm/lib/Analysis/ScalarEvolution.cpp\r\nindex 4b2db80bc1ec..3b73f9511eca 100644\r\n--- a/llvm/lib/Analysis/ScalarEvolution.cpp\r\n+++ b/llvm/lib/Analysis/ScalarEvolution.cpp\r\n@@ -6023,8 +6023,13 @@ const SCEV *ScalarEvolution::createNodeForPHI(PHINode *PN) {\r\n   if (const SCEV *S = createAddRecFromPHI(PN))\r\n     return S;\r\n \r\n+  // If the PHI has a single incoming value, follow that value, unless the\r\n+  // PHI's incoming blocks are in a different loop, in which case doing so\r\n+  // risks breaking LCSSA form. Instcombine would normally zap these, but\r\n+  // it doesn't have DominatorTree information, so it may miss cases.\r\n   if (Value *V = simplifyInstruction(PN, {getDataLayout(), &TLI, &DT, &AC}))\r\n-    return getSCEV(V);\r\n+    if (LI.replacementPreservesLCSSAForm(PN, V))\r\n+      return getSCEV(V);\r\n \r\n   if (const SCEV *S = createNodeFromSelectLikePHI(PN))\r\n     return S;\r\n```\r\n"
      },
      {
        "author": "nikic",
        "body": "Reduced:\r\n```llvm\r\n; RUN: opt -passes=\"print<scalar-evolution>,loop-unroll\" -unroll-runtime\r\ndefine void @test(i1 %c, ptr %p) {\r\nentry:\r\n  br label %loop\r\n\r\nloop:\r\n  %phi = phi ptr [ null, %entry ], [ %p, %loop ]\r\n  %load = load i64, ptr %p, align 8\r\n  %add = add i64 %load, 1\r\n  br i1 %c, label %bb2, label %loop\r\n\r\nbb2:\r\n  %add.lcssa = phi i64 [ %add, %loop ]\r\n  %gep = getelementptr i64, ptr %p, i64 %add.lcssa\r\n  br label %loop2\r\n\r\nloop2:\r\n  %iv = phi ptr [ %p, %bb2 ], [ %iv.next, %loop2 ]\r\n  %iv.next = getelementptr i8, ptr %iv, i64 8\r\n  %icmp = icmp eq ptr %iv, %gep\r\n  br i1 %icmp, label %exit, label %loop2\r\n\r\nexit:\r\n  ret void\r\n}\r\n```"
      },
      {
        "author": "nikic",
        "body": "From a cursory look, the problem here is that the BECount of `loop2` depends on `%load`, and after peeling it should instead depend on a phi node, but instead still depends on `%load`. As the BECount does not dominate the loop, SCEV is invalid.\r\n\r\nThis issue sounds very familiar, we've fixed variants of this in the past."
      }
    ]
  },
  "verified": true,
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "bisect": "Cannot find a good commit"
}