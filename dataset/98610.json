{
  "bug_id": "98610",
  "issue_url": "https://github.com/llvm/llvm-project/issues/98610",
  "bug_type": "hang",
  "base_commit": "9ad72df55cb74b29193270c28f6974d2af8e0b71",
  "knowledge_cutoff": "2024-07-12T10:31:22Z",
  "lit_test_dir": [
    "llvm/test/Transforms/MemCpyOpt"
  ],
  "hints": {
    "fix_commit": "71051deff27928cff908ea794e09806eee662801",
    "components": [
      "MemCpyOptimizer"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp": [
        [
          1296,
          1301
        ],
        [
          1312,
          1318
        ],
        [
          1726,
          1733
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp": [
        "MemCpyOptPass::processMemSetMemCpyDependence",
        "MemCpyOptPass::processMemCpy"
      ]
    }
  },
  "patch": "commit 71051deff27928cff908ea794e09806eee662801\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Mon Jul 15 09:41:11 2024 +0200\n\n    [MemCpyOpt] Fix infinite loop in memset+memcpy fold (#98638)\n    \n    For the case where the memcpy size is zero, this transform is a complex\n    no-op. This can lead to an infinite loop when the size is zero in a way\n    that BasicAA understands, because it can still understand that dst and\n    dst + src_size are MustAlias.\n    \n    I've tried to mitigate this before using the isZeroSize() check, but we\n    can hit cases where InstSimplify doesn't understand that the size is\n    zero, but BasicAA does.\n    \n    As such, this bites the bullet and adds an explicit isKnownNonZero()\n    check to guard against no-op transforms.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/98610.\n\ndiff --git a/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp b/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp\nindex 4063762c88a2..cee34f0a6da1 100644\n--- a/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp\n+++ b/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp\n@@ -1296,6 +1296,15 @@ bool MemCpyOptPass::processMemSetMemCpyDependence(MemCpyInst *MemCpy,\n   if (!BAA.isMustAlias(MemSet->getDest(), MemCpy->getDest()))\n     return false;\n \n+  // Don't perform the transform if src_size may be zero. In that case, the\n+  // transform is essentially a complex no-op and may lead to an infinite\n+  // loop if BasicAA is smart enough to understand that dst and dst + src_size\n+  // are still MustAlias after the transform.\n+  Value *SrcSize = MemCpy->getLength();\n+  if (!isKnownNonZero(SrcSize,\n+                      SimplifyQuery(MemCpy->getDataLayout(), DT, AC, MemCpy)))\n+    return false;\n+\n   // Check that src and dst of the memcpy aren't the same. While memcpy\n   // operands cannot partially overlap, exact equality is allowed.\n   if (isModSet(BAA.getModRefInfo(MemCpy, MemoryLocation::getForSource(MemCpy))))\n@@ -1312,7 +1321,6 @@ bool MemCpyOptPass::processMemSetMemCpyDependence(MemCpyInst *MemCpy,\n   // Use the same i8* dest as the memcpy, killing the memset dest if different.\n   Value *Dest = MemCpy->getRawDest();\n   Value *DestSize = MemSet->getLength();\n-  Value *SrcSize = MemCpy->getLength();\n \n   if (mayBeVisibleThroughUnwinding(Dest, MemSet, MemCpy))\n     return false;\n@@ -1726,8 +1734,7 @@ bool MemCpyOptPass::processMemCpy(MemCpyInst *M, BasicBlock::iterator &BBI) {\n     return true;\n   }\n \n-  // If the size is zero, remove the memcpy. This also prevents infinite loops\n-  // in processMemSetMemCpyDependence, which is a no-op for zero-length memcpys.\n+  // If the size is zero, remove the memcpy.\n   if (isZeroSize(M->getLength())) {\n     ++BBI;\n     eraseInstruction(M);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/MemCpyOpt/memcpy-zero-size.ll",
      "commands": [
        "opt -S -passes=memcpyopt < %s"
      ],
      "tests": [
        {
          "test_name": "pr64886",
          "test_body": "; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\ndefine void @pr64886(i64 %len, ptr noalias %p) {\n  call void @llvm.memset.p0.i64(ptr inttoptr (i64 -1 to ptr), i8 0, i64 %len, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr inttoptr (i64 -1 to ptr), ptr %p, i64 poison, i1 false)\n  ret void\n}\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\n"
        },
        {
          "test_name": "pr98610",
          "test_body": "; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\ndefine void @pr98610(ptr %p, ptr noalias %p2) {\n  call void @llvm.memset.p0.i64(ptr %p, i8 0, i64 1, i1 false)\n  %zero.ext = zext i32 0 to i64\n  %mul = mul i64 %zero.ext, 1\n  call void @llvm.memcpy.p0.p0.i64(ptr %p, ptr %p2, i64 %mul, i1 false)\n  ret void\n}\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/MemCpyOpt/memset-memcpy-dbgloc.ll",
      "commands": [
        "opt -passes=memcpyopt -S %s -verify-memoryssa"
      ],
      "tests": [
        {
          "test_name": "test_constant",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\n@C = external constant [0 x i8]\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\ndefine void @test_constant(i64 %src_size, ptr %dst, i64 %dst_size, i8 %c) !dbg !5 {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false), !dbg !11\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr @C, i64 %src_size, i1 false), !dbg !12\n  ret void, !dbg !13\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n\n!llvm.dbg.cu = !{!0}\n!llvm.debugify = !{!2, !3}\n!llvm.module.flags = !{!4}\n\n!0 = distinct !DICompileUnit(language: DW_LANG_C, file: !1, producer: \"debugify\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug)\n!1 = !DIFile(filename: \"memset-memcpy-dbgloc.ll\", directory: \"/\")\n!2 = !{i32 3}\n!3 = !{i32 1}\n!4 = !{i32 2, !\"Debug Info Version\", i32 3}\n!5 = distinct !DISubprogram(name: \"test_constant\", linkageName: \"test_constant\", scope: null, file: !1, line: 1, type: !6, scopeLine: 1, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !8)\n!6 = !DISubroutineType(types: !7)\n!7 = !{}\n!8 = !{!9}\n!9 = !DILocalVariable(name: \"1\", scope: !5, file: !1, line: 3, type: !10)\n!10 = !DIBasicType(name: \"ty32\", size: 32, encoding: DW_ATE_unsigned)\n!11 = !DILocation(line: 1, column: 1, scope: !5)\n!12 = !DILocation(line: 2, column: 1, scope: !5)\n!13 = !DILocation(line: 3, column: 1, scope: !5)\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/MemCpyOpt/memset-memcpy-redundant-memset.ll",
      "commands": [
        "opt -passes=memcpyopt -S %s -verify-memoryssa"
      ],
      "tests": [
        {
          "test_name": "test_different_types_i32_i128",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_different_types_i32_i128(ptr noalias %dst, ptr %src, i32 %dst_size, i128 %src_size, i8 %c) {\n  %non.zero = icmp ne i128 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i32(ptr %dst, i8 %c, i32 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i128(ptr %dst, ptr %src, i128 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i128(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i128, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_missing_noalias",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_missing_noalias(ptr %src, i64 %src_size, ptr %dst, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_different_types_i128_i32",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_different_types_i128_i32(ptr noalias %dst, ptr %src, i128 %dst_size, i32 %src_size, i8 %c) {\n  %non.zero = icmp ne i32 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i128(ptr %dst, i8 %c, i128 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i32(ptr %dst, ptr %src, i32 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i128(ptr nocapture writeonly, i8, i128, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_align_memcpy",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_align_memcpy(ptr %src, ptr noalias %dst, i64 %dst_size) {\n  call void @llvm.memset.p0.i64(ptr %dst, i8 0, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dst, ptr align 8 %src, i64 80, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\n"
        },
        {
          "test_name": "test_different_dst",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_different_dst(ptr noalias %dst2, ptr %src, i64 %src_size, ptr noalias %dst, i64 %dst_size) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 0, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst2, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_non_i8_dst_type",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_non_i8_dst_type(ptr %src, i64 %src_size, ptr noalias %dst_pi64, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst_pi64, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst_pi64, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_different_types_i64_i32",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_different_types_i64_i32(ptr noalias %dst, ptr %src, i64 %dst_size, i32 %src_size, i8 %c) {\n  %non.zero = icmp ne i32 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i32(ptr %dst, ptr %src, i32 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_intermediate_write",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\n%struct = type { [8 x i8], [8 x i8] }\n\ndefine void @test_intermediate_write(ptr %b) {\n  %a = alloca %struct, align 8\n  %a1 = getelementptr %struct, ptr %a, i32 0, i32 1, i32 0\n  call void @llvm.memset.p0.i64(ptr %a, i8 0, i64 16, i1 false)\n  store i8 1, ptr %a1, align 1\n  call void @llvm.memcpy.p0.p0.i64(ptr %a, ptr %b, i64 8, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\n"
        },
        {
          "test_name": "test",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test(ptr %src, i64 %src_size, ptr noalias %dst, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_same_dynamic_size",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_same_dynamic_size(ptr noalias %src, ptr noalias %dst, i64 %size, i8 %c) {\n  %non.zero = icmp ne i64 %size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_weird_element_type",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_weird_element_type(ptr %src, i64 %src_size, ptr noalias %dst, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_throwing_call",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_throwing_call(ptr %src, i64 %src_size, ptr noalias %dst, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @call() #3\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\ndeclare void @call()\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\nattributes #3 = { memory(none) }\n"
        },
        {
          "test_name": "test_same_const_size",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_same_const_size(ptr noalias %src, ptr noalias %dst, i8 %c) {\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 16, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 16, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\n"
        },
        {
          "test_name": "test_must_alias_different_size",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_must_alias_different_size(ptr noalias %src, i64 %src_size, ptr noalias %dst, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  %gep1 = getelementptr i8, ptr %dst, i64 16\n  call void @llvm.memset.p0.i64(ptr %gep1, i8 %c, i64 %dst_size, i1 false)\n  %gep2 = getelementptr i8, ptr %dst, i64 16\n  call void @llvm.memcpy.p0.p0.i64(ptr %gep2, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_throwing_call_alloca",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_throwing_call_alloca(ptr %src, i64 %src_size, i64 %dst_size, i8 %c) {\n  %dst = alloca i8, align 1\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @call() #3\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\ndeclare void @call()\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\nattributes #3 = { memory(none) }\n"
        },
        {
          "test_name": "test_addrspace",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_addrspace(ptr addrspace(1) %src, i64 %src_size, ptr addrspace(1) noalias %dst, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p1.i64(ptr addrspace(1) %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst, ptr addrspace(1) %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p1.i64(ptr addrspace(1) nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) noalias nocapture writeonly, ptr addrspace(1) noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_constant",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\n@C = external constant [0 x i8]\n\ndefine void @test_constant(i64 %src_size, ptr %dst, i64 %dst_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr @C, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_different_types_i32_i64",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_different_types_i32_i64(ptr noalias %dst, ptr %src, i32 %dst_size, i64 %src_size, i8 %c) {\n  %non.zero = icmp ne i64 %src_size, 0\n  call void @llvm.assume(i1 %non.zero)\n  call void @llvm.memset.p0.i32(ptr %dst, i8 %c, i32 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1 immarg) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #2\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #2 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        },
        {
          "test_name": "test_must_alias_same_size",
          "test_body": "target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n\ndefine void @test_must_alias_same_size(ptr noalias %src, ptr noalias %dst, i8 %c) {\n  %gep1 = getelementptr i8, ptr %dst, i64 16\n  call void @llvm.memset.p0.i64(ptr %gep1, i8 %c, i64 16, i1 false)\n  %gep2 = getelementptr i8, ptr %dst, i64 16\n  call void @llvm.memcpy.p0.p0.i64(ptr %gep2, ptr %src, i64 16, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/MemCpyOpt/opaque-ptr.ll",
      "commands": [
        "opt -passes=memcpyopt -S %s -verify-memoryssa"
      ],
      "tests": [
        {
          "test_name": "test_memset_memcpy",
          "test_body": "define void @test_memset_memcpy(ptr %src, i64 range(i64 1, 42) %src_size, ptr noalias %dst, i64 %dst_size, i8 %c) {\n  call void @llvm.memset.p0.i64(ptr %dst, i8 %c, i64 %dst_size, i1 false)\n  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %src, i64 %src_size, i1 false)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)\ndeclare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0\n\n; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1\n\nattributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }\nattributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Clang hangs forever building under -O1",
    "body": "ToT Clang hangs when building under -O1.\r\n\r\n```\r\nclang++ test.i -fno-exceptions -O1 -c -emit-llvm\r\n```\r\n\r\nThe reproducer, `test.i`:\r\n\r\n```c++\r\nclass MockDevice;\r\nstruct sp {\r\n  MockDevice operator*();\r\n};\r\nvoid memset(void *__dest, int __ch, unsigned __len) {\r\n  long __trans_tmp_1 = __builtin_object_size(__dest, 0);\r\n  __builtin___memset_chk(__dest, __ch, __len, __trans_tmp_1);\r\n}\r\ntemplate <class>\r\nclass function;\r\ntemplate <class _Rp, class... _ArgTypes>\r\nclass function<_Rp(_ArgTypes...)> {\r\n public:\r\n  template <class _Fp>\r\n  function operator=(_Fp);\r\n};\r\ntemplate <typename T>\r\nstruct hidl_vec {\r\n  hidl_vec() : mSize() { memset(mPad, 0, 0); }\r\n  hidl_vec(hidl_vec &other) { *this = other; }\r\n  hidl_vec &operator=(hidl_vec &other) {\r\n    copyFrom(other, other.mSize);\r\n    return *this;\r\n  }\r\n  T &operator[](unsigned index) { return mBuffer[index]; }\r\n  T* mBuffer;\r\n  unsigned mSize;\r\n  unsigned mPad[];\r\n  template <typename Array>\r\n  void copyFrom(Array &data, unsigned size) {\r\n    mSize = size;\r\n    if (mSize) mBuffer = new T();\r\n    for (int i = 0; i < size; ++i) mBuffer[i] = data[i];\r\n  }\r\n};\r\nstruct Capabilities {\r\n  struct OperandPerformance {\r\n    int a, b, c;\r\n  };\r\n  hidl_vec<OperandPerformance> operandPerformance;\r\n};\r\ntemplate <typename>\r\nclass Action;\r\ntemplate <typename R, typename... Args>\r\nclass Action<R(Args...)> {\r\n  using F = R();\r\n public:\r\n  template <typename G>\r\n  Action(G fun) {\r\n    fun_ = fun;\r\n  }\r\n  function<F> fun_;\r\n};\r\nstruct OnCallSpec {\r\n  OnCallSpec WillByDefault(Action<void()>);\r\n};\r\nstruct MockSpec {\r\n  OnCallSpec InternalDefaultActionSetAt();\r\n};\r\nstruct MockDevice {\r\n  MockSpec gmock_getCapabilities();\r\n};\r\nsp createMockDevice_mockDevice;\r\nMockDevice createMockDevice() {\r\n  Capabilities getCapabilities_ret;\r\n  (*createMockDevice_mockDevice)\r\n      .gmock_getCapabilities()\r\n      .InternalDefaultActionSetAt()\r\n      .WillByDefault(getCapabilities_ret);\r\n  return *createMockDevice_mockDevice;\r\n}\r\n```",
    "author": "kongy",
    "labels": [
      "confirmed",
      "llvm:hang",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "AaronBallman",
        "body": "This seems to be hanging somewhere in this vicinity:\r\n```\r\n>\tclang.exe!llvm::detail::CheckedInt::from<int,0>(int FromValue) Line 136\tC++\r\n \tclang.exe!llvm::detail::CheckedInt::from<enum llvm::IRMemLocation,0>(llvm::IRMemLocation FromValue) Line 143\tC++\r\n \tclang.exe!llvm::detail::SafeIntIterator<enum llvm::IRMemLocation,0>::SafeIntIterator<enum llvm::IRMemLocation,0>(llvm::IRMemLocation Value) Line 196\tC++\r\n \tclang.exe!llvm::iota_range<enum llvm::IRMemLocation>::iota_range<enum llvm::IRMemLocation>(llvm::IRMemLocation Begin, llvm::IRMemLocation End, bool Inclusive) Line 275\tC++\r\n \tclang.exe!llvm::enum_seq_inclusive<enum llvm::IRMemLocation,void>(llvm::IRMemLocation Begin, llvm::IRMemLocation End, llvm::force_iteration_on_noniterable_enum_t __formal) Line 381\tC++\r\n \tclang.exe!llvm::MemoryEffectsBase<enum llvm::IRMemLocation>::locations() Line 96\tC++\r\n \tclang.exe!llvm::MemoryEffectsBase<enum llvm::IRMemLocation>::MemoryEffectsBase<enum llvm::IRMemLocation>(llvm::ModRefInfo MR) Line 107\tC++\r\n \tclang.exe!llvm::MemoryEffectsBase<enum llvm::IRMemLocation>::unknown() Line 113\tC++\r\n \tclang.exe!llvm::GlobalsAAResult::getMemoryEffects(const llvm::Function * F) Line 244\tC++\r\n \tclang.exe!llvm::AAResults::Model<llvm::GlobalsAAResult>::getMemoryEffects(const llvm::Function * F) Line 784\tC++\r\n \tclang.exe!llvm::AAResults::getMemoryEffects(const llvm::Function * F) Line 396\tC++\r\n \tclang.exe!llvm::BasicAAResult::getMemoryEffects(const llvm::CallBase * Call, llvm::AAQueryInfo & AAQI) Line 830\tC++\r\n \tclang.exe!llvm::AAResults::Model<llvm::BasicAAResult>::getMemoryEffects(const llvm::CallBase * Call, llvm::AAQueryInfo & AAQI) Line 780\tC++\r\n \tclang.exe!llvm::AAResults::getMemoryEffects(const llvm::CallBase * Call, llvm::AAQueryInfo & AAQI) Line 377\tC++\r\n \tclang.exe!llvm::AAResults::getModRefInfo(const llvm::CallBase * Call, const llvm::MemoryLocation & Loc, llvm::AAQueryInfo & AAQI) Line 230\tC++\r\n \tclang.exe!llvm::AAResults::getModRefInfo(const llvm::Instruction * I, const std::optional<llvm::MemoryLocation> & OptLoc, llvm::AAQueryInfo & AAQIP) Line 628\tC++\r\n \tclang.exe!llvm::BatchAAResults::getModRefInfo(const llvm::Instruction * I, const std::optional<llvm::MemoryLocation> & OptLoc) Line 646\tC++\r\n \tclang.exe!llvm::MemCpyOptPass::processMemSetMemCpyDependence(llvm::MemCpyInst * MemCpy, llvm::MemSetInst * MemSet, llvm::BatchAAResults & BAA) Line 1252\tC++\r\n \tclang.exe!llvm::MemCpyOptPass::processMemCpy(llvm::MemCpyInst * M, llvm::ilist_iterator_w_bits<llvm::ilist_detail::node_options<llvm::Instruction,1,0,void,1,llvm::BasicBlock>,0,0> & BBI) Line 1725\tC++\r\n \tclang.exe!llvm::MemCpyOptPass::iterateOnFunction(llvm::Function & F) Line 2013\tC++\r\n \tclang.exe!llvm::MemCpyOptPass::runImpl(llvm::Function & F, llvm::TargetLibraryInfo * TLI_, llvm::AAResults * AA_, llvm::AssumptionCache * AC_, llvm::DominatorTree * DT_, llvm::PostDominatorTree * PDT_, llvm::MemorySSA * MSSA_) Line 2070\tC++\r\n \tclang.exe!llvm::MemCpyOptPass::run(llvm::Function & F, llvm::AnalysisManager<llvm::Function> & AM) Line 2045\tC++\r\n \tclang.exe!llvm::detail::PassModel<llvm::Function,llvm::MemCpyOptPass,llvm::AnalysisManager<llvm::Function>>::run(llvm::Function & IR, llvm::AnalysisManager<llvm::Function> & AM) Line 90\tC++\r\n \tclang.exe!llvm::PassManager<llvm::Function,llvm::AnalysisManager<llvm::Function>>::run(llvm::Function & IR, llvm::AnalysisManager<llvm::Function> & AM) Line 85\tC++\r\n \tclang.exe!llvm::detail::PassModel<llvm::Function,llvm::PassManager<llvm::Function,llvm::AnalysisManager<llvm::Function>>,llvm::AnalysisManager<llvm::Function>>::run(llvm::Function & IR, llvm::AnalysisManager<llvm::Function> & AM) Line 90\tC++\r\n \tclang.exe!llvm::CGSCCToFunctionPassAdaptor::run(llvm::LazyCallGraph::SCC & C, llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &> & AM, llvm::LazyCallGraph & CG, llvm::CGSCCUpdateResult & UR) Line 543\tC++\r\n \tclang.exe!llvm::detail::PassModel<llvm::LazyCallGraph::SCC,llvm::CGSCCToFunctionPassAdaptor,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &>,llvm::LazyCallGraph &,llvm::CGSCCUpdateResult &>::run(llvm::LazyCallGraph::SCC & IR, llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &> & AM, llvm::LazyCallGraph & <ExtraArgs_0>, llvm::CGSCCUpdateResult & <ExtraArgs_1>) Line 90\tC++\r\n \tclang.exe!llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &>,llvm::LazyCallGraph &,llvm::CGSCCUpdateResult &>::run(llvm::LazyCallGraph::SCC & InitialC, llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &> & AM, llvm::LazyCallGraph & G, llvm::CGSCCUpdateResult & UR) Line 90\tC++\r\n \tclang.exe!llvm::detail::PassModel<llvm::LazyCallGraph::SCC,llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &>,llvm::LazyCallGraph &,llvm::CGSCCUpdateResult &>,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &>,llvm::LazyCallGraph &,llvm::CGSCCUpdateResult &>::run(llvm::LazyCallGraph::SCC & IR, llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &> & AM, llvm::LazyCallGraph & <ExtraArgs_0>, llvm::CGSCCUpdateResult & <ExtraArgs_1>) Line 90\tC++\r\n \tclang.exe!llvm::DevirtSCCRepeatedPass::run(llvm::LazyCallGraph::SCC & InitialC, llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &> & AM, llvm::LazyCallGraph & CG, llvm::CGSCCUpdateResult & UR) Line 415\tC++\r\n \tclang.exe!llvm::detail::PassModel<llvm::LazyCallGraph::SCC,llvm::DevirtSCCRepeatedPass,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &>,llvm::LazyCallGraph &,llvm::CGSCCUpdateResult &>::run(llvm::LazyCallGraph::SCC & IR, llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph &> & AM, llvm::LazyCallGraph & <ExtraArgs_0>, llvm::CGSCCUpdateResult & <ExtraArgs_1>) Line 90\tC++\r\n \tclang.exe!llvm::ModuleToPostOrderCGSCCPassAdaptor::run(llvm::Module & M, llvm::AnalysisManager<llvm::Module> & AM) Line 277\tC++\r\n \tclang.exe!llvm::detail::PassModel<llvm::Module,llvm::ModuleToPostOrderCGSCCPassAdaptor,llvm::AnalysisManager<llvm::Module>>::run(llvm::Module & IR, llvm::AnalysisManager<llvm::Module> & AM) Line 90\tC++\r\n \tclang.exe!llvm::PassManager<llvm::Module,llvm::AnalysisManager<llvm::Module>>::run(llvm::Module & IR, llvm::AnalysisManager<llvm::Module> & AM) Line 85\tC++\r\n \tclang.exe!llvm::ModuleInlinerWrapperPass::run(llvm::Module & M, llvm::AnalysisManager<llvm::Module> & MAM) Line 631\tC++\r\n \tclang.exe!llvm::detail::PassModel<llvm::Module,llvm::ModuleInlinerWrapperPass,llvm::AnalysisManager<llvm::Module>>::run(llvm::Module & IR, llvm::AnalysisManager<llvm::Module> & AM) Line 90\tC++\r\n \tclang.exe!llvm::PassManager<llvm::Module,llvm::AnalysisManager<llvm::Module>>::run(llvm::Module & IR, llvm::AnalysisManager<llvm::Module> & AM) Line 85\tC++\r\n \tclang.exe!`anonymous namespace'::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction Action, std::unique_ptr<llvm::raw_pwrite_stream,std::default_delete<llvm::raw_pwrite_stream>> & OS, std::unique_ptr<llvm::ToolOutputFile,std::default_delete<llvm::ToolOutputFile>> & ThinLinkOS, clang::BackendConsumer * BC) Line 1114\tC++\r\n \tclang.exe!`anonymous namespace'::EmitAssemblyHelper::EmitAssembly(clang::BackendAction Action, std::unique_ptr<llvm::raw_pwrite_stream,std::default_delete<llvm::raw_pwrite_stream>> OS, clang::BackendConsumer * BC) Line 1180\tC++\r\n \tclang.exe!clang::EmitBackendOutput(clang::DiagnosticsEngine & Diags, const clang::HeaderSearchOptions & HeaderOpts, const clang::CodeGenOptions & CGOpts, const clang::TargetOptions & TOpts, const clang::LangOptions & LOpts, llvm::StringRef TDesc, llvm::Module * M, clang::BackendAction Action, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS, std::unique_ptr<llvm::raw_pwrite_stream,std::default_delete<llvm::raw_pwrite_stream>> OS, clang::BackendConsumer * BC) Line 1341\tC++\r\n \tclang.exe!clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext & C) Line 354\tC++\r\n \tclang.exe!clang::ParseAST(clang::Sema & S, bool PrintStats, bool SkipFunctionBodies) Line 183\tC++\r\n \tclang.exe!clang::ASTFrontendAction::ExecuteAction() Line 1192\tC++\r\n \tclang.exe!clang::CodeGenAction::ExecuteAction() Line 1144\tC++\r\n \tclang.exe!clang::FrontendAction::Execute() Line 1078\tC++\r\n \tclang.exe!clang::CompilerInstance::ExecuteAction(clang::FrontendAction & Act) Line 1061\tC++\r\n \tclang.exe!clang::ExecuteCompilerInvocation(clang::CompilerInstance * Clang) Line 280\tC++\r\n \tclang.exe!cc1_main(llvm::ArrayRef<char const *> Argv, const char * Argv0, void * MainAddr) Line 283\tC++\r\n \tclang.exe!ExecuteCC1Tool(llvm::SmallVectorImpl<char const *> & ArgV, const llvm::ToolContext & ToolContext) Line 215\tC++\r\n \tclang.exe!clang_main(int Argc, char * * Argv, const llvm::ToolContext & ToolContext) Line 256\tC++\r\n \tclang.exe!main(int argc, char * * argv) Line 17\tC++\r\n \tclang.exe!invoke_main() Line 79\tC++\r\n \tclang.exe!__scrt_common_main_seh() Line 288\tC++\r\n \tclang.exe!__scrt_common_main() Line 331\tC++\r\n \tclang.exe!mainCRTStartup(void * __formal) Line 17\tC++\r\n \tkernel32.dll!00007ff830e07344()\tUnknown\r\n \tntdll.dll!00007ff83149cc91()\tUnknown\r\n```"
      },
      {
        "author": "nikic",
        "body": "Reduced:\r\n```llvm\r\n; RUN: opt -S -passes=memcpyopt < %s\r\ndefine void @test(ptr %p, ptr noalias %p2) {\r\n  call void @llvm.memset.p0.i64(ptr %p, i8 0, i64 1, i1 false)\r\n  %zero.ext = zext i32 0 to i64\r\n  %mul = mul i64 %zero.ext, 1\r\n  call void @llvm.memcpy.p0.p0.i64(ptr %p, ptr %p2, i64 %mul, i1 false)\r\n  ret void\r\n}\r\n```"
      },
      {
        "author": "nikic",
        "body": "This is an infinite loop in the processMemSetMemCpyDependence() transform. I've tried to mitigate this in the past, but it looks like the mitigation doesn't work for this case. I guess we'll have to add an isKnownNonZero() check to prevent it."
      }
    ]
  },
  "verified": true
}