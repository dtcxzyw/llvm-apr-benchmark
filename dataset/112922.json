{
  "bug_id": "112922",
  "issue_url": "https://github.com/llvm/llvm-project/issues/112922",
  "bug_type": "crash",
  "base_commit": "b5fa4fee46c1d0046cc395e3338ae13fe6e2cb84",
  "knowledge_cutoff": "2024-10-18T15:25:44Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "2a6b09e0d3d3c1a05d3d5165202a6e68900974b1",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        [
          5738,
          5751
        ],
        [
          5760,
          5767
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          2958,
          2968
        ],
        [
          2976,
          2983
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/LoopVectorize.cpp": [
        "LoopVectorizationCostModel::getInterleaveGroupCost"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPInterleaveRecipe::computeCost"
      ]
    }
  },
  "patch": "commit 2a6b09e0d3d3c1a05d3d5165202a6e68900974b1\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Fri Oct 18 19:12:39 2024 -0700\n\n    [LV] Use type from InsertPos for cost computation of interleave groups.\n    \n    Previously the legacy cost model would pick the type for the cost\n    computation depending on the order of the members in the input IR.\n    This is incompatible with the VPlan-based cost model (independent of\n    original IR order) and also doesn't match code-gen, which uses the type\n    of the insert position.\n    \n    Update the legacy cost model to use the type (and address space) from\n    the Group's insert position.\n    \n    This brings the legacy cost model in line with the legacy cost model and\n    fixes a divergence between both models.\n    \n    Note that the X86 cost model seems to assign different costs to groups\n    with i64 and double types. Added a TODO to check.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/112922.\n\ndiff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 857efbdf687c..ce0903b838aa 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -5738,14 +5738,15 @@ LoopVectorizationCostModel::getGatherScatterCost(Instruction *I,\n InstructionCost\n LoopVectorizationCostModel::getInterleaveGroupCost(Instruction *I,\n                                                    ElementCount VF) {\n-  Type *ValTy = getLoadStoreType(I);\n-  auto *VectorTy = cast<VectorType>(ToVectorTy(ValTy, VF));\n-  unsigned AS = getLoadStoreAddressSpace(I);\n-  enum TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;\n-\n   const auto *Group = getInterleavedAccessGroup(I);\n   assert(Group && \"Fail to get an interleaved access group.\");\n \n+  Instruction *InsertPos = Group->getInsertPos();\n+  Type *ValTy = getLoadStoreType(InsertPos);\n+  auto *VectorTy = cast<VectorType>(ToVectorTy(ValTy, VF));\n+  unsigned AS = getLoadStoreAddressSpace(InsertPos);\n+  enum TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;\n+\n   unsigned InterleaveFactor = Group->getFactor();\n   auto *WideVecTy = VectorType::get(ValTy, VF * InterleaveFactor);\n \n@@ -5760,8 +5761,9 @@ LoopVectorizationCostModel::getInterleaveGroupCost(Instruction *I,\n       (Group->requiresScalarEpilogue() && !isScalarEpilogueAllowed()) ||\n       (isa<StoreInst>(I) && (Group->getNumMembers() < Group->getFactor()));\n   InstructionCost Cost = TTI.getInterleavedMemoryOpCost(\n-      I->getOpcode(), WideVecTy, Group->getFactor(), Indices, Group->getAlign(),\n-      AS, CostKind, Legal->isMaskRequired(I), UseMaskForGaps);\n+      InsertPos->getOpcode(), WideVecTy, Group->getFactor(), Indices,\n+      Group->getAlign(), AS, CostKind, Legal->isMaskRequired(I),\n+      UseMaskForGaps);\n \n   if (Group->isReverse()) {\n     // TODO: Add support for reversed masked interleaved access.\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex f4a1f58debba..41f13cc2d9a9 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -2958,11 +2958,20 @@ void VPInterleaveRecipe::print(raw_ostream &O, const Twine &Indent,\n \n InstructionCost VPInterleaveRecipe::computeCost(ElementCount VF,\n                                                 VPCostContext &Ctx) const {\n-  Instruction *I = getInsertPos();\n+  Instruction *InsertPos = getInsertPos();\n+  // Find the VPValue index of the interleave group. We need to skip gaps.\n+  unsigned InsertPosIdx = 0;\n+  for (unsigned Idx = 0; IG->getFactor(); ++Idx)\n+    if (auto *Member = IG->getMember(Idx)) {\n+      if (Member == InsertPos)\n+        break;\n+      InsertPosIdx++;\n+    }\n   Type *ValTy = Ctx.Types.inferScalarType(\n-      getNumDefinedValues() > 0 ? getVPValue(0) : getStoredValues()[0]);\n+      getNumDefinedValues() > 0 ? getVPValue(InsertPosIdx)\n+                                : getStoredValues()[InsertPosIdx]);\n   auto *VectorTy = cast<VectorType>(ToVectorTy(ValTy, VF));\n-  unsigned AS = getLoadStoreAddressSpace(I);\n+  unsigned AS = getLoadStoreAddressSpace(InsertPos);\n   enum TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;\n \n   unsigned InterleaveFactor = IG->getFactor();\n@@ -2976,8 +2985,8 @@ InstructionCost VPInterleaveRecipe::computeCost(ElementCount VF,\n \n   // Calculate the cost of the whole interleaved group.\n   InstructionCost Cost = Ctx.TTI.getInterleavedMemoryOpCost(\n-      I->getOpcode(), WideVecTy, IG->getFactor(), Indices, IG->getAlign(), AS,\n-      CostKind, getMask(), NeedsMaskForGaps);\n+      InsertPos->getOpcode(), WideVecTy, IG->getFactor(), Indices,\n+      IG->getAlign(), AS, CostKind, getMask(), NeedsMaskForGaps);\n \n   if (!IG->isReverse())\n     return Cost;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/interleave-cost.ll",
      "commands": [
        "opt -p loop-vectorize -S %s"
      ],
      "tests": [
        {
          "test_name": "geps_feeding_interleave_groups_with_reuse",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @geps_feeding_interleave_groups_with_reuse(ptr %arg, i64 %arg1, ptr %arg2) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %shl.iv.5 = shl i64 %iv, 5\n  %gep.1 = getelementptr i8, ptr %arg, i64 %shl.iv.5\n  %add.5 = or disjoint i64 %shl.iv.5, 16\n  %gep.2 = getelementptr i8, ptr %arg, i64 %add.5\n  %shl.iv.4 = shl i64 %iv, 4\n  %gep.3 = getelementptr i8, ptr %arg2, i64 %shl.iv.4\n  %l.1 = load float, ptr %gep.1, align 4\n  %l.2 = load float, ptr %gep.2, align 4\n  %add.1 = fadd float %l.1, %l.2\n  %mul.1 = fmul float %add.1, 0.000000e+00\n  store float %mul.1, ptr %gep.3, align 4\n  %gep.4 = getelementptr i8, ptr %gep.1, i64 4\n  %l.3 = load float, ptr %gep.4, align 4\n  %gep.5 = getelementptr i8, ptr %gep.2, i64 4\n  %l.4 = load float, ptr %gep.5, align 4\n  %add.2 = fadd float %l.3, %l.4\n  %mul.2 = fmul float %add.2, 0.000000e+00\n  %gep.6 = getelementptr i8, ptr %gep.3, i64 4\n  store float %mul.2, ptr %gep.6, align 4\n  %gep.7 = getelementptr i8, ptr %gep.1, i64 8\n  %l.5 = load float, ptr %gep.7, align 4\n  %gep.8 = getelementptr i8, ptr %gep.2, i64 8\n  %l.6 = load float, ptr %gep.8, align 4\n  %add.3 = fadd float %l.5, %l.6\n  %mul.3 = fmul float %add.3, 0.000000e+00\n  %gep.9 = getelementptr i8, ptr %gep.3, i64 8\n  store float %mul.3, ptr %gep.9, align 4\n  %i27 = getelementptr i8, ptr %gep.1, i64 12\n  %l.7 = load float, ptr %i27, align 4\n  %gep.10 = getelementptr i8, ptr %gep.2, i64 12\n  %l.8 = load float, ptr %gep.10, align 4\n  %add.4 = fadd float %l.7, %l.8\n  %mul.4 = fmul float %add.4, 0.000000e+00\n  %gep.11 = getelementptr i8, ptr %gep.3, i64 12\n  store float %mul.4, ptr %gep.11, align 4\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, %arg1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+sse4.2\" }\n"
        },
        {
          "test_name": "geps_feeding_interleave_groups_with_reuse2",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @geps_feeding_interleave_groups_with_reuse2(ptr %A, ptr %B, i64 %N) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next.7, %loop ]\n  %shr.1 = lshr exact i64 %iv, 1\n  %gep.B = getelementptr nusw i32, ptr %B, i64 %shr.1\n  %l = load i32, ptr %gep.B, align 4\n  %gep.A = getelementptr i32, ptr %A, i64 %iv\n  store i32 %l, ptr %gep.A, align 4\n  %iv.next = or disjoint i64 %iv, 1\n  %gep.A.1 = getelementptr i32, ptr %A, i64 %iv.next\n  store i32 0, ptr %gep.A.1, align 4\n  %iv.next.1 = or disjoint i64 %iv, 2\n  %shr.2 = lshr exact i64 %iv.next.1, 1\n  %gep.B.2 = getelementptr i32, ptr %B, i64 %shr.2\n  %0 = load i32, ptr %gep.B.2, align 4\n  %gep.A.2 = getelementptr i32, ptr %A, i64 %iv.next.1\n  store i32 %0, ptr %gep.A.2, align 4\n  %iv.next.2 = or disjoint i64 %iv, 3\n  %gep.A.3 = getelementptr i32, ptr %A, i64 %iv.next.2\n  store i32 0, ptr %gep.A.3, align 4\n  %iv.next.3 = or disjoint i64 %iv, 4\n  %gep.B.4 = getelementptr i32, ptr %B, i64 %iv\n  %1 = load i32, ptr %gep.B.4, align 4\n  %gep.A.4 = getelementptr i32, ptr %A, i64 %iv.next.3\n  store i32 %1, ptr %gep.A.4, align 4\n  %iv.next.4 = or disjoint i64 %iv, 5\n  %gep.A.5 = getelementptr i32, ptr %A, i64 %iv.next.4\n  store i32 0, ptr %gep.A.5, align 4\n  %iv.next.5 = or disjoint i64 %iv, 6\n  %gep.A.6 = getelementptr i32, ptr %A, i64 %iv.next.5\n  store i32 0, ptr %gep.A.6, align 4\n  %iv.next.6 = or disjoint i64 %iv, 7\n  %gep.A.7 = getelementptr i32, ptr %A, i64 %iv.next.6\n  store i32 0, ptr %gep.A.7, align 4\n  %iv.next.7 = add nuw nsw i64 %iv, 8\n  %ec = icmp eq i64 %iv, %N\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"min-legal-vector-width\"=\"0\" \"target-cpu\"=\"cascadelake\" }\n"
        },
        {
          "test_name": "interleave_store_double_i64_2",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @interleave_store_double_i64_2(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.1 = getelementptr { i64, double }, ptr %dst, i64 %iv, i32 1\n  store double 0.000000e+00, ptr %gep.1, align 8\n  %gep.0 = getelementptr { i64, double }, ptr %dst, i64 %iv\n  store i64 %iv, ptr %gep.0, align 8\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "interleave_store_i64_double",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @interleave_store_i64_double(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.0 = getelementptr { double, i64 }, ptr %dst, i64 %iv\n  store double 0.000000e+00, ptr %gep.0, align 8\n  %gep.1 = getelementptr { double, i64 }, ptr %dst, i64 %iv, i32 1\n  store i64 %iv, ptr %gep.1, align 8\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "test_free_instructions_feeding_geps_for_interleave_groups",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @test_free_instructions_feeding_geps_for_interleave_groups(ptr noalias %p.invar, ptr noalias %dst.1, ptr noalias %dst.2) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %l.0 = load float, ptr %p.invar, align 4\n  %iv.mul = shl i64 %iv, 2\n  %gep.dst.19 = getelementptr float, ptr %dst.1, i64 %iv.mul\n  store float %l.0, ptr %gep.dst.19, align 4\n  %l.1 = load float, ptr %p.invar, align 4\n  %add.1 = or disjoint i64 %iv.mul, 1\n  %gep.dst.119 = getelementptr float, ptr %dst.1, i64 %add.1\n  store float %l.1, ptr %gep.dst.119, align 4\n  %add.2 = or disjoint i64 %iv.mul, 2\n  %gep.dst.129 = getelementptr float, ptr %dst.1, i64 %add.2\n  store float 0.000000e+00, ptr %gep.dst.129, align 4\n  %add.3 = or disjoint i64 %iv.mul, 3\n  %gep.dst.140 = getelementptr float, ptr %dst.1, i64 %add.3\n  store float 0.000000e+00, ptr %gep.dst.140, align 4\n  %l.2 = load float, ptr %p.invar, align 4\n  %gep.dst.247 = getelementptr float, ptr %dst.2, i64 %iv.mul\n  store float %l.2, ptr %gep.dst.247, align 4\n  %gep.dst.255 = getelementptr float, ptr %dst.2, i64 %add.1\n  store float 0.000000e+00, ptr %gep.dst.255, align 4\n  %gep.dst.265 = getelementptr float, ptr %dst.2, i64 %add.2\n  store float 0.000000e+00, ptr %gep.dst.265, align 4\n  %gep.dst.276 = getelementptr float, ptr %dst.2, i64 %add.3\n  store float 0.000000e+00, ptr %gep.dst.276, align 4\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv.next, 0\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "interleave_store_double_i64",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @interleave_store_double_i64(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.1 = getelementptr { double, i64 }, ptr %dst, i64 %iv, i32 1\n  store i64 %iv, ptr %gep.1, align 8\n  %gep.0 = getelementptr { double, i64 }, ptr %dst, i64 %iv\n  store double 0.000000e+00, ptr %gep.0, align 8\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "interleave_store_i64_double_2",
          "test_body": "target datalayout = \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-apple-macosx10.15.0\"\n\ndefine void @interleave_store_i64_double_2(ptr %dst) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.0 = getelementptr { i64, double }, ptr %dst, i64 %iv\n  store i64 %iv, ptr %gep.0, align 8\n  %gep.1 = getelementptr { i64, double }, ptr %dst, i64 %iv, i32 1\n  store double 0.000000e+00, ptr %gep.1, align 8\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[clang] Assertion in `llvm::LoopVectorizationPlanner::computeBestVF()`",
    "body": "When building the METIS (v5.1.0) library (GKLib) an assertion is thrown during LoopVectorize. This error was introduced within the past few days (see git sha of broken and working versions below).\r\n\r\n#### Error:\r\n```shell\r\nclang: /mnt/thera/cicd/actions_work/ActionsRunner/ActionsRunner/trunk_repos/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7457: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.\r\nStack dump:\r\n0.      Program arguments: /share/contrib-modules/Core/llvm/2024-10-16/bin/clang -I/home/bcornill/libraries/metis-5.1.0/GKlib/. -I/home/bcornill/libraries/metis-5.1.0/GKlib/test -DLINUX -D_FILE_OFFSET_BITS=64 -DNDEBUG -DNDEBUG2 -DHAVE_EXECINFO_H -DHAVE_GETLINE -O3 -MD -MT CMakeFiles/GKlib.dir/blas.c.o -MF CMakeFiles/GKlib.dir/blas.c.o.d -o CMakeFiles/GKlib.dir/blas.c.o -c /home/bcornill/libraries/metis-5.1.0/GKlib/blas.c\r\n1.      <eof> parser at end of file\r\n2.      Optimizer\r\n3.      Running pass \"function<eager-inv>(float2int,lower-constant-intrinsics,chr,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O3>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"/home/bcornill/libraries/metis-5.1.0/GKlib/blas.c\"\r\n4.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"gk_dargmax_n\"\r\n #0 0x00007fa15911cc8b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMSupport.so.20.0git+0x1c2c8b)\r\n #1 0x00007fa15911a664 llvm::sys::CleanupOnSignal(unsigned long) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMSupport.so.20.0git+0x1c0664)\r\n #2 0x00007fa1590227f8 CrashRecoverySignalHandler(int) CrashRecoveryContext.cpp:0:0\r\n #3 0x00007fa1615e0dd0 __restore_rt sigaction.c:0:0\r\n #4 0x00007fa15821e70f raise (/lib64/libc.so.6+0x3770f)\r\n #5 0x00007fa158208b25 abort (/lib64/libc.so.6+0x21b25)\r\n #6 0x00007fa1582089f9 _nl_load_domain.cold.0 loadmsgcat.c:0:0\r\n #7 0x00007fa158216cc6 .annobin___GI___assert_fail.end assert.c:0:0\r\n #8 0x00007fa15db3af1b llvm::LoopVectorizationPlanner::computeBestVF() (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMVectorize.so.20.0git+0xb5f1b)\r\n #9 0x00007fa15db52d46 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMVectorize.so.20.0git+0xcdd46)\r\n#10 0x00007fa15db55ed1 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMVectorize.so.20.0git+0xd0ed1)\r\n#11 0x00007fa15db56517 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMVectorize.so.20.0git+0xd1517)\r\n#12 0x00007fa155d90a9e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/../lib/libLLVMPasses.so.20.0git+0x76a9e)\r\n#13 0x00007fa15998eab7 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMCore.so.20.0git+0x323ab7)\r\n#14 0x00007fa16434e17e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMX86CodeGen.so.20.0git+0xa917e)\r\n#15 0x00007fa15998ce55 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMCore.so.20.0git+0x321e55)\r\n#16 0x00007fa16434e56e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMX86CodeGen.so.20.0git+0xa956e)\r\n#17 0x00007fa15998d9bc llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMCore.so.20.0git+0x3229bc)\r\n#18 0x00007fa15faab288 (anonymous namespace)::EmitAssemblyHelper::RunOptimizationPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&, clang::BackendConsumer*) BackendUtil.cpp:0:0\r\n#19 0x00007fa15faaeb9c clang::EmitBackendOutput(clang::DiagnosticsEngine&, clang::HeaderSearchOptions const&, clang::CodeGenOptions const&, clang::TargetOptions const&, clang::LangOptions const&, llvm::StringRef, llvm::Module*, clang::BackendAction, llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>, clang::BackendConsumer*) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangCodeGen.so.20.0git+0x111b9c)\r\n#20 0x00007fa15ffdd293 clang::BackendConsumer::HandleTranslationUnit(clang::ASTContext&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangCodeGen.so.20.0git+0x640293)\r\n#21 0x00007fa150c5592c clang::ParseAST(clang::Sema&, bool, bool) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/../lib/libclangParse.so.20.0git+0x3c92c)\r\n#22 0x00007fa15d75dee9 clang::FrontendAction::Execute() (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangFrontend.so.20.0git+0x138ee9)\r\n#23 0x00007fa15d6ceb05 clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangFrontend.so.20.0git+0xa9b05)\r\n#24 0x00007fa1613cad83 clang::ExecuteCompilerInvocation(clang::CompilerInstance*) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangFrontendTool.so.20.0git+0x4d83)\r\n#25 0x00000000004141c7 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) (/share/contrib-modules/Core/llvm/2024-10-16/bin/clang+0x4141c7)\r\n#26 0x000000000040b96a ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&, llvm::ToolContext const&) driver.cpp:0:0\r\n#27 0x00007fa15d135049 void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()>(long) Job.cpp:0:0\r\n#28 0x00007fa159022cb4 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libLLVMSupport.so.20.0git+0xc8cb4)\r\n#29 0x00007fa15d13589e clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const (.part.0) Job.cpp:0:0\r\n#30 0x00007fa15d0f22fc clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangDriver.so.20.0git+0x922fc)\r\n#31 0x00007fa15d0f33fd clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangDriver.so.20.0git+0x933fd)\r\n#32 0x00007fa15d1039c4 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) (/share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/../lib/libclangDriver.so.20.0git+0xa39c4)\r\n#33 0x0000000000410b5b clang_main(int, char**, llvm::ToolContext const&) (/share/contrib-modules/Core/llvm/2024-10-16/bin/clang+0x410b5b)\r\n#34 0x000000000040b074 main (/share/contrib-modules/Core/llvm/2024-10-16/bin/clang+0x40b074)\r\n#35 0x00007fa15820a6a3 __libc_start_main (/lib64/libc.so.6+0x236a3)\r\n#36 0x000000000040b0be _start (/share/contrib-modules/Core/llvm/2024-10-16/bin/clang+0x40b0be)\r\nclang: error: clang frontend command failed with exit code 134 (use -v to see invocation)\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project ae68d532f810e217c747b10b26aeea3bb84c3844)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin\r\nBuild config: +assertions\r\nConfiguration file: /share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/clang.cfg\r\nclang: note: diagnostic msg:\r\n********************\r\n\r\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\r\nPreprocessed source(s) and associated run script(s) are located at:\r\nclang: note: diagnostic msg: /tmp/blas-9fe25d.c\r\nclang: note: diagnostic msg: /tmp/blas-9fe25d.sh\r\nclang: note: diagnostic msg:\r\n\r\n********************\r\n```\r\n#### Reproducer:\r\n[gklib-blas.tar.gz](https://github.com/user-attachments/files/17437550/gklib-blas.tar.gz)\r\n\r\n#### Broken Versions:\r\n```shell\r\n>> clang --version\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project ae68d532f810e217c747b10b26aeea3bb84c3844)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin\r\nBuild config: +assertions\r\nConfiguration file: /share/contrib-modules/Core/llvm/2024-10-16_20.0-0/bin/clang.cfg\r\n\r\n>> clang --version\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project af90e7c5161de9a36af768dd5c9d73464e0eed64)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /share/contrib-modules/Core/llvm/2024-10-18_20.0-0/bin\r\nBuild config: +assertions\r\nConfiguration file: /share/contrib-modules/Core/llvm/2024-10-18_20.0-0/bin/clang.cfg\r\n```\r\n\r\n#### Working version:\r\n```shell\r\n>> clang --version\r\nclang version 20.0.0git (https://github.com/llvm/llvm-project 48deb3568eb2452ff385b04b8f71c34121f47387)\r\nTarget: x86_64-unknown-linux-gnu\r\nThread model: posix\r\nInstalledDir: /share/contrib-modules/Core/llvm/2024-10-13_20.0-0/bin\r\nBuild config: +assertions\r\nConfiguration file: /share/contrib-modules/Core/llvm/2024-10-13_20.0-0/bin/clang.cfg\r\n```",
    "author": "bcornille",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": [
      {
        "author": "fhahn",
        "body": "Thanks, taking a look!"
      }
    ]
  }
}