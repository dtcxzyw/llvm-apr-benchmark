{
  "bug_id": "113301",
  "issue_url": "https://github.com/llvm/llvm-project/issues/113301",
  "bug_type": "miscompilation",
  "base_commit": "979a0356d4c90ec855be4f2d2f6687132cf10298",
  "knowledge_cutoff": "2024-10-22T11:39:42Z",
  "lit_test_dir": [
    "llvm/test/Transforms/InstCombine"
  ],
  "hints": {
    "fix_commit": "7bbc049688a1586827d87ad8e2fc7cb3638ef2fc",
    "components": [
      "InstCombine"
    ],
    "files": [
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        [
          1332,
          1338
        ],
        [
          1966,
          1982
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp": [
        "InstCombinerImpl::foldSelectInstWithICmp",
        "InstCombinerImpl::foldSelectValueEquivalence",
        "foldSelectICmpEq"
      ]
    }
  },
  "patch": "commit 7bbc049688a1586827d87ad8e2fc7cb3638ef2fc\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Mon Dec 2 09:45:39 2024 +0100\n\n    [InstCombine] Consolidate another fold into select value equivalence (#117746)\n    \n    We had a separate fold that handled just the trivial case where we're\n    replacing exactly the argument of the select. Handle this in select\n    value equivalence by relaxing the infinite loop protection to allow a\n    replacement of a non-constant with a constant.\n    \n    This also fixes https://github.com/llvm/llvm-project/issues/113301, as\n    the separate fold did not handle undef values correctly.\n\ndiff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\nindex e0c5728b6f26..dde35fe3f69d 100644\n--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp\n@@ -1332,7 +1332,7 @@ Instruction *InstCombinerImpl::foldSelectValueEquivalence(SelectInst &Sel,\n     // If we will be able to evaluate f(Y) to a constant, we can allow undef,\n     // otherwise Y cannot be undef as we might pick different values for undef\n     // in the cmp and in f(Y).\n-    if (TrueVal == OldOp)\n+    if (TrueVal == OldOp && (isa<Constant>(OldOp) || !isa<Constant>(NewOp)))\n       return nullptr;\n \n     if (Value *V = simplifyWithOpReplaced(TrueVal, OldOp, NewOp, SQ,\n@@ -1966,17 +1966,6 @@ Instruction *InstCombinerImpl::foldSelectInstWithICmp(SelectInst &SI,\n   ICmpInst::Predicate Pred = ICI->getPredicate();\n   Value *CmpLHS = ICI->getOperand(0);\n   Value *CmpRHS = ICI->getOperand(1);\n-  if (CmpRHS != CmpLHS && isa<Constant>(CmpRHS) && !isa<Constant>(CmpLHS)) {\n-    if (CmpLHS == TrueVal && Pred == ICmpInst::ICMP_EQ) {\n-      // Transform (X == C) ? X : Y -> (X == C) ? C : Y\n-      replaceOperand(SI, 1, CmpRHS);\n-      Changed = true;\n-    } else if (CmpLHS == FalseVal && Pred == ICmpInst::ICMP_NE) {\n-      // Transform (X != C) ? Y : X -> (X != C) ? Y : C\n-      replaceOperand(SI, 2, CmpRHS);\n-      Changed = true;\n-    }\n-  }\n \n   if (Instruction *NewSel = foldSelectICmpEq(SI, ICI, *this))\n     return NewSel;\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/InstCombine/select-value-equivalence.ll",
      "commands": [
        "opt -passes=instcombine -S %s"
      ],
      "tests": [
        {
          "test_name": "select_vec_op_const_no_undef",
          "test_body": "define <2 x i8> @select_vec_op_const_no_undef(<2 x i8> %x) {\n  %xz = icmp eq <2 x i8> %x, <i8 1, i8 2>\n  %xr = select <2 x i1> %xz, <2 x i8> %x, <2 x i8> <i8 4, i8 3>\n  ret <2 x i8> %xr\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Wrong canonicalization of `add` and bitwise logic operation",
    "body": "https://github.com/llvm/llvm-project/blob/f1ade1f874db066a46142cacbb67f80d272862ed/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp#L2158-L2200\r\n\r\nAlive2 report: https://alive2.llvm.org/ce/z/n2TNxF\r\n\r\n```llvm\r\n\r\n----------------------------------------\r\ndefine <2 x i8> @t5_splat_undef_0b1000.2(<2 x i8> %x) {\r\n#0:\r\n  %#1 = xor <2 x i8> %x, { 15, undef }\r\n  %x.lowbits.are.zero = icmp eq <2 x i8> %#1, { 0, 0 }\r\n  %x.biased = add <2 x i8> %x, { 16, 16 }\r\n  %x.biased.highbits = and <2 x i8> %x.biased, { 240, 240 }\r\n  %x.roundedup = select <2 x i1> %x.lowbits.are.zero, <2 x i8> %x, <2 x i8> %x.biased.highbits\r\n  ret <2 x i8> %x.roundedup\r\n}\r\n=>\r\ndefine <2 x i8> @t5_splat_undef_0b1000.2(<2 x i8> %x) {\r\n#0:\r\n  %x.lowbits.are.zero = icmp eq <2 x i8> %x, { 15, undef }\r\n  %#1 = and <2 x i8> %x, { 240, 240 }\r\n  %x.biased.highbits = add <2 x i8> %#1, { 16, 16 }\r\n  %x.roundedup = select <2 x i1> %x.lowbits.are.zero, <2 x i8> { 15, undef }, <2 x i8> %x.biased.highbits\r\n  ret <2 x i8> %x.roundedup\r\n}\r\nTransformation doesn't verify!\r\n\r\nERROR: Value mismatch\r\n\r\nExample:\r\n<2 x i8> %x = < #x00 (0), #x00 (0) >\r\n\r\nSource:\r\n<2 x i8> %#1 = < #x0f (15), #x00 (0)\t[based on undef value] >\r\n<2 x i1> %x.lowbits.are.zero = < #x0 (0), #x1 (1) >\r\n<2 x i8> %x.biased = < #x10 (16), #x10 (16) >\r\n<2 x i8> %x.biased.highbits = < #x10 (16), #x10 (16) >\r\n<2 x i8> %x.roundedup = < #x10 (16), #x00 (0) >\r\n\r\nTarget:\r\n<2 x i1> %x.lowbits.are.zero = < #x0 (0), #x1 (1) >\r\n<2 x i8> %#1 = < #x00 (0), #x00 (0) >\r\n<2 x i8> %x.biased.highbits = < #x10 (16), #x10 (16) >\r\n<2 x i8> %x.roundedup = < #x10 (16), #x02 (2) >\r\nSource value: < #x10 (16), #x00 (0) >\r\nTarget value: < #x10 (16), #x02 (2) >\r\n\r\n\r\n----------------------------------------\r\ndefine i8 @t5_splat_undef_0b1000.3(i8 %x) {\r\n#0:\r\n  %#1 = xor i8 %x, undef\r\n  %x.lowbits.are.zero = icmp eq i8 %#1, 0\r\n  %x.biased = add i8 %x, 16\r\n  %x.biased.highbits = and i8 %x.biased, 240\r\n  %x.roundedup = select i1 %x.lowbits.are.zero, i8 %x, i8 %x.biased.highbits\r\n  ret i8 %x.roundedup\r\n}\r\n=>\r\ndefine i8 @t5_splat_undef_0b1000.3(i8 %x) {\r\n#0:\r\n  ret i8 %x\r\n}\r\nTransformation seems to be correct!\r\n\r\nSummary:\r\n  1 correct transformations\r\n  1 incorrect transformations\r\n  0 failed-to-prove transformations\r\n  0 Alive2 errors\r\n```\r\n",
    "author": "bongjunj",
    "labels": [
      "miscompilation",
      "llvm:instcombine"
    ],
    "comments": [
      {
        "author": "duk-37",
        "body": "This seems to be the underlying transform failing verification: https://alive2.llvm.org/ce/z/bs8v-9"
      },
      {
        "author": "nikic",
        "body": "The problematic fold is: https://github.com/llvm/llvm-project/blob/86f7f089ee6bcf01bf082ca802220b1143a3ade9/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp#L1928-L1938 Unlike the generic select value equivalence fold, this one does not handle undef correctly."
      },
      {
        "author": "nikic",
        "body": "We can fix this by removing the separate fold: https://github.com/llvm/llvm-project/pull/117746"
      }
    ]
  }
}
