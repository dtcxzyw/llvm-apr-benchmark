{
  "bug_id": "151785",
  "issue_url": "https://github.com/llvm/llvm-project/issues/151785",
  "bug_type": "crash",
  "base_commit": "1feed444aa065ff94ce63250a00de188001617be",
  "knowledge_cutoff": "2025-08-01T23:45:20Z",
  "lit_test_dir": [
    "llvm/test/Transforms/GVN"
  ],
  "hints": {
    "fix_commit": "4b5b36e5c4b887a86fc7164d6899caaa2e2f5aed",
    "components": [
      "GVN",
      "Loads"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/Loads.cpp": [
        [
          833,
          838
        ]
      ],
      "llvm/lib/Transforms/Scalar/GVN.cpp": [
        [
          2502,
          2507
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/Loads.cpp": [
        "llvm::canReplacePointersInUseIfEqual"
      ],
      "llvm/lib/Transforms/Scalar/GVN.cpp": [
        "GVNPass::replaceOperandsForInBlockEquality"
      ]
    }
  },
  "patch": "commit 4b5b36e5c4b887a86fc7164d6899caaa2e2f5aed\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Mon Aug 4 12:05:37 2025 +0200\n\n    [GVN] Avoid creating lifetime of non-alloca\n    \n    There is a larger problem here in that we should not be performing\n    arbitrary pointer replacements for assumes. This is handled for\n    branches, but assume goes through a different code path.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/151785.\n\ndiff --git a/llvm/lib/Analysis/Loads.cpp b/llvm/lib/Analysis/Loads.cpp\nindex 6fc81d787c22..da76f5b3d498 100644\n--- a/llvm/lib/Analysis/Loads.cpp\n+++ b/llvm/lib/Analysis/Loads.cpp\n@@ -833,6 +833,10 @@ bool llvm::canReplacePointersInUseIfEqual(const Use &U, const Value *To,\n   if (!To->getType()->isPointerTy())\n     return true;\n \n+  // Do not perform replacements in lifetime intrinsic arguments.\n+  if (isa<LifetimeIntrinsic>(U.getUser()))\n+    return false;\n+\n   if (isPointerAlwaysReplaceable(&*U, To, DL))\n     return true;\n   return isPointerUseReplacable(U);\ndiff --git a/llvm/lib/Transforms/Scalar/GVN.cpp b/llvm/lib/Transforms/Scalar/GVN.cpp\nindex f6bf09d09433..fa6ee95d33d1 100644\n--- a/llvm/lib/Transforms/Scalar/GVN.cpp\n+++ b/llvm/lib/Transforms/Scalar/GVN.cpp\n@@ -2502,6 +2502,10 @@ bool GVNPass::replaceOperandsForInBlockEquality(Instruction *Instr) const {\n     Value *Operand = Instr->getOperand(OpNum);\n     auto It = ReplaceOperandsWithMap.find(Operand);\n     if (It != ReplaceOperandsWithMap.end()) {\n+      // Do not replace lifetime alloca argument with something else.\n+      if (Instr->isLifetimeStartOrEnd())\n+        continue;\n+\n       LLVM_DEBUG(dbgs() << \"GVN replacing: \" << *Operand << \" with \"\n                         << *It->second << \" in instruction \" << *Instr << '\\n');\n       Instr->setOperand(OpNum, It->second);\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/GVN/lifetime-simple.ll",
      "commands": [
        "opt < %s -passes=gvn -S"
      ],
      "tests": [
        {
          "test_name": "assume_eq_null",
          "test_body": "define void @assume_eq_null() {\n  %alloca = alloca i32, align 4, addrspace(1)\n  %cmp = icmp eq ptr addrspace(1) %alloca, null\n  call void @llvm.assume(i1 %cmp)\n  call void @llvm.lifetime.start.p1(i64 4, ptr addrspace(1) %alloca)\n  store volatile i32 0, ptr addrspace(1) %alloca, align 4\n  call void @llvm.lifetime.end.p1(i64 4, ptr addrspace(1) %alloca)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.end.p1(i64 immarg, ptr addrspace(1) captures(none)) #1\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p1(i64 immarg, ptr addrspace(1) captures(none)) #1\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\n"
        },
        {
          "test_name": "dom_eq_null",
          "test_body": "define void @dom_eq_null() {\n  %alloca = alloca i32, align 4, addrspace(1)\n  %cmp = icmp eq ptr addrspace(1) %alloca, null\n  br i1 %cmp, label %if, label %else\n\nif:                                               ; preds = %0\n  call void @llvm.lifetime.start.p1(i64 4, ptr addrspace(1) %alloca)\n  store volatile i32 0, ptr addrspace(1) %alloca, align 4\n  call void @llvm.lifetime.end.p1(i64 4, ptr addrspace(1) %alloca)\n  ret void\n\nelse:                                             ; preds = %0\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.end.p1(i64 immarg, ptr addrspace(1) captures(none)) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p1(i64 immarg, ptr addrspace(1) captures(none)) #0\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\n"
        },
        {
          "test_name": "assume_eq_arg",
          "test_body": "define void @assume_eq_arg(ptr %arg) {\n  %alloca = alloca i32, align 4\n  %cmp = icmp eq ptr %alloca, %arg\n  call void @llvm.assume(i1 %cmp)\n  call void @llvm.lifetime.start.p0(i64 4, ptr %alloca)\n  store volatile i32 0, ptr %alloca, align 4\n  call void @llvm.lifetime.end.p0(i64 4, ptr %alloca)\n  ret void\n}\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.start.p0(i64 immarg, ptr captures(none)) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)\ndeclare void @llvm.lifetime.end.p0(i64 immarg, ptr captures(none)) #0\n\n; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)\ndeclare void @llvm.assume(i1 noundef) #1\n\nattributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }\nattributes #1 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "Non alloca pointer in llvm.lifetime.end appeared after GVN",
    "body": "https://godbolt.org/z/sK5aYrfhs\n\n```llvm\ndefine ptr @foobar(ptr %this, ptr %RHS) {\nentry:\n  store volatile i32 0, ptr %this, align 4\n  %call2 = call ptr @bar(ptr %this, ptr %RHS)\n  ret ptr %call2\n}\n\ndefine ptr @bar(ptr %this, ptr %RHS) {\nentry:\n  %cmp = icmp eq ptr %this, %RHS\n  call void @llvm.assume(i1 %cmp)\n  ret ptr null\n}\n\ndefine i1 @foo(ptr %Builder) {\nentry:\n  %Result = alloca { [24 x i8] }, align 8\n  %0 = call ptr @foobar(ptr %Result, ptr %Builder)\n  call void @llvm.lifetime.end.p0(i64 0, ptr %Result)\n  ret i1 false\n}\n```\n`opt -O2` produces\n```\nllvm.lifetime.start/end can only be used on alloca\n  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %Builder)\n```\nIt is a result of GVN\n```llvm\n; *** IR Dump After MergedLoadStoreMotionPass on foo ***\ndefine i1 @foo(ptr readnone captures(address) %Builder) local_unnamed_addr {\nentry:\n  %Result = alloca { [24 x i8] }, align 8\n  store volatile i32 0, ptr %Result, align 4\n  %cmp.i.i = icmp eq ptr %Result, %Builder\n  call void @llvm.assume(i1 %cmp.i.i)\n  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %Result)\n  ret i1 false\n}\n; *** IR Dump After GVNPass on foo ***\ndefine i1 @foo(ptr readnone captures(address) %Builder) local_unnamed_addr {\nentry:\n  %Result = alloca { [24 x i8] }, align 8\n  store volatile i32 0, ptr %Result, align 4\n  %cmp.i.i = icmp eq ptr %Result, %Builder\n  call void @llvm.assume(i1 %cmp.i.i)\n  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %Builder)\n  ret i1 false\n}\n```\n\nRelates to #149310 and https://github.com/llvm/llvm-project/pull/149838 cc @nikic ",
    "author": "e-kud",
    "labels": [
      "regression",
      "crash-on-valid",
      "llvm:GVN"
    ],
    "comments": [
      {
        "author": "e-kud",
        "body": "A shorter reproducer\n```llvm\ndefine i1 @foo(ptr %Builder) {\nentry:\n  %Result = alloca { [24 x i8] }, align 8\n  store volatile i32 0, ptr %Result, align 4\n  %cmp = icmp eq ptr %Result, %Builder\n  call void @llvm.assume(i1 %cmp)\n  call void @llvm.lifetime.end.p0(i64 0, ptr %Result)\n  ret i1 false\n}\n```"
      }
    ]
  },
  "verified": true
}