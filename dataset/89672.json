{
  "bug_id": "89672",
  "issue_url": "https://github.com/llvm/llvm-project/issues/89672",
  "bug_type": "miscompilation",
  "base_commit": "b64e483785bfef5ec4977988543ed5cfaf62f306",
  "knowledge_cutoff": "2024-04-22T21:35:16Z",
  "lit_test_dir": [
    "llvm/test/Transforms/SimplifyCFG"
  ],
  "hints": {
    "fix_commit": "883887493c882d656d5da100ee637a348e81357c",
    "components": [
      "SimplifyCFG"
    ],
    "files": [
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp": [
        [
          2888,
          2894
        ],
        [
          2896,
          2902
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/SimplifyCFG.cpp": [
        "isSafeToSpeculateStore"
      ]
    }
  },
  "patch": "commit 883887493c882d656d5da100ee637a348e81357c\nAuthor: Nikita Popov <npopov@redhat.com>\nDate:   Tue Apr 23 12:36:35 2024 +0900\n\n    [SimplifyCFG] Check alignment when speculating stores\n    \n    When speculating a store based on a preceding load/store, we need\n    to ensure that the speculated store does not have a higher\n    alignment (which might only be guaranteed by the branch condition).\n    \n    There are various ways in which this could be strengthened (we\n    could get or enforce the alignment), but for now just do the\n    simple check against the preceding load/store.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/89672.\n\ndiff --git a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\nindex da3eb229c041..0826d748ba0d 100644\n--- a/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\n+++ b/llvm/lib/Transforms/Utils/SimplifyCFG.cpp\n@@ -2888,7 +2888,8 @@ static Value *isSafeToSpeculateStore(Instruction *I, BasicBlock *BrBB,\n       // simple, to avoid introducing a spurious non-atomic write after an\n       // atomic write.\n       if (SI->getPointerOperand() == StorePtr &&\n-          SI->getValueOperand()->getType() == StoreTy && SI->isSimple())\n+          SI->getValueOperand()->getType() == StoreTy && SI->isSimple() &&\n+          SI->getAlign() >= StoreToHoist->getAlign())\n         // Found the previous store, return its value operand.\n         return SI->getValueOperand();\n       return nullptr; // Unknown store.\n@@ -2896,7 +2897,7 @@ static Value *isSafeToSpeculateStore(Instruction *I, BasicBlock *BrBB,\n \n     if (auto *LI = dyn_cast<LoadInst>(&CurI)) {\n       if (LI->getPointerOperand() == StorePtr && LI->getType() == StoreTy &&\n-          LI->isSimple()) {\n+          LI->isSimple() && LI->getAlign() >= StoreToHoist->getAlign()) {\n         // Local objects (created by an `alloca` instruction) are always\n         // writable, so once we are past a read from a location it is valid to\n         // also write to that same location.\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/SimplifyCFG/speculate-store.ll",
      "commands": [
        "opt -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S < %s"
      ],
      "tests": [
        {
          "test_name": "load_before_store_escape",
          "test_body": "define i32 @load_before_store_escape(i64 %i, i32 %b) {\nentry:\n  %a = alloca [2 x i32], align 8\n  store i64 4294967296, ptr %a, align 8\n  call void @fork_some_threads(ptr %a)\n  %arrayidx = getelementptr inbounds [2 x i32], ptr %a, i64 0, i64 %i\n  %0 = load i32, ptr %arrayidx, align 4\n  %cmp = icmp slt i32 %0, %b\n  br i1 %cmp, label %if.then, label %if.end\n\nif.then:                                          ; preds = %entry\n  store i32 %b, ptr %arrayidx, align 4\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %entry\n  %1 = load i32, ptr %a, align 4\n  %arrayidx2 = getelementptr inbounds [2 x i32], ptr %a, i64 0, i64 1\n  %2 = load i32, ptr %arrayidx2, align 4\n  %add = add nsw i32 %1, %2\n  call void @join_some_threads()\n  ret i32 %add\n}\n\ndeclare void @fork_some_threads(ptr)\n\ndeclare void @join_some_threads()\n"
        },
        {
          "test_name": "not_alone_in_block",
          "test_body": "define i32 @not_alone_in_block(i64 %i, i32 %b) {\nentry:\n  %a = alloca [2 x i32], align 8\n  store i64 4294967296, ptr %a, align 8\n  %arrayidx = getelementptr inbounds [2 x i32], ptr %a, i64 0, i64 %i\n  %0 = load i32, ptr %arrayidx, align 4\n  %cmp = icmp slt i32 %0, %b\n  br i1 %cmp, label %if.then, label %if.end\n\nif.then:                                          ; preds = %entry\n  store i32 %b, ptr %arrayidx, align 4\n  store i32 %b, ptr %a, align 4\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %entry\n  %1 = load i32, ptr %a, align 4\n  %arrayidx2 = getelementptr inbounds [2 x i32], ptr %a, i64 0, i64 1\n  %2 = load i32, ptr %arrayidx2, align 4\n  %add = add nsw i32 %1, %2\n  ret i32 %add\n}\n"
        },
        {
          "test_name": "load_before_store_noescape",
          "test_body": "define i32 @load_before_store_noescape(i64 %i, i32 %b) {\nentry:\n  %a = alloca [2 x i32], align 8\n  store i64 4294967296, ptr %a, align 8\n  %arrayidx = getelementptr inbounds [2 x i32], ptr %a, i64 0, i64 %i\n  %0 = load i32, ptr %arrayidx, align 4\n  %cmp = icmp slt i32 %0, %b\n  br i1 %cmp, label %if.then, label %if.end\n\nif.then:                                          ; preds = %entry\n  store i32 %b, ptr %arrayidx, align 4\n  br label %if.end\n\nif.end:                                           ; preds = %if.then, %entry\n  %1 = load i32, ptr %a, align 4\n  %arrayidx2 = getelementptr inbounds [2 x i32], ptr %a, i64 0, i64 1\n  %2 = load i32, ptr %arrayidx2, align 4\n  %add = add nsw i32 %1, %2\n  ret i32 %add\n}\n"
        },
        {
          "test_name": "noifconvertstore_volatile",
          "test_body": "define void @noifconvertstore_volatile(ptr %A, i32 %B, i32 %C, i32 %D) {\nentry:\n  store i32 %B, ptr %A, align 4\n  %cmp6 = icmp sgt i32 %D, 42\n  br i1 %cmp6, label %if.then, label %ret.end\n\nif.then:                                          ; preds = %entry\n  store volatile i32 %C, ptr %A, align 4\n  br label %ret.end\n\nret.end:                                          ; preds = %if.then, %entry\n  ret void\n}\n"
        },
        {
          "test_name": "noifconvertstore2",
          "test_body": "declare void @unknown_fun()\n\ndefine void @noifconvertstore2(ptr %A, i32 %B, i32 %C, i32 %D) {\nentry:\n  store i32 %B, ptr %A, align 4\n  call void @unknown_fun()\n  %cmp6 = icmp sgt i32 %D, 42\n  br i1 %cmp6, label %if.then, label %ret.end\n\nif.then:                                          ; preds = %entry\n  store i32 %C, ptr %A, align 4\n  br label %ret.end\n\nret.end:                                          ; preds = %if.then, %entry\n  ret void\n}\n"
        },
        {
          "test_name": "wrong_align_store",
          "test_body": "define void @wrong_align_store(ptr %A, i32 %B, i32 %C, i32 %D) {\nentry:\n  store i32 %B, ptr %A, align 4\n  %cmp = icmp sgt i32 %D, 42\n  br i1 %cmp, label %if.then, label %ret.end\n\nif.then:                                          ; preds = %entry\n  store i32 %C, ptr %A, align 8\n  br label %ret.end\n\nret.end:                                          ; preds = %if.then, %entry\n  ret void\n}\n"
        },
        {
          "test_name": "ifconvertstore",
          "test_body": "define void @ifconvertstore(ptr %A, i32 %B, i32 %C, i32 %D) {\nentry:\n  store i32 %B, ptr %A, align 4\n  %cmp = icmp sgt i32 %D, 42\n  br i1 %cmp, label %if.then, label %ret.end, !prof !0\n\nif.then:                                          ; preds = %entry\n  store i32 %C, ptr %A, align 4\n  br label %ret.end\n\nret.end:                                          ; preds = %if.then, %entry\n  ret void\n}\n\n!0 = !{!\"branch_weights\", i32 3, i32 5}\n"
        },
        {
          "test_name": "wrong_align_load",
          "test_body": "define void @wrong_align_load(i32 %C, i32 %D) {\nentry:\n  %A = alloca i32, align 4\n  %0 = load i32, ptr %A, align 4\n  %cmp = icmp sgt i32 %D, 42\n  br i1 %cmp, label %if.then, label %ret.end\n\nif.then:                                          ; preds = %entry\n  store i32 %C, ptr %A, align 8\n  br label %ret.end\n\nret.end:                                          ; preds = %if.then, %entry\n  ret void\n}\n"
        },
        {
          "test_name": "noifconvertstore1",
          "test_body": "define void @noifconvertstore1(ptr %A1, ptr %A2, i32 %B, i32 %C, i32 %D) {\nentry:\n  store i32 %B, ptr %A1, align 4\n  %cmp = icmp sgt i32 %D, 42\n  br i1 %cmp, label %if.then, label %ret.end\n\nif.then:                                          ; preds = %entry\n  store i32 %C, ptr %A2, align 4\n  br label %ret.end\n\nret.end:                                          ; preds = %if.then, %entry\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "coalescing of redundant vector stores isn't preserving alignment correctly",
    "body": "https://alive2.llvm.org/ce/z/-qQphe\r\n\r\noptimizing this code:\r\n```llvm\r\ndefine i32 @f(ptr %0, i1 %1) {\r\n  store <2 x i64> zeroinitializer, ptr %0, align 8\r\n  br i1 %1, label %4, label %3\r\n\r\n3:                                                ; preds = %2\r\n  store <2 x i64> zeroinitializer, ptr %0, align 16\r\n  br label %4\r\n\r\n4:                                                ; preds = %3, %2\r\n  ret i32 0\r\n}\r\n```\r\n\r\nis mostly doing what we expect, but the coalesced store should retain the smaller alignnment value of the two, not the larger:\r\n```lllvm\r\ndefine noundef i32 @f(ptr nocapture writeonly %0, i1 %1) local_unnamed_addr #0 {\r\n  store <2 x i64> zeroinitializer, ptr %0, align 16\r\n  ret i32 0\r\n}\r\n\r\nattributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }\r\n```\r\n\r\ncc @nunoplopes @hatsunespica",
    "author": "regehr",
    "labels": [
      "miscompilation",
      "llvm:transforms"
    ],
    "comments": [
      {
        "author": "nikic",
        "body": "The issue is introduced by SimplifyCFG: https://alive2.llvm.org/ce/z/zf-j74"
      },
      {
        "author": "nikic",
        "body": "Specifically this is isSafeToSpeculateStore(), which looks for a preceding store to check whether it is safe to speculate, but fails to check alignment."
      }
    ]
  }
}
