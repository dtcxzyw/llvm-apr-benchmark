{
  "bug_id": "160396",
  "issue_url": "https://github.com/llvm/llvm-project/issues/160396",
  "bug_type": "crash",
  "base_commit": "2f5d5a3f748391f85cfa33702a247d42549f7b9d",
  "knowledge_cutoff": "2025-09-23T21:07:51Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "70a26da63992142ba2221f1034048ea883cdcb3d",
    "components": [
      "LoopVectorize"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Vectorize/VPlan.h": [
        [
          705,
          710
        ],
        [
          1494,
          1502
        ],
        [
          1504,
          1514
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        [
          2016,
          2028
        ]
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        [
          2195,
          2201
        ],
        [
          3566,
          3578
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Vectorize/VPlan.h": [
        "VPIRFlags",
        "VPWidenCastRecipe",
        "clone"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp": [
        "VPIRFlags::flagsValidForOpcode"
      ],
      "llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp": [
        "VPlanTransforms::truncateToMinimalBitwidths",
        "tryToMatchAndCreateMulAccumulateReduction"
      ]
    }
  },
  "patch": "commit 70a26da63992142ba2221f1034048ea883cdcb3d\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Thu Sep 25 09:00:45 2025 +0100\n\n    [VPlan] Set correct flags when creating and cloning VPWidenCastRecipe.\n    \n    Make sure that we set the correct wrap flags when creating new\n    VPWidenCastRecipes for truncs and preserve the flags from the recipe\n    directly when cloning, to make sure they are not dropped.\n    \n    Fixes https://github.com/llvm/llvm-project/issues/160396\n\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlan.h b/llvm/lib/Transforms/Vectorize/VPlan.h\nindex e64cefde81e3..0822511150e9 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlan.h\n+++ b/llvm/lib/Transforms/Vectorize/VPlan.h\n@@ -705,6 +705,9 @@ public:\n   VPIRFlags(WrapFlagsTy WrapFlags)\n       : OpType(OperationType::OverflowingBinOp), WrapFlags(WrapFlags) {}\n \n+  VPIRFlags(TruncFlagsTy TruncFlags)\n+      : OpType(OperationType::Trunc), TruncFlags(TruncFlags) {}\n+\n   VPIRFlags(FastMathFlags FMFs) : OpType(OperationType::FPMathOp), FMFs(FMFs) {}\n \n   VPIRFlags(DisjointFlagsTy DisjointFlags)\n@@ -1494,9 +1497,10 @@ public:\n \n   VPWidenCastRecipe(Instruction::CastOps Opcode, VPValue *Op, Type *ResultTy,\n                     const VPIRFlags &Flags = {},\n+                    const VPIRMetadata &Metadata = {},\n                     DebugLoc DL = DebugLoc::getUnknown())\n       : VPRecipeWithIRFlags(VPDef::VPWidenCastSC, Op, Flags, DL),\n-        VPIRMetadata(), Opcode(Opcode), ResultTy(ResultTy) {\n+        VPIRMetadata(Metadata), Opcode(Opcode), ResultTy(ResultTy) {\n     assert(flagsValidForOpcode(Opcode) &&\n            \"Set flags not supported for the provided opcode\");\n   }\n@@ -1504,11 +1508,11 @@ public:\n   ~VPWidenCastRecipe() override = default;\n \n   VPWidenCastRecipe *clone() override {\n+    auto *New = new VPWidenCastRecipe(Opcode, getOperand(0), ResultTy, *this,\n+                                      *this, getDebugLoc());\n     if (auto *UV = getUnderlyingValue())\n-      return new VPWidenCastRecipe(Opcode, getOperand(0), ResultTy,\n-                                   *cast<CastInst>(UV));\n-\n-    return new VPWidenCastRecipe(Opcode, getOperand(0), ResultTy);\n+      New->setUnderlyingValue(UV);\n+    return New;\n   }\n \n   VP_CLASSOF_IMPL(VPDef::VPWidenCastSC)\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex aa3de3613b68..deb64bfc7506 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -2016,13 +2016,13 @@ bool VPIRFlags::flagsValidForOpcode(unsigned Opcode) const {\n     return Opcode == Instruction::FAdd || Opcode == Instruction::FMul ||\n            Opcode == Instruction::FSub || Opcode == Instruction::FNeg ||\n            Opcode == Instruction::FDiv || Opcode == Instruction::FRem ||\n+           Opcode == Instruction::FPExt || Opcode == Instruction::FPTrunc ||\n            Opcode == Instruction::FCmp || Opcode == Instruction::Select ||\n            Opcode == VPInstruction::WideIVStep ||\n            Opcode == VPInstruction::ReductionStartVector ||\n            Opcode == VPInstruction::ComputeReductionResult;\n   case OperationType::NonNegOp:\n-    return Opcode == Instruction::ZExt;\n-    break;\n+    return Opcode == Instruction::ZExt || Opcode == Instruction::UIToFP;\n   case OperationType::Cmp:\n     return Opcode == Instruction::FCmp || Opcode == Instruction::ICmp;\n   case OperationType::Other:\ndiff --git a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\nindex 84f02059743c..58fab8f222d2 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp\n@@ -2195,7 +2195,8 @@ void VPlanTransforms::truncateToMinimalBitwidths(\n         auto [ProcessedIter, IterIsEmpty] = ProcessedTruncs.try_emplace(Op);\n         VPWidenCastRecipe *NewOp =\n             IterIsEmpty\n-                ? new VPWidenCastRecipe(Instruction::Trunc, Op, NewResTy)\n+                ? new VPWidenCastRecipe(Instruction::Trunc, Op, NewResTy,\n+                                        VPIRFlags::TruncFlagsTy(false, false))\n                 : ProcessedIter->second;\n         R.setOperand(Idx, NewOp);\n         if (!IterIsEmpty)\n@@ -3566,13 +3567,13 @@ tryToMatchAndCreateMulAccumulateReduction(VPReductionRecipe *Red,\n                                    Mul, Ext0, Ext1, Ext)) {\n       auto *NewExt0 = new VPWidenCastRecipe(\n           Ext0->getOpcode(), Ext0->getOperand(0), Ext->getResultType(), *Ext0,\n-          Ext0->getDebugLoc());\n+          *Ext0, Ext0->getDebugLoc());\n       NewExt0->insertBefore(Ext0);\n \n       VPWidenCastRecipe *NewExt1 = NewExt0;\n       if (Ext0 != Ext1) {\n         NewExt1 = new VPWidenCastRecipe(Ext1->getOpcode(), Ext1->getOperand(0),\n-                                        Ext->getResultType(), *Ext1,\n+                                        Ext->getResultType(), *Ext1, *Ext1,\n                                         Ext1->getDebugLoc());\n         NewExt1->insertBefore(Ext1);\n       }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopVectorize/cse-casts.ll",
      "commands": [
        "opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=2 -S %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine i8 @preserve_flags_when_cloning_trunc(i8 %start, ptr noalias %src, ptr noalias %dst) {\n;\nentry:\n  br label %loop\n\nloop:\n  %iv = phi i64 [ %iv.next, %loop ], [ 0, %entry ]\n  %red = phi i8 [ %red.next, %loop ], [ %start, %entry ]\n  %l = load i32, ptr %src, align 4\n  %cmp = icmp ne i32 %l, 0\n  %cmp.ext = zext i1 %cmp to i64\n  %cmp.trunc = trunc i64 %cmp.ext to i16\n  %gep.dst = getelementptr i16, ptr %dst, i64 %iv\n  store i16 %cmp.trunc, ptr %gep.dst, align 2\n  %red.next = mul i8 %red, 3\n  %iv.next = add i64 %iv, 1\n  %ec = icmp ult i64 %iv, 416\n  br i1 %ec, label %loop, label %exit\n\nexit:\n  ret i8 %red.next\n}\n\n\ndefine void @preserve_flags_narrowing_extends_and_truncs(ptr noalias %A, ptr noalias %B, ptr noalias %C) {\n;\nentry:\n  br label %loop\n\nloop:\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %gep.A = getelementptr inbounds i8, ptr %A, i64 %iv\n  %l = load i8, ptr %gep.A\n  %l.ext = zext i8 %l to i64\n  %gep.C = getelementptr inbounds i8, ptr %C, i64 %iv\n  store i64 %l.ext, ptr %gep.C\n  %gep.B = getelementptr inbounds i8, ptr %B, i64 %iv\n  %l.1 = load i8, ptr %gep.B, align 1\n  %masked = and i8 %l.1, 1\n  %l.1.trunc = trunc i8 %l.1 to i1\n  %sel.0 = select i1 %l.1.trunc, float 1.000000e+00, float 0.000000e+00\n  %masked.trunc = trunc i8 %masked to i1\n  %sel.1 = select i1 %masked.trunc, float 3.000000e+00, float %sel.0\n  %bc = bitcast float %sel.1 to i32\n  %bc.trunc = trunc i32 %bc to i8\n  store i8 %bc.trunc, ptr %gep.B, align 1\n  %iv.next = add i64 %iv, 1\n  %ec = icmp eq i64 %iv, 1\n  br i1 %ec, label %exit, label %loop\n\nexit:\n  ret void\n}"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize] Assertion `OpType == Other.OpType && \"OpType must match\"' failed.",
    "body": "Testcase:\n```llvm ir\ntarget datalayout = \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"riscv64-unknown-linux-gnu\"\n\ndefine i8 @c() #0 {\nentry:\n  br label %for.cond1.preheader.us\n\nfor.cond1.preheader.us:                           ; preds = %for.cond1.preheader.us, %entry\n  %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond1.preheader.us ], [ 0, %entry ]\n  %.us-phi4748.us = phi i8 [ %mul.us54, %for.cond1.preheader.us ], [ 0, %entry ]\n  %arrayidx12.us = getelementptr [6 x [6 x i16]], ptr null, i64 %indvars.iv\n  %0 = load i32, ptr null, align 4\n  %tobool9.us52 = icmp ne i32 %0, 0\n  %1 = zext i1 %tobool9.us52 to i64\n  %conv11.us53 = trunc i64 %1 to i16\n  store i16 %conv11.us53, ptr %arrayidx12.us, align 2\n  %mul.us54 = mul i8 %.us-phi4748.us, 0\n  %indvars.iv.next = add i64 %indvars.iv, 1\n  %cmp.us = icmp ult i64 %indvars.iv, 416\n  br i1 %cmp.us, label %for.cond1.preheader.us, label %for.cond.cleanup.sink.split.loopexit81\n\nfor.cond.cleanup.sink.split.loopexit81:           ; preds = %for.cond1.preheader.us\n  ret i8 %mul.us54\n}\n\nattributes #0 = { \"target-features\"=\"+v\" }\n```\nCommands/backtrace:\n```\n$ /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt --passes=loop-vectorize reduced.ll\nWARNING: You're attempting to print out a bitcode file.\nThis is inadvisable as it may cause display problems. If\nyou REALLY want to taste LLVM bitcode first-hand, you\ncan force output with the `-f' option.\n\nopt: /scratch/ewlu/daily-upstream-build/llvm/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:396: void llvm::VPIRFlags::intersectFlags(const llvm::VPIRFlags&): Assertion `OpType == Other.OpType && \"OpType must match\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.      Program arguments: /scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt --passes=loop-vectorize reduced.ll\n1.      Running pass \"function(loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>)\" on module \"reduced.ll\"\n2.      Running pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"c\"\n #0 0x0000588c53884c12 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x33ffc12)\n #1 0x0000588c5388190f llvm::sys::RunSignalHandlers() (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x33fc90f)\n #2 0x0000588c53881a5c SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #3 0x0000750611645330 (/lib/x86_64-linux-gnu/libc.so.6+0x45330)\n #4 0x000075061169eb2c __pthread_kill_implementation ./nptl/pthread_kill.c:44:76\n #5 0x000075061169eb2c __pthread_kill_internal ./nptl/pthread_kill.c:78:10\n #6 0x000075061169eb2c pthread_kill ./nptl/pthread_kill.c:89:10\n #7 0x000075061164527e raise ./signal/../sysdeps/posix/raise.c:27:6\n #8 0x00007506116288ff abort ./stdlib/abort.c:81:7\n #9 0x000075061162881b _nl_load_domain ./intl/loadmsgcat.c:1177:9\n#10 0x000075061163b517 (/lib/x86_64-linux-gnu/libc.so.6+0x3b517)\n#11 0x0000588c51656fcc (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x11d1fcc)\n#12 0x0000588c516a53e6 llvm::VPlanTransforms::cse(llvm::VPlan&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x12203e6)\n#13 0x0000588c5148525a llvm::LoopVectorizationPlanner::executePlan(llvm::ElementCount, unsigned int, llvm::VPlan&, llvm::InnerLoopVectorizer&, llvm::DominatorTree*, bool) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x100025a)\n#14 0x0000588c514a3d58 llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x101ed58)\n#15 0x0000588c514a6601 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x1021601)\n#16 0x0000588c514a6c16 llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x1021c16)\n#17 0x0000588c50d36865 llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x8b1865)\n#18 0x0000588c53664155 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x31df155)\n#19 0x0000588c50d39095 llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x8b4095)\n#20 0x0000588c53662741 llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x31dd741)\n#21 0x0000588c509c3515 llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x53e515)\n#22 0x0000588c53662f2d llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x31ddf2d)\n#23 0x0000588c509cf599 llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x54a599)\n#24 0x0000588c509c16ed optMain (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x53c6ed)\n#25 0x000075061162a1ca __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:74:3\n#26 0x000075061162a28b call_init ./csu/../csu/libc-start.c:128:20\n#27 0x000075061162a28b __libc_start_main ./csu/../csu/libc-start.c:347:5\n#28 0x0000588c509b7615 _start (/scratch/ewlu/daily-upstream-build/build-gcv/build-llvm-linux/bin/opt+0x532615)\nAborted\n```\n\nGodbolt: https://godbolt.org/z/qn5rr7xn9\n\nFound via fuzzer",
    "author": "ewlu",
    "labels": [
      "vectorizers",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": false,
    "is_single_func_fix": false
  },
  "verified": true
}