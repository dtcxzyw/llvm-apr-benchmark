{
  "bug_id": "167627",
  "issue_url": "https://github.com/llvm/llvm-project/issues/167627",
  "bug_type": "miscompilation",
  "base_commit": "3cfe6aa46e06a8caa3f07057838d31c6ce840076",
  "knowledge_cutoff": "2025-11-12T03:06:22Z",
  "lit_test_dir": [
    "llvm/test/Transforms/Float2Int"
  ],
  "hints": {
    "fix_commit": "edd8b29667716101ed026baf3aa4befb37ac132a",
    "components": [
      "Float2Int"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Scalar/Float2Int.cpp": [
        [
          237,
          246
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Scalar/Float2Int.cpp": [
        "Float2IntPass::calcRange"
      ]
    }
  },
  "patch": "commit edd8b29667716101ed026baf3aa4befb37ac132a\nAuthor: Yingwei Zheng <dtcxzyw2333@gmail.com>\nDate:   Thu Nov 13 20:54:32 2025 +0800\n\n    [Float2Int] Make sure the CFP can be represented in the integer type (#167699)\n    \n    When `convertToInteger` fails, the integer result is undefined. In this\n    case, we cannot use it in the subsequent steps.\n    Close https://github.com/llvm/llvm-project/issues/167627.\n\ndiff --git a/llvm/lib/Transforms/Scalar/Float2Int.cpp b/llvm/lib/Transforms/Scalar/Float2Int.cpp\nindex 14686ce8c2ab..37822cf05f14 100644\n--- a/llvm/lib/Transforms/Scalar/Float2Int.cpp\n+++ b/llvm/lib/Transforms/Scalar/Float2Int.cpp\n@@ -237,10 +237,14 @@ std::optional<ConstantRange> Float2IntPass::calcRange(Instruction *I) {\n       // OK, it's representable. Now get it.\n       APSInt Int(MaxIntegerBW+1, false);\n       bool Exact;\n-      CF->getValueAPF().convertToInteger(Int,\n-                                         APFloat::rmNearestTiesToEven,\n-                                         &Exact);\n-      OpRanges.push_back(ConstantRange(Int));\n+      APFloat::opStatus Status = CF->getValueAPF().convertToInteger(\n+          Int, APFloat::rmNearestTiesToEven, &Exact);\n+      // Although the round above is loseless, we still need to check if the\n+      // floating-point value can be represented in the integer type.\n+      if (Status == APFloat::opOK || Status == APFloat::opInexact)\n+        OpRanges.push_back(ConstantRange(Int));\n+      else\n+        return badRange();\n     } else {\n       llvm_unreachable(\"Should have already marked this as badRange!\");\n     }\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/Float2Int/pr167627.ll",
      "commands": [
        "opt -S -passes=float2int < %s"
      ],
      "tests": [
        {
          "test_name": "pr167627",
          "test_body": "define i1 @pr167627() {\nentry:\n  %fadd = fadd float 0xC5AAD8ABE0000000, 0xC57E819700000000\n  %cmp = fcmp one float %fadd, 0.000000e+00\n  ret i1 %cmp\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[Float2Int] Miscompilation at O3",
    "body": "Reproducer: https://alive2.llvm.org/ce/z/u3J86e\n```\n; bin/opt -passes=float2int test.ll -S\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine i1 @src() {\nentry:\n  %0 = fadd float 0xC5AAD8ABE0000000, 0xC57E819700000000\n  %1 = fcmp one float %0, 0.000000e+00\n  ret i1 %1\n}\n```\n```\n=>\ndefine i1 @src() {\nentry:\n  ret i1 0\n}\nTransformation doesn't verify!\n\nERROR: Value mismatch\n\nNOTE: The counterexample is unique.\n\nExample:\n\nSource:\nfloat %#0 = #xed7546f6 (-4744350869734834488282710016)\ni1 %#1 = #x1 (1)\n\nTarget:\nSource value: #x1 (1)\nTarget value: #x0 (0)\n```\nllvm version: cf35502dd569d842a860696650a783f896db0648",
    "author": "dtcxzyw",
    "labels": [
      "miscompilation",
      "floating-point",
      "llvm:transforms",
      "generated by fuzzer"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}