{
  "bug_id": "173357",
  "issue_url": "https://github.com/llvm/llvm-project/issues/173357",
  "bug_type": "crash",
  "base_commit": "c4d52553ee4b8572b8ddaafa53ed3d8864b91989",
  "knowledge_cutoff": "2025-12-23T11:17:24Z",
  "lit_test_dir": [
    "llvm/test/Transforms/LoopDeletion"
  ],
  "hints": {
    "fix_commit": "f98cc40b5211a7f008556609fea0bcf285d52bce",
    "components": [
      "LoopUtils"
    ],
    "bug_location_lineno": {
      "llvm/lib/Transforms/Utils/LoopUtils.cpp": [
        [
          608,
          637
        ],
        [
          646,
          652
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Transforms/Utils/LoopUtils.cpp": [
        "llvm::deleteDeadLoop"
      ]
    }
  },
  "patch": "commit f98cc40b5211a7f008556609fea0bcf285d52bce\nAuthor: Craig Topper <craig.topper@sifive.com>\nDate:   Tue Dec 30 09:00:09 2025 -0800\n\n    [LoopDeletion] Check for uses in unreachable basic blocks even when there is no exit block. (#173428)\n    \n    Fixes #173357\n\ndiff --git a/llvm/lib/Transforms/Utils/LoopUtils.cpp b/llvm/lib/Transforms/Utils/LoopUtils.cpp\nindex 8e2a4f80fce1..6a77fc47fb0e 100644\n--- a/llvm/lib/Transforms/Utils/LoopUtils.cpp\n+++ b/llvm/lib/Transforms/Utils/LoopUtils.cpp\n@@ -608,30 +608,30 @@ void llvm::deleteDeadLoop(Loop *L, DominatorTree *DT, ScalarEvolution *SE,\n   llvm::SmallDenseSet<DebugVariable, 4> DeadDebugSet;\n   llvm::SmallVector<DbgVariableRecord *, 4> DeadDbgVariableRecords;\n \n-  if (ExitBlock) {\n-    // Given LCSSA form is satisfied, we should not have users of instructions\n-    // within the dead loop outside of the loop. However, LCSSA doesn't take\n-    // unreachable uses into account. We handle them here.\n-    // We could do it after drop all references (in this case all users in the\n-    // loop will be already eliminated and we have less work to do but according\n-    // to API doc of User::dropAllReferences only valid operation after dropping\n-    // references, is deletion. So let's substitute all usages of\n-    // instruction from the loop with poison value of corresponding type first.\n-    for (auto *Block : L->blocks())\n-      for (Instruction &I : *Block) {\n-        auto *Poison = PoisonValue::get(I.getType());\n-        for (Use &U : llvm::make_early_inc_range(I.uses())) {\n-          if (auto *Usr = dyn_cast<Instruction>(U.getUser()))\n-            if (L->contains(Usr->getParent()))\n-              continue;\n-          // If we have a DT then we can check that uses outside a loop only in\n-          // unreachable block.\n-          if (DT)\n-            assert(!DT->isReachableFromEntry(U) &&\n-                   \"Unexpected user in reachable block\");\n-          U.set(Poison);\n-        }\n+  // Given LCSSA form is satisfied, we should not have users of instructions\n+  // within the dead loop outside of the loop. However, LCSSA doesn't take\n+  // unreachable uses into account. We handle them here.\n+  // We could do it after drop all references (in this case all users in the\n+  // loop will be already eliminated and we have less work to do but according\n+  // to API doc of User::dropAllReferences only valid operation after dropping\n+  // references, is deletion. So let's substitute all usages of\n+  // instruction from the loop with poison value of corresponding type first.\n+  for (auto *Block : L->blocks())\n+    for (Instruction &I : *Block) {\n+      auto *Poison = PoisonValue::get(I.getType());\n+      for (Use &U : llvm::make_early_inc_range(I.uses())) {\n+        if (auto *Usr = dyn_cast<Instruction>(U.getUser()))\n+          if (L->contains(Usr->getParent()))\n+            continue;\n+        // If we have a DT then we can check that uses outside a loop only in\n+        // unreachable block.\n+        if (DT)\n+          assert(!DT->isReachableFromEntry(U) &&\n+                 \"Unexpected user in reachable block\");\n+        U.set(Poison);\n+      }\n \n+      if (ExitBlock) {\n         // For one of each variable encountered, preserve a debug record (set\n         // to Poison) and transfer it to the loop exit. This terminates any\n         // variable locations that were set during the loop.\n@@ -646,7 +646,9 @@ void llvm::deleteDeadLoop(Loop *L, DominatorTree *DT, ScalarEvolution *SE,\n           DeadDbgVariableRecords.push_back(&DVR);\n         }\n       }\n+    }\n \n+  if (ExitBlock) {\n     // After the loop has been deleted all the values defined and modified\n     // inside the loop are going to be unavailable. Values computed in the\n     // loop will have been deleted, automatically causing their debug uses\n",
  "tests": [
    {
      "file": "llvm/test/Transforms/LoopDeletion/pr173357.ll",
      "commands": [
        "opt -S -passes=loop-deletion < %s"
      ],
      "tests": [
        {
          "test_name": "<module>",
          "test_body": "\ndefine void @foo(ptr %P) #0 {\n;\nbb:\n  %p.promoted2 = load ptr, ptr %P, align 8\n  br label %bb1\n\nbb1:                                              ; preds = %bb1.backedge, %bb\n  %p.ph = phi ptr [ %P, %bb ], [ %p.promoted2, %bb1.backedge ]\n  br label %bb1.backedge\n\nbb1.backedge:                                     ; preds = %bb1, %merge\n  br label %bb1\n\nmerge:                                            ; No predecessors!\n  store ptr %p.ph, ptr %P, align 8\n  br label %bb1.backedge\n}\n\nattributes #0 = { willreturn }"
        }
      ]
    }
  ],
  "issue": {
    "title": "opt crashes in llvm/lib/IR/Value.cpp:102",
    "body": "When running opt on the following IR, opt crashes. \nI am not sure whether this is a valid case. If using opt in this way is not appropriate, I am open to closing this issue.\ngodbolt: https://godbolt.org/z/WP538Wx4z\n\nllvm version 50ae726bb3498\n\ntest.ll\n\n```\ndefine void @foo(ptr writeonly captures(none) initializes((0, 4)) %P) #0 {\nbb:\n  %p.promoted2 = load ptr, ptr %P, align 8\n  br label %bb1\n\nbb1:                                              ; preds = %bb1.backedge, %bb\n  %p.ph = phi ptr [ %P, %bb ], [ %p.promoted2, %bb1.backedge ]\n  br label %bb1.backedge\n\nbb1.backedge:                                     ; preds = %bb1, %merge\n  br label %bb1\n\nmerge:                                            ; No predecessors!\n  store ptr %p.ph, ptr %P, align 8\n  br label %bb1.backedge\n}\n\nattributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }\n\n```\n\n\ncommads\n./bin/opt test.ll -passes=loop-deletion -S\n\nstacktrace\n\n```\nWhile deleting: ptr %p.ph\nUse still stuck around after Def is destroyed:  store ptr %p.ph, ptr %P, align 8\nUses remain when a value is destroyed!\nUNREACHABLE executed at /root/llvm-project/llvm/lib/IR/Value.cpp:102!\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -passes=loop-deletion -S <source>\n1.\tRunning pass \"function(loop(loop-deletion))\" on module \"<source>\"\n2.\tRunning pass \"loop(loop-deletion)\" on function \"foo\"\n #0 0x0000000005a44d98 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5a44d98)\n #1 0x0000000005a41c44 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x00007dc51e242520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x00007dc51e2969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x00007dc51e242476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x00007dc51e2287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x000000000597959a (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x597959a)\n #7 0x0000000005859a21 llvm::Value::~Value() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5859a21)\n #8 0x0000000005859bba llvm::Value::deleteValue() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5859bba)\n #9 0x0000000005655e5e llvm::BasicBlock::~BasicBlock() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5655e5e)\n#10 0x00000000056560f5 llvm::BasicBlock::eraseFromParent() (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x56560f5)\n#11 0x0000000004c3d859 llvm::deleteDeadLoop(llvm::Loop*, llvm::DominatorTree*, llvm::ScalarEvolution*, llvm::LoopInfo*, llvm::MemorySSA*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x4c3d859)\n#12 0x00000000047321f7 llvm::LoopDeletionPass::run(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x47321f7)\n#13 0x0000000003020c4e llvm::detail::PassModel<llvm::Loop, llvm::LoopDeletionPass, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::run(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x3020c4e)\n#14 0x00000000047894d6 std::optional<llvm::PreservedAnalyses> llvm::PassManager<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::runSinglePass<llvm::Loop, std::unique_ptr<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>, std::default_delete<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>>>>(llvm::Loop&, std::unique_ptr<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>, std::default_delete<llvm::detail::PassConcept<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>>>&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&, llvm::PassInstrumentation&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x47894d6)\n#15 0x00000000047896bf llvm::PassManager<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::runWithoutLoopNestPasses(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x47896bf)\n#16 0x000000000478ae24 llvm::PassManager<llvm::Loop, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&>::run(llvm::Loop&, llvm::AnalysisManager<llvm::Loop, llvm::LoopStandardAnalysisResults&>&, llvm::LoopStandardAnalysisResults&, llvm::LPMUpdater&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x478ae24)\n#17 0x000000000478bdff llvm::FunctionToLoopPassAdaptor::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x478bdff)\n#18 0x0000000000f1874e llvm::detail::PassModel<llvm::Function, llvm::FunctionToLoopPassAdaptor, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xf1874e)\n#19 0x0000000005821031 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5821031)\n#20 0x0000000000f1952e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xf1952e)\n#21 0x000000000581f6fa llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x581f6fa)\n#22 0x000000000097d43e llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97d43e)\n#23 0x000000000581f0b1 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x581f0b1)\n#24 0x000000000098776a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x98776a)\n#25 0x000000000097b5e8 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97b5e8)\n#26 0x00007dc51e229d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#27 0x00007dc51e229e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#28 0x0000000000972085 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x972085)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```\n",
    "author": "Emilyaxe",
    "labels": [
      "loopoptim",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}