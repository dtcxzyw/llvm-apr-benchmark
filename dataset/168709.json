{
  "bug_id": "168709",
  "issue_url": "https://github.com/llvm/llvm-project/issues/168709",
  "bug_type": "crash",
  "base_commit": "8a40d08b836ff5f363783f99efd901a44d8575de",
  "knowledge_cutoff": "2025-11-19T13:56:06Z",
  "lit_test_dir": [
    "llvm/test/Analysis/ScalarEvolution",
    "llvm/test/Transforms/LoopVectorize"
  ],
  "hints": {
    "fix_commit": "5d876093b72182ede3d8beb551397b7fe90faa84",
    "components": [
      "ScalarEvolution"
    ],
    "bug_location_lineno": {
      "llvm/lib/Analysis/ScalarEvolution.cpp": [
        [
          3492,
          3508
        ]
      ]
    },
    "bug_location_funcname": {
      "llvm/lib/Analysis/ScalarEvolution.cpp": [
        "ScalarEvolution::getUDivExpr"
      ]
    }
  },
  "patch": "commit 5d876093b72182ede3d8beb551397b7fe90faa84\nAuthor: Florian Hahn <flo@fhahn.com>\nDate:   Tue Dec 2 14:09:53 2025 +0000\n\n    [SCEV] Allow udiv canonicalization of potentially-wrapping AddRecs (#169576)\n    \n    Extend the {X,+,N}/C => {(X - X%N),+,N}/C canonicalization to handle\n    AddRecs that may wrap, when X < N <= C and both N,C are powers of 2. The\n    alignment and power-of-2 properties ensure division results remain\n    equivalent for all offsets [(X - X%N), X).\n    \n    Alive2 Proof: https://alive2.llvm.org/ce/z/iu2tav\n    \n    Fixes https://github.com/llvm/llvm-project/issues/168709\n    \n    PR: https://github.com/llvm/llvm-project/pull/169576\n\ndiff --git a/llvm/lib/Analysis/ScalarEvolution.cpp b/llvm/lib/Analysis/ScalarEvolution.cpp\nindex a31f17b1936d..60d3535ea609 100644\n--- a/llvm/lib/Analysis/ScalarEvolution.cpp\n+++ b/llvm/lib/Analysis/ScalarEvolution.cpp\n@@ -3492,17 +3492,25 @@ const SCEV *ScalarEvolution::getUDivExpr(const SCEV *LHS,\n           /// {X,+,N}/C => {Y,+,N}/C where Y=X-(X%N). Safe when C%N=0.\n           // We can currently only fold X%N if X is constant.\n           const SCEVConstant *StartC = dyn_cast<SCEVConstant>(AR->getStart());\n-          if (StartC && !DivInt.urem(StepInt) &&\n-              getZeroExtendExpr(AR, ExtTy) ==\n-              getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n-                            getZeroExtendExpr(Step, ExtTy),\n-                            AR->getLoop(), SCEV::FlagAnyWrap)) {\n+          if (StartC && !DivInt.urem(StepInt)) {\n             const APInt &StartInt = StartC->getAPInt();\n             const APInt &StartRem = StartInt.urem(StepInt);\n-            if (StartRem != 0) {\n-              const SCEV *NewLHS =\n-                  getAddRecExpr(getConstant(StartInt - StartRem), Step,\n-                                AR->getLoop(), SCEV::FlagNW);\n+            bool NoWrap =\n+                getZeroExtendExpr(AR, ExtTy) ==\n+                getAddRecExpr(getZeroExtendExpr(AR->getStart(), ExtTy),\n+                              getZeroExtendExpr(Step, ExtTy), AR->getLoop(),\n+                              SCEV::FlagAnyWrap);\n+\n+            // With N <= C and both N, C as powers-of-2, the transformation\n+            // {X,+,N}/C => {(X - X%N),+,N}/C preserves division results even\n+            // if wrapping occurs, as the division results remain equivalent for\n+            // all offsets in [[(X - X%N), X).\n+            bool CanFoldWithWrap = StepInt.ule(DivInt) && // N <= C\n+                                   StepInt.isPowerOf2() && DivInt.isPowerOf2();\n+            if (StartRem != 0 && (NoWrap || CanFoldWithWrap)) {\n+              const SCEV *NewLHS = getAddRecExpr(\n+                  getConstant(StartInt - StartRem), Step, AR->getLoop(),\n+                  NoWrap ? SCEV::FlagNW : SCEV::FlagAnyWrap);\n               if (LHS != NewLHS) {\n                 LHS = NewLHS;\n \n",
  "tests": [
    {
      "file": "llvm/test/Analysis/ScalarEvolution/addrec-may-wrap-udiv-canonicalize.ll",
      "commands": [
        "opt < %s -passes='print<scalar-evolution>' -disable-output 2>&1"
      ],
      "tests": [
        {
          "test_name": "test_step4_div4",
          "test_body": "declare void @use(i64)\n\ndefine void @test_step4_div4(i64 %n) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %div.0 = udiv i64 %iv, 4\n  call void @use(i64 %div.0)\n  %iv.1 = add i64 %iv, 1\n  %div.1 = udiv i64 %iv.1, 4\n  call void @use(i64 %div.1)\n  %iv.2 = add i64 %iv, 2\n  %div.2 = udiv i64 %iv.2, 4\n  call void @use(i64 %div.2)\n  %iv.3 = add i64 %iv, 3\n  %div.3 = udiv i64 %iv.3, 4\n  call void @use(i64 %div.3)\n  %iv.4 = add i64 %iv, 4\n  %div.4 = udiv i64 %iv.4, 4\n  call void @use(i64 %div.4)\n  %iv.5 = add i64 %iv, 5\n  %div.5 = udiv i64 %iv.5, 4\n  call void @use(i64 %div.5)\n  %iv.next = add i64 %iv, 4\n  %cond = icmp slt i64 %iv, %n\n  br i1 %cond, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        },
        {
          "test_name": "test_step2_div4",
          "test_body": "declare void @use(i64)\n\ndefine void @test_step2_div4(i64 %n) {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %div.0 = udiv i64 %iv, 4\n  call void @use(i64 %div.0)\n  %iv.1 = add i64 %iv, 1\n  %div.1 = udiv i64 %iv.1, 4\n  call void @use(i64 %div.1)\n  %iv.2 = add i64 %iv, 2\n  %div.2 = udiv i64 %iv.2, 4\n  call void @use(i64 %div.2)\n  %iv.neg.1 = add i64 %iv, -1\n  %div.neg.1 = udiv i64 %iv.neg.1, 4\n  call void @use(i64 %div.neg.1)\n  %iv.next = add i64 %iv, 2\n  %cond = icmp slt i64 %iv, %n\n  br i1 %cond, label %loop, label %exit\n\nexit:                                             ; preds = %loop\n  ret void\n}\n"
        }
      ]
    },
    {
      "file": "llvm/test/Transforms/LoopVectorize/X86/uniformshift.ll",
      "commands": [
        "opt -mtriple=x86_64-apple-darwin -mattr=+sse2 -passes=loop-vectorize -debug-only=loop-vectorize -S < %s 2>&1"
      ],
      "tests": [
        {
          "test_name": "shift_and_masked_load_store",
          "test_body": "define void @shift_and_masked_load_store(i64 %trip.count) #0 {\nentry:\n  br label %loop\n\nloop:                                             ; preds = %loop, %entry\n  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]\n  %shifted = lshr i64 %iv, 2\n  %masked.idx = and i64 %shifted, 1\n  %load.ptr = getelementptr i16, ptr poison, i64 %masked.idx\n  %val = load i16, ptr %load.ptr, align 2\n  %store.idx = shl nuw i64 %iv, 2\n  %store.ptr = getelementptr i8, ptr poison, i64 %store.idx\n  store i16 %val, ptr %store.ptr, align 2\n  %iv.next = add i64 %iv, 1\n  %cmp = icmp eq i64 %iv, %trip.count\n  br i1 %cmp, label %exit, label %loop\n\nexit:                                             ; preds = %loop\n  ret void\n}\n\nattributes #0 = { \"target-features\"=\"+avx2\" \"tune-cpu\"=\"alderlake\" }\n"
        },
        {
          "test_name": "foo",
          "test_body": "define void @foo(ptr captures(none) %p, i32 %k) local_unnamed_addr {\nentry:\n  br label %body\n\nbody:                                             ; preds = %body, %entry\n  %i = phi i64 [ 0, %entry ], [ %next, %body ]\n  %ptr = getelementptr inbounds i32, ptr %p, i64 %i\n  %val = load i32, ptr %ptr, align 4\n  %shift = ashr i32 %val, %k\n  store i32 %shift, ptr %ptr, align 4\n  %next = add nuw nsw i64 %i, 1\n  %cmp = icmp eq i64 %next, 16\n  br i1 %cmp, label %exit, label %body\n\nexit:                                             ; preds = %body\n  ret void\n}\n"
        }
      ]
    }
  ],
  "issue": {
    "title": "[LoopVectorize] opt crashed at -O2/O3: Assertion \"VPlan cost model and legacy cost model disagreed\" failed.",
    "body": "Reproducer: https://godbolt.org/z/E3jq9MPsc\nTestcase:\n```llvm\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n\ndefine <8 x i64> @backsmith_pure_0(ptr %0) {\nentry:\n  %BS_VAR_2 = alloca [6 x i16], align 2\n  %BS_VAR_3 = alloca [7 x i16], align 2\n  %BS_ARG_01 = load <64 x i8>, ptr %0, align 64\n  store i8 0, ptr %BS_VAR_2, align 2\n  %conv = extractelement <64 x i8> %BS_ARG_01, i64 44\n  %cmp = icmp ult i8 %conv, 60\n  %narrow = select i1 %cmp, i8 %conv, i8 0\n  %cond = zext i8 %narrow to i32\n  br label %for.cond\n\nfor.cond:                                         ; preds = %for.body, %entry\n  %BS_INC_0.0 = phi i32 [ 0, %entry ], [ %add, %for.body ]\n  %cmp7 = icmp ult i32 %BS_INC_0.0, %cond\n  br i1 %cmp7, label %for.body, label %for.cond.cleanup\n\nfor.cond.cleanup:                                 ; preds = %for.cond\n  ret <8 x i64> zeroinitializer\n\nfor.body:                                         ; preds = %for.cond\n  %div2 = lshr i32 %BS_INC_0.0, 2\n  %idxprom = zext i32 %div2 to i64\n  %arrayidx = getelementptr i16, ptr %BS_VAR_2, i64 %idxprom\n  %1 = load i16, ptr %arrayidx, align 2\n  %mul = shl i32 %BS_INC_0.0, 1\n  %idxprom12 = zext i32 %mul to i64\n  %arrayidx13 = getelementptr nusw i16, ptr %BS_VAR_3, i64 %idxprom12\n  %2 = load i16, ptr %arrayidx13, align 2\n  %sub = or i16 %2, %1\n  store i16 %sub, ptr %arrayidx13, align 2\n  %add = add i32 %BS_INC_0.0, 1\n  br label %for.cond\n}\n\ndefine <8 x i64> @backsmith_pure_6(i32 %vecext, ptr %byval-temp11) #0 {\nentry:\n  %vecinit9 = insertelement <16 x i32> zeroinitializer, i32 %vecext, i64 11\n  store <16 x i32> %vecinit9, ptr %byval-temp11, align 64\n  %call13 = call <8 x i64> @backsmith_pure_0(ptr %byval-temp11)\n  ret <8 x i64> %call13\n}\n\nattributes #0 = { \"target-features\"=\"+avx2\" \"tune-cpu\"=\"alderlake\" }\n```\n\nopt output:\n```\nopt: /root/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:7181: llvm::VectorizationFactor llvm::LoopVectorizationPlanner::computeBestVF(): Assertion `(BestFactor.Width == LegacyVF.Width || BestPlan.hasEarlyExit() || !Legal->getLAI()->getSymbolicStrides().empty() || planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width), CostCtx, OrigLoop, BestFactor.Width) || planContainsAdditionalSimplifications( getPlanFor(LegacyVF.Width), CostCtx, OrigLoop, LegacyVF.Width)) && \" VPlan cost model and legacy cost model disagreed\"' failed.\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace and instructions to reproduce the bug.\nStack dump:\n0.\tProgram arguments: /opt/compiler-explorer/clang-assertions-trunk/bin/opt -o /app/output.s -S -O2 <source>\n1.\tRunning pass \"function<eager-inv>(drop-unnecessary-assumes,float2int,lower-constant-intrinsics,loop(loop-rotate<header-duplication;no-prepare-for-lto>,loop-deletion),loop-distribute,inject-tli-mappings,loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>,drop-unnecessary-assumes,infer-alignment,loop-load-elim,instcombine<max-iterations=1;no-verify-fixpoint>,simplifycfg<bonus-inst-threshold=1;forward-switch-cond;switch-range-to-icmp;switch-to-arithmetic;switch-to-lookup;no-keep-loops;hoist-common-insts;no-hoist-loads-stores-with-cond-faulting;sink-common-insts;speculate-blocks;simplify-cond-branch;no-speculate-unpredictables>,slp-vectorizer,vector-combine,instcombine<max-iterations=1;no-verify-fixpoint>,loop-unroll<O2>,transform-warning,sroa<preserve-cfg>,infer-alignment,instcombine<max-iterations=1;no-verify-fixpoint>,loop-mssa(licm<allowspeculation>),alignment-from-assumptions,loop-sink,instsimplify,div-rem-pairs,tailcallelim,simplifycfg<bonus-inst-threshold=1;no-forward-switch-cond;switch-range-to-icmp;switch-to-arithmetic;no-switch-to-lookup;keep-loops;no-hoist-common-insts;hoist-loads-stores-with-cond-faulting;no-sink-common-insts;speculate-blocks;simplify-cond-branch;speculate-unpredictables>)\" on module \"<source>\"\n2.\tRunning pass \"loop-vectorize<no-interleave-forced-only;no-vectorize-forced-only;>\" on function \"backsmith_pure_6\"\n #0 0x0000000005970698 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x5970698)\n #1 0x000000000596d544 SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0\n #2 0x0000772001e42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\n #3 0x0000772001e969fc pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fc)\n #4 0x0000772001e42476 gsignal (/lib/x86_64-linux-gnu/libc.so.6+0x42476)\n #5 0x0000772001e287f3 abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f3)\n #6 0x0000772001e2871b (/lib/x86_64-linux-gnu/libc.so.6+0x2871b)\n #7 0x0000772001e39e96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\n #8 0x00000000036b434a (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36b434a)\n #9 0x00000000036b664e llvm::LoopVectorizePass::processLoop(llvm::Loop*) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36b664e)\n#10 0x00000000036b9470 llvm::LoopVectorizePass::runImpl(llvm::Function&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36b9470)\n#11 0x00000000036b9b9b llvm::LoopVectorizePass::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x36b9b9b)\n#12 0x0000000002fa0f6e llvm::detail::PassModel<llvm::Function, llvm::LoopVectorizePass, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x2fa0f6e)\n#13 0x000000000574fbd1 llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x574fbd1)\n#14 0x0000000000efd90e llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0xefd90e)\n#15 0x000000000574e29a llvm::ModuleToFunctionPassAdaptor::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x574e29a)\n#16 0x0000000000973bfe llvm::detail::PassModel<llvm::Module, llvm::ModuleToFunctionPassAdaptor, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x973bfe)\n#17 0x000000000574dc51 llvm::PassManager<llvm::Module, llvm::AnalysisManager<llvm::Module>>::run(llvm::Module&, llvm::AnalysisManager<llvm::Module>&) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x574dc51)\n#18 0x000000000097de2a llvm::runPassPipeline(llvm::StringRef, llvm::Module&, llvm::TargetMachine*, llvm::TargetLibraryInfoImpl*, llvm::RTLIB::RuntimeLibcallsInfo&, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::ToolOutputFile*, llvm::StringRef, llvm::ArrayRef<llvm::PassPlugin>, llvm::ArrayRef<std::function<void (llvm::PassBuilder&)>>, llvm::opt_tool::OutputKind, llvm::opt_tool::VerifierKind, bool, bool, bool, bool, bool, bool, bool, bool) (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x97de2a)\n#19 0x0000000000971ea8 optMain (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x971ea8)\n#20 0x0000772001e29d90 (/lib/x86_64-linux-gnu/libc.so.6+0x29d90)\n#21 0x0000772001e29e40 __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e40)\n#22 0x00000000009690b5 _start (/opt/compiler-explorer/clang-assertions-trunk/bin/opt+0x9690b5)\nProgram terminated with signal: SIGSEGV\nCompiler returned: 139\n```",
    "author": "XChy",
    "labels": [
      "llvm:SCEV",
      "crash"
    ],
    "comments": []
  },
  "properties": {
    "is_single_file_fix": true,
    "is_single_func_fix": true
  },
  "verified": true
}